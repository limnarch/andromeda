//
// Implements the slab allocator for the kernel pool.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

// slab allocation functions. should be called only through MmAllocWithTag and
// MmFree.

var MmSlabBytesUsedExternally 0
public MmSlabBytesUsedExternally

var MmSlabBytesUsedInternally 0
public MmSlabBytesUsedInternally

table MmSlabListHeads[MMSLABBUCKETS]

table MmSlabBucketCounts[MMSLABBUCKETS]
public MmSlabBucketCounts

extern MmHeapPrintTag { tag -- }

fn MmSlabAlloc { bytes tag flags -- ptr ok }
	0 ok!

	// calculate as much stuff as possible here before we disable interrupts

	MmPoolSlab_SIZEOF bytes +=

	auto sz
	1 MMSLABPO2START << sz!

	auto bucketindex
	0 bucketindex!
	
	while (sz@ bytes@ <)
		1 sz <<=
		1 bucketindex +=
	end

	auto slabsperpage
	PAGESIZE bucketindex@ MMSLABPO2START + >> 1 - slabsperpage!

	if (DEBUGCHECKS)
		if (bucketindex@ MMSLABBUCKETS >=)
			"MmSlabAlloc: bucketindex too big\n" KeCrash
		end
	end

	auto pfdbe

	auto pfn
	0 pfn!

	auto listhead
	[bucketindex@]MmSlabListHeads listhead!

	auto rs
	HALCPUInterruptDisable rs!

	listhead@@ ptr!

	while (1)
		if (ptr@)
			if (ptr@ MmPoolSlab_Magic + gi MMSLABFREEMAGIC ~=)
				ptr@ MmPoolSlab_TagOrNextFree + @
				ptr@ MmPoolSlab_Magic + gi
				ptr@ "MmSlabAlloc: slab 0x%08x had bad magic (0x%04x) %x\n" KeCrash
			end

			if (DEBUGCHECKS)
				if (ptr@ MmPoolSlab_Reserved + gb)
					ptr@ MmPoolSlab_Reserved + gb
					ptr@ "MmSlabAlloc: slab 0x%08x had a non-zero reserved byte (0x%08x)\n" KeCrash
				end

				if (ptr@ MmPoolSlab_BucketIndex + gb bucketindex@ ~=)
					ptr@ MmPoolSlab_BucketIndex + gb
					bucketindex@
					ptr@ "MmSlabAlloc: slab 0x%08x had a weird bucketindex, wanted %d, found %d\n" KeCrash
				end
			end

			ptr@ IDENTITYSPACE ~ & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!
			pfdbe@ MmEvictablePageReference drop

			auto n
			ptr@ MmPoolSlab_TagOrNextFree + @ n!

			n@ listhead@!

			if (n@)
				0 n@ MmPoolSlab_PrevFree + !
			end

			if (DEBUGCHECKS)
				1 [bucketindex@]MmSlabBucketCounts +=
			end

			sz@ MmSlabBytesUsedInternally +=

			rs@ HALCPUInterruptRestore

			if (pfn@)
				pfn@ MmPageFree
			end

			tag@ ptr@ MmPoolSlab_TagOrNextFree + !
			MMSLABSWIFTMAGIC ptr@ MmPoolSlab_Magic + si
			0 ptr@ MmPoolSlab_PrevFree + !

			MmPoolSlab_SIZEOF ptr +=

			return
		end

		// no slab found, allocate a physical page and turn it into a bunch of
		// properly-sized slabs. dip down into IPLDPC and turn interrupts back
		// on since this just turned into a lengthy operation.

		auto ipl

		if (flags@ CANBLOCK & ~~)
			IPLDPC KeIPLRaise ipl!
		end

		rs@ HALCPUInterruptRestore

		0 // flags
		MMEVICTTYPE_SLAB // evictabletype
		FREEFIRST flags@ | // priority
		MmEvictablePageAlloc ok! pfn! pfdbe!

		if (flags@ CANBLOCK &)
			HALCPUInterruptDisable rs!

			listhead@@ ptr!

			if (ptr@)
				// while we were blocked waiting for that page, someone else
				// managed to accomplish what we were doing. free the page we
				// just allocated, and continue in our weird loop so that we
				// can just yoink that one.

				if (ok@)
					// we failed to allocate the page anyway so don't defer
					// freeing it.

					0 pfn!
				end

				continue
			end

			IPLDPC KeIPLRaise ipl!

			rs@ HALCPUInterruptRestore
		end

		if (ok@)
			ipl@ KeIPLLower

			return
		end

		break
	end

	bucketindex@ pfdbe@ MmPageFrameEntrySlab_BucketIndex + !

	pfn@ PAGESHIFT << IDENTITYSPACE | ptr!

	if (DEBUGCHECKS)
		0 ptr@ MmPoolSlab_Reserved + sb
	end

	bucketindex@ ptr@ MmPoolSlab_BucketIndex + sb
	0 ptr@ MmPoolSlab_PrevFree + !
	tag@ ptr@ MmPoolSlab_TagOrNextFree + !
	MMSLABSWIFTMAGIC ptr@ MmPoolSlab_Magic + si

	pfdbe@ MmPoolPageInsert

	// store current slab pointer in pfdbe to avoid saving another auto in the
	// function prologue
	ptr@ sz@ + pfdbe!

	// store last slab pointer in ok for same reason as above
	listhead@@ ok!

	while (slabsperpage@)
		if (DEBUGCHECKS)
			0 pfdbe@ MmPoolSlab_Reserved + sb
		end

		bucketindex@ pfdbe@ MmPoolSlab_BucketIndex + sb
		0 pfdbe@ MmPoolSlab_PrevFree + !
		ok@ pfdbe@ MmPoolSlab_TagOrNextFree + !
		MMSLABFREEMAGIC pfdbe@ MmPoolSlab_Magic + si

		if (ok@)
			pfdbe@ ok@ MmPoolSlab_PrevFree + !
		end

		pfdbe@ ok!
		1 slabsperpage -=
		sz@ pfdbe +=
	end

	sz@ pfdbe -=
	pfdbe@ listhead@!

	if (DEBUGCHECKS)
		1 [bucketindex@]MmSlabBucketCounts +=
	end

	PAGESIZE MmSlabBytesUsedExternally +=
	sz@ MmSlabBytesUsedInternally +=

	ipl@ KeIPLLower

	MmPoolSlab_SIZEOF ptr +=

	0 ok!
end

fn MmSlabFree { ptr -- }
	MmPoolSlab_SIZEOF ptr -=

	if (ptr@ MmPoolSlab_Magic + gi MMSLABSWIFTMAGIC ~=)
		ptr@ MmPoolSlab_Magic + gi
		ptr@ "MmSlabFree: slab 0x%08x had bad magic (0x%08x)\n" KeCrash
	end

	if (DEBUGCHECKS)
		if (ptr@ MmPoolSlab_Reserved + gb)
			ptr@ MmPoolSlab_Reserved + gb
			ptr@ "MmSlabFree: slab 0x%08x had a non-zero reserved byte (0x%08x)\n" KeCrash
		end
	end

	auto pfn
	ptr@ IDENTITYSPACE ~ & PAGESHIFT >> pfn!

	auto pfdbe
	pfn@ MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto bucketindex
	ptr@ MmPoolSlab_BucketIndex + gb bucketindex!

	auto h

	MMSLABFREEMAGIC ptr@ MmPoolSlab_Magic + si

	auto sz
	1 MMSLABPO2START bucketindex@ + << sz!

	auto rs
	HALCPUInterruptDisable rs!

	auto listhead
	[bucketindex@]MmSlabListHeads listhead!

	listhead@@ h!

	h@ ptr@ MmPoolSlab_TagOrNextFree + !
	0 ptr@ MmPoolSlab_PrevFree + !
	ptr@ listhead@!

	if (h@)
		ptr@ h@ MmPoolSlab_PrevFree + !
	end

	pfdbe@ MmEvictablePageDereference drop

	if (DEBUGCHECKS)
		1 [bucketindex@]MmSlabBucketCounts -=
	end

	sz@ MmSlabBytesUsedInternally -=

	rs@ HALCPUInterruptRestore
end

fn (MmEvictionFunction) MmSlabEvictionFunction { pfdbe -- }
	pfdbe@ MmPoolPageRemove

	// we need to unlink all the free slabs from the proper list

	auto bucketindex
	pfdbe@ MmPageFrameEntrySlab_BucketIndex + @ bucketindex!

	auto listhead
	[bucketindex@]MmSlabListHeads listhead!

	auto slab
	pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | slab!

	auto sz
	1 MMSLABPO2START bucketindex@ + << sz!

	auto slabsperpage
	PAGESIZE bucketindex@ MMSLABPO2START + >> slabsperpage!

	while (slabsperpage@)
		if (slab@ MmPoolSlab_Magic + gi MMSLABFREEMAGIC ~=)
			slab@ MmPoolSlab_Magic + gi
			slab@ MmPoolSlab_TagOrNextFree + @
			slab@
			"MmSlabEvictionFunction: 0x%08x (0x%08x): bad magic 0x%04x\n" KeCrash
		end

		auto ls
		slab@ MmPoolSlab_PrevFree + @ ls!

		auto ns
		slab@ MmPoolSlab_TagOrNextFree + @ ns!

		if (ls@)
			ns@ ls@ MmPoolSlab_TagOrNextFree + !
		end else
			ns@ listhead@!
		end

		if (ns@)
			ls@ ns@ MmPoolSlab_PrevFree + !
		end

		sz@ slab +=
		1 slabsperpage -=
	end

	PAGESIZE MmSlabBytesUsedExternally -=
end