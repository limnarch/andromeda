//
// Implements the memory management worker threads.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

// fraction over 128 of the number of evicted pages that should be written to
// swap.
var MmSwappiness 0
public MmSwappiness

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the swap thread

	auto sleptonce
	0 sleptonce!

	auto failcount
	0 failcount!

	auto forcedire
	0 forcedire!

	auto ipl

	while (1)
		auto ok
		auto reason
		auto evictcount

		KERNELMODE // waitmode
		0 // alertable
		2000 // timeout
		MmEventLowMemory // object
		KeThreadWaitForObject reason!

		if (DEBUGCHECKS)
			if (reason@)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "MmEvictionWorker: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		IPLDPC KeIPLRaise ipl!

		if (MmPageFreeCount@ MmEvictableFastPageCount@ + MmPageFreeCountSufficient@ >=)
			MmEventLowMemory // event
			KeEventReset drop

			ipl@ KeIPLLower

			0 sleptonce!
			0 failcount!
			0 forcedire!

			continue
		end else
			MmPageFreeCountSufficient@ MmEvictableFastPageCount@ + MmPageFreeCount@ - evictcount!
		end

		ipl@ KeIPLLower

		if (failcount@ 4 >=)
			// we've been here a lot of times...
			// giving up the processor for 50ms might untangle things and help
			// us evict more pages...

			50 // interval
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep ok!

			if (DEBUGCHECKS)
				if (ok@ STATUS_WAIT_TIMEOUT ~=)
					ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
				end
			end

			1 forcedire!
			0 failcount!

			continue
		end

		if (sleptonce@ ~~)
			if (IOCachePagesDirtyCount@ IOCachePagesDirtyMaximum@ 3 / >=)
				// there's IOCachePagesDirtyMaximum/3 or more dirty page
				// frames.
				// go to sleep for 50ms with the hope that the writebehind
				// worker will have freed some up by
				// the time we wake up.

				// we may do this only once per eviction period.
				1 sleptonce!

				50 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
					end
				end

				continue
			end
		end

		auto succeedcount
		0 succeedcount!

		auto done
		0 done!

		evictcount@ // trycount
		0 // fast
		MmEvictablePageListHead // listhead
		MmEvictFromList ok! done! succeedcount!

		if (ok@)
			ok@ "MmEvictionWorker: slow page evict (%i)\n" KeCrash
		end

		if (succeedcount@ evictcount@ >=)
			0 failcount!
		end

		if (done@)
			continue
		end

		1 failcount +=
	end
end

fn MmPopulateLists { dire pagecount -- }
	auto ok

	auto ipl
	IPLDPC KeIPLRaise ipl!

	// check if we need to populate the lists at all judging by their current
	// sizes and the given pagecount.

	if (MmEvictablePageCount@ pagecount@ >=)
		ipl@ KeIPLLower

		return
	end

	MmEvictablePageCount@ pagecount -=

	ipl@ KeIPLLower

	PsProcessListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmPopulateLists: failed to lock process list\n" KeCrash
		end
	end

	auto process
	PsProcessListHead@ process!

	auto count
	PsActiveProcessCount@ count!

	auto nprocess

	while (process@ count@ &&)
		process@ PsProcess_GlobalListNext + @ nprocess!

		if (process@ PsProcess_WorkingSetSize + @)
			process@ MmWorkingSetLockTimeout ok!

			if (ok@ ~~)
				dire@ // dire
				pagecount@ // pages
				process@ // process
				MmWorkingSetTrim pagecount -=

				process@ MmWorkingSetUnlock

				if (DEBUGCHECKS)
					if (pagecount@ 0 s<)
						"MmPopulateLists: pagecount<0\n" KeCrash
					end
				end

				if (process@ PsProcessListTail@ ~=)
					process@ PsProcessRemove
					process@ PsProcessInsert
				end

				if (pagecount@ ~~)
					break
				end
			end
		end

		1 count -=
		nprocess@ process!
	end

	PsProcessListUnlock
end

fn MmBalanceSetManager { -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!
	PRIORITY_LOWREALTIME 2 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet
	ipl@ KeIPLLower

	// responsible for:
	// - kernel thread stack swapping
	// - process swapping (page table swapping & working set purging)
	// - random thread priority boosting
	// - working set trimming

	// this little idiot is the only reason we will fit snugly in 4MB RAM.

	auto rs

	while (1)
		auto ok
		auto reason

		KERNELMODE // waitmode
		0 // alertable
		1000 // timeout
		MmEventLowMemory // object
		KeThreadWaitForObject reason!

		if (DEBUGCHECKS)
			if (reason@)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "MmEvictionWorker: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		if (reason@ 0 ==)
			HALCPUInterruptDisable rs!

			if (MmPageFreeCount@ MmPageFreeCountSufficient@ <)
				auto needed
				MmPageFreeCountSufficient@ MmPageFreeCount@ - needed!

				if (MmEvictablePageCount@ needed@ <)
					MmEvictablePageCount@ needed -=

					rs@ HALCPUInterruptRestore

					MmPageFreeCount@ MMDIREPAGES < // dire
					needed@ // pagecount
					MmPopulateLists
				end else
					rs@ HALCPUInterruptRestore
				end
			end else
				rs@ HALCPUInterruptRestore
			end

			// wait 100ms before trying again

			100 // interval
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep drop
		end
	end
end

fn MmZeroPageWorker { -- }
	// the fate of the idle thread is to endlessly spin and check for page
	// frames in the free list. if it finds any, it zeroes them out and places
	// them on the zero list. if it doesn't, it halts the processor until next
	// interrupt.

	while (1)
		auto pfdbe
		MmPageFreeListHead@ pfdbe!

		if (pfdbe@)
			// there's a page, zero it

			auto rs
			HALCPUInterruptDisable rs!

			MmPageFreeListHead@ pfdbe!

			// make sure the free list didnt become empty in that brief timespan

			if (pfdbe@ ~~)
				rs@ HALCPUInterruptRestore

				continue
			end

			// yoink off the list

			auto pfn
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			// account for the absence of this page frame from either list while we're zeroing it

			1 MmPageFreeCount -=

			rs@ HALCPUInterruptRestore

			// zero out this page frame

			pfn@ PAGESHIFT << IDENTITYSPACE | // ptr
			PAGESIZE // size
			0 // word
			memset

			HALCPUInterruptDisable rs!

			// place on zero list

			MmPageZeroListHead@ pfdbe@ MmPageFrameEntryFree_Next + !
			pfdbe@ MmPageZeroListHead!

			1 MmPageFreeCount +=

			rs@ HALCPUInterruptRestore
		end else
			// there are no free list pages for now, halt

			HALCPUHalt
		end
	end
end