//
// Implements the memory management worker threads.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

// fraction over 128 of the number of evicted pages that should be written to
// swap.
var MmSwappiness 0
public MmSwappiness

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the eviction/swap thread

	auto sleptonce
	0 sleptonce!

	auto failcount
	0 failcount!

	auto forcedire
	0 forcedire!

	auto ipl

	while (1)
		auto ok
		auto reason
		auto evictcount

		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		MmEventLowMemory // object
		KeThreadWaitForObject reason!

		if (DEBUGCHECKS)
			if (reason@)
				reason@ "MmEvictionWorker: failed to wait on low memory event (%i)\n" KeCrash
			end
		end

		IPLDPC KeIPLRaise ipl!

		if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
			MmEventLowMemory // event
			KeEventReset drop

			ipl@ KeIPLLower

			0 sleptonce!
			0 failcount!
			0 forcedire!

			continue
		end else
			MmPageFreeCountSufficient@ MmPageFreeCount@ - evictcount!
		end

		ipl@ KeIPLLower

		if (failcount@ 4 >=)
			// we've been here a lot of times...
			// giving up the processor for 50ms might untangle things and help
			// us evict more pages...

			50 // interval
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep ok!

			if (DEBUGCHECKS)
				if (ok@ STATUS_WAIT_TIMEOUT ~=)
					ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
				end
			end

			1 forcedire!
			0 failcount!

			continue
		end

		auto slowcount

		// in normal person speak this is
		// swapcount = evictcount * (MmSwappiness/128)
		evictcount@ 7 << MmSwappiness@ * 14 >> slowcount!

		auto fastcount
		evictcount@ slowcount@ - fastcount!

		if (sleptonce@ ~~)
			if (IOCachePagesDirtyCount@ IOCachePagesDirtyMaximum@ 3 / >=)
				// there's IOCachePagesDirtyMaximum/3 or more dirty page
				//frames.
				// go to sleep for 50ms with the hope that the writebehind
				// worker will have freed some up by
				// the time we wake up.

				// we may do this only once per eviction period.
				1 sleptonce!

				50 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
					end
				end

				continue
			end
		end

		// ensure we can progress by putting a minimum on these
		if (MmSwappiness@)
			slowcount@ 10 max slowcount!
		end
		fastcount@ 16 max fastcount!

		fastcount@ slowcount@ + evictcount!

		auto succeedcount
		0 succeedcount!

		auto done
		0 done!

		auto big
		0 big!

		if (MmEvictableFastPageCount@ evictcount@ 100 + >)
			// there's enough fast pages to fulfill the eviction, with a
			// margin of 100 pages. attempt the entire eviction through the
			// fast list.

			evictcount@ // trycount
			1 // fast
			MmEvictableFastPageListHead // listhead
			MmEvictFromList ok! done! succeedcount!

			if (ok@)
				ok@ "MmEvictionWorker: fast page evict (%i)\n" KeCrash
			end

			1 big!
		end elseif (MmEvictableSlowPageCount@ evictcount@ 50 + > MmSwappiness@ &&)
			// there's enough slow pages to fulfill the eviction, with a
			// margin of 50 pages.

			evictcount@ // trycount
			0 // fast
			MmEvictablePageListHead // listhead
			MmEvictFromList ok! done! succeedcount!

			if (ok@)
				ok@ "MmEvictionWorker: slow page evict (%i)\n" KeCrash
			end

			1 big!
		end

		if (big@)
			if (done@ ~~)
				1 failcount +=
			end

			continue
		end

		// attempt to collect enough pages in both lists to satisfy these
		// targets

		MmPageFreeCount@ MMDIREPAGES < forcedire@ || // dire
		evictcount@ // pagecount
		MmPopulateLists

		// try a combination

		fastcount@ // trycount
		1 // fast
		MmEvictableFastPageListHead // listhead
		MmEvictFromList ok! done! succeedcount!

		if (ok@)
			ok@ "MmEvictionWorker: fast page evict (%i)\n" KeCrash
		end

		if (succeedcount@ fastcount@ >=)
			0 failcount!
		end

		if (done@)
			continue
		end

		slowcount@ // trycount
		0 // fast
		MmEvictablePageListHead // listhead
		MmEvictFromList ok! done! succeedcount!

		if (ok@)
			ok@ "MmEvictionWorker: slow page evict (%i)\n" KeCrash
		end

		if (succeedcount@ fastcount@ >=)
			0 failcount!
		end

		if (done@)
			continue
		end

		1 failcount +=
	end
end

fn MmPopulateLists { dire pagecount -- }
	auto ok

	auto ipl
	IPLDPC KeIPLRaise ipl!

	// check if we need to populate the lists at all judging by their current
	// sizes and the given pagecount.

	if (MmEvictableFastPageCount@ MmEvictableSlowPageCount@ + pagecount@ >=)
		ipl@ KeIPLLower

		return
	end

	MmEvictableFastPageCount@ MmEvictableSlowPageCount@ + pagecount -=

	ipl@ KeIPLLower

	PsProcessListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmPopulateLists: failed to lock process list\n" KeCrash
		end
	end

	auto process
	PsProcessListHead@ process!

	auto count
	PsActiveProcessCount@ count!

	auto nprocess

	while (process@ count@ &&)
		process@ PsProcess_GlobalListNext + @ nprocess!

		if (process@ PsProcess_WorkingSetSize + @)
			process@ MmWorkingSetLockTimeout ok!

			if (ok@ ~~)
				dire@ // dire
				pagecount@ // pages
				process@ // process
				MmWorkingSetTrim pagecount -=

				process@ MmWorkingSetUnlock

				if (DEBUGCHECKS)
					if (pagecount@ 0 s<)
						"MmPopulateLists: pagecount<0\n" KeCrash
					end
				end

				if (process@ PsProcessListTail@ ~=)
					process@ PsProcessRemove
					process@ PsProcessInsert
				end

				if (pagecount@ ~~)
					break
				end
			end
		end

		1 count -=
		nprocess@ process!
	end

	PsProcessListUnlock
end

fn MmZeroPageWorker { -- }
	// the fate of the idle thread is to endlessly spin and check for page
	// frames in the free list. if it finds any, it zeroes them out and places
	// them on the zero list. if it doesn't, it halts the processor until next
	// interrupt.

	while (1)
		auto pfdbe
		MmPageFreeListHead@ pfdbe!

		if (pfdbe@)
			// there's a page, zero it

			auto rs
			HALCPUInterruptDisable rs!

			MmPageFreeListHead@ pfdbe!

			// make sure the free list didnt become empty in that brief timespan

			if (pfdbe@ ~~)
				rs@ HALCPUInterruptRestore

				continue
			end

			// yoink off the list

			auto pfn
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			// account for the absence of this page frame from either list while we're zeroing it

			1 MmPageFreeCount -=

			rs@ HALCPUInterruptRestore

			// zero out this page frame

			pfn@ PAGESHIFT << IDENTITYSPACE | // ptr
			PAGESIZE // size
			0 // word
			memset

			HALCPUInterruptDisable rs!

			// place on zero list

			MmPageZeroListHead@ pfdbe@ MmPageFrameEntryFree_Next + !
			pfdbe@ MmPageZeroListHead!

			1 MmPageFreeCount +=

			rs@ HALCPUInterruptRestore
		end else
			// there are no free list pages for now, halt

			HALCPUHalt
		end
	end
end