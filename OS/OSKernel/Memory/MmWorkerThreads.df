//
// Implements the memory management worker threads.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn MmModifiedPageWriter { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	IOSwapFileAwaitCreation

	// the swap thread. writes out modified anon pages and slaps them on the
	// evictable list. does this when it is asked to and also every 30
	// seconds.

	while (1)
		auto ok
		auto waitok

		KERNELMODE // waitmode
		0 // alertable
		30000 // timeout
		MmModifiedPageEvent // object
		KeThreadWaitForObject waitok!

		if (DEBUGCHECKS)
			if (waitok@ 0 s<)
				if (waitok@ STATUS_WAIT_TIMEOUT ~=)
					waitok@ "MmModifiedPageWriter: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		auto writescore
		0 writescore!

		auto modcount
		MmEvictableModifiedPageCount@ modcount!

		while (1)
			if (modcount@ ~~)
				if (waitok@ 0 ==)
					100 // interval
					KERNELMODE // waitmode
					0 // alertable
					KeThreadSleep drop
				end

				break
			end

			auto thresh

			if (modcount@ 1 ==)
				1 thresh!
			end else
				modcount@ 1 >> thresh!
			end

			if (writescore@ thresh@ >=)
				// if we tried to unsuccessfully write modcount/2 times in a
				// row, odds are we're stuck in an infinite loop and we need
				// to let user threads run for a bit in order to successfully
				// write out any more pages. go to sleep for 50ms.

				0 writescore!

				50 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "MmModifiedPageWriter: wait failed (%i)\n" KeCrash
					end
				end

				MmEvictableModifiedPageCount@ modcount!

				0 ok!
			end

			auto written
			auto dropped

			auto ipl
			IPLDPC KeIPLRaise ipl!

			auto pfdbe
			MmEvictableModifiedPageListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmEvictablePageReference drop

				auto evictionfuncs
				pfdbe@ MmPageFrameEntryEvictable_EvictableFunctions + @ evictionfuncs!

				pfdbe@ // pfdbe
				evictionfuncs@ MmEvictableFunctions_WriteModifiedFunc + @
				MmWriteModifiedFunction drop dropped! written!

				if (written@ ~~)
					1 writescore +=
				end else
					0 writescore!

					if (modcount@)
						1 modcount -=
					end
				end

				pfdbe@ MmEvictablePageDereference drop
			end else
				0 modcount!
			end

			ipl@ KeIPLLower
		end
	end
end

fn MmPopulateLists { dire pagecount -- }
	auto ok

	PsProcessListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmPopulateLists: failed to lock process list\n" KeCrash
		end
	end

	auto process
	PsProcessListHead@ process!

	auto count
	PsActiveProcessCount@ count!

	auto nprocess

	while (process@ count@ &&)
		process@ PsProcess_GlobalListNext + @ nprocess!

		if (process@ PsProcess_WorkingSetSize + @)
			process@ MmWorkingSetLockTimeout ok!

			if (ok@ ~~)
				auto trimmed

				dire@ // dire
				pagecount@ // pages
				process@ // process
				MmWorkingSetTrim trimmed!

				process@ MmWorkingSetUnlock

				if (process@ PsProcessListTail@ ~=)
					process@ PsProcessRemove
					process@ PsProcessInsert
				end

				if (trimmed@ pagecount@ >=)
					break
				end

				trimmed@ pagecount -=
			end
		end

		1 count -=
		nprocess@ process!
	end

	PsProcessListUnlock
end

buffer MmBalanceSetManagerTimer KeTimer_SIZEOF

const MMBALANCESETINTERVAL 1000

fn MmBalanceSetManager { -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet
	ipl@ KeIPLLower

	// responsible for:
	// - kernel thread stack swapping
	// - process swapping (page table swapping & working set purging)
	// - random thread priority boosting
	// - working set trimming

	// this little idiot is the only reason we will fit snugly in 4MB RAM.

	"MmBalanceSetManagerTimer" // name
	0 // function
	MmBalanceSetManagerTimer // timer
	KeTimerInitialize

	auto objecttable
	8 alloc objecttable!

	MmBalanceSetManagerTimer objecttable@!
	MmEventLowMemory objecttable@ 4 + !

	0 // context1
	0 // context2
	MMBALANCESETINTERVAL // interval
	MmBalanceSetManagerTimer // timer
	KeTimerEnqueue

	while (1)
		auto ok
		auto reason

		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		OSWAIT_TIMEOUTINFINITE // timeout
		2 // objectcount
		objecttable@ // objecttable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ 0 s<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "MmBalanceSetManager: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		auto needed
		auto dire

		if (reason@ 0 ==)
			// timer expired

			0 // context1
			0 // context2
			MMBALANCESETINTERVAL // interval
			MmBalanceSetManagerTimer // timer
			KeTimerEnqueue
		end elseif (reason@ 1 ==)
			// low memory event

			IPLDPC KeIPLRaise ipl!

			if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ >=)
				MmEventLowMemory // event
				KeEventReset drop

				ipl@ KeIPLLower

				continue
			end

			MmPageFreeCountSufficient@ MmPageFreeCount@ MmEvictablePageCount@ + - needed!
			MmPageFreeCount@ MmEvictablePageCount@ + MMDIREPAGES < dire!

			ipl@ KeIPLLower

			dire@ // dire
			needed@ // pagecount
			MmPopulateLists

			// wait 100ms before trying again

			100 // interval
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep drop
		end
	end
end

fn MmZeroPageWorker { -- }
	// the fate of the idle thread is to endlessly spin and check for page
	// frames in the free list. if it finds any, it zeroes them out and places
	// them on the zero list. if it doesn't, it halts the processor until next
	// interrupt.

	while (1)
		auto pfdbe
		MmPageFreeListHead@ pfdbe!

		if (pfdbe@)
			// there's a page, zero it

			auto rs
			HALCPUInterruptDisable rs!

			MmPageFreeListHead@ pfdbe!

			// make sure the free list didnt become empty in that brief timespan

			if (pfdbe@ ~~)
				rs@ HALCPUInterruptRestore

				continue
			end

			// yoink off the list

			auto pfn
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			// account for the absence of this page frame from either list while we're zeroing it

			rs@ HALCPUInterruptRestore

			// zero out this page frame

			pfn@ PAGESHIFT << IDENTITYSPACE | // ptr
			PAGESIZE // size
			0 // word
			memset

			HALCPUInterruptDisable rs!

			// place on zero list

			MmPageZeroListHead@ pfdbe@ MmPageFrameEntryFree_Next + !
			pfdbe@ MmPageZeroListHead!

			rs@ HALCPUInterruptRestore
		end else
			// there are no free list pages for now, halt

			HALCPUHalt
		end
	end
end