#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OSStatus.h"

// fraction over 128 of the number of evicted pages that should be written to
// swap.
var MmSwappiness 0
public MmSwappiness

fn MmEvictionWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// the eviction/swap thread

	auto sleptonce
	0 sleptonce!

	auto failcount
	0 failcount!

	auto ipl

	while (1)
		auto ok
		auto reason
		auto evictcount

		KERNELMODE // waitmode
		0 // alertable
		60000 // timeout (evict up to the high watermark every 60 seconds)
		MmEventLowMemory // object
		KeThreadWaitForObject reason!

		if (DEBUGCHECKS)
			if (reason@)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "MmEvictionWorker: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		IPLDPC KeIPLRaise ipl!

		if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
			MmEventLowMemory // event
			KeEventReset drop

			ipl@ KeIPLLower

			0 sleptonce!
			0 failcount!

			continue
		end else
			MmPageFreeCountSufficient@ MmPageFreeCount@ - evictcount!
		end

		ipl@ KeIPLLower

		1 failcount +=

		if (failcount@ 8 >=)
			// we've been here a lot of times...
			// giving up the processor for 25ms might untangle things and help
			// us evict more pages...

			25 // interval
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep ok!

			if (DEBUGCHECKS)
				if (ok@ STATUS_WAIT_TIMEOUT ~=)
					ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
				end
			end

			0 failcount!

			continue
		end

		auto slowcount

		// in normal person speak this is
		// swapcount = evictcount * (MmSwappiness/128)
		evictcount@ 7 << MmSwappiness@ * 14 >> slowcount!

		auto fastcount
		evictcount@ slowcount@ - fastcount!

		if (reason@ STATUS_WAIT_TIMEOUT ~=)
			if (sleptonce@ ~~)
				if (IOCacheModifiedPageListHead@)
					// there's some modified page frames.
					// go to sleep for 50ms with the hope that the modified page writer will have freed some up by
					// the time we wake up.

					// we may do this only once per eviction period.

					1 sleptonce!

					50 // interval
					KERNELMODE // waitmode
					0 // alertable
					KeThreadSleep ok!

					if (DEBUGCHECKS)
						if (ok@ STATUS_WAIT_TIMEOUT ~=)
							ok@ "MmEvictionWorker: wait failed (%i)\n" KeCrash
						end
					end

					continue
				end
			end

			// ensure we can progress by putting a minimum on these
			if (MmSwappiness@)
				slowcount@ 20 max slowcount!
			end
			fastcount@ 32 max fastcount!
		end

		// attempt to collect enough pages in both lists to satisfy these
		// targets

		auto succeedcount

		slowcount@ // slowneeded
		fastcount@ // fastneeded
		MmPopulateLists

		if (reason@ STATUS_WAIT_TIMEOUT ~=)
			auto done

			fastcount@ // trycount
			1 // fast
			MmEvictableFastPageListHead // listhead
			MmEvictFromList ok! done! succeedcount!

			if (ok@)
				ok@ "MmEvictionWorker: fast page evict (%i)\n" KeCrash
			end

			if (done@)
				// free page count became sufficient while evicting
				continue
			end

			if (succeedcount@)
				0 failcount!
			end

			slowcount@ // trycount
			0 // fast
			MmEvictablePageListHead // listhead
			MmEvictFromList ok! done! succeedcount!

			if (ok@)
				ok@ "MmEvictionWorker: slow page evict (%i)\n" KeCrash
			end

			if (done@)
				continue
			end

			if (succeedcount@)
				0 failcount!
			end
		end
	end
end

fn MmPopulateLists { slowneeded fastneeded -- }
	// aims towards getting at least slowneeded and fastneeded pages in each
	// list.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	// check if we need to populate the lists at all judging by their current
	// sizes and the given slowneeded and fastneeded.

	if (fastneeded@ MmEvictableFastPageCount@ >)
		MmEvictableFastPageCount@ fastneeded -=
	end else
		0 fastneeded!
	end

	if (slowneeded@ MmEvictableSlowPageCount@ >)
		MmEvictableSlowPageCount@ slowneeded -=
	end else
		0 fastneeded!
	end

	if (fastneeded@ ~~)
		if (slowneeded@ ~~)
			ipl@ KeIPLLower

			return
		end
	end

	// IPL still raised...

	"MmPopulateLists: TODO trim working sets\n" KeCrash
end

fn MmZeroPageWorker { -- }
	// the fate of the idle thread is to endlessly spin and check for page
	// frames in the free list. if it finds any, it zeroes them out and places
	// them on the zero list. if it doesn't, it halts the processor until next
	// interrupt.

	while (1)
		auto pfdbe
		MmPageFreeListHead@ pfdbe!

		if (pfdbe@)
			// there's a page, zero it

			auto rs
			HALCPUInterruptDisable rs!

			MmPageFreeListHead@ pfdbe!

			if (pfdbe@ ~~)
				// make sure the free list didnt become empty in that brief timespan

				rs@ HALCPUInterruptRestore

				continue
			end

			// yoink off the list

			auto pfn
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			// account for the absence of this page frame from either list while we're zeroing it

			1 MmPageFreeCount -=

			rs@ HALCPUInterruptRestore

			// zero out this page frame

			pfn@ PAGESHIFT << IDENTITYSPACE | // ptr
			PAGESIZE // size
			0 // word
			memset

			HALCPUInterruptDisable rs!

			// place on zero list

			MmPageZeroListHead@ pfdbe@ MmPageFrameEntryFree_Next + !
			pfdbe@ MmPageZeroListHead!

			1 MmPageFreeCount +=

			rs@ HALCPUInterruptRestore
		end else
			// there are no free list pages for now, halt

			HALCPUHalt
		end
	end
end