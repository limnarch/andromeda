//
// Implements allocation of private virtual memory for userspace.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn MmAllocateProcessObject { length startva processobject pageprotection flags -- realva ok }
	auto kernelmapping
	processobject@ PsSystemProcess@ == kernelmapping!

	if (kernelmapping@)
		if (flags@ OSMAPFLAG_FIXEDADDRESS &)
			STATUS_INVALID_ARGUMENT ok!
			return
		end
	end

	if (pageprotection@ PAGEACCESS_WRITECOPY &)
		// COW makes no sense for private memory.
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (startva@ PAGEOFFSETMASK &)
		// requested startva isn't page-aligned
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (length@ 0 ==)
		// length is given as 0 which makes this a no-op
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	length@ PAGEOFFSETMASK + PAGENUMBERMASK & length!

	if (length@ 0 ==)
		// length overflowed
		STATUS_OVERFLOW ok!

		return
	end

	if (startva@ length@ + startva@ <)
		// startva+length overflows
		STATUS_OVERFLOW ok!

		return
	end

	if (kernelmapping@ ~~)
		if (startva@ length@ + MMHIGHESTUSERADDRESS >)
			// requested region goes outside userspace

			if (flags@ OSMAPFLAG_FIXEDADDRESS &)
				STATUS_UNAVAILABLE_ADDRESS ok!

				return
			end

			0 startva!
		end
	end

	// XXX in principle we only need to do this if the target process is
	// different from the calling process, but its easier to just always lock
	// the createdelete rwlock.

	0 // needsthread
	processobject@ // processobject
	PsProcessCreateDeleteAcquireCheck ok!

	if (ok@)
		return
	end

	if (kernelmapping@)
		// this is a kernel mapping, so reserve POOLSPACE and use that as the
		// startva. it must be done like this because kernel page tables are
		// necessarily not dynamic.

		length@ PAGESHIFT >> MmPoolSpaceReserve ok! startva!

		if (ok@)
			processobject@ PsProcessCreateDeleteUnlock

			return
		end

		startva@ PAGESHIFT << POOLSPACE + startva!
	end

	length@ // viewsize
	startva@ // startva
	flags@ OSMAPFLAG_FIXEDADDRESS & // fixedva
	pageprotection@ // pageprotection
	0 // sectionoffset
	0 // mappedobject
	processobject@ // processobject
	MmVADFindAndMapFreeRegion ok! realva!

	if (ok@)
		if (kernelmapping@)
			length@ PAGESHIFT >> // pages
			startva@ POOLSPACE - PAGESHIFT >> // offset
			MmPoolSpaceRelease
		end
	end

	processobject@ PsProcessCreateDeleteUnlock
end

fn MmAllocate { length startva processhandle pageprotection flags -- realva ok }
	auto access
	auto processobject

	PsProcessObjectType@ // type
	processhandle@ // handle
	ObObjectReferenceByHandle ok! processobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	length@ // length
	startva@ // startva
	processobject@ // processobject
	pageprotection@ // pageprotection
	flags@ // flags
	MmAllocateProcessObject ok! realva!

	processobject@ ObObjectDereferenceByPointer drop
end