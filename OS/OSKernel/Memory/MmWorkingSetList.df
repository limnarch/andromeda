//
// Implements the Working Set List (WSL) data structure.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMWORKINGSETENTRY_VALID 1
const MMWORKINGSETENTRY_FILE  2

const MMWORKINGSETTABLESIZE       (128 MmPoolSlab_SIZEOF -)
const MMWORKINGSETENTRIESPERTABLE (MMWORKINGSETTABLESIZE 4 /)

fn MmWorkingSetLock { processobject -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetLockTimeout { timeout processobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	timeout@ // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetTryLock { processobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetUnlock { processobject -- }
	0 // abandon
	processobject@ PsProcess_WorkingSetMutex + // mutex
	KeMutexRelease drop
end

fn MmWorkingSetListInitialize { process -- ok }
	0 ok!

	"MmWorkingSetMutex" // name
	KERNELMODE // mode
	process@ PsProcess_WorkingSetMutex + // mutex
	KeMutexInitialize

	0 process@ PsProcess_WorkingSetSize + !
	MMWORKINGSETDEFAULTMINIMUM process@ PsProcess_WorkingSetMinimum + !
	MMWORKINGSETDEFAULTMAXIMUM process@ PsProcess_WorkingSetMaximum + !

	-1 process@ PsProcess_WorkingSetFreeListHead + !
	-1 process@ PsProcess_WorkingSetMaximumIndex + !
	0 process@ PsProcess_WorkingSetReplacementIndex + !
	0 process@ PsProcess_WorkingSetTrimFaultCount + !

	process@ PsProcess_WorkingSetListPointers + // ptr
	WORKINGSETLISTCOUNT 4 * // size
	0 // word
	memset

	// allocate the first working set list table now.


end

// unless explicitly stated otherwise, all working set manipulation functions
// assume the caller took care of the necessary locking.

fn MmWorkingSetListFree { process -- }
	if (DEBUGCHECKS)
		if (process@ PsProcess_WorkingSetSize + @)
			process@ PsProcess_WorkingSetSize + @
			"MmWorkingSetListFree: working set size > 0 (%d)\n" KeCrash
		end
	end

	auto count
	WORKINGSETLISTCOUNT count!

	auto ptr
	process@ PsProcess_WorkingSetListPointers + ptr!

	while (count@)
		if (ptr@@)
			ptr@@ MmFree

			0 ptr@!
		end

		4 ptr +=
		1 count -=
	end

	-1 process@ PsProcess_WorkingSetFreeListHead + !
	-1 process@ PsProcess_WorkingSetMaximumIndex + !
	0 process@ PsProcess_WorkingSetReplacementIndex + !
end

fn MmWorkingSetTrimPage { wsli wsleptr process -- }
	wsleptr@ // wsleptr
	process@ // process
	MmWorkingSetEntryRemove

	wsli@ // wsli
	wsleptr@ // wsleptr
	process@ // process
	MmWorkingSetEntryFree

	1 // charge
	process@ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeWorkingSet
end

fn MmWorkingSetTrim { dire pages process -- trimmed }
	// trim the working set of the specified process.
	// attempt to trim the given number of pages, and return the real number
	// of pages trimmed.

	0 trimmed!

	auto wsli
	auto wsleptr
	auto ok

	process@ PsProcess_PageFaultCount + @ process@ PsProcess_WorkingSetTrimFaultCount + !

	while (process@ PsProcess_WorkingSetSize + @ process@ PsProcess_WorkingSetMaximum + @ >)
		// greater than the maximum, nuke all the way down to it

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end

	if (dire@)
		15 pages@ min pages!
	end else
		5 pages@ min pages!
	end

	while (process@ PsProcess_WorkingSetSize + @ process@ PsProcess_WorkingSetMinimum + @ >)
		// between minimum and maximum, nuke at most 5 entries, or 15 if dire

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end

	auto musthave

	if (dire@)
		0 musthave!
		5 pages@ min pages!
	end else
		2 musthave!
		1 pages@ min pages!
	end

	while (process@ PsProcess_WorkingSetSize + @ musthave@ >)
		// below minimum, nuke only 1 entry, or 5 if dire

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end
end

fn MmWorkingSetPurge { process -- }
	// purge the entire working set of the process

	0 // startva
	MMHIGHESTUSERADDRESS 1 + // endva
	process@ // process
	MmWorkingSetTrimRange
end

fn MmWorkingSetRemap { flags startva endva process -- }
	// update all of the mapped PTEs in the process to have the new flags.

	auto wsli
	0 wsli!

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	auto wsleptr
	tabptr@@ wsleptr!

	auto wsle

	auto ok
	auto pteaddr

	auto leftintable
	MMWORKINGSETENTRIESPERTABLE leftintable!

	auto maxi
	process@ PsProcess_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		return
	end

	while (wsli@ maxi@ <=)
		if (leftintable@ ~~)
			4 tabptr +=
			tabptr@@ wsleptr!
			MMWORKINGSETENTRIESPERTABLE leftintable!
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			if (wsle@ startva@ >=)
				if (wsle@ endva@ <)
					// found one, remap it

					wsle@ // vaddr
					process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
					MmVirtualtoPTEAddress ok! pteaddr!

					if (DEBUGCHECKS)
						if (ok@)
							"MmWorkingSetRemap: no PTE\n" KeCrash
						end
					end

					auto phyaddr
					pteaddr@ // pteaddr
					MmPTEInterpret ok! drop phyaddr!

					if (DEBUGCHECKS)
						if (ok@)
							"MmWorkingSetRemap: invalid PTE\n" KeCrash
						end
					end

					phyaddr@ // phyaddr
					flags@ // flags
					wsle@ // vaddr
					pteaddr@ // pteaddr
					process@ PsProcess_PCB + KeProcess_ASID + @ // asid
					MmPTEUpdate drop drop drop
				end
			end
		end

		1 leftintable -=
		4 wsleptr +=
		1 wsli +=
	end
end

fn MmWorkingSetTrimRange { startva endva process -- }
	// trim any entries between startva and endva out of the working set.

	auto wsli
	0 wsli!

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	auto wsleptr
	tabptr@@ wsleptr!

	auto wsle

	auto leftintable
	MMWORKINGSETENTRIESPERTABLE leftintable!

	auto maxi
	process@ PsProcess_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		return
	end

	while (wsli@ maxi@ <=)
		if (process@ PsProcess_WorkingSetSize + @ ~~)
			return
		end

		if (leftintable@ ~~)
			4 tabptr +=
			tabptr@@ wsleptr!
			MMWORKINGSETENTRIESPERTABLE leftintable!
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			if (wsle@ startva@ >=)
				if (wsle@ endva@ <)
					// found one, remove it

					wsli@ // wsli
					wsleptr@ // wsleptr
					process@ // process
					MmWorkingSetTrimPage
				end
			end
		end

		1 leftintable -=
		4 wsleptr +=
		1 wsli +=
	end
end

fn MmWorkingSetEntryInsert { vaddr isfilepage wsleptr process -- }
	// caller must create the associated PTE before calling this function.

	// increments the working set size.
	// does NOT charge working set quota.

	if (DEBUGCHECKS)
		if (vaddr@ PAGEOFFSETMASK &)
			"MmWorkingSetEntryUpdate: unaligned vaddr\n" KeCrash
		end
	end

	auto wsle
	vaddr@ MMWORKINGSETENTRY_VALID | wsle!

	if (isfilepage@)
		MMWORKINGSETENTRY_FILE wsle |=
	end

	1 process@ PsProcess_WorkingSetSize + +=

	wsle@ wsleptr@!
end

fn MmWorkingSetEntryReserve { process -- wsli wsleptr ok }
	// first we check to see if the working set can take a page:
	//
	// - if the working set size is below the minimum, it can.
	//
	// - if the size is between the minimum and the maximum, it can if it has
	// had more than 20 page faults since the last time it was trimmed, and
	// the system is not in a low memory condition.
	//
	// - if the size >= maximum, it can if it has had more than 100 page faults
	// since the last time it was trimmed, and the system has at least
	// MmPageFreeCountSufficient free pages.
	//
	// - if the process's working set quota is at its maximum, it can't.
	//
	// if it can, we yoink the first free entry, mark it reserved, and return
	// the index in wsli.
	//
	// if it can't, we try to replace another entry in the working set at
	// random.

	// increments the page fault count. also charges working set quota.

	auto room
	0 room!

	0 ok!

	auto wssize
	process@ PsProcess_WorkingSetSize + @ wssize!

	if (wssize@ process@ PsProcess_WorkingSetMinimum + @ <)
		// below minimum, there's always room
		1 room!
	end elseif (wssize@ process@ PsProcess_WorkingSetMaximum + @ <)
		// between minimum and maximum
		if (MmEventLowMemory KeDispatchIsSignaled ~~)
			if (process@ PsProcess_PageFaultCount + @ process@ PsProcess_WorkingSetTrimFaultCount + @ - 20 >)
				1 room!
			end
		end
	end else
		// above maximum
		if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ >=)
			if (process@ PsProcess_PageFaultCount + @ process@ PsProcess_WorkingSetTrimFaultCount + @ - 100 >)
				1 room!
			end
		end
	end

	1 process@ PsProcess_PageFaultCount + +=

	if (room@)
		1 // charge
		process@ PsProcess_QuotaBlock + @ // quotablock
		MmQuotaBlockChargeWorkingSet ok!

		if (ok@)
			0 room!
			0 ok!
		end
	end

	while (1)
		if (room@ ~~)
			// no room, kick one out

			process@ // process
			MmWorkingSetEntryReplace ok! wsleptr! wsli!

			if (ok@)
				// failed to find one to replace...
				return
			end

			wsleptr@ // wsleptr
			process@ // process
			MmWorkingSetEntryRemove
		end else
			process@ PsProcess_WorkingSetFreeListHead + @ wsli!

			if (wsli@ -1 ~=)
				// yoink

				wsli@ // wsli
				process@ // process
				MmWorkingSetEntryFindByIndex ok! wsleptr!

				if (DEBUGCHECKS)
					if (ok@)
						"MmWorkingSetEntryReserve: failed to find by index\n" KeCrash
					end
				end

				auto wsle
				wsleptr@@ wsle!

				if (DEBUGCHECKS)
					if (wsle@ MMWORKINGSETENTRY_VALID &)
						"MmWorkingSetEntryReserve: wsle was valid\n" KeCrash
					end
				end

				if (wsle@ PAGENUMBERMASK ==)
					-1 process@ PsProcess_WorkingSetFreeListHead + !
				end else
					wsle@ PAGESHIFT >> process@ PsProcess_WorkingSetFreeListHead + !
				end
			end else
				// no free entries, we need to allocate a new working set
				// array.

				process@ MmWorkingSetArrayExpand ok! wsleptr! wsli!

				if (ok@)
					if (ok@ STATUS_NO_MEMORY ==)
						// uncharge working set quota and loop with room=0 if
						// failed to allocate, in order to retry the
						// reservation as a replacement.

						1 // charge
						process@ PsProcess_QuotaBlock + @ // quotablock
						MmQuotaBlockUnchargeWorkingSet

						0 room!

						continue
					end

					return
				end
			end
		end

		0 wsleptr@!

		return
	end

	"MmWorkingSetEntryReserve: unreachable\n" KeCrash
end

fn MmWorkingSetArrayExpand { process -- wsli wsleptr ok }
	// first we have to find the first zero pointer in the process
	// PsProcess_WorkingSetListPointers array. if there is none, we've hit the
	// capacity of the working set list data structure and must count that as
	// a failed allocation.

	// then we need to allocate the array and set the pointer in the process's
	// WorkingSetListPointers array. then we need to initialize it by placing
	// MMWORKINGSETENTRIESPERTABLE-1 of its entries on the free list,
	// reserving the last one for our caller.

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	auto count
	WORKINGSETLISTCOUNT count!

	0 wsli!

	while (count@)
		if (tabptr@@ ~~)
			// found it

			auto tab
			MMWORKINGSETTABLESIZE // bytes
			'MmWs' // tag
			0 // flags
			MmAllocWithTag ok! tab!

			if (ok@)
				return
			end

			0 tab@!

			tab@ wsleptr!
			tab@ tabptr@!

			MMWORKINGSETENTRIESPERTABLE 1 - count!

			auto last
			-1 last!

			auto iwsli
			wsli@ 1 + iwsli!

			4 tab +=

			// initialize the free list

			while (count@)
				last@ PAGESHIFT << tab@!

				iwsli@ last!
				4 tab +=
				1 iwsli +=
				1 count -=
			end

			if (DEBUGCHECKS)
				if (last@ -1 ==)
					"MmWorkingSetArrayExpand\n" KeCrash
				end
			end

			last@ process@ PsProcess_WorkingSetMaximumIndex + !
			last@ process@ PsProcess_WorkingSetFreeListHead + !

			return
		end

		MMWORKINGSETENTRIESPERTABLE wsli +=
		4 tabptr +=
		1 count -=
	end

	STATUS_NO_MEMORY ok!
end

fn MmWorkingSetEntryReplace { process -- wsli wsleptr ok }
	// find a working set entry to replace.

	0 ok!

	if (process@ PsProcess_WorkingSetMaximumIndex + @ -1 ==)
		-1 ok!

		return
	end

	auto hint
	process@ PsProcess_WorkingSetReplacementIndex + @ hint!

	if (hint@ process@ PsProcess_WorkingSetMaximumIndex + @ >)
		0 hint!
	end

	// search from the replacement index to the end of the working set for a
	// valid entry to replace, then from the start to the replacement index.

	auto i
	0 i!

	while (i@ 2 <)
		auto endindex

		if (i@ 0 ==)
			hint@ wsli!
			process@ PsProcess_WorkingSetMaximumIndex + @ 1 + endindex!
		end elseif (hint@)
			0 wsli!
			hint@ endindex!
		end else
			-1 ok!

			return
		end

		auto tabptr
		process@ PsProcess_WorkingSetListPointers + wsli@ MMWORKINGSETENTRIESPERTABLE / 2 << + tabptr!

		auto off
		wsli@ MMWORKINGSETENTRIESPERTABLE % off!

		tabptr@@ off@ 2 << + wsleptr!

		auto wsle

		auto leftintable
		MMWORKINGSETENTRIESPERTABLE off@ - leftintable!

		while (wsli@ endindex@ <)
			if (leftintable@ ~~)
				4 tabptr +=
				tabptr@@ wsleptr!
				MMWORKINGSETENTRIESPERTABLE leftintable!
			end

			wsleptr@@ wsle!

			if (wsle@ MMWORKINGSETENTRY_VALID &)
				// found one
				wsli@ 1 + process@ PsProcess_WorkingSetReplacementIndex + !

				return
			end

			1 leftintable -=
			4 wsleptr +=
			1 wsli +=
		end

		1 i +=
	end

	-1 ok!
end

fn MmWorkingSetEntryRemove { wsleptr process -- }
	// remove the specified entry from the working set. deletes the PTE unless
	// COW.

	// unmap it from the process's pagemap, and decrement its refcount.
	// if COW, set transition PTE pointers.
	// if file, clear any associated dirty PTE pointer.

	// DOES remove the valid bit, but does NOT free the entry; caller must do
	// that if it wants that to happen.

	// also does NOT uncharge working set quota.

	// decrements the working set size.

	if (DEBUGCHECKS)
		if (wsleptr@@ MMWORKINGSETENTRY_VALID & ~~)
			"MmWorkingSetEntryRemove: not valid\n" KeCrash
		end
	end

	auto vaddr
	wsleptr@@ PAGENUMBERMASK & vaddr!

	auto isfile
	wsleptr@@ MMWORKINGSETENTRY_FILE & isfile!

	auto pteaddr
	auto ok

	vaddr@ // vaddr
	process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (DEBUGCHECKS)
		if (ok@)
			"MmWorkingSetEntryRemove: no PTE\n" KeCrash
		end
	end

	auto phyaddr
	auto pfdbe
	auto flags

	pteaddr@ // pteaddr
	MmPTEInterpret ok! flags! phyaddr!

	if (DEBUGCHECKS)
		if (ok@)
			"MmWorkingSetEntryRemove: invalid PTE\n" KeCrash
		end
	end

	phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto ipl
	-1 ipl!

	if (isfile@)
		if (flags@ PTE_W &)
			IPLDPC KeIPLRaise ipl!

			if (pfdbe@ IOPageFrameEntryCache_DirtyPTE + @ pteaddr@ ==)
				0 pfdbe@ IOPageFrameEntryCache_DirtyPTE + !
				
				// DONT undirty the PTE, just leave IPL raised and allow it
				// to be unmapped below

				// pteaddr@ MmPTEUndirty
			end else
				ipl@ KeIPLLower

				-1 ipl!
			end
		end
	end

	// unmap

	0 // phyaddr
	0 // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	process@ PsProcess_PCB + KeProcess_ASID + @ // asid
	MmPTEUpdate drop drop drop

	if (ipl@ -1 ~=)
		ipl@ KeIPLLower
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + @ MMEVICTFLAG_COW &)
		// COW page. create transition PTE so we can soft-fault it back in
		// later.

		phyaddr@ PTE_TRANSITION | pteaddr@!
	end else
		pteaddr@ // pteaddr
		vaddr@ // vaddr
		process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
		MmPTEDelete drop
	end

	pfdbe@ MmEvictablePageDereference drop

	MMWORKINGSETENTRY_VALID ~ wsleptr@ &=

	auto oldcount
	process@ PsProcess_WorkingSetSize + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmWorkingSetEntryRemove: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - process@ PsProcess_WorkingSetSize + !
end

fn MmWorkingSetEntryFindByIndex { wsli process -- wsleptr ok }
	// look up a working set index in the working set and return the pointer.
	// return -1 in ok if the index is beyond the end of valid indices.

	if (process@ PsProcess_WorkingSetMaximumIndex + @ -1 ==)
		-1 ok!
		return
	end

	if (wsli@ process@ PsProcess_WorkingSetMaximumIndex + @ >)
		-1 ok!
		return
	end

	0 ok!

	auto ix
	wsli@ MMWORKINGSETENTRIESPERTABLE / ix!

	auto off
	wsli@ MMWORKINGSETENTRIESPERTABLE % off!

	auto tab
	process@ PsProcess_WorkingSetListPointers + ix@ 2 << + @ tab!

	if (DEBUGCHECKS)
		if (tab@ ~~)
			"MmWorkingSetEntryFindByIndex: no table despite being <= maximum index\n" KeCrash
		end
	end

	tab@ off@ 2 << + wsleptr!
end

fn MmWorkingSetEntryFindByVirtualAddress { vaddr process -- wsli wsleptr ok }
	"MmWorkingSetEntryFindByVirtualAddress: REVIEW ME\n" KeCrash

	// look up a virtual address in the working set and return the pointer.
	// return -1 in ok if the virtual address is not part of the working set.

	// caller must make sure the vaddr points to a physical page frame.

	if (DEBUGCHECKS)
		if (vaddr@ PAGEOFFSETMASK &)
			"MmWorkingSetEntryFindByVirtualAddress: unaligned vaddr\n" KeCrash
		end
	end

	// look up vaddr in process's pagemap, if it's not valid we know it's not
	// in the working set.

	auto pteaddr
	vaddr@ // vaddr
	process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (ok@)
		return
	end

	auto pfdbe

	pteaddr@ // pteaddr
	MmPTEInterpret ok! drop pfdbe!

	if (ok@)
		return
	end

	pfdbe@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	// it is valid. look in pfdbe for working set index hint and see if it
	// resides in that entry.

	pfdbe@ MmPageFrameEntryEvictable_WorkingSetIndexHint + @ wsli!

	wsli@ // wsli
	process@ // process
	MmWorkingSetEntryFindByIndex ok! wsleptr!

	auto wsle

	if (ok@ ~~)
		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			if (wsle@ PAGENUMBERMASK & vaddr@ ==)
				// found it!

				return
			end
		end
	end

	// not there. search the entire working set up to the last valid index.

	0 wsli!

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	tabptr@@ wsleptr!

	auto leftintable
	MMWORKINGSETENTRIESPERTABLE leftintable!

	auto maxi
	process@ PsProcess_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		-1 ok!
		return
	end

	while (wsli@ maxi@ <=)
		if (leftintable@ ~~)
			4 tabptr +=
			tabptr@@ wsleptr!
			MMWORKINGSETENTRIESPERTABLE leftintable!
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			if (wsle@ PAGENUMBERMASK & vaddr@ ==)
				// found it!

				return
			end
		end

		1 leftintable -=
		4 wsleptr +=
		1 wsli +=
	end

	-1 ok!
end

fn MmWorkingSetEntryFree { wsli wsleptr process -- }
	// place a working set entry on the free list.

	process@ PsProcess_WorkingSetFreeListHead + @ PAGESHIFT << wsleptr@!
	wsli@ process@ PsProcess_WorkingSetFreeListHead + !
end

// this function is called by the balance set manager thread when free/standby
// memory is low.

fn MmManageWorkingSets { -- success }
	auto pagecount
	auto dire

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ >=)
		MmEventLowMemory // event
		KeEventReset drop

		ipl@ KeIPLLower

		1 success!

		return
	end

	MmPageFreeCountSufficient@ MmPageFreeCount@ MmEvictablePageCount@ + - pagecount!
	MmPageFreeCount@ MmEvictablePageCount@ + MMDIREPAGES < dire!

	ipl@ KeIPLLower

	0 success!

	PsProcessListLock drop

	auto process
	PsProcessListHead@ process!

	auto count
	PsActiveProcessCount@ count!

	auto nprocess

	while (process@ count@ &&)
		process@ PsProcess_GlobalListNext + @ nprocess!

		if (process@ PsProcess_WorkingSetSize + @)
			auto ok

			10 // timeout
			process@ // processobject
			MmWorkingSetLockTimeout ok!

			if (ok@ ~~)
				auto trimmed

				dire@ // dire
				pagecount@ // pages
				process@ // process
				MmWorkingSetTrim trimmed!

				process@ MmWorkingSetUnlock

				if (process@ PsProcessListTail@ ~=)
					process@ PsProcessRemove
					process@ PsProcessInsert
				end

				if (trimmed@ pagecount@ >=)
					0 pagecount!
					break
				end

				trimmed@ pagecount -=
			end
		end

		1 count -=
		nprocess@ process!
	end

	PsProcessListUnlock

	if (pagecount@ ~~)
		1 success!
	end
end