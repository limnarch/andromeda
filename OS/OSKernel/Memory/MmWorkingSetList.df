//
// Implements the Working Set List (WSL) data structure.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMWORKINGSETTABLESIZE       (PAGESIZE MmProcessHeader_SIZEOF -)
const MMWORKINGSETENTRIESPERTABLE (MMWORKINGSETTABLESIZE 4 /)

const MMWORKINGSETINITIALENTRIES  256
const MMWORKINGSETEXTENDENTRIES   8

const MMWORKINGSETENTRY_VALID 1

fn MmWorkingSetListInitialize { process -- ok }
	fnsection "PAGE$text"

	0 ok!

	MmWorkingSetDefaultMinimum@ // charge
	process@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ // quotablock
	MmQuotaBlockChargeWS ok!

	if (ok@)
		return
	end

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	0 phdr@ MmProcessHeader_WorkingSetSize + !
	MmWorkingSetDefaultMinimum@ phdr@ MmProcessHeader_WorkingSetMinimum + !
	MmWorkingSetDefaultMaximum@ phdr@ MmProcessHeader_WorkingSetMaximum + !
	MmWorkingSetDefaultQuota@ phdr@ MmProcessHeader_WorkingSetQuota + !

	0 phdr@ MmProcessHeader_WorkingSetReplacementIndex + !
	0 phdr@ MmProcessHeader_WorkingSetTrimFaultCount + !
	0 phdr@ MmProcessHeader_WorkingSetLastReplacedVirtual + !

	0 phdr@ MmProcessHeader_ModifiedPageCount + !

	// initialize the working set list.

	auto entryptr
	phdr@ MmProcessHeader_SIZEOF +
	MMWORKINGSETINITIALENTRIES 4 * + entryptr!

	auto last
	-1 last!

	auto ihandle
	MMWORKINGSETINITIALENTRIES ihandle!

	auto count
	MMWORKINGSETINITIALENTRIES count!

	// initialize the free list

	while (count@)
		4 entryptr -=
		1 ihandle -=

		last@ PAGESHIFT << entryptr@!

		ihandle@ last!
		1 count -=
	end

	last@ phdr@ MmProcessHeader_WorkingSetFreeListHead + !
	MMWORKINGSETINITIALENTRIES 1 - phdr@ MmProcessHeader_WorkingSetMaximumIndex + !
end

// unless explicitly stated otherwise, all working set manipulation functions
// assume the caller took care of the necessary locking.

fn MmWorkingSetListFree { process -- }
	if (DEBUGCHECKS)
		if (process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + @)
			process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + @
			"MmWorkingSetListFree: working set size > 0 (%d)\n" KeCrash
		end
	end

	process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetMinimum + @ // charge
	process@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeWS

	return
end

fn MmWorkingSetTrimPage { wsli wsleptr process -- }
	wsleptr@ // wsleptr
	process@ // process
	MmWorkingSetEntryRemove

	wsli@ // wsli
	wsleptr@ // wsleptr
	process@ // process
	MmWorkingSetEntryFree
end

fn MmWorkingSetTrim { dire pages process -- trimmed }
	// trim the working set of the specified process.
	// attempt to trim the given number of pages, and return the real number
	// of pages trimmed.

	0 trimmed!

	auto wsli
	auto wsleptr
	auto ok

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	process@ PsProcess_PageFaultCount + @ phdr@ MmProcessHeader_WorkingSetTrimFaultCount + !

	while (phdr@ MmProcessHeader_WorkingSetSize + @ phdr@ MmProcessHeader_WorkingSetMaximum + @ >)
		// greater than the maximum, nuke all the way down to it

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end

	if (dire@)
		15 pages@ min pages!
	end else
		5 pages@ min pages!
	end

	while (phdr@ MmProcessHeader_WorkingSetSize + @ phdr@ MmProcessHeader_WorkingSetMinimum + @ >)
		// between minimum and maximum, nuke at most 5 entries, or 15 if dire

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end

	if (dire@ ~~)
		return
	end
	
	1 pages@ min pages!

	while (phdr@ MmProcessHeader_WorkingSetSize + @)
		// below minimum, nuke only 1 entry, or 5 if dire

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end
end

fn MmWorkingSetPurge { process -- }
	// purge the entire working set of the process

	0 // startva
	MMHIGHESTUSERADDRESS 1 + // endva
	process@ // process
	MmWorkingSetTrimRange
end

fn MmWorkingSetRemap { flags startva endva process -- }
	// update all of the mapped PTEs in the process to have the new flags.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (process@ KeProcess_MemoryStateB + gb PROCESSSTATE_RESIDENT ~=)
		ipl@ KeIPLLower
		return
	end

	auto wsli
	0 wsli!

	auto wsleptr
	process@ PsProcess_MmHeader + @ MmProcessHeader_SIZEOF + wsleptr!

	auto wsle

	auto ok
	auto pteaddr

	auto maxi
	process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		ipl@ KeIPLLower
		return
	end

	while (wsli@ maxi@ <=)
		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			if (wsle@ startva@ >=)
				if (wsle@ endva@ <)
					// found one, remap it

					if (process@ PsSystemProcess@ ==)
						wsle@ // vaddr
						MmVirtualtoPTEAddress pteaddr!
					end else
						wsle@ // vaddr
						MmVirtualtoPTEAddressUser pteaddr!
					end

					auto oldflags

					auto phyaddr
					pteaddr@ // pteaddr
					MmPTEInterpret ok! oldflags! phyaddr!

					if (DEBUGCHECKS)
						if (ok@)
							pteaddr@@ "MmWorkingSetRemap: invalid PTE %08x\n" KeCrash
						end
					end

					if (oldflags@ PTE_D &)
						// page was dirty, reflect that in the pfdbe.

						auto pfdbe
						phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

						pfdbe@ // pfdbe
						process@ // process
						MmEvictablePageModify
					end

					phyaddr@ // phyaddr
					flags@ // flags
					pteaddr@ // pteaddr
					MmPTEUpdate drop drop
				end
			end
		end

		4 wsleptr +=
		1 wsli +=
	end

	ipl@ KeIPLLower
end

fn MmWorkingSetTrimRange { startva endva process -- }
	// trim any entries between startva and endva out of the working set.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (process@ KeProcess_MemoryStateB + gb PROCESSSTATE_RESIDENT ~=)
		ipl@ KeIPLLower
		return
	end

	auto wsli
	0 wsli!

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	auto wsleptr
	process@ PsProcess_MmHeader + @ MmProcessHeader_SIZEOF + wsleptr!

	auto wsle

	auto maxi
	phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		ipl@ KeIPLLower
		return
	end

	while (wsli@ maxi@ <=)
		if (phdr@ MmProcessHeader_WorkingSetSize + @ ~~)
			ipl@ KeIPLLower
			return
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			if (wsle@ startva@ >=)
				if (wsle@ endva@ <)
					// found one, remove it

					wsli@ // wsli
					wsleptr@ // wsleptr
					process@ // process
					MmWorkingSetTrimPage
				end
			end
		end

		4 wsleptr +=
		1 wsli +=
	end

	ipl@ KeIPLLower
end

fn MmWorkingSetSwapOut { process -- }
	// does two passes. the first removes normal pages, and the second removes
	// page tables. it must be done like this otherwise there's a chicken and
	// egg problem with removing the page tables.

	auto wsli
	0 wsli!

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	auto wsleptr
	process@ PsProcess_MmHeader + @ MmProcessHeader_SIZEOF + wsleptr!

	auto wsle

	auto maxi
	phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		return
	end

	while (wsli@ maxi@ <=)
		if (phdr@ MmProcessHeader_WorkingSetSize + @ ~~)
			return
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			if (wsle@ PAGETABLE < wsle@ SYSPAGETABLE >= ||)
				// found one, remove it

				wsli@ // wsli
				wsleptr@ // wsleptr
				process@ // process
				MmWorkingSetTrimPage
			end
		end

		4 wsleptr +=
		1 wsli +=
	end

	0 wsli!
	process@ PsProcess_MmHeader + @ MmProcessHeader_SIZEOF + wsleptr!

	while (wsli@ maxi@ <=)
		if (phdr@ MmProcessHeader_WorkingSetSize + @ ~~)
			return
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			// found one, remove it

			wsli@ // wsli
			wsleptr@ // wsleptr
			process@ // process
			MmWorkingSetTrimPage
		end

		4 wsleptr +=
		1 wsli +=
	end
end

fn MmWorkingSetEntryInsert { vaddr wsleptr process -- }
	// caller must create the associated PTE before calling this function.

	// increments the working set size.

	if (DEBUGCHECKS)
		if (vaddr@ PAGEOFFSETMASK &)
			"MmWorkingSetEntryUpdate: unaligned vaddr\n" KeCrash
		end
	end

	auto wsle
	vaddr@ MMWORKINGSETENTRY_VALID | wsle!

	1 process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + +=

	wsle@ wsleptr@!
end

fn MmWorkingSetEntryReserve { process -- wsli wsleptr ok }
	// first we check to see if the working set can take a page:
	//
	//   1. if the working set size is below the minimum, it can.
	//   2. if the size is between the minimum and the maximum, it can if the
	//      system is not in a low memory condition.
	//   3. if the process is at its working set quota, it can't.
	//   4. if the size >= maximum, it can if it has had more than 100 page faults
	//      since the last time it was trimmed, and the system has at least
	//      MmPageFreeCountSufficient free pages.
	//
	// if it can, we yoink the first free entry, mark it reserved, and return
	// the index in wsli.
	//
	// if it can't, we try to replace another entry in the working set at
	// random.

	auto room
	0 room!

	0 ok!

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	auto wssize
	phdr@ MmProcessHeader_WorkingSetSize + @ wssize!

	if (wssize@ phdr@ MmProcessHeader_WorkingSetMinimum + @ <)
		// below minimum, there's always room
		1 room!
	end elseif (wssize@ phdr@ MmProcessHeader_WorkingSetMaximum + @ <)
		// between minimum and maximum
		if (MmEventLowMemory KeDispatchIsSignaled ~~)
			1 room!
		end
	end elseif (wssize@ phdr@ MmProcessHeader_WorkingSetQuota + @ >=)
		// above quota
		0 room!
	end else
		// above maximum
		if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ >=)
			if (process@ PsProcess_PageFaultCount + @ phdr@ MmProcessHeader_WorkingSetTrimFaultCount + @ - 100 >)
				1 room!
			end
		end
	end

	1 process@ PsProcess_PageFaultCount + +=

	while (1)
		if (room@ ~~)
			// no room, kick one out

			process@ // process
			MmWorkingSetEntryReplace ok! wsleptr! wsli!

			if (ok@)
				// failed to find one to replace...
				return
			end

			wsleptr@ // wsleptr
			process@ // process
			MmWorkingSetEntryRemove
		end else
			phdr@ MmProcessHeader_WorkingSetFreeListHead + @ wsli!

			if (wsli@ -1 ~=)
				// yoink

				wsli@ // wsli
				process@ // process
				MmWorkingSetEntryFindByIndex ok! wsleptr!

				if (DEBUGCHECKS)
					if (ok@)
						"MmWorkingSetEntryReserve: failed to find by index\n" KeCrash
					end
				end

				auto wsle
				wsleptr@@ wsle!

				if (DEBUGCHECKS)
					if (wsle@ MMWORKINGSETENTRY_VALID &)
						"MmWorkingSetEntryReserve: wsle was valid\n" KeCrash
					end
				end

				if (wsle@ PAGENUMBERMASK ==)
					-1 phdr@ MmProcessHeader_WorkingSetFreeListHead + !
				end else
					wsle@ PAGESHIFT >> phdr@ MmProcessHeader_WorkingSetFreeListHead + !
				end
			end else
				// no free entries, we need to allocate a new working set
				// array.

				process@ MmWorkingSetArrayExpand ok! wsleptr! wsli!

				if (ok@)
					if (ok@ STATUS_NO_MEMORY ==)
						// loop with room=0 if failed to allocate, in order to
						// retry the reservation as a replacement.

						0 room!

						continue
					end

					return
				end
			end
		end

		0 wsleptr@!

		return
	end

	if (DEBUGCHECKS)
		"MmWorkingSetEntryReserve: unreachable\n" KeCrash
	end
end

fn MmWorkingSetArrayExpand { process -- wsli wsleptr ok }
	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	auto maxi
	phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ maxi!

	auto size
	maxi@ 1 + size!

	auto count
	MMWORKINGSETEXTENDENTRIES count!

	if (size@ MMWORKINGSETENTRIESPERTABLE >=)
		STATUS_NO_MEMORY ok!
		return
	end elseif (size@ count@ + MMWORKINGSETENTRIESPERTABLE >=)
		MMWORKINGSETENTRIESPERTABLE size@ - count!
	end

	// extend the working set list.

	auto entryptr
	phdr@ MmProcessHeader_SIZEOF +
	size@ 4 * +
	count@ 4 * + entryptr!

	auto last
	-1 last!

	auto ihandle
	size@ count@ + ihandle!

	// extend the free list

	auto i
	count@ 1 - i!

	while (i@)
		4 entryptr -=
		1 ihandle -=

		last@ PAGESHIFT << entryptr@!

		ihandle@ last!
		1 i -=
	end

	last@ phdr@ MmProcessHeader_WorkingSetFreeListHead + !
	size@ count@ + 1 - phdr@ MmProcessHeader_WorkingSetMaximumIndex + !

	entryptr@ 4 - wsleptr!
	ihandle@ 1 - wsli!

	0 ok!
end

fn MmWorkingSetEntryReplace { process -- wsli wsleptr ok }
	// find a working set entry to replace.

	0 ok!

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	if (phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ -1 ==)
		-1 ok!

		return
	end

	auto hint
	phdr@ MmProcessHeader_WorkingSetReplacementIndex + @ hint!

	if (hint@ phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ >)
		0 hint!
	end

	auto searchcount
	0 searchcount!

	// search from the replacement index to the end of the working set for a
	// valid entry to replace, then from the start to the replacement index.

	auto i
	0 i!

	while (i@ 2 <)
		auto endindex

		if (i@ 0 ==)
			hint@ wsli!
			phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ 1 + endindex!
		end elseif (hint@)
			0 wsli!
			hint@ endindex!
		end else
			-1 ok!

			return
		end

		phdr@ MmProcessHeader_SIZEOF + wsleptr!
		wsli@ 2 << wsleptr +=

		auto wsle

		while (wsli@ endindex@ <)
			wsleptr@@ wsle!

			if (wsle@ MMWORKINGSETENTRY_VALID &)
				auto useit
				0 useit!

				auto vaddr
				wsle@ PAGENUMBERMASK & vaddr!

				if (searchcount@ 16 >=)
					1 useit!
				end elseif (vaddr@ phdr@ MmProcessHeader_WorkingSetLastReplacedVirtual + @ ~=)
					1 useit!
				end

				if (vaddr@ PAGETABLE >= vaddr@ SYSPAGETABLE < &&)
					auto pfdbe
					vaddr@ MmVirtualToPFDBE pfdbe!

					if (pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi 1 >)
						// this page is a pinned page table. can't use it.

						0 useit!
					end
				end

				if (useit@)
					// found one
					wsli@ 1 + phdr@ MmProcessHeader_WorkingSetReplacementIndex + !
					vaddr@ phdr@ MmProcessHeader_WorkingSetLastReplacedVirtual + !

					return
				end
			end

			4 wsleptr +=
			1 wsli +=
			1 searchcount +=
		end

		1 i +=
	end

	-1 ok!
end

fn MmWorkingSetEntryForceOut { vaddr pfdbe process -- }
	// force out the specified virtual address from the process's working set.
	// DOES NOT set the PTE.
	// used in very specific circumstances.

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	if (phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ -1 ==)
		return
	end

	auto endindex
	auto wsli
	auto wsleptr
	auto wsle

	0 wsli!
	phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ 1 + endindex!
	phdr@ MmProcessHeader_SIZEOF + wsleptr!

	while (wsli@ endindex@ <)
		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			if (vaddr@ wsle@ PAGENUMBERMASK & ==)
				MMWORKINGSETENTRY_VALID ~ wsleptr@ &=

				pfdbe@ MmEvictablePageDereference drop

				auto oldcount
				process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + @ oldcount!

				if (DEBUGCHECKS)
					if (oldcount@ 0 ==)
						"MmWorkingSetEntryForceOut: underflow\n" KeCrash
					end
				end

				oldcount@ 1 - process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + !
			end
		end

		4 wsleptr +=
		1 wsli +=
	end
end

fn MmWorkingSetEntryRemove { wsleptr process -- }
	// remove the specified entry from the working set. deletes the PTE unless
	// COW.

	// unmap it from the process's pagemap, and decrement its refcount.
	// if COW, set transition PTE pointers.
	// if file, clear any associated dirty PTE pointer.

	// DOES remove the valid bit, but does NOT free the entry; caller must do
	// that if it wants that to happen.

	// decrements the working set size.

	if (DEBUGCHECKS)
		if (wsleptr@@ MMWORKINGSETENTRY_VALID & ~~)
			"MmWorkingSetEntryRemove: not valid\n" KeCrash
		end
	end

	auto vaddr
	wsleptr@@ PAGENUMBERMASK & vaddr!

	auto pteaddr
	auto ok

	if (process@ PsSystemProcess@ ==)
		vaddr@ // vaddr
		MmVirtualtoPTEAddress pteaddr!
	end elseif (vaddr@ PAGETABLE >= vaddr@ SYSPAGETABLE < &&)
		vaddr@ // vaddr
		MmVirtualtoPTEAddress pteaddr!
	end else
		vaddr@ // vaddr
		MmVirtualtoPTEAddressUser pteaddr!
	end

	auto phyaddr
	auto pfdbe
	auto flags

	pteaddr@ // pteaddr
	MmPTEInterpret ok! flags! phyaddr!

	if (DEBUGCHECKS)
		if (ok@)
			vaddr@
			pteaddr@
			pteaddr@@
			"MmWorkingSetEntryRemove: invalid PTE %x (%x,%x)\n" KeCrash
		end
	end

	// unmap

	phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	if (flags@ PTE_D &)
		// page was dirty, reflect that in the pfdbe.
		// this is necessary because the page might have gotten flushed
		// manually while it was mapped. additionally, the hardware might
		// enforce the dirty bit, in which case we have no way of knowing that
		// it was modified until this moment anyway.

		// charge the process for the modified pages now, since it won't have
		// been done in the page fault handler.

		pfdbe@ // pfdbe
		process@ // process
		MmEvictablePageModify
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE &)
		// private page. create transition PTE so we can soft-fault it back in
		// later.

		if (process@ PsSystemProcess@ ==)
			phyaddr@ PTE_TRANSITION | PTE_TLBHACK | // pte
			pteaddr@ // pteaddr
			MmPTESet
		end else
			phyaddr@ PTE_TRANSITION | // pte
			pteaddr@ // pteaddr
			MmPTESet
		end
	end else
		0 // phyaddr
		0 // flags
		pteaddr@ // pteaddr
		MmPTEUpdate drop drop

		if (process@ PsSystemProcess@ ~=)
			1 // deref
			pteaddr@ // pteaddr
			MmPTEDelete
		end else
			// shared system pages are assumed to have been in the viewcache
			1 MmViewCachePageCount -=
		end
	end

	MMWORKINGSETENTRY_VALID ~ wsleptr@ &=

	pfdbe@ MmEvictablePageDereference drop

	auto oldcount
	process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmWorkingSetEntryRemove: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + !
end

fn MmWorkingSetEntryFindByIndex { wsli process -- wsleptr ok }
	// look up a working set index in the working set and return the pointer.
	// return -1 in ok if the index is beyond the end of valid indices.

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	if (phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ -1 ==)
		-1 ok!
		return
	end

	if (wsli@ phdr@ MmProcessHeader_WorkingSetMaximumIndex + @ >)
		-1 ok!
		return
	end

	0 ok!

	phdr@ MmProcessHeader_SIZEOF +
	wsli@ 2 << + wsleptr!
end

fn MmWorkingSetEntryFree { wsli wsleptr process -- }
	// place a working set entry on the free list.

	process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetFreeListHead + @ PAGESHIFT << wsleptr@!
	wsli@ process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetFreeListHead + !
end

// this function is called by the balance set manager thread when free/standby
// memory is low.

fn MmManageWorkingSets { -- success }
	while (1)
		auto pagecount
		auto dire

		auto ipl
		IPLDPC KeIPLRaise ipl!

		if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ >=)
			MmEventLowMemory // event
			KeEventReset drop

			ipl@ KeIPLLower

			1 success!

			return
		end

		MmPageFreeCountSufficient@ MmPageFreeCount@ MmEvictablePageCount@ + - pagecount!
		MmPageFreeCount@ MmEvictablePageCount@ + MMDIREPAGES < dire!

		if (MmPhysicalCommitUsage@ MmPhysicalCommitLimit@ >)
			1 dire!
		end

		ipl@ KeIPLLower

		0 success!

		PsProcessListLock drop

		auto process
		PsProcessTrimListHead@ process!

		auto count
		PsActiveProcessCount@ count!

		auto nprocess

		auto totaltrimmed
		0 totaltrimmed!

		auto checkloop
		0 checkloop!

		while (process@ count@ &&)
			if (process@ checkloop@ ==)
				break
			end
			
			process@ PsProcess_TrimListNext + @ nprocess!

			auto ok
			1 // try
			process@ // process
			KeProcessAttach ok! ipl!

			if (ok@ ~~)
				auto ipl2
				IPLDPC KeIPLRaise ipl2!

				auto trimmed

				dire@ // dire
				pagecount@ // pages
				process@ // process
				MmWorkingSetTrim trimmed!

				ipl2@ KeIPLLower

				ipl@ KeProcessDetach

				if (process@ PsProcessTrimListTail@ ~=)
					if (checkloop@ ~~)
						process@ checkloop!
					end

					// remove and re-insert the process so we don't trim
					// it again for a while.

					1 // trim
					process@ // process
					PsProcessRemove
					
					1 // trim
					process@ // process
					PsProcessInsert
				end

				if (trimmed@ pagecount@ >=)
					0 pagecount!
					break
				end

				trimmed@ totaltrimmed +=

				trimmed@ pagecount -=
			end

			1 count -=
			nprocess@ process!
		end

		PsProcessListUnlock

		if (pagecount@ ~~)
			1 success!
			break
		end

		if (totaltrimmed@ ~~)
			return
		end
	end
end