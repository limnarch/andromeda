#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMWORKINGSETENTRY_VALID    1
const MMWORKINGSETENTRY_RESERVED 2
const MMWORKINGSETENTRY_NOTFREE  (MMWORKINGSETENTRY_VALID MMWORKINGSETENTRY_RESERVED |)

fn MmWorkingSetLock { processobject -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetTryLock { processobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetUnlock { processobject -- }
	processobject@ PsProcess_WorkingSetMutex + KeMutexRelease drop
end

fn MmWorkingSetListInitialize { process -- ok }
	"MmWorkingSetMutex" // name
	KERNELMODE // mode
	process@ PsProcess_WorkingSetMutex + // mutex
	KeMutexInitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			"MmWorkingSetInitialize: couldn't initialize MmWorkingSetMutex\n" KeCrash
		end
	end

	0 process@ PsProcess_WorkingSetSize + !
	MMWORKINGSETDEFAULTMINIMUM process@ PsProcess_WorkingSetMinimum + !
	MMWORKINGSETDEFAULTMAXIMUM process@ PsProcess_WorkingSetMaximum + !

	0 process@ PsProcess_WorkingSetFreeListHead + !
	0 process@ PsProcess_WorkingSetMaximumIndex + !
	0 process@ PsProcess_WorkingSetReplacementIndex + !

	process@ PsProcess_WorkingSetListPointers + // ptr
	WORKINGSETLISTCOUNT 4 * // size
	0 // word
	memset
end

// all working set manipulation functions assume the caller took care of the
// necessary locking.

fn MmWorkingSetListFree { process -- }
	auto count
	WORKINGSETLISTCOUNT count!

	auto ptr
	process@ PsProcess_WorkingSetListPointers + ptr!

	while (count@)
		if (ptr@@)
			ptr@@ MmFree

			0 ptr@!
		end

		4 ptr +=
		1 count -=
	end
end

fn MmWorkingSetTrim { pages process -- trimmed }
	// trim the working set of the specified process.
	// attempt to trim the given number of pages, and return the real number
	// of pages trimmed.


end

fn MmWorkingSetEntryReserve { process -- wsli wsleptr ok }
	// first we check to see if the working set can take a page:
	//
	// - if the process's working set quota is at its maximum, it can't.
	//
	// - if the working set size is below the minimum, it can.
	//
	// - if the size is between the minimum and the maximum, it can if it has
	// had more than 20 page faults since the last time it was trimmed, and
	// the system is not in a low memory condition.
	//
	// - if the size >= maximum, it can if it has had more than 100 page faults
	// since the last time it was trimmed, and the system has at least
	// MmPageFreeCountSufficient free pages.
	//
	// if it can, we yoink the first free entry, mark it reserved, and return
	// the index in wsli.
	//
	// if it can't, we try to replace another entry in the working set at
	// random.


end

fn MmWorkingSetEntryRemove { wsleptr process -- }
	// remove the specified entry from the working set.
	// unmap it from the process's pagemap, and decrement its refcount.
	// if COW, set transition PTE pointers.
	// if file, clear any associated modified PTE pointer.
	// does NOT free the entry, caller must do that if it desires.


end

fn MmWorkingSetEntryFindByIndex { wsli process -- wsleptr ok }
	// look up a working set index in the working set and return the pointer.
	// return -1 in ok if the index is beyond the end of valid indices.


end

fn MmWorkingSetEntryFindByVirtualAddress { vaddr process -- wsli wsleptr ok }
	// look up a virtual address in the working set and return the pointer.
	// return -1 in ok if the virtual address is not part of the working set.



	// look up vaddr in process's pagemap, if it's not valid we know it's not
	// in the working set.



	// it is valid. look in pfdbe for working set index hint and see if it
	// resides in that entry. if not, search the entire working set up to the
	// last valid index.


end

fn MmWorkingSetEntryFree { wsleptr process -- }
	// mark a working set entry free by pointer.
	// zero it out and place it on the free list.


end