//
// Implements the Working Set List (WSL) data structure.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMWORKINGSETENTRY_VALID 1

fn MmWorkingSetLock { processobject -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetLockTimeout { timeout processobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	timeout@ // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetTryLock { processobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetUnlock { processobject -- }
	0 // abandon
	processobject@ PsProcess_WorkingSetMutex + // mutex
	KeMutexRelease drop
end

fn MmWorkingSetListInitialize { process -- ok }
	0 ok!

	"MmWorkingSetMutex" // name
	KERNELMODE // mode
	process@ PsProcess_WorkingSetMutex + // mutex
	KeMutexInitialize

	0 process@ PsProcess_WorkingSetSize + !
	MMWORKINGSETDEFAULTMINIMUM process@ PsProcess_WorkingSetMinimum + !
	MMWORKINGSETDEFAULTMAXIMUM process@ PsProcess_WorkingSetMaximum + !

	-1 process@ PsProcess_WorkingSetFreeListHead + !
	-1 process@ PsProcess_WorkingSetMaximumIndex + !
	0 process@ PsProcess_WorkingSetReplacementIndex + !
	0 process@ PsProcess_WorkingSetTrimFaultCount + !

	process@ PsProcess_WorkingSetListPointers + // ptr
	WORKINGSETLISTCOUNT 4 * // size
	0 // word
	memset

	// allocate the first working set list table now.

	auto wsli
	auto wsleptr
	process@ MmWorkingSetArrayExpand ok! wsleptr! wsli!

	if (ok@)
		return
	end

	// relinquish the first entry MmWorkingSetArrayExpand gave us.

	wsli@ wsleptr@ process@ MmWorkingSetEntryFree
end

// unless explicitly stated otherwise, all working set manipulation functions
// assume the caller took care of the necessary locking.

fn MmWorkingSetListFree { process -- }
	if (DEBUGCHECKS)
		if (process@ PsProcess_WorkingSetSize + @)
			process@ PsProcess_WorkingSetSize + @
			"MmWorkingSetListFree: working set size > 0 (%d)\n" KeCrash
		end
	end

	auto count
	WORKINGSETLISTCOUNT count!

	auto ptr
	process@ PsProcess_WorkingSetListPointers + ptr!

	while (count@)
		if (ptr@@)
			ptr@@ MmFree

			0 ptr@!
		end

		4 ptr +=
		1 count -=
	end

	-1 process@ PsProcess_WorkingSetFreeListHead + !
	-1 process@ PsProcess_WorkingSetMaximumIndex + !
	0 process@ PsProcess_WorkingSetReplacementIndex + !
end

fn MmWorkingSetTrimPage { wsli wsleptr process -- }
	wsleptr@ // wsleptr
	process@ // process
	MmWorkingSetEntryRemove

	wsli@ // wsli
	wsleptr@ // wsleptr
	process@ // process
	MmWorkingSetEntryFree
end

fn MmWorkingSetTrim { dire pages process -- trimmed }
	// trim the working set of the specified process.
	// attempt to trim the given number of pages, and return the real number
	// of pages trimmed.

	0 trimmed!

	auto wsli
	auto wsleptr
	auto ok

	process@ PsProcess_PageFaultCount + @ process@ PsProcess_WorkingSetTrimFaultCount + !

	while (process@ PsProcess_WorkingSetSize + @ process@ PsProcess_WorkingSetMaximum + @ >)
		// greater than the maximum, nuke all the way down to it

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end

	if (dire@)
		15 pages@ min pages!
	end else
		5 pages@ min pages!
	end

	while (process@ PsProcess_WorkingSetSize + @ process@ PsProcess_WorkingSetMinimum + @ >)
		// between minimum and maximum, nuke at most 5 entries, or 15 if dire

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end

	auto musthave

	if (dire@)
		0 musthave!
		5 pages@ min pages!
	end else
		2 musthave!
		1 pages@ min pages!
	end

	while (process@ PsProcess_WorkingSetSize + @ musthave@ >)
		// below minimum, nuke only 1 entry, or 5 if dire

		if (pages@ ~~)
			return
		end

		process@ // process
		MmWorkingSetEntryReplace ok! wsleptr! wsli!

		if (ok@)
			return
		end

		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetTrimPage

		1 pages -=
		1 trimmed +=
	end
end

fn MmWorkingSetPurge { process -- }
	// purge the entire working set of the process

	0 // startva
	MMHIGHESTUSERADDRESS 1 + // endva
	process@ // process
	MmWorkingSetTrimRange
end

fn MmWorkingSetRemap { flags startva endva process -- }
	// update all of the mapped PTEs in the process to have the new flags.

	auto wsli
	0 wsli!

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	auto wsleptr
	tabptr@@ wsleptr!

	auto wsle

	auto ok
	auto pteaddr

	auto leftintable
	MMWORKINGSETENTRIESPERTABLE leftintable!

	auto maxi
	process@ PsProcess_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		return
	end

	while (wsli@ maxi@ <=)
		if (leftintable@ ~~)
			4 tabptr +=
			tabptr@@ wsleptr!
			MMWORKINGSETENTRIESPERTABLE leftintable!
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			if (wsle@ startva@ >=)
				if (wsle@ endva@ <)
					// found one, remap it

					wsle@ // vaddr
					process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
					MmVirtualtoPTEAddressUser pteaddr!

					auto phyaddr
					pteaddr@ // pteaddr
					MmPTEInterpret ok! drop phyaddr!

					if (DEBUGCHECKS)
						if (ok@)
							"MmWorkingSetRemap: invalid PTE\n" KeCrash
						end
					end

					phyaddr@ // phyaddr
					flags@ // flags
					wsle@ // vaddr
					pteaddr@ // pteaddr
					process@ PsProcess_PCB + KeProcess_ASID + @ // asid
					MmPTEUpdate drop drop drop
				end
			end
		end

		1 leftintable -=
		4 wsleptr +=
		1 wsli +=
	end
end

fn MmWorkingSetTrimRange { startva endva process -- }
	// trim any entries between startva and endva out of the working set.

	auto wsli
	0 wsli!

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	auto wsleptr
	tabptr@@ wsleptr!

	auto wsle

	auto leftintable
	MMWORKINGSETENTRIESPERTABLE leftintable!

	auto maxi
	process@ PsProcess_WorkingSetMaximumIndex + @ maxi!

	if (maxi@ -1 ==)
		return
	end

	while (wsli@ maxi@ <=)
		if (process@ PsProcess_WorkingSetSize + @ ~~)
			return
		end

		if (leftintable@ ~~)
			4 tabptr +=
			tabptr@@ wsleptr!
			MMWORKINGSETENTRIESPERTABLE leftintable!
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			wsle@ PAGENUMBERMASK & wsle!

			if (wsle@ startva@ >=)
				if (wsle@ endva@ <)
					// found one, remove it

					wsli@ // wsli
					wsleptr@ // wsleptr
					process@ // process
					MmWorkingSetTrimPage
				end
			end
		end

		1 leftintable -=
		4 wsleptr +=
		1 wsli +=
	end
end

fn MmWorkingSetEntryInsert { vaddr wsleptr process -- }
	// caller must create the associated PTE before calling this function.

	// increments the working set size.
	// does NOT charge working set quota.

	if (DEBUGCHECKS)
		if (vaddr@ PAGEOFFSETMASK &)
			"MmWorkingSetEntryUpdate: unaligned vaddr\n" KeCrash
		end
	end

	auto wsle
	vaddr@ MMWORKINGSETENTRY_VALID | wsle!

	1 process@ PsProcess_WorkingSetSize + +=

	wsle@ wsleptr@!
end

fn MmWorkingSetEntryReserve { process -- wsli wsleptr ok }
	// first we check to see if the working set can take a page:
	// 1. if the working set size is below the minimum, it can.
	// 2. if the size is between the minimum and the maximum, it can if the
	//    system is not in a low memory condition.
	// 3. if the size >= maximum, it can if it has had more than 50 page faults
	//    since the last time it was trimmed, and the system has at least
	//    MmPageFreeCountSufficient free pages.
	// 4. if the process's working set quota is at its maximum, it can't.
	//
	// if it can, we yoink the first free entry, mark it reserved, and return
	// the index in wsli.
	//
	// if it can't, we try to replace another entry in the working set at
	// random.

	// increments the page fault count. also charges working set quota.

	auto room
	0 room!

	0 ok!

	auto wssize
	process@ PsProcess_WorkingSetSize + @ wssize!

	if (wssize@ process@ PsProcess_WorkingSetMinimum + @ <)
		// below minimum, there's always room
		1 room!
	end elseif (wssize@ process@ PsProcess_WorkingSetMaximum + @ <)
		// between minimum and maximum
		if (MmEventLowMemory KeDispatchIsSignaled ~~)
			1 room!
		end
	end else
		// above maximum
		if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ >=)
			if (process@ PsProcess_PageFaultCount + @ process@ PsProcess_WorkingSetTrimFaultCount + @ - 50 >)
				1 room!
			end
		end
	end

	1 process@ PsProcess_PageFaultCount + +=

	while (1)
		if (room@ ~~)
			// no room, kick one out

			process@ // process
			MmWorkingSetEntryReplace ok! wsleptr! wsli!

			if (ok@)
				// failed to find one to replace...
				return
			end

			wsleptr@ // wsleptr
			process@ // process
			MmWorkingSetEntryRemove
		end else
			process@ PsProcess_WorkingSetFreeListHead + @ wsli!

			if (wsli@ -1 ~=)
				// yoink

				wsli@ // wsli
				process@ // process
				MmWorkingSetEntryFindByIndex ok! wsleptr!

				if (DEBUGCHECKS)
					if (ok@)
						"MmWorkingSetEntryReserve: failed to find by index\n" KeCrash
					end
				end

				auto wsle
				wsleptr@@ wsle!

				if (DEBUGCHECKS)
					if (wsle@ MMWORKINGSETENTRY_VALID &)
						"MmWorkingSetEntryReserve: wsle was valid\n" KeCrash
					end
				end

				if (wsle@ PAGENUMBERMASK ==)
					-1 process@ PsProcess_WorkingSetFreeListHead + !
				end else
					wsle@ PAGESHIFT >> process@ PsProcess_WorkingSetFreeListHead + !
				end
			end else
				// no free entries, we need to allocate a new working set
				// array.

				process@ MmWorkingSetArrayExpand ok! wsleptr! wsli!

				if (ok@)
					if (ok@ STATUS_NO_MEMORY ==)
						// uncharge working set quota and loop with room=0 if
						// failed to allocate, in order to retry the
						// reservation as a replacement.

						0 room!

						continue
					end

					return
				end
			end
		end

		0 wsleptr@!

		return
	end

	"MmWorkingSetEntryReserve: unreachable\n" KeCrash
end

fn MmWorkingSetArrayExpand { process -- wsli wsleptr ok }
	// first we have to find the first zero pointer in the process
	// PsProcess_WorkingSetListPointers array. if there is none, we've hit the
	// capacity of the working set list data structure and must count that as
	// a failed allocation.

	// then we need to allocate the array and set the pointer in the process's
	// WorkingSetListPointers array. then we need to initialize it by placing
	// MMWORKINGSETENTRIESPERTABLE-1 of its entries on the free list,
	// reserving the last one for our caller.

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	auto count
	WORKINGSETLISTCOUNT count!

	0 wsli!

	while (count@)
		if (tabptr@@ ~~)
			// found it

			auto tab
			MMWORKINGSETTABLESIZE // bytes
			'MmWs' // tag
			0 // flags
			MmAllocWithTag ok! tab!

			if (ok@)
				return
			end

			0 tab@!

			tab@ wsleptr!
			tab@ tabptr@!

			MMWORKINGSETENTRIESPERTABLE 1 - count!

			auto last
			-1 last!

			auto iwsli
			wsli@ 1 + iwsli!

			4 tab +=

			// initialize the free list

			while (count@)
				last@ PAGESHIFT << tab@!

				iwsli@ last!
				4 tab +=
				1 iwsli +=
				1 count -=
			end

			if (DEBUGCHECKS)
				if (last@ -1 ==)
					"MmWorkingSetArrayExpand\n" KeCrash
				end
			end

			last@ process@ PsProcess_WorkingSetMaximumIndex + !
			last@ process@ PsProcess_WorkingSetFreeListHead + !

			0 wsleptr@!

			return
		end

		MMWORKINGSETENTRIESPERTABLE wsli +=
		4 tabptr +=
		1 count -=
	end

	STATUS_NO_MEMORY ok!
end

fn MmWorkingSetEntryReplace { process -- wsli wsleptr ok }
	// find a working set entry to replace.

	0 ok!

	if (process@ PsProcess_WorkingSetMaximumIndex + @ -1 ==)
		-1 ok!

		return
	end

	auto hint
	process@ PsProcess_WorkingSetReplacementIndex + @ hint!

	if (hint@ process@ PsProcess_WorkingSetMaximumIndex + @ >)
		0 hint!
	end

	// search from the replacement index to the end of the working set for a
	// valid entry to replace, then from the start to the replacement index.

	auto i
	0 i!

	while (i@ 2 <)
		auto endindex

		if (i@ 0 ==)
			hint@ wsli!
			process@ PsProcess_WorkingSetMaximumIndex + @ 1 + endindex!
		end elseif (hint@)
			0 wsli!
			hint@ endindex!
		end else
			-1 ok!

			return
		end

		auto tabptr
		process@ PsProcess_WorkingSetListPointers + wsli@ MMWORKINGSETENTRIESPERTABLE / 2 << + tabptr!

		auto off
		wsli@ MMWORKINGSETENTRIESPERTABLE % off!

		tabptr@@ off@ 2 << + wsleptr!

		auto wsle

		auto leftintable
		MMWORKINGSETENTRIESPERTABLE off@ - leftintable!

		while (wsli@ endindex@ <)
			if (leftintable@ ~~)
				4 tabptr +=
				tabptr@@ wsleptr!
				MMWORKINGSETENTRIESPERTABLE leftintable!
			end

			wsleptr@@ wsle!

			if (wsle@ MMWORKINGSETENTRY_VALID &)
				// found one
				wsli@ 1 + process@ PsProcess_WorkingSetReplacementIndex + !

				return
			end

			1 leftintable -=
			4 wsleptr +=
			1 wsli +=
		end

		1 i +=
	end

	-1 ok!
end

fn MmWorkingSetEntryRemove { wsleptr process -- }
	// remove the specified entry from the working set. deletes the PTE unless
	// COW.

	// unmap it from the process's pagemap, and decrement its refcount.
	// if COW, set transition PTE pointers.
	// if file, clear any associated dirty PTE pointer.

	// DOES remove the valid bit, but does NOT free the entry; caller must do
	// that if it wants that to happen.

	// also does NOT uncharge working set quota.

	// decrements the working set size.

	if (DEBUGCHECKS)
		if (wsleptr@@ MMWORKINGSETENTRY_VALID & ~~)
			"MmWorkingSetEntryRemove: not valid\n" KeCrash
		end
	end

	auto vaddr
	wsleptr@@ PAGENUMBERMASK & vaddr!

	auto pteaddr
	auto ok

	if (process@ PsSystemProcess@ ==)
		vaddr@ // vaddr
		process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
		MmVirtualtoPTEAddress pteaddr!
	end else
		vaddr@ // vaddr
		process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
		MmVirtualtoPTEAddressUser pteaddr!
	end

	auto phyaddr
	auto pfdbe
	auto flags

	pteaddr@ // pteaddr
	MmPTEInterpret ok! flags! phyaddr!

	if (DEBUGCHECKS)
		if (ok@)
			pteaddr@@ "MmWorkingSetEntryRemove: invalid PTE %x\n" KeCrash
		end
	end

	// unmap

	phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_FILE ==)
		if (flags@ PTE_W &)
			// page was modifiable, reflect that in the pfdbe.
			// this is necessary because the page might have gotten flushed
			// manually while it was mapped.

			pfdbe@ // pfdbe
			0 // process
			MmEvictablePageModify
		end
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	0 // phyaddr
	0 // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	process@ PsProcess_PCB + KeProcess_ASID + @ // asid
	MmPTEUpdate drop drop drop

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE &)
		// private page. create transition PTE so we can soft-fault it back in
		// later.

		phyaddr@ PTE_TRANSITION | pteaddr@!

		if (process@ PsSystemProcess@ ==)
			PTE_TLBHACK pteaddr |=
		end

		ipl@ KeIPLLower
	end else
		ipl@ KeIPLLower

		if (process@ PsSystemProcess@ ~=)
			1 // deref
			pteaddr@ // pteaddr
			vaddr@ // vaddr
			process@ // process
			MmPTEDelete drop
		end
	end

	MMWORKINGSETENTRY_VALID ~ wsleptr@ &=

	pfdbe@ MmEvictablePageDereference drop

	auto oldcount
	process@ PsProcess_WorkingSetSize + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmWorkingSetEntryRemove: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - process@ PsProcess_WorkingSetSize + !
end

fn MmWorkingSetEntryFindByIndex { wsli process -- wsleptr ok }
	// look up a working set index in the working set and return the pointer.
	// return -1 in ok if the index is beyond the end of valid indices.

	if (process@ PsProcess_WorkingSetMaximumIndex + @ -1 ==)
		-1 ok!
		return
	end

	if (wsli@ process@ PsProcess_WorkingSetMaximumIndex + @ >)
		-1 ok!
		return
	end

	0 ok!

	auto ix
	wsli@ MMWORKINGSETENTRIESPERTABLE / ix!

	auto off
	wsli@ MMWORKINGSETENTRIESPERTABLE % off!

	auto tab
	process@ PsProcess_WorkingSetListPointers + ix@ 2 << + @ tab!

	if (DEBUGCHECKS)
		if (tab@ ~~)
			"MmWorkingSetEntryFindByIndex: no table despite being <= maximum index\n" KeCrash
		end
	end

	tab@ off@ 2 << + wsleptr!
end

fn MmWorkingSetEntryFree { wsli wsleptr process -- }
	// place a working set entry on the free list.

	process@ PsProcess_WorkingSetFreeListHead + @ PAGESHIFT << wsleptr@!
	wsli@ process@ PsProcess_WorkingSetFreeListHead + !
end

// this function is called by the balance set manager thread when free/standby
// memory is low.

fn MmManageWorkingSets { -- success }
	while (1)
		auto pagecount
		auto dire

		auto ipl
		IPLDPC KeIPLRaise ipl!

		if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ >=)
			MmEventLowMemory // event
			KeEventReset drop

			ipl@ KeIPLLower

			1 success!

			return
		end

		MmPageFreeCountSufficient@ MmPageFreeCount@ MmEvictablePageCount@ + - pagecount!
		MmPageFreeCount@ MmEvictablePageCount@ + MMDIREPAGES < dire!

		ipl@ KeIPLLower

		0 success!

		PsProcessListLock drop

		auto process
		PsProcessListHead@ process!

		auto count
		PsActiveProcessCount@ count!

		auto nprocess

		auto totaltrimmed
		0 totaltrimmed!

		while (process@ count@ &&)
			process@ PsProcess_GlobalListNext + @ nprocess!

			if (process@ PsProcess_WorkingSetSize + @)
				auto ok

				10 // timeout
				process@ // processobject
				MmWorkingSetLockTimeout ok!

				if (ok@ ~~)
					auto trimmed

					dire@ // dire
					pagecount@ // pages
					process@ // process
					MmWorkingSetTrim trimmed!

					process@ MmWorkingSetUnlock

					if (process@ PsProcessListTail@ ~=)
						process@ PsProcessRemove
						process@ PsProcessInsert
					end

					if (trimmed@ pagecount@ >=)
						0 pagecount!
						break
					end

					trimmed@ totaltrimmed +=

					trimmed@ pagecount -=
				end
			end

			1 count -=
			nprocess@ process!
		end

		PsProcessListUnlock

		if (pagecount@ ~~)
			1 success!
			break
		end

		if (totaltrimmed@ ~~)
			return
		end
	end
end