#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMWORKINGSETENTRY_VALID 1
const MMWORKINGSETENTRY_FILE  2

const MMWORKINGSETTABLESIZE       (128 MmPoolSlab_SIZEOF -)
const MMWORKINGSETENTRIESPERTABLE (MMWORKINGSETTABLESIZE 4 /)

fn MmWorkingSetLock { processobject -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetTryLock { processobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	processobject@ PsProcess_WorkingSetMutex + // object
	KeThreadWaitForObject ok!
end

fn MmWorkingSetUnlock { processobject -- }
	processobject@ PsProcess_WorkingSetMutex + KeMutexRelease drop
end

fn MmWorkingSetListInitialize { process -- ok }
	"MmWorkingSetMutex" // name
	KERNELMODE // mode
	process@ PsProcess_WorkingSetMutex + // mutex
	KeMutexInitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			"MmWorkingSetInitialize: couldn't initialize MmWorkingSetMutex\n" KeCrash
		end
	end

	0 process@ PsProcess_WorkingSetSize + !
	MMWORKINGSETDEFAULTMINIMUM process@ PsProcess_WorkingSetMinimum + !
	MMWORKINGSETDEFAULTMAXIMUM process@ PsProcess_WorkingSetMaximum + !

	0 process@ PsProcess_WorkingSetFreeListHead + !
	0 process@ PsProcess_WorkingSetMaximumIndex + !
	0 process@ PsProcess_WorkingSetReplacementIndex + !
	0 process@ PsProcess_WorkingSetTrimFaultCount + !

	process@ PsProcess_WorkingSetListPointers + // ptr
	WORKINGSETLISTCOUNT 4 * // size
	0 // word
	memset
end

// all working set manipulation functions assume the caller took care of the
// necessary locking.

fn MmWorkingSetListFree { process -- }
	auto count
	WORKINGSETLISTCOUNT count!

	auto ptr
	process@ PsProcess_WorkingSetListPointers + ptr!

	while (count@)
		if (ptr@@)
			ptr@@ MmFree

			0 ptr@!
		end

		4 ptr +=
		1 count -=
	end
end

fn MmWorkingSetTrim { pages process -- trimmed }
	// trim the working set of the specified process.
	// attempt to trim the given number of pages, and return the real number
	// of pages trimmed.


end

fn MmWorkingSetEntryInsert { vaddr isfilepage wsleptr process -- }
	"MmWorkingSetEntryInsert: REVIEW ME\n" KeCrash

	// caller must create the associated PTE before calling this function.
	// XXX is it before or after? update this comment when we find out

	// increments the working set size.

	if (DEBUGCHECKS)
		if (vaddr@ PAGEOFFSETMASK &)
			"MmWorkingSetEntryUpdate: unaligned vaddr\n" KeCrash
		end
	end

	auto wsle
	vaddr@ MMWORKINGSETENTRY_VALID | wsle!

	if (isfilepage@)
		MMWORKINGSETENTRY_FILE wsle |=
	end

	1 process@ PsProcess_WorkingSetSize + +=

	wsle@ wsleptr@!
end

fn MmWorkingSetEntryReserve { process -- wsli wsleptr ok }
	"MmWorkingSetEntryReserve: REVIEW ME\n" KeCrash

	// first we check to see if the working set can take a page:
	//
	// - if the working set size is below the minimum, it can.
	//
	// - if the size is between the minimum and the maximum, it can if it has
	// had more than 20 page faults since the last time it was trimmed, and
	// the system is not in a low memory condition.
	//
	// - if the size >= maximum, it can if it has had more than 100 page faults
	// since the last time it was trimmed, and the system has at least
	// MmPageFreeCountSufficient free pages.
	//
	// - if the process's working set quota is at its maximum, it can't.
	//
	// if it can, we yoink the first free entry, mark it reserved, and return
	// the index in wsli.
	//
	// if it can't, we try to replace another entry in the working set at
	// random.

	// increments the page fault count.

	auto room
	0 room!

	0 ok!

	auto wssize
	process@ PsProcess_WorkingSetSize + @ wssize!

	if (wssize@ process@ PsProcess_WorkingSetMinimum + @ <)
		// below minimum, there's always room
		1 room!
	end elseif (wssize@ process@ PsProcess_WorkingSetMaximum + @ <)
		// between minimum and maximum
		if (MmEventLowMemory KeDispatchIsSignaled ~~)
			if (process@ PsProcess_PageFaultCount + @ process@ PsProcess_WorkingSetTrimFaultCount + @ - 20 >)
				1 room!
			end
		end
	end else
		// above maximum
		if (MmPageFreeCount@ MmPageFreeCountSufficient@ >=)
			if (process@ PsProcess_PageFaultCount + @ process@ PsProcess_WorkingSetTrimFaultCount + @ - 100 >)
				1 room!
			end
		end
	end

	1 process@ PsProcess_PageFaultCount + +=

	if (room@)
		1 // charge
		process@ PsProcess_QuotaBlock + @ // quotablock
		MmQuotaBlockChargeWorkingSet ok!

		if (ok@)
			0 room!
			0 ok!
		end
	end

	while (1)
		if (room@ ~~)
			// no room, kick one out

			process@ // process
			MmWorkingSetEntryReplace ok! wsleptr! wsli!

			if (ok@)
				// failed to find one to replace...
				return
			end

			wsleptr@ // wsleptr
			process@ // process
			MmWorkingSetEntryRemove
		end else
			process@ PsProcess_WorkingSetFreeListHead + @ wsli!

			if (wsli@ -1 ~=)
				// yoink

				wsli@ // wsli
				process@ // process
				MmWorkingSetEntryFindByIndex ok! wsleptr!

				if (DEBUGCHECKS)
					if (ok@)
						"MmWorkingSetEntryReserve: failed to find by index\n" KeCrash
					end
				end

				auto wsle
				wsleptr@@ wsle!

				if (DEBUGCHECKS)
					if (wsle@ MMWORKINGSETENTRY_VALID &)
						"MmWorkingSetEntryReserve: wsle was valid\n" KeCrash
					end
				end

				if (wsle@ PAGENUMBERMASK ==)
					-1 process@ PsProcess_WorkingSetFreeListHead + !
				end else
					wsle@ PAGESHIFT >> process@ PsProcess_WorkingSetFreeListHead + !
				end
			end else
				// no free entries, we need to allocate a new working set
				// array.

				// first we have to find the first zero pointer in the process
				// PsProcess_WorkingSetListPointers array. if there is none,
				// we've hit the capacity of the working set list data
				// structure and must count that as a failed allocation.

				// then we need to allocate the array and set the pointer in
				// the process's WorkingSetListPointers array. then we need to
				// initialize it by placing MMWORKINGSETENTRIESPERTABLE-1 of
				// its entries on the free list, reserving the last one for
				// ourselves.

				// uncharge working set quota and loop with room=0 if failed
				// to allocate, in order to retry the reservation as a
				// replacement.

				"TODO THIS PART\n" KeCrash
			end
		end

		if (wsli@ process@ PsProcess_WorkingSetMaximumIndex + @ >)
			wsli@ process@ PsProcess_WorkingSetMaximumIndex + !
		end

		0 wsleptr@!

		return
	end

	"MmWorkingSetEntryReserve: unreachable\n" KeCrash
end

fn MmWorkingSetEntryReplace { process -- wsli wsleptr ok }
	"MmWorkingSetEntryReplace: REVIEW ME\n" KeCrash

	// find a working set entry to replace.

	auto hint
	process@ PsProcess_WorkingSetReplacementIndex + @ hint!

	if (hint@ process@ PsProcess_WorkingSetMaximumIndex + @ >)
		0 hint!
	end

	// search from the replacement index to the end of the working set for a
	// valid entry to replace, then from the start to the replacement index.

	auto i
	0 i!

	while (i@ 2 <)
		auto endindex

		if (i@ 0 ==)
			hint@ wsli!
			process@ PsProcess_WorkingSetMaximumIndex + @ 1 + endindex!
		end elseif (hint@)
			0 wsli!
			hint@ endindex!
		end else
			-1 ok!

			return
		end

		auto tabptr
		process@ PsProcess_WorkingSetListPointers + wsli@ MMWORKINGSETENTRIESPERTABLE / 2 << + tabptr!

		auto off
		wsli@ MMWORKINGSETENTRIESPERTABLE % off!

		tabptr@@ off@ 2 << + wsleptr!

		auto wsle

		auto leftintable
		MMWORKINGSETENTRIESPERTABLE off@ - leftintable!

		while (wsli@ endindex@ <)
			if (leftintable@ ~~)
				4 tabptr +=
				tabptr@@ wsleptr!
				MMWORKINGSETENTRIESPERTABLE leftintable!
			end

			wsleptr@@ wsle!

			if (wsle@ MMWORKINGSETENTRY_VALID &)
				// found one
				wsli@ 1 + process@ PsProcess_WorkingSetReplacementIndex + !

				return
			end

			1 leftintable -=
			4 wsleptr +=
			1 wsli +=
		end

		1 i +=
	end

	-1 ok!
end

fn MmWorkingSetEntryRemove { wsleptr process -- }
	"MmWorkingSetEntryRemove: REVIEW ME\n" KeCrash

	// remove the specified entry from the working set. deletes the PTE unless
	// COW.

	// unmap it from the process's pagemap, and decrement its refcount.
	// if COW, set transition PTE pointers.
	// if file, clear any associated modified PTE pointer.

	// DOES remove the valid bit, but does NOT free the entry; caller must do
	// that if it wants that to happen.

	// also does NOT uncharge working set quota.

	// decrements the working set size.

	if (DEBUGCHECKS)
		if (wsleptr@@ MMWORKINGSETENTRY_VALID & ~~)
			"MmWorkingSetEntryRemove: not valid\n" KeCrash
		end
	end

	auto vaddr
	wsleptr@@ PAGENUMBERMASK & vaddr!

	auto isfile
	wsleptr@@ MMWORKINGSETENTRY_FILE & isfile!

	auto pteaddr
	auto ok

	vaddr@ // vaddr
	process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (DEBUGCHECKS)
		if (ok@)
			"MmWorkingSetEntryRemove: no PTE\n" KeCrash
		end
	end

	auto phyaddr
	auto pfdbe
	auto flags

	pteaddr@ // pteaddr
	MmPTEInterpret ok! flags! phyaddr!

	if (DEBUGCHECKS)
		if (ok@)
			"MmWorkingSetEntryRemove: invalid PTE\n" KeCrash
		end
	end

	phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto ipl
	-1 ipl!

	if (isfile@)
		if (flags@ PTE_W &)
			IPLDPC KeIPLRaise ipl!

			if (pfdbe@ IOPageFrameEntryCache_ModifiedPTE + @ pteaddr@ ==)
				0 pfdbe@ IOPageFrameEntryCache_ModifiedPTE + !
				
				// DONT unmodify the PTE, just leave IPL raised and allow it
				// to be unmapped below

				// pteaddr@ MmPTEUnmodify
			end else
				ipl@ KeIPLLower

				-1 ipl!
			end
		end
	end

	// unmap

	0 // phyaddr
	0 // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	process@ PsProcess_PCB + KeProcess_ASID + @ // asid
	MmPTEUpdate drop drop drop

	if (ipl@ -1 ~=)
		ipl@ KeIPLLower
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + @ MMEVICTFLAG_COW &)
		// create transition PTE and link back

		pteaddr@ pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + !
		phyaddr@ PTE_TRANSITION | pteaddr@!
	end else
		pteaddr@ // pteaddr
		vaddr@ // vaddr
		process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
		MmPTEDelete drop
	end

	pfdbe@ MmEvictablePageDereference drop

	MMWORKINGSETENTRY_VALID ~ wsleptr@ &=

	auto oldcount
	process@ PsProcess_WorkingSetSize + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmWorkingSetEntryRemove: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - process@ PsProcess_WorkingSetSize + !
end

fn MmWorkingSetEntryFindByIndex { wsli process -- wsleptr ok }
	"MmWorkingSetEntryFindByIndex: REVIEW ME\n" KeCrash

	// look up a working set index in the working set and return the pointer.
	// return -1 in ok if the index is beyond the end of valid indices.

	if (wsli@ process@ PsProcess_WorkingSetMaximumIndex + @ >)
		-1 ok!
		return
	end

	0 ok!

	auto ix
	wsli@ MMWORKINGSETENTRIESPERTABLE / ix!

	auto off
	wsli@ MMWORKINGSETENTRIESPERTABLE % off!

	auto tab
	process@ PsProcess_WorkingSetListPointers + ix@ 2 << + @ tab!

	if (DEBUGCHECKS)
		if (tab@ ~~)
			"MmWorkingSetEntryFindByIndex: no table despite being <= maximum index\n" KeCrash
		end
	end

	tab@ off@ 2 << + wsleptr!
end

fn MmWorkingSetEntryFindByVirtualAddress { vaddr process -- wsli wsleptr ok }
	"MmWorkingSetEntryFindByVirtualAddress: REVIEW ME\n" KeCrash

	// look up a virtual address in the working set and return the pointer.
	// return -1 in ok if the virtual address is not part of the working set.

	// caller must make sure the vaddr points to a physical page frame.

	// look up vaddr in process's pagemap, if it's not valid we know it's not
	// in the working set.

	if (DEBUGCHECKS)
		if (vaddr@ PAGEOFFSETMASK &)
			"MmWorkingSetEntryFindByVirtualAddress: unaligned vaddr\n" KeCrash
		end
	end

	auto pteaddr

	vaddr@ // vaddr
	process@ PsProcess_PCB + KeProcess_PageDirectory + @ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (ok@)
		return
	end

	auto pfdbe

	pteaddr@ // pteaddr
	MmPTEInterpret ok! drop pfdbe!

	if (ok@)
		return
	end

	pfdbe@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	// it is valid. look in pfdbe for working set index hint and see if it
	// resides in that entry.

	pfdbe@ MmPageFrameEntryEvictable_WorkingSetIndexHint + @ wsli!

	wsli@ // wsli
	process@ // process
	MmWorkingSetEntryFindByIndex ok! wsleptr!

	auto wsle

	if (ok@ ~~)
		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			if (wsle@ PAGENUMBERMASK & vaddr@ ==)
				// found it!

				return
			end
		end
	end

	// not there. search the entire working set up to the last valid index.

	0 wsli!

	auto tabptr
	process@ PsProcess_WorkingSetListPointers + tabptr!

	tabptr@@ wsleptr!

	auto leftintable
	MMWORKINGSETENTRIESPERTABLE leftintable!

	auto maxi
	process@ PsProcess_WorkingSetMaximumIndex + @ maxi!

	while (wsli@ maxi@ <=)
		if (leftintable@ ~~)
			4 tabptr +=
			tabptr@@ wsleptr!
			MMWORKINGSETENTRIESPERTABLE leftintable!
		end

		wsleptr@@ wsle!

		if (wsle@ MMWORKINGSETENTRY_VALID &)
			if (wsle@ PAGENUMBERMASK & vaddr@ ==)
				// found it!

				return
			end
		end

		1 leftintable -=
		4 wsleptr +=
		1 wsli +=
	end

	-1 ok!
end

fn MmWorkingSetEntryFree { wsli wsleptr process -- }
	"MmWorkingSetEntryFree: REVIEW ME\n" KeCrash

	// place a working set entry on the free list.

	process@ PsProcess_WorkingSetFreeListHead + @ PAGESHIFT << wsleptr@!

	wsli@ process@ PsProcess_WorkingSetFreeListHead + !
end