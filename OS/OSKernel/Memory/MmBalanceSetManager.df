//
// Implements the balance set manager thread.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALRTC.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

buffer MmSwapEvent KeEvent_SIZEOF
public MmSwapEvent

buffer MmBalanceSetManagerTimer KeTimer_SIZEOF

const MMBALANCESETINTERVAL 1000

var MmStackAge 0

var MmSwapOutStacksPlease 0
public MmSwapOutStacksPlease

var MmForcedOutProcessListHead 0
public MmForcedOutProcessListHead

var MmForcedOutProcessListTail 0
public MmForcedOutProcessListTail

externptr MmOkToUnwire

fn MmBalanceSetManager { -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet
	ipl@ KeIPLLower

	KeThreadCurrent@ KeThreadIgnoreKill drop

	// tell the idle thread its okay to unwire the kernel.

	1 MmOkToUnwire!

	// create the swap thread in the context of the balance set manager cuz
	// I like to be confusing.

	0 // signaled
	OSEVENT_SYNCH // type
	"MmSwapEvent" // name
	MmSwapEvent // event
	KeEventInitialize

	0 // context1
	0 // context2
	pointerof MmSwapWorker // startfunc
	0 // creationflags
	ACCESS_OWNER_ALL // permissions
	"SwapWorker" // name
	PsSystemProcess@ // processobject
	PsThreadCreateObject ok! drop

	if (ok@)
		ok@ "MmBalanceSetManager: couldn't create 'SwapWorker' thread (%i)\n" KeCrash
	end

	// responsible for:
	// - kernel thread stack swapping
	// - process swapping (page table swapping & working set purging)
	// - random thread priority boosting
	// - working set trimming

	// this little idiot is the only reason we will fit snugly in 4MB RAM.

	"MmBalanceSetManagerTimer" // name
	0 // function
	MmBalanceSetManagerTimer // timer
	KeTimerInitialize

	auto objecttable
	8 alloc objecttable!

	MmBalanceSetManagerTimer objecttable@!
	MmEventLowMemory objecttable@ 4 + !

	auto stackperiod
	0 stackperiod!

	0 // context1
	0 // context2
	MMBALANCESETINTERVAL // interval
	MmBalanceSetManagerTimer // timer
	KeTimerEnqueue

	while (1)
		auto ok
		auto reason

		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		OSWAIT_TIMEOUTINFINITE // timeout
		2 // objectcount
		objecttable@ // objecttable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ z<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "MmBalanceSetManager: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		auto needed
		auto dire
		auto rs

		if (reason@ 0 ==)
			// timer expired

			if (ExShuttingDown@ ~~)
				if (PsSystemInitProcess@ KeProcess_Terminated + @)
					PsSystemInitProcess@ KeProcess_KilledStatus + @
					"SystemInit died (%i)\n" KeCrash
				end
			end

			auto stackscanperiod

			if (MmPhysicalCommitUsage@ MmPhysicalCommitLimit@ >)
				1 stackscanperiod!
				0 MmStackAge!

				MmBalanceOutProcesses
			end else
				5 stackscanperiod!
				10 MmStackAge!

				0 MmBalanceInProcesses
			end

			if (MmForcedOutProcessListHead@)
				10 MmBalanceInProcesses
			end

			MmManageWorkingSets drop

			if (stackperiod@ stackscanperiod@ >=)
				HALCPUInterruptDisable rs!

				if (MmSwapOutStacksPlease@ ~~)
					1 MmSwapOutStacksPlease!
					rs@ HALCPUInterruptRestore

					0 // priboost
					MmSwapEvent // event
					KeEventSignal
				end else
					rs@ HALCPUInterruptRestore
				end

				0 stackperiod!
			end else
				1 stackperiod +=
			end

			0 // context1
			0 // context2
			MMBALANCESETINTERVAL // interval
			MmBalanceSetManagerTimer // timer
			KeTimerEnqueue
		end elseif (reason@ 1 ==)
			// low memory event

			if (MmManageWorkingSets ~~)
				0 // priboost
				MmModifiedPageEvent // event
				KeEventSignal
			end

			// wait 80ms before trying again

			80 // interval
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep drop
		end
	end
end

fn MmBalanceOutProcesses { -- }
	PsProcessListLock drop

	auto firstpass
	1 firstpass!

	auto time
	KeTime_SIZEOF alloc time!

	auto timesec
	time@ KeTime_SecPart + @ timesec!

	time@ HALUptimeQuery

	auto process
	PsProcessListHead@ process!

	auto count
	PsActiveProcessCount@ count!

	auto nprocess

	auto checkloop
	0 checkloop!

	while (process@ count@ &&)
		if (process@ checkloop@ ==)
			break
		end
		
		process@ PsProcess_GlobalListNext + @ nprocess!

		auto balanceout
		0 balanceout!

		if (process@ PsSystemProcess@ ~=)
			if (process@ KeProcess_MemoryState + @ PROCESSSTATE_RESIDENT ==)
				if (process@ PsProcess_RemovedFromBalanceSet + @ ~~)
					if (firstpass@)
						1 balanceout!
					end else
						auto ipl
						IPLDPC KeIPLRaise ipl!

						auto thread
						process@ KeProcess_ThreadListHead + @ thread!

						while (thread@)
							if (thread@ KeThread_Status + @ THREADSTATUS_READY ==)
								if (timesec@ thread@ KeThread_WaitOrReadyTimeSec + @ - 10 >=)
									1 balanceout!
									break
								end
							end

							thread@ KeThread_ProcessNext + @ thread!
						end

						ipl@ KeIPLLower
					end
				end
			end
		end

		if (balanceout@)
			auto rs
			HALCPUInterruptDisable rs!

			1 process@ PsProcess_RemovedFromBalanceSet + !

			auto t
			MmForcedOutProcessListTail@ t!

			if (t@ ~~)
				0 process@ PsProcess_ForcedOutListNext + !
				0 process@ PsProcess_ForcedOutListPrev + !

				process@ MmForcedOutProcessListHead!
				process@ MmForcedOutProcessListTail!
			end else
				0 process@ PsProcess_ForcedOutListNext + !

				t@ process@ PsProcess_ForcedOutListPrev + !
				process@ t@ PsProcess_ForcedOutListNext + !
				process@ MmForcedOutProcessListTail!
			end

			rs@ HALCPUInterruptRestore

			if (process@ PsProcessListTail@ ~=)
				if (checkloop@ ~~)
					process@ checkloop!
				end

				process@ PsProcessRemove
				process@ PsProcessInsert
			end
		end

		1 count -=
		0 firstpass!
		nprocess@ process!
	end

	PsProcessListUnlock
end

fn MmBalanceInProcesses { swapoutmaxtime -- }
	auto time
	KeTime_SIZEOF alloc time!

	time@ HALUptimeQuery

	auto timesec
	time@ KeTime_SecPart + @ timesec!

	auto balancein

	auto checkloop
	0 checkloop!

	auto nprocess

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto process
	MmForcedOutProcessListHead@ process!

	while (process@)
		process@ PsProcess_ForcedOutListNext + @ nprocess!

		0 balancein!

		if (process@ KeProcess_MemoryState + @ PROCESSSTATE_OUTSWAPPED ==)
			if (timesec@ process@ PsProcess_SwappedOutTimeSec + @ - swapoutmaxtime@ >=)
				1 balancein!
			end
		end elseif (swapoutmaxtime@ ~~)
			1 balancein!
		end

		if (balancein@)
			process@ MmBalanceInProcess

			break
		end

		nprocess@ process!
	end

	ipl@ KeIPLLower
end

fn MmBalanceInProcess { process -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (process@ PsProcess_RemovedFromBalanceSet + @ ~~)
		ipl@ KeIPLLower
		return
	end

	0 process@ PsProcess_RemovedFromBalanceSet + !

	// remove from list

	auto ls
	process@ PsProcess_ForcedOutListPrev + @ ls!

	auto ns
	process@ PsProcess_ForcedOutListNext + @ ns!

	if (ls@)
		ns@ ls@ PsProcess_ForcedOutListNext + !
	end else
		ns@ MmForcedOutProcessListHead!
	end

	if (ns@)
		ls@ ns@ PsProcess_ForcedOutListPrev + !
	end else
		ls@ MmForcedOutProcessListTail!
	end

	0 process@ PsProcess_ForcedOutListPrev + !
	0 process@ PsProcess_ForcedOutListNext + !

	// resume threads

	auto thread
	process@ KeProcess_ThreadListHead + @ thread!

	while (thread@)
		if (thread@ KeThread_Status + @ THREADSTATUS_BALSETREMOVED ==)
			0 // waitstatus
			1 // priboost
			thread@ // thread
			KeThreadWakeup drop
		end

		thread@ KeThread_ProcessNext + @ thread!
	end

	ipl@ KeIPLLower
end

var MmProcessSwapOutListHead 0
public MmProcessSwapOutListHead

fn MmSwapWorker { context1 context2 -- }
	PRIORITY_HIGHREALTIME 1 - // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	KeThreadCurrent@ KeThreadIgnoreKill drop

	// not to be confused with the thread that writes pages to swap, which is
	// the modified page writer. this evicts entire processes from memory for
	// being inactive too long.

	while (1)
		auto ok
		auto waitok

		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		MmSwapEvent // object
		KeThreadWaitForObject waitok!

		if (DEBUGCHECKS)
			if (waitok@ z<)
				waitok@ "MmSwapWorker: failed to wait on swap event (%i)\n" KeCrash
			end
		end

		while (1)
			auto ipl
			IPLDPC KeIPLRaise ipl!

			if (MmSwapOutStacksPlease@)
				0 MmSwapOutStacksPlease!
				MmSwapOutStacks

				ipl@ KeIPLLower

				continue
			end elseif (MmProcessSwapOutListHead@)
				MmSwapOutProcesses

				ipl@ KeIPLLower

				continue
			end elseif (KeProcessSwapInListHead@)
				MmSwapInProcesses

				ipl@ KeIPLLower

				continue
			end elseif (KeThreadSwapInListHead@)
				MmSwapInStacks

				ipl@ KeIPLLower

				continue
			end

			ipl@ KeIPLLower

			break
		end
	end
end

fn MmSwapOutStacks { -- }
	// scans the list of blocked threads and makes the kernel stacks of those
	// that have been blocked longer than MMSTACKAGE seconds non-resident.

	// called at IPLDPC.

	auto uptime
	KeTime_SIZEOF alloc uptime!

	uptime@ HALUptimeQuery

	auto uptimesec
	uptime@ KeTime_SecPart + @ uptimesec!

	auto thread
	KeThreadWaitListHead@ thread!

	while (thread@)
		if (thread@ KeThread_KernelStackResident + @)
			if (uptimesec@ thread@ KeThread_WaitOrReadyTimeSec + @ - MmStackAge@ >=)
				if (thread@ KeThread_WaitMode + @ USERMODE ==)
					// yeet it.
					thread@ MmKernelStackSwapOut

					auto process
					thread@ KeThread_Process + @ process!

					1 process@ KeProcess_ResidentStackCount + -=

					if (DEBUGCHECKS)
						if (process@ KeProcess_ResidentStackCount + @ z<)
							"MmSwapOutStacks: underflow\n" KeCrash
						end
					end

					if (process@ KeProcess_ResidentStackCount + @ ~~)
						if (DEBUGCHECKS)
							if (process@ KeProcess_MemoryState + @ PROCESSSTATE_RESIDENT ~=)
								process@ KeProcess_MemoryState + @
								"MmSwapOutStacks: unexpected process state %d\n" Printf
							end
						end

						PROCESSSTATE_TRANSITION process@ KeProcess_MemoryState + !

						MmProcessSwapOutListHead@ process@ KeProcess_SwapListNext + !
						process@ MmProcessSwapOutListHead!
					end
				end
			end
		end

		thread@ KeThread_QueueNext + @ thread!
	end
end

fn MmSwapInStacks { -- }
	// called at IPLDPC

	while (1)
		auto thread
		KeThreadSwapInListHead@ thread!

		if (thread@ ~~)
			break
		end

		thread@ KeThread_QueueNext + @ KeThreadSwapInListHead!
		0 thread@ KeThread_QueueNext + !

		auto process
		thread@ KeThread_Process + @ process!

		if (DEBUGCHECKS)
			if (process@ KeProcess_MemoryState + @ PROCESSSTATE_RESIDENT ~=)
				process@ "MmSwapInStacks: process %x wasn't resident\n" KeCrash
			end
		end

		IPLLOW KeIPLLower

		thread@ MmKernelStackSwapIn
		QUEUEBACK thread@ KeThreadReady

		IPLDPC KeIPLRaise drop
	end
end

fn MmSwapInProcesses { -- }
	// called at IPLDPC

	while (1)
		auto process
		KeProcessSwapInListHead@ process!

		if (process@ ~~)
			break
		end

		process@ KeProcess_SwapListNext + @ KeProcessSwapInListHead!
		0 process@ KeProcess_SwapListNext + !

		IPLLOW KeIPLLower

		process@ MmProcessSwapIn

		IPLDPC KeIPLRaise drop

		process@ MmSwapReadyDeferred
	end
end

fn MmSwapOutProcesses { -- }
	// called at IPLDPC

	while (1)
		auto process
		MmProcessSwapOutListHead@ process!

		if (process@ ~~)
			break
		end

		process@ KeProcess_SwapListNext + @ MmProcessSwapOutListHead!
		0 process@ KeProcess_SwapListNext + !

		if (process@ KeProcess_DeferredThreadListHead + @)
			// threads were added to the deferred list while the process
			// was pending swapout. don't swap it out.

			process@ MmSwapReadyDeferred
		end else
			PROCESSSTATE_OUTSWAPPED process@ KeProcess_MemoryState + !

			IPLLOW KeIPLLower

			process@ MmProcessSwapOut

			IPLDPC KeIPLRaise drop
		end
	end
end

fn MmSwapReadyDeferred { process -- }
	PROCESSSTATE_RESIDENT process@ KeProcess_MemoryState + !

	while (1)
		auto thread
		process@ KeProcess_DeferredThreadListHead + @ thread!

		if (thread@ ~~)
			break
		end

		thread@ KeThread_QueueNext + @ process@ KeProcess_DeferredThreadListHead + !
		0 thread@ KeThread_QueueNext + !

		QUEUEBACK thread@ KeThreadReady
	end

	process@ MmBalanceInProcess
end