//
// Initialization of the MINTIA memory manager.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALResource.h"

#include "../../Loader/LoaderGlobal.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Process.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

externptr HALLoaderPFDB
externptr HALLoaderInitialBitmap
externptr HALLoaderInitialBitmapSize
externptr HALLoaderTotalRAM
externptr HALLoaderHeap
externptr HALLoaderHeapSize

externptr HALResourceKeepHeaders
externptr HALLoaderInfo

externptr HALPageFaultFunction

var MmPageFrameDatabase 0
public MmPageFrameDatabase

var MmPageFreeListHead 0
public MmPageFreeListHead

var MmPageZeroListHead 0
public MmPageZeroListHead

var MmPageTotal 0
public MmPageTotal

var MmPageTotalTotal 0
public MmPageTotalTotal

var MmPageFreeCount 0
public MmPageFreeCount

var MmInited 0
public MmInited

buffer MmQuotaSystem MmQuotaBlock_SIZEOF
public MmQuotaSystem

buffer MmEventLowMemory KeEvent_SIZEOF
public MmEventLowMemory

buffer MmModifiedPageEvent KeEvent_SIZEOF
public MmModifiedPageEvent

var MmPageFreeCountLow 0
public MmPageFreeCountLow

var MmPageFreeCountSufficient 0
public MmPageFreeCountSufficient

var MmModifiedPageMaximum 0
public MmModifiedPageMaximum

var MmCommitLimit 0
public MmCommitLimit

var MmCommitUsage 0
public MmCommitUsage

buffer MmEventPageAvailable KeEvent_SIZEOF
public MmEventPageAvailable

buffer MmAsyncEvictEvent KeEvent_SIZEOF
public MmAsyncEvictEvent

// initializes physical memory allocation

fn MmInitPhase0 { -- }
	auto ptr

	HALLoaderPFDB@ dup MmPageFrameDatabase! ptr!

	auto i
	0 i!

	auto pages
	HALLoaderTotalRAM@ PAGESHIFT >> pages!

	pages@ MmPageTotalTotal!

	auto bmp
	HALLoaderInitialBitmap@ bmp!

	auto sz
	HALLoaderInitialBitmapSize@ 32 * sz!

	auto word

	auto last
	0 last!

	// initialize the page DB by linking all of the entries into the
	// free list, except those marked allocated in the loader bitmap.

	while (i@ pages@ <)
		if (i@ sz@ <)
			if (i@ 31 & ~~)
				bmp@@ word!
				4 bmp +=
			end

			if (word@ i@ 31 & bitget ~~)
				1 MmPageFreeCount +=

				if (last@)
					ptr@ last@ MmPageFrameEntryFree_Next + !
				end else
					ptr@ MmPageFreeListHead!
				end

				ptr@ last!
			end
		end else
			1 MmPageFreeCount +=

			if (last@)
				ptr@ last@ MmPageFrameEntryFree_Next + !
			end else
				ptr@ MmPageFreeListHead!
			end

			ptr@ last!
		end

		0 ptr@ MmPageFrameEntryFree_Next + !
		i@ ptr@ MmPageFrameEntry_PFN + !

		MmPageFrameEntry_SIZEOF ptr +=
		1 i +=
	end

	MmPageFreeCount@ MmPageTotal!

	1 MmInited!

	"Pre-boot memory statistics:\n" "MmInitPhase0" HALLog

	MmUsageDump

	auto idleproc
	KeProcessCurrent idleproc!

	MMQUOTAINFINITE // modmax
	MMQUOTAINFINITE // wsmax
	MMQUOTAINFINITE // vmmax
	MMQUOTAINFINITE // heapmax
	MmQuotaSystem // quota
	MmQuotaBlockInitialize word!

	if (word@)
		"MmInitPhase0: couldn't initialize system quota block\n" KeCrash
	end

	// bias the reference by one to make sure the system never attempts to
	// free this
	MmQuotaSystem MmQuotaBlockReference

	MmQuotaSystem idleproc@ PsProcess_QuotaBlock + !

	0 // signaled
	OSEVENT_NOTIF // type
	"MmEventLowMemory" // name
	MmEventLowMemory // event
	KeEventInitialize

	0 // signaled
	OSEVENT_SYNCH // type
	"MmEventPageAvailable" // name
	MmEventPageAvailable // event
	KeEventInitialize

	0 // signaled
	OSEVENT_SYNCH // type
	"IODirtyPageEvent" // name
	IODirtyPageEvent // event
	KeEventInitialize

	0 // signaled
	OSEVENT_SYNCH // type
	"MmModifiedPageEvent" // name
	MmModifiedPageEvent // event
	KeEventInitialize

	0 // signaled
	OSEVENT_SYNCH // type
	"MmAsyncEvictEvent" // name
	MmAsyncEvictEvent // event
	KeEventInitialize

	MmPoolInit

	MmReclaimFirmware
end

var MmSectionObjectType 0
public MmSectionObjectType

fn MmInitPhase1 { -- }
	auto typeinit
	ObTypeInitializer_SIZEOF alloc typeinit!

	// initialize ObTypeInitializer fields

	typeinit@ ObTypeInitializerInitialize

	// create Section type

	auto type

	"Section" typeinit@ ObTypeInitializer_Name + !
	'Sect' typeinit@ ObTypeInitializer_Tag + !
	0 typeinit@ ObTypeInitializer_BodySize + !
	pointerof MmSectionObjectDelete typeinit@ ObTypeInitializer_DeleteFunction + !
	typeinit@ ObTypeCreate ok! type!

	if (ok@)
		ok@ "MmInitPhase1: couldn't create Section type (%i)\n" KeCrash
	end

	type@ MmSectionObjectType!

	// initialize eviction/swap

	auto membytes
	MmPageTotalTotal@ PAGESHIFT << membytes!

	if (membytes@ 2 1024 * 1024 * <=)
		// tiny system, 2MB

		25 MmPageFreeCountLow!
		60 MmPageFreeCountSufficient!
		50 IOCachePagesDirtyMaximum!
		25 MmModifiedPageMaximum!
	end elseif (membytes@ 4 1024 * 1024 * <=)
		// small system, 4MB

		60 MmPageFreeCountLow!
		150 MmPageFreeCountSufficient!
		100 IOCachePagesDirtyMaximum!
		75 MmModifiedPageMaximum!
	end elseif (membytes@ 8 1024 * 1024 * <=)
		// medium system, 8MB

		60 MmPageFreeCountLow!
		200 MmPageFreeCountSufficient!
		150 IOCachePagesDirtyMaximum!
		130 MmModifiedPageMaximum!
	end elseif (membytes@ 12 1024 * 1024 * <=)
		// large system, 12MB

		60 MmPageFreeCountLow!
		250 MmPageFreeCountSufficient!
		200 IOCachePagesDirtyMaximum!
		180 MmModifiedPageMaximum!
	end elseif (membytes@ 32 1024 * 1024 * >=)
		// massive system, >=32MB

		70 MmPageFreeCountLow!
		300 MmPageFreeCountSufficient!
		300 IOCachePagesDirtyMaximum!
		200 MmModifiedPageMaximum!
	end

	// initialize the commit limit to the free page count plus 100 pages.
	// will get set to the size of the swapfile later.
	MmPageFreeCount@ 100 + MmCommitLimit!

	MmPageFreeCountSufficient@
	MmPageFreeCountLow@
	"free page targets: %d pages -> %d pages\n" "MmInitPhase1" HALLog

	IOCachePagesDirtyMaximum@ PAGESHIFT <<
	IOCachePagesDirtyMaximum@ "dirty page maximum: %d pages (%d bytes)\n" "MmInitPhase1" HALLog

	MmModifiedPageMaximum@ PAGESHIFT <<
	MmModifiedPageMaximum@ "modified page maximum: %d pages (%d bytes)\n" "MmInitPhase1" HALLog

	auto ok

	0 // context1
	0 // context2
	pointerof MmModifiedPageWriter // startfunc
	0 // creationflags
	ACCESS_OWNER_ALL // permissions
	"ModifiedPageWriter" // name
	PsSystemProcess@ // processobject
	PsThreadCreateObject ok! drop

	if (ok@)
		ok@ "MmInitPhase1: couldn't create 'ModifiedPageWriter' thread (%i)\n" KeCrash
	end
end

fn MmReclaimFirmware { -- }
	// lift the resource list and DLL list into our kernel heap and then
	// reclaim the firmware.

	// XXX this is LIMNstation specific and will be replaced by a platform-
	// -independent memory map based mechanism in the future.

	auto ok

	auto newlisthead

	// rebuild the resource list on our own heap

	auto prev
	auto new

	auto current
	HALLoaderInfo@ LoaderInfo_ResourceListHead + @ current!

	0 newlisthead!

	while (current@)
		BootResource_SIZEOF // bytes
		'nRSR' // tag
		MmAllocWithTag ok! new!

		if (ok@)
			"MmReclaimFirmware: couldn't relocate resources list.\n" KeCrash
		end

		if (newlisthead@ ~~)
			new@ newlisthead!
		end else
			new@ prev@ BootResource_Next + !
		end

		new@ prev!

		new@ // dest
		current@ // src
		BootResource_SIZEOF // size
		memcpy

		0 new@ BootResource_Next + !

		current@ BootResource_Next + @ current!
	end

	newlisthead@ HALResourceListHead!

	// rebuild the DLL list on our own heap so we can reclaim the firmware

	auto start
	auto sz
	auto rs

	0 newlisthead!

	HALLoaderInfo@ LoaderInfo_DLLListHead + @ current!

	while (current@)
		if (HALResourceKeepHeaders@ ~~)
			// free all the DLL information

			current@ DLL_LOFF + LOFFLoaded_HeaderSize + @ PAGEOFFSETMASK + PAGESHIFT >> sz!
			current@ DLL_LOFF + LOFFLoaded_Base + @ IDENTITYSPACEMASK & PAGESHIFT >> start!

			while (sz@)
				start@ MmPageFree

				HALCPUInterruptDisable rs!
				// the page is now un-wired
				1 MmPageTotal +=
				rs@ HALCPUInterruptRestore

				1 start +=
				1 sz -=
			end
		end

		DLL_SIZEOF // bytes
		'nDLL' // tag
		MmAllocWithTag ok! new!

		if (ok@)
			"MmReclaimFirmware: couldn't relocate DLL list. try unloading the debugger.\n" KeCrash
		end

		if (newlisthead@ ~~)
			new@ newlisthead!
		end else
			new@ prev@ DLL_Next + !
		end

		new@ prev!

		new@ // dest
		current@ // src
		DLL_SIZEOF // size
		memcpy

		0 new@ DLL_Next + !

		current@ DLL_Next + @ current!
	end

	newlisthead@ HALLoaderInfo@ LoaderInfo_DLLListHead + !

	HALLoaderInfo@ LoaderInfo_TopOfReclaimable + @ PAGESHIFT >> sz!
	
	if (sz@)
		1 start!
		1 sz -=

		while (sz@)
			start@ MmPageFree

			HALCPUInterruptDisable rs!
			// the page is now un-wired
			1 MmPageTotal +=
			rs@ HALCPUInterruptRestore

			1 start +=
			1 sz -=
		end
	end
end

fn MmResourceJettison { -- }
	auto rsrc
	HALResourceListHead@ rsrc!

	auto sz
	auto start
	auto ok

	auto rs

	while (rsrc@)
		if (rsrc@ BootResource_Jettison + @)
			rsrc@ BootResource_Size + @ PAGEOFFSETMASK + PAGESHIFT >> sz!
			rsrc@ BootResource_Data + @ IDENTITYSPACEMASK & PAGESHIFT >> start!

			while (sz@)
				start@ MmPageFree

				HALCPUInterruptDisable rs!
				// the page is now un-wired
				1 MmPageTotal +=
				rs@ HALCPUInterruptRestore

				1 start +=
				1 sz -=
			end

			0 rsrc@ BootResource_Data + ! // mark jettisoned
		end

		auto nrsrc
		rsrc@ BootResource_Next + @ nrsrc!

		rsrc@ MmFree

		nrsrc@ rsrc!
	end

	0 HALResourceListHead!
end

fn MmQuery { query -- ok }
	0 ok!

	query@ // ptr
	OSMemoryInformation_SIZEOF // size
	0 // word
	memset

	MmPageTotalTotal@ query@ OSMemoryInformation_PageTotalCount + !
	MmPageTotal@ query@ OSMemoryInformation_PageTotalNonWiredCount + !
	
	MmPageFreeCount@ query@ OSMemoryInformation_PageFreeCount + !

	IOCachePagesUsed@ query@ OSMemoryInformation_FileCachePageCount + !
	MmAnonymousPageCount@ query@ OSMemoryInformation_AnonymousPageCount + !

	IOCachePagesDirtyCount@ query@ OSMemoryInformation_DirtyPageCount + !
	IOCachePagesDirtyMaximum@ query@ OSMemoryInformation_DirtyPageMaximum + !

	IOSwapPagesCount@ query@ OSMemoryInformation_SwapPageTotalCount + !
	IOSwapPagesUsed@ query@ OSMemoryInformation_SwapPageUsedCount + !
	IOSwapPagesUsedPeak@ query@ OSMemoryInformation_SwapPagePeakCount + !

	IOSwapPagesRead@ query@ OSMemoryInformation_SwapPagesRead + !
	IOSwapPagesWritten@ query@ OSMemoryInformation_SwapPagesWritten + !

	MmSlabBytesUsedInternally@ MmPoolBytesUsed@ +
	query@ OSMemoryInformation_PoolBytesUsedInternally + !

	MmSlabBytesUsedExternally@ MmPoolBytesUsed@ +
	query@ OSMemoryInformation_PoolBytesUsedExternally + !

	MmEvictablePageCount@ query@ OSMemoryInformation_EvictablePageCount + !

	MmEvictableModifiedPageCount@ query@ OSMemoryInformation_ModifiedPageCount + !
	MmModifiedPageMaximum@ query@ OSMemoryInformation_ModifiedPageMaximum + !

	MmTotalWorkingSetSize@ query@ OSMemoryInformation_WorkingSetPageTotalCount + !
	MmPeakWorkingSetSize@ query@ OSMemoryInformation_WorkingSetPagePeakCount + !

	MmPageFaultCount@ query@ OSMemoryInformation_PageFaultCount + !

	MmCommitLimit@ query@ OSMemoryInformation_CommitLimit + !
	MmCommitUsage@ query@ OSMemoryInformation_CommitUsage + !
end

fn MmUsageDump { -- }
	auto pageswired
	MmPageTotalTotal@ MmPageTotal@ - pageswired!

	auto pagesused
	MmPageTotalTotal@ MmPageFreeCount@ - pagesused!

	pageswired@ PAGESHIFT << 1024 /
	MmPageTotalTotal@ PAGESHIFT << 1024 /
	pagesused@ PAGESHIFT << 1024 / " PHYS: %dKB/%dKB used (%dKB unswappable kernel data)\n" Printf

	IOSwapPagesUsedPeak@ PAGESHIFT << 1024 /
	IOSwapPagesCount@ PAGESHIFT << 1024 /
	IOSwapPagesUsed@ PAGESHIFT << 1024 / " SWAP: %dKB/%dKB used (%dKB peak)\n" Printf
	
	MmSlabBytesUsedExternally@ 1024 /
	MmSlabBytesUsedInternally@ 1024 / " HEAP: %dKB used, occupying %dKB in memory\n" Printf
	
	MmPoolBytesUsed@ 1024 / " POOL: %dKB used\n" Printf
	IOCachePagesUsed@ PAGESHIFT << 1024 / " CACH: %dKB used\n" Printf
	MmAnonymousPageCount@ PAGESHIFT << 1024 / " ANON: %dKB used\n" Printf
	MmEvictablePageCount@ PAGESHIFT << 1024 / " EVIC: %dKB evictable\n" Printf

	MmPeakWorkingSetSize@ PAGESHIFT << 1024 /
	MmTotalWorkingSetSize@ PAGESHIFT << 1024 / " WSET: %dKB resident in process working sets (%dKB peak)\n" Printf
end