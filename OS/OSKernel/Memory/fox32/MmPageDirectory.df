//
// Implements page directory management for the fox32 architecture.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OSStatus.h"

#include "../MmInternal.h"

fn MiPageDirectoryDestroy { process -- }
	fnsection "PAGE$text"

	auto pagemap
	process@ KeProcess_PageDirectory + @ pagemap!

	auto pfdbe
	pagemap@ PAGESHIFT >> MiPageFrameEntry_SIZEOF * MiPageFrameDatabase@ + pfdbe!

	pfdbe@ MiAnonymousPageDelete

	pfdbe@ MmEvictablePageDereference drop

	auto quotablock
	process@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	1 // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargeWS
end

fn MiPageDirectoryAlloc { process -- ok }
	fnsection "PAGE$text"

	auto quotablock
	process@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	1 // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeWS ok!

	if (ok@)
		return
	end

	auto pdir
	auto pfdbe
	process@ KeProcess_PageDirectory + // pte
	ZEROMUST // priority
	MiAnonymousPageAlloc ok! pdir! pfdbe!

	if (ok@)
		1 // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeWS

		return
	end

	process@ pfdbe@ MiPageFrameEntryAnonymous_Process + !

	pfdbe@ // pfdbe
	0 // process
	MmEvictablePageModify

	PAGESHIFT pdir <<=

	pdir@ MiPageDirectoryCopy

	pdir@ process@ KeProcess_PageDirectory + !
end

fn MiPageDirectoryCopy { pdir -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto qp
	pdir@ MiMapQuickPage qp!

	qp@ 2048 + // dest
	PAGEDIRECTORY 2048 + // src
	2048 // size
	memcpy

	// create recursive mapping of page tables

	pdir@ PTE_V | PTE_W | qp@ PAGETABLE 22 >> 2 << + !

	qp@ MiUnmapQuickPage

	ipl@ KeIPLLower
end

fn MiPageDirectoryReference { pri process -- ok }
	if (DEBUGCHECKS)
		if (KeThreadCurrent@ KeThread_IgnoreKill + @ ~~)
			"MiPageDirectoryReference: thread could be killed\n" KeCrash
		end
	end

	0 ok!

	auto pfdbe

	auto ipl
	IPLDPC KeIPLRaise ipl!

	0 // process
	pri@ CANBLOCK | // priority
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	if (process@ KeProcess_PageDirectory + @ PTE_INSWAP &)
		auto pt

		pri@ // priority
		process@ KeProcess_PageDirectory + // pte
		process@ KeProcess_PageDirectory + @ PAGESHIFT >> // pno
		ipl@ // ipl
		MiAnonymousSwapIn ok! pt! pfdbe!

		if (ok@)
			return
		end

		pt@ PAGESHIFT << process@ KeProcess_PageDirectory + !

		IPLDPC KeIPLRaise ipl!

		auto qp
		pt@ PAGESHIFT << MiMapQuickPage qp!

		// re-create recursive mapping of page tables since the physical
		// address of the page directory has probably changed.

		pt@ PAGESHIFT << PTE_V | PTE_W |
		qp@ PAGETABLE 22 >> 2 << + !

		process@ pfdbe@ MiPageFrameEntryAnonymous_Process + !

		qp@ MiUnmapQuickPage

		ipl@ KeIPLLower
	end else
		process@ KeProcess_PageDirectory + @ PAGESHIFT >> MiPageFrameEntry_SIZEOF * MiPageFrameDatabase@ + pfdbe!
		
		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		pfdbe@ // pfdbe
		0 // process
		MmEvictablePageModify
	end
end

fn MiPageDirectoryDereference { process -- }
	process@ KeProcess_PageDirectory + @ PAGESHIFT >> MiPageFrameEntry_SIZEOF * MiPageFrameDatabase@ +
	MmEvictablePageDereference drop
end