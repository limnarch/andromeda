//
// Implements the modified page writer thread.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn MmModifiedPageWriter { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	KeThreadCurrent@ KeThreadIgnoreKill drop

	IOSwapFileAwaitCreation

	auto mdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!

	auto mdlpos
	auto pagecount

	// the page writer thread. writes out modified pages and slaps them on the
	// evictable list. does this when it is asked to and also every 30 seconds

	while (1)
		auto ok
		auto waitok

		KERNELMODE // waitmode
		0 // alertable
		30000 // timeout
		MmModifiedPageEvent // object
		KeThreadWaitForObject waitok!

		if (DEBUGCHECKS)
			if (waitok@ 0 s<)
				if (waitok@ STATUS_WAIT_TIMEOUT ~=)
					waitok@ "MmModifiedPageWriter: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		mdl@ MmMDLHeader_SIZEOF + mdlpos!
		0 pagecount!

		auto modcount
		MmModifiedPageCount@ modcount!

		while (1)
			if (modcount@ ~~)
				if (waitok@ 0 ==)
					100 // interval
					KERNELMODE // waitmode
					0 // alertable
					KeThreadSleep drop
				end

				break
			end

			auto ipl
			IPLDPC KeIPLRaise ipl!

			auto pfdbe
			MmModifiedPageListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmEvictablePageReference drop

				if (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ==)
					if (DEBUGCHECKS)
						if (pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + @ MMSWAPPAGE_NONE ~=)
							"MmModifiedPageWriter: swap page exists\n" KeCrash
						end
					end

					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

					ipl@ KeIPLLower

					pfdbe@ mdlpos@!
					4 mdlpos +=
					-1 mdlpos@!

					1 pagecount +=

					if (pagecount@ IOTRANSFERMAX PAGESHIFT >> ==)
						// maximum transfer has been clustered, do it

						pagecount@ // pagecount
						mdl@ // mdl
						IOSwapFileWriteMDL ok!

						if (ok@)
							ok@ "MmModifiedPageWriter: swapout failed (%i)\n" KeCrash
						end

						0 pagecount!
						mdl@ MmMDLHeader_SIZEOF + mdlpos!
					end

					IPLDPC KeIPLRaise ipl!
				end elseif (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_FILE ==)
					auto cacheblock
					pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

					cacheblock@ // cacheblock
					IOCacheInfoBlockTryLockShared ok!

					if (ok@)
						// locked successfully

						ipl@ KeIPLLower

						// write out page

						IOKFLAG_SWAPOUT // kflags
						pfdbe@ // pfdbe
						IOCachePageWrite drop

						cacheblock@ // cacheblock
						IOCacheInfoBlockUnlock

						IPLDPC KeIPLRaise ipl!
					end

					pfdbe@ MmEvictablePageDereference drop
				end

				if (modcount@)
					1 modcount -=
				end
			end else
				0 modcount!
			end

			ipl@ KeIPLLower
		end

		if (pagecount@)
			pagecount@ // pagecount
			mdl@ // mdl
			IOSwapFileWriteMDL ok!

			if (ok@)
				ok@ "MmModifiedPageWriter: swapout failed (%i)\n" KeCrash
			end

			0 pagecount!
			mdl@ MmMDLHeader_SIZEOF + mdlpos!
		end
	end
end

fn MmFlushModifiedPages { -- }
	// artifically signal the dirty page event to sweep all the dirty
	// pages to disk. returns asynchronously, up to the caller to query the
	// dirty page count and figure out when they've all been written.

	0 // priboost
	MmModifiedPageEvent // event
	KeEventSignal
end