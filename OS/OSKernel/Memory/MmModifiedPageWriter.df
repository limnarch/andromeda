//
// Implements the modified page writer thread.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Transfer.h"

#include "<ll>/OSDLL/OS.h"

const MPWFILETRANSFERS 8

struct IOTransferTable
	KeEvent_SIZEOF Event
endstruct

struct IOAnonTransferTable
	IOTransferTable_SIZEOF Header
	(IOSWAPFILEMAXPRI 4 *) FreeListHeads
endstruct

struct IOFileTransferTable
	IOTransferTable_SIZEOF Header
	4 FreeListHead
endstruct

var MmTransfersAvailableOrInFlight 0
public MmTransfersAvailableOrInFlight

buffer MmMPWFileTransfers (IOFileTransferTable_SIZEOF IOTransfer_SIZEOF MPWFILETRANSFERS * +)
buffer MmMPWAnonTransfers IOAnonTransferTable_SIZEOF

fn IOTransferTableInitialize { transfertable -- }
	0 // signaled
	OSEVENT_SYNCH // type
	"IOTransferAvailableEvent" // name
	transfertable@ IOTransferTable_Event + // event
	KeEventInitialize
end

fn IOTransferComplete { transfer -- }
	// complete a transfer by putting it on the free list and signaling its
	// event.

	auto ttable
	transfer@ IOTransfer_TransferTable + @ ttable!

	auto rs

	if (transfer@ IOTransfer_SwapFile + @)
		// anon transfer, place on priority list

		auto pri
		transfer@ IOTransfer_SwapFile + @ IOSwapFileGetPriority pri!

		HALCPUInterruptDisable rs!
		ttable@ IOAnonTransferTable_FreeListHeads + pri@ 2 << + @ transfer@ IOTransfer_Next + !
		transfer@ ttable@ IOAnonTransferTable_FreeListHeads + pri@ 2 << + !
		rs@ HALCPUInterruptRestore
	end else
		// file transfer, place on free list

		HALCPUInterruptDisable rs!
		ttable@ IOFileTransferTable_FreeListHead + @ transfer@ IOTransfer_Next + !
		transfer@ ttable@ IOFileTransferTable_FreeListHead + !
		rs@ HALCPUInterruptRestore
	end

	0 // priboost
	ttable@ IOTransferTable_Event + // event
	KeEventSignal
end

fn MmMPWAnonTransferInitialize { swapfile transfer -- }
	swapfile@ transfer@ IOTransfer_SwapFile + !
	MmMPWAnonTransfers transfer@ IOTransfer_TransferTable + !
	0 transfer@ IOTransfer_Next + !
end

fn MmMPWGetAnonTransfer { wait ipl -- transfer }
	auto h
	MmMPWAnonTransfers IOAnonTransferTable_FreeListHeads + h!

	auto p
	0 p!

	0 transfer!

	while (p@ IOSWAPFILEMAXPRI <)
		if (h@@)
			h@@ transfer!
			transfer@ IOTransfer_Next + @ h@!
			return
		end

		1 p +=
		4 h +=
	end

	if (wait@)
		ipl@ KeIPLLower

		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		MmMPWAnonTransfers IOTransferTable_Event + // object
		KeThreadWaitForObject drop
	end
end

fn MmMPWGetFileTransfer { wait ipl -- transfer }
	MmMPWFileTransfers IOFileTransferTable_FreeListHead + @ transfer!

	if (transfer@)
		transfer@ IOTransfer_Next + @ MmMPWFileTransfers IOFileTransferTable_FreeListHead + !
		return
	end

	if (wait@)
		ipl@ KeIPLLower

		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		MmMPWFileTransfers IOTransferTable_Event + // object
		KeThreadWaitForObject drop
	end
end

fn MmModifiedPageWriter { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	1 KeThreadCurrent@ PsThread_MemoryPrivilegedCount + !

	KeThreadCurrent@ KeThreadIgnoreKill drop

	auto anontransfers
	MmMPWAnonTransfers anontransfers!

	auto filetransfers
	MmMPWFileTransfers filetransfers!

	anontransfers@ // transfertable
	IOTransferTableInitialize

	filetransfers@ // transfertable
	IOTransferTableInitialize

	auto i
	0 i!

	auto transfer
	filetransfers@ IOFileTransferTable_SIZEOF + transfer!

	while (i@ MPWFILETRANSFERS <)
		filetransfers@ transfer@ IOTransfer_TransferTable + !

		0 transfer@ IOTransfer_SwapFile + !

		filetransfers@ IOFileTransferTable_FreeListHead + @ transfer@ IOTransfer_Next + !
		transfer@ filetransfers@ IOFileTransferTable_FreeListHead + !

		IOTransfer_SIZEOF transfer +=
		1 i +=
	end

	auto mdlpos

	0 transfer!

	// the page writer thread. writes out modified pages and slaps them on the
	// evictable list. does this when memory is low or there are too many
	// modified pages.

	while (1)
		auto ok
		auto waitok

		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		MmModifiedPageEvent // object
		KeThreadWaitForObject waitok!

		if (DEBUGCHECKS)
			if (waitok@ z<)
				if (waitok@ STATUS_WAIT_TIMEOUT ~=)
					waitok@ "MmModifiedPageWriter: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		0 pagecount!

		auto modcount
		MmModifiedPageCount@ modcount!

		while (modcount@)
			auto ipl
			IPLDPC KeIPLRaise ipl!

			auto pfdbe
			MmModifiedPageListHead@ pfdbe!

			if (pfdbe@ ~~)
				// no modified pages to write.

				ipl@ KeIPLLower

				0 modcount!

				break
			end

			// if this is an anonymous page, try to get an anon transfer.
			// if there are none, seek to the next file page, and try to get
			// a file transfer. if there are none, wait for an anon transfer
			// to become available and then loop.
			// if its a file page, do the opposite of the above.
			//
			// in this way, we try to make page-out as efficient as possible
			// by saturating output with one or the other type.

			if (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ==)
				0 // wait
				ipl@ // ipl
				MmMPWGetAnonTransfer transfer!

				if (transfer@ ~~)
					if (MmModifiedFilePageCount@) // there must be a file page to find
						0 // wait
						ipl@ // ipl
						MmMPWGetFileTransfer transfer!

						if (transfer@)
							while (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_FILE ~=)
								pfdbe@ MmPageFrameEntryEvictable_Next + @ pfdbe!
							end
						end
					end
				end
			end else
				0 // wait
				ipl@ // ipl
				MmMPWGetFileTransfer transfer!

				if (transfer@ ~~)
					if (MmModifiedPageCount@ MmModifiedFilePageCount@ -) // there must be an anon page to find
						0 // wait
						ipl@ // ipl
						MmMPWGetAnonTransfer transfer!

						if (transfer@)
							while (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ~=)
								pfdbe@ MmPageFrameEntryEvictable_Next + @ pfdbe!
							end
						end
					end
				end
			end

			if (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ==)
				transfer@ // transfer
				pfdbe@ // pfdbe
				MmMPWClusterAnonymousPages
			end else
				transfer@ // transfer
				pfdbe@ // pfdbe
				MmMPWClusterFilePages
			end

			pfdbe@ MmEvictablePageReference drop

			if (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ==)
				if (DEBUGCHECKS)
					if (pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ PTE_INSWAP &)
						"MmModifiedPageWriter: swap page exists\n" KeCrash
					end
				end

				pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
				pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

				ipl@ KeIPLLower

				pfdbe@ mdlpos@!
				4 mdlpos +=
				-1 mdlpos@!

				1 pagecount +=

				if (pagecount@ clustermax@ >=)
					// maximum transfer has been clustered, do it

					pagecount@ // pagecount
					transfer@ // mdl
					IOSwapFileWriteMDL drop

					0 pagecount!
					0 transfer!
				end

				IPLDPC KeIPLRaise ipl!
			end else
				ftransfer@ // transfer
				IOKFLAG_SWAPOUT // kflags
				pfdbe@ // pfdbe
				IOCachePageWrite drop

				0 ftransfer!

				pfdbe@ MmEvictablePageDereference drop
			end

			if (modcount@)
				1 modcount -=
			end

			ipl@ KeIPLLower
		end

		if (pagecount@)
			pagecount@ // pagecount
			transfer@ // mdl
			IOSwapFileWriteMDL drop

			0 pagecount!
			0 transfer!
		end
	end
end

fn MmMPWClusterAnonymousPages { transfer pfdbe -- }
	// try to allocate a contiguous cluster on the swapfile.

	
end

fn MmMPWClusterFilePages { transfer pfdbe -- }

end