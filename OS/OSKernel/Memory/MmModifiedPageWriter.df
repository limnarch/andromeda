//
// Implements the modified page writer thread.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Transfer.h"

#include "<ll>/OSDLL/OS.h"

const MPWTRANSFERCOUNT 4

struct IOTransferTable
	KeEvent_SIZEOF Event
	4 FreeListHead

	(IOTransfer_SIZEOF MPWTRANSFERCOUNT *) Transfers
endstruct

buffer MmMPWFileTransfers IOTransferTable_SIZEOF
buffer MmMPWAnonTransfers IOTransferTable_SIZEOF

fn IOTransferTableInitialize { transfertable -- }
	0 // signaled
	OSEVENT_SYNCH // type
	"IOTransferAvailableEvent" // name
	transfertable@ IOTransferTable_Event + // event
	KeEventInitialize

	auto i
	0 i!

	auto transfer
	transfertable@ IOTransferTable_Transfers + transfer!

	while (i@ MPWTRANSFERCOUNT <)
		transfertable@ transfer@ IOTransfer_TransferTable + !

		transfertable@ IOTransferTable_FreeListHead + @ transfer@ IOTransfer_FileOrNext + !
		transfer@ transfertable@ IOTransferTable_FreeListHead + !

		IOTransfer_SIZEOF transfer +=
		1 i +=
	end
end

fn IOTransferComplete { transfer -- }
	auto ttable
	transfer@ IOTransfer_TransferTable + @ ttable!

	ttable@ IOTransferTable_FreeListHead + @ transfer@ IOTransfer_FileOrNext + !
	transfer@ ttable@ IOTransferTable_FreeListHead + !

	0 // priboost
	ttable@ IOTransferTable_Event + // event
	KeEventSignal
end

fn MmMPWWaitForTransfer { transfertable -- }
	// try to find an available transfer to use.
	// if none are available, wait for one to complete and use that.

	auto transfer
	transfertable@ IOTransferTable_FreeListHead + @ transfer!

	while (transfer@ ~~)
		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		transfertable@ IOTransferTable_Event + // object
		KeThreadWaitForObject drop

		transfertable@ IOTransferTable_FreeListHead + @ transfer!
	end
end

fn MmModifiedPageWriter { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	KeThreadCurrent@ KeThreadIgnoreKill drop

	IOSwapFileAwaitCreation

	auto anontransfers
	MmMPWAnonTransfers anontransfers!

	auto filetransfers
	MmMPWFileTransfers filetransfers!

	anontransfers@ // transfertable
	IOTransferTableInitialize

	filetransfers@ // transfertable
	IOTransferTableInitialize

	auto mdlpos
	auto pagecount

	auto transfer
	0 transfer!

	auto ftransfer
	0 ftransfer!

	// the page writer thread. writes out modified pages and slaps them on the
	// evictable list. does this when it is asked to and also every 30 seconds

	while (1)
		auto ok
		auto waitok

		KERNELMODE // waitmode
		0 // alertable
		30000 // timeout
		MmModifiedPageEvent // object
		KeThreadWaitForObject waitok!

		if (DEBUGCHECKS)
			if (waitok@ 0 s<)
				if (waitok@ STATUS_WAIT_TIMEOUT ~=)
					waitok@ "MmModifiedPageWriter: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		0 pagecount!

		auto modcount
		MmModifiedPageCount@ modcount!

		while (1)
			if (modcount@ ~~)
				if (waitok@ 0 ==)
					100 // interval
					KERNELMODE // waitmode
					0 // alertable
					KeThreadSleep drop
				end

				break
			end

			auto ipl
			IPLDPC KeIPLRaise ipl!

			auto pfdbe
			MmModifiedPageListHead@ pfdbe!

			if (pfdbe@)
				if (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ==)
					if (transfer@ ~~)
						anontransfers@ IOTransferTable_FreeListHead + @ transfer!

						if (transfer@ ~~)
							ipl@ KeIPLLower

							anontransfers@ // transfertable
							MmMPWWaitForTransfer

							continue
						end

						transfer@ IOTransfer_FileOrNext + @ anontransfers@ IOTransferTable_FreeListHead + !
						transfer@ MmMDLHeader_SIZEOF + mdlpos!
					end
				end else
					if (ftransfer@ ~~)
						filetransfers@ IOTransferTable_FreeListHead + @ ftransfer!

						if (ftransfer@ ~~)
							ipl@ KeIPLLower

							filetransfers@ // transfertable
							MmMPWWaitForTransfer

							continue
						end

						ftransfer@ IOTransfer_FileOrNext + @ filetransfers@ IOTransferTable_FreeListHead + !
					end
				end

				pfdbe@ MmEvictablePageReference drop

				if (pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ==)
					if (DEBUGCHECKS)
						if (pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ MMSWAPPAGE_NONE ~=)
							"MmModifiedPageWriter: swap page exists\n" KeCrash
						end
					end

					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

					ipl@ KeIPLLower

					pfdbe@ mdlpos@!
					4 mdlpos +=
					-1 mdlpos@!

					1 pagecount +=

					if (pagecount@ IOTRANSFERMAX PAGESHIFT >> ==)
						// maximum transfer has been clustered, do it

						pagecount@ // pagecount
						transfer@ // mdl
						IOSwapFileWriteMDL ok!

						if (ok@)
							ok@ "MmModifiedPageWriter: swapout failed (%i)\n" KeCrash
						end

						0 pagecount!
						0 transfer!
					end

					IPLDPC KeIPLRaise ipl!
				end else
					ftransfer@ // transfer
					IOKFLAG_SWAPOUT // kflags
					pfdbe@ // pfdbe
					IOCachePageWrite drop

					0 ftransfer!

					pfdbe@ MmEvictablePageDereference drop
				end

				if (modcount@)
					1 modcount -=
				end
			end else
				0 modcount!
			end

			ipl@ KeIPLLower
		end

		if (pagecount@)
			pagecount@ // pagecount
			transfer@ // mdl
			IOSwapFileWriteMDL ok!

			if (ok@)
				ok@ "MmModifiedPageWriter: swapout failed (%i)\n" KeCrash
			end

			0 pagecount!
			0 transfer!
		end
	end
end

fn MmFlushModifiedPages { -- }
	// artifically signal the dirty page event to sweep all the dirty
	// pages to disk. returns asynchronously, up to the caller to query the
	// dirty page count and figure out when they've all been written.

	0 // priboost
	MmModifiedPageEvent // event
	KeEventSignal
end