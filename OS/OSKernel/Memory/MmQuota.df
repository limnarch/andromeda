//
// Implements job quota management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn MmQuotaBlockCreate { wsmax vmmax heapmax -- quotablock ok }
	MmQuotaBlock_SIZEOF // bytes
	'Quot' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! quotablock!

	if (ok@)
		return
	end

	wsmax@ vmmax@ heapmax@ quotablock@ MmQuotaBlockInitialize ok!
end

fn MmQuotaBlockFork { quotablock -- newquotablock ok }
	MmQuotaBlock_SIZEOF // bytes
	'Quot' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! newquotablock!

	if (ok@)
		return
	end

	quotablock@ MmQuotaBlock_WorkingSetMax + @ // wsmax
	quotablock@ MmQuotaBlock_VMMax + @ // vmmax
	quotablock@ MmQuotaBlock_HeapMax + @ // heapmax
	newquotablock@ // quotablock
	MmQuotaBlockInitialize ok!
end

fn MmQuotaBlockInitialize { wsmax vmmax heapmax quotablock -- ok }
	0 ok!

	1 quotablock@ MmQuotaBlock_References + !

	0 quotablock@ MmQuotaBlock_HeapUsed + !
	heapmax@ quotablock@ MmQuotaBlock_HeapMax + !

	0 quotablock@ MmQuotaBlock_VMUsed + !
	vmmax@ quotablock@ MmQuotaBlock_VMMax + !

	0 quotablock@ MmQuotaBlock_WorkingSetUsed + !
	wsmax@ quotablock@ MmQuotaBlock_WorkingSetMax + !
end

fn MmQuotaBlockReference { quotablock -- }
	auto rs
	HALCPUInterruptDisable rs!

	if (DEBUGCHECKS)
		if (quotablock@ MmQuotaBlock_References + @ 0xFFFFFFFF ==)
			"MmQuotaBlockReference: overflow!\n" KeCrash
		end
	end

	1 quotablock@ MmQuotaBlock_References + +=

	rs@ HALCPUInterruptRestore
end

fn MmQuotaBlockDereference { quotablock -- }
	auto rs
	HALCPUInterruptDisable rs!

	auto oldcount
	quotablock@ MmQuotaBlock_References + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmQuotaBlockDereference: references<0\n" KeCrash
		end
	end

	oldcount@ 1 - quotablock@ MmQuotaBlock_References + !

	rs@ HALCPUInterruptRestore

	if (oldcount@ 1 ==)
		// got dereferenced to 0, delete

		quotablock@ MmFree
	end
end

fn MmQuotaChargeBuffer { buffersize -- ok }
	// helper function for charging heap quota for query syscalls

	buffersize@ MmChargeBytesGet // charge
	KeProcessCurrent PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockCharge ok!
end

fn MmQuotaUnchargeBuffer { buffersize -- }
	buffersize@ MmChargeBytesGet // charge
	KeProcessCurrent PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUncharge
end

fn MmQuotaBlockCharge { charge quotablock -- ok }
	if (charge@ 0 s<)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	0 ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto commitlimit
	MmNonpageableCommitLimit@ commitlimit!

	auto commitused
	MmNonpageableCommitUsage@ commitused!

	if (commitused@ charge@ PAGESHIFT >> + commitlimit@ >)
		ipl@ KeIPLLower

		STATUS_NONPAGE_COMMIT_EXCEEDED ok!

		return
	end

	auto heapmax
	quotablock@ MmQuotaBlock_HeapMax + @ heapmax!

	auto oldcharge
	quotablock@ MmQuotaBlock_HeapUsed + @ oldcharge!

	if (oldcharge@ charge@ + heapmax@ >)
		ipl@ KeIPLLower

		STATUS_QUOTA_EXCEEDED ok!

		return
	end

	oldcharge@ charge@ + quotablock@ MmQuotaBlock_HeapUsed + !
	commitused@ charge@ + MmNonpageableCommitUsage!

	ipl@ KeIPLLower
end

fn MmQuotaBlockUncharge { charge quotablock -- }
	auto rs
	HALCPUInterruptDisable rs!

	auto oldcharge
	quotablock@ MmQuotaBlock_HeapUsed + @ oldcharge!

	auto commitused
	MmNonpageableCommitUsage@ commitused!

	if (DEBUGCHECKS)
		if (charge@ oldcharge@ >)
			charge@
			oldcharge@
			"MmQuotaBlockUncharge: attempt to uncharge more than was charged (oldcharge=%d charge=%d)\n" KeCrash
		end

		if (charge@ PAGESHIFT >> commitused@ >)
			commitused@
			charge@ PAGESHIFT >>
			"MmQuotaBlockUncharge: attempt to uncharge more commit than was charged %d > %d\n" KeCrash
		end
	end

	oldcharge@ charge@ - quotablock@ MmQuotaBlock_HeapUsed + !
	commitused@ charge@ - MmNonpageableCommitUsage!

	rs@ HALCPUInterruptRestore
end

fn MmQuotaBlockChargeVM { charge quotablock -- ok }
	if (DEBUGCHECKS)
		if (charge@ PAGEOFFSETMASK &)
			"MmQuotaBlockChargeVM: charge isn't aligned to page size\n" KeCrash
		end
	end

	if (charge@ 0 s<)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	PAGESHIFT charge >>=

	0 ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto vmmax
	quotablock@ MmQuotaBlock_VMMax + @ vmmax!

	auto oldcharge
	quotablock@ MmQuotaBlock_VMUsed + @ oldcharge!

	if (oldcharge@ charge@ PAGESHIFT << + vmmax@ >)
		ipl@ KeIPLLower

		STATUS_VM_QUOTA_EXCEEDED ok!

		return
	end

	oldcharge@ charge@ PAGESHIFT << + quotablock@ MmQuotaBlock_VMUsed + !

	auto commitlimit
	MmCommitLimit@ commitlimit!

	auto commitused
	MmCommitUsage@ commitused!

	while (commitused@ charge@ + commitlimit@ >)
		charge@ IOSwapFileRequestExpansion ok!

		if (ok@)
			// uncharge quota
			charge@ PAGESHIFT << quotablock@ MmQuotaBlock_VMUsed + -=

			ipl@ KeIPLLower

			return
		end

		MmCommitLimit@ commitlimit!
		MmCommitUsage@ commitused!
	end

	commitused@ charge@ + MmCommitUsage!

	ipl@ KeIPLLower
end

fn MmQuotaBlockUnchargeVM { charge quotablock -- }
	if (DEBUGCHECKS)
		if (charge@ PAGEOFFSETMASK &)
			"MmQuotaBlockUnchargeVM: charge isn't aligned to page size\n" KeCrash
		end
	end

	auto rs
	HALCPUInterruptDisable rs!

	auto oldcharge
	quotablock@ MmQuotaBlock_VMUsed + @ oldcharge!

	auto commitused
	MmCommitUsage@ commitused!

	if (DEBUGCHECKS)
		if (charge@ oldcharge@ >)
			"MmQuotaBlockUnchargeVM: attempt to uncharge more than was charged\n" KeCrash
		end

		if (charge@ PAGESHIFT >> commitused@ >)
			commitused@
			charge@ PAGESHIFT >>
			"MmQuotaBlockUnchargeVM: attempt to uncharge more commit than was charged %d > %d\n" KeCrash
		end
	end

	oldcharge@ charge@ - quotablock@ MmQuotaBlock_VMUsed + !
	commitused@ charge@ PAGESHIFT >> - MmCommitUsage!

	rs@ HALCPUInterruptRestore
end

fn MmQuotaBlockChargeWorkingSet { charge quotablock -- ok }
	if (charge@ 0 s<)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	0 ok!

	auto rs
	HALCPUInterruptDisable rs!

	auto wsmax
	quotablock@ MmQuotaBlock_WorkingSetMax + @ wsmax!

	auto oldcharge
	quotablock@ MmQuotaBlock_WorkingSetUsed + @ oldcharge!

	if (oldcharge@ charge@ + wsmax@ >)
		rs@ HALCPUInterruptRestore

		STATUS_WS_QUOTA_EXCEEDED ok!

		return
	end

	oldcharge@ charge@ + quotablock@ MmQuotaBlock_WorkingSetUsed + !

	rs@ HALCPUInterruptRestore
end

fn MmQuotaBlockUnchargeWorkingSet { charge quotablock -- }
	auto rs
	HALCPUInterruptDisable rs!

	auto oldcharge
	quotablock@ MmQuotaBlock_WorkingSetUsed + @ oldcharge!

	if (DEBUGCHECKS)
		if (charge@ oldcharge@ >)
			"MmQuotaBlockUnchargeWorkingSet: attempt to uncharge more than was charged\n" KeCrash
		end
	end

	oldcharge@ charge@ - quotablock@ MmQuotaBlock_WorkingSetUsed + !

	rs@ HALCPUInterruptRestore
end

fn MmSetQuota { quota quotablock -- }
	// set new limits on the quotablock.

	quota@ OSQuota_Heap + @ quotablock@ MmQuotaBlock_HeapMax + !
	quota@ OSQuota_VirtualMemory + @ quotablock@ MmQuotaBlock_VMMax + !
	quota@ OSQuota_WorkingSet + @ quotablock@ MmQuotaBlock_WorkingSetMax + !
end

fn MmQuotaQuery { query quotablock -- }
	query@ // ptr
	OSQuotaInformation_SIZEOF // size
	0 // word
	memset

	quotablock@ MmQuotaBlock_HeapUsed + @ query@ OSQuotaInformation_HeapUsed + !
	quotablock@ MmQuotaBlock_HeapMax + @ query@ OSQuotaInformation_HeapMaximum + !

	quotablock@ MmQuotaBlock_VMUsed + @ query@ OSQuotaInformation_VirtualMemoryUsed + !
	quotablock@ MmQuotaBlock_VMMax + @ query@ OSQuotaInformation_VirtualMemoryMaximum + !

	quotablock@ MmQuotaBlock_WorkingSetUsed + @ query@ OSQuotaInformation_WorkingSetUsed + !
	quotablock@ MmQuotaBlock_WorkingSetMax + @ query@ OSQuotaInformation_WorkingSetMaximum + !
end

fn MmQuotaBlockPrint { quotablock -- }
	quotablock@ MmQuotaBlock_HeapMax + @
	quotablock@ MmQuotaBlock_HeapUsed + @ " HEAP = %d/%i bytes\n" Printf

	quotablock@ MmQuotaBlock_VMMax + @
	quotablock@ MmQuotaBlock_VMUsed + @ " VM   = %d/%i bytes\n" Printf

	quotablock@ MmQuotaBlock_WorkingSetMax + @
	quotablock@ MmQuotaBlock_WorkingSetUsed + @ " WSET = %d/%i pages\n" Printf

	quotablock@ MmQuotaBlock_References + @ " REFS = %d\n" Printf
end