//
// Implements the system page fault handler.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALInterrupt.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

var MmPageFaultCount 0
public MmPageFaultCount

fn MmPageFault { writing badaddr trapframe -- handled }
	if (DEBUGCHECKS)
		if (KeThreadCurrent@ KeThread_Priority + @ PRIORITY_IDLE ==)
			"MmPageFault: idle thread took a page fault\n" KeCrash
		end
	end

	if (KeIPLCurrentGet IPLDPC >=)
		0 handled!
		return
	end

	auto signal
	0 signal!

	auto process
	KeProcessCurrent process!

	auto kernelmapping
	0 kernelmapping!

	if (badaddr@ PAGESIZE <)
		OSSIGNAL_SEGV signal!
	end else
		if (trapframe@ HALCPUIsUserTrapFrame)
			if (badaddr@ MMHIGHESTUSERADDRESS >)
				OSSIGNAL_SEGV signal!
			end
		end elseif (badaddr@ MMLOWESTSYSTEMADDRESS >=)
			PsSystemProcess@ process!
			1 kernelmapping!
		end
	end

	if (signal@ ~~)
		// too complex to deal with being murdered here
		KeThreadCurrent@ KeThreadIgnoreKill drop

		auto ipl
		IPLAPC KeIPLRaise ipl!

		auto refaults
		0 refaults!

		STATUS_REFAULT signal!

		if (kernelmapping@ ~~)
			process@ MmVADListLock drop
		end

		while (signal@ STATUS_REFAULT ==)
			if (refaults@ 10 >=)
				// throttle

				if (kernelmapping@ ~~)
					process@ MmVADListUnlock
				end

				ipl@ KeIPLLower

				50 // ms
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep drop

				IPLAPC KeIPLRaise ipl!

				if (kernelmapping@ ~~)
					process@ MmVADListLock drop
				end

				0 refaults!
			end

			1 refaults +=

			kernelmapping@ // kernelmapping
			writing@ // writing
			badaddr@ // vaddr
			MmSatisfyFault signal!
		end

		if (kernelmapping@ ~~)
			process@ MmVADListUnlock
		end

		ipl@ KeIPLLower

		KeThreadCurrent@ KeThreadAcceptKill drop
	end

	if (signal@ STATUS_FAULT_ERROR ==)
		// system error happened
		0 handled!
	end elseif (signal@)
		// generate signal or cause return from safecopy.
		1 handled!

		if (trapframe@ HALCPUIsUserTrapFrame)
			// user mode

			if (signal@ OSSIGNAL_KILL ==)
				OSSIGNAL_KILL // signal
				KeProcessCurrent // process
				KeProcessSignal drop
			end else
				signal@ // signal
				KeThreadCurrent@ // thread
				KeThreadSignal drop
			end
		end else
			// kernel mode

			auto abort
			KeThreadCurrent@ KeThread_SafeAccessAbort + @ abort!

			if (abort@ ~~)
				// happened at an unexpected time!
				0 handled!
			end else
				// thought this might happen.
				abort@ trapframe@ HALCPUTrapFrameAbort
			end
		end
	end else
		auto rs
		HALCPUInterruptDisable rs!
		1 MmPageFaultCount +=
		rs@ HALCPUInterruptRestore

		// handled successfully
		1 handled!
	end
end

fn MmThrottle { -- }
	if (IOSwapFileCount@ ~~)
		return
	end

	auto process
	KeProcessCurrent process!

	auto phdr
	process@ PsProcess_MmHeader + @ phdr!

	if (phdr@ MmProcessHeader_ModifiedPageCount + @ MMMODIFIEDPAGETHROTTLE >=)
		while (MmModifiedPageCount@ MmModifiedPageMaximum@ >=)
			// throttle the thread

			75 // ms
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep drop
		end

		0 phdr@ MmProcessHeader_ModifiedPageCount + !
	end
end

fn MmSatisfyFault { kernelmapping writing vaddr -- signal }
	0 signal!

	auto ok
	auto pteaddr
	auto phyaddr
	auto flags
	auto pfdbe
	auto wsleptr
	auto wsli
	auto ptpfdbe
	auto process
	auto rs

	if (kernelmapping@ ~~)
		KeProcessCurrent process!

		MmThrottle

		0 // pri
		vaddr@ // vaddr
		process@ // process
		MmPTEReference ok! pteaddr! ptpfdbe!

		if (ok@)
			if (ok@ -1 ==)
				// no page table
				0 ptpfdbe!
			end else
				// something else happened
				OSSIGNAL_KILL signal!
				return
			end
		end
	end else
		PsSystemProcess@ process!

		0 ptpfdbe!

		vaddr@ // vaddr
		process@ KeProcess_PageDirectory + @ // pagemap
		MmVirtualtoPTEAddress pteaddr!

		0 ok!
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (ok@ ~~)
		pteaddr@ // pteaddr
		MmPTEInterpret ok! flags! phyaddr!

		if (ok@ ~~)
			ipl@ KeIPLLower

			// valid

			if (flags@ PTE_W &)
				// no work to do

				if (ptpfdbe@)
					ptpfdbe@ process@ MmPTEDereference
				end

				return
			end elseif (writing@)
				pteaddr@ // pteaddr
				vaddr@ // vaddr
				process@ // process
				MmWriteFault signal!

				if (ptpfdbe@)
					ptpfdbe@ process@ MmPTEDereference
				end

				return
			end else
				// no work to do

				if (ptpfdbe@)
					ptpfdbe@ process@ MmPTEDereference
				end

				return
			end
		end else
			// hold PTE contents in flags temporarily
			pteaddr@@ flags!

			if (flags@ MmPTEIsZero)
				ipl@ KeIPLLower
			end else
				// private page. we need to do work here

				auto waited

				if (kernelmapping@)
					0 // process
					CANBLOCK TRYFOREVER | // priority
					MmPageWait ok! waited!
				end else
					0 // process
					CANBLOCK // priority
					MmPageWait ok! waited!
				end

				if (ok@)
					ipl@ KeIPLLower
					if (ptpfdbe@)
						ptpfdbe@ process@ MmPTEDereference
					end
					OSSIGNAL_KILL signal!
					return
				end

				if (waited@)
					ipl@ KeIPLLower
					if (ptpfdbe@)
						ptpfdbe@ process@ MmPTEDereference
					end
					STATUS_REFAULT signal!
					return
				end

				process@ // process
				MmWorkingSetEntryReserve ok! wsleptr! wsli!

				if (ok@)
					ipl@ KeIPLLower
					if (ptpfdbe@)
						ptpfdbe@ process@ MmPTEDereference
					end
					OSSIGNAL_KILL signal!
					return
				end

				if (kernelmapping@)
					PTE_KERNEL_DEMANDZERO // dzpte
					MMEVICTFLAG_PRIVATE // evictflag
					ptpfdbe@ // refpfdbe
					process@ // process
					TRYFOREVER // pri
					vaddr@ // vaddr
					pteaddr@ // pteaddr
					0 // localpteaddr
					MmAnonymousPageReferenceByPTE ok! phyaddr! pfdbe!
				end else
					-1 // dzpte
					MMEVICTFLAG_PRIVATE // evictflag
					ptpfdbe@ // refpfdbe
					process@ // process
					0 // pri
					vaddr@ // vaddr
					pteaddr@ // pteaddr
					-1 // localpteaddr
					MmAnonymousPageReferenceByPTE ok! phyaddr! pfdbe!
				end

				if (ok@)
					wsli@ // wsli
					wsleptr@ // wsleptr
					process@ // process
					MmWorkingSetEntryFree
				end else
					vaddr@ PAGENUMBERMASK & // vaddr
					wsleptr@ // wsleptr
					process@ // process
					MmWorkingSetEntryInsert
				end

				ipl@ KeIPLLower

				if (ptpfdbe@)
					ptpfdbe@ process@ MmPTEDereference
				end

				if (ok@)
					if (ok@ STATUS_REFAULT ~=)
						OSSIGNAL_KILL signal!
					end else
						STATUS_REFAULT signal!
					end
				end elseif (writing@)
					STATUS_REFAULT signal!
				end

				return
			end
		end
	end else
		ipl@ KeIPLLower
	end

	if (kernelmapping@)
		if (vaddr@ POOLSPACE < vaddr@ POOLSPACE POOLSIZE + >= ||)
			// this kernel fault lays outside POOLSPACE and the PTE
			// wasn't pre-built. this is an error.

			STATUS_FAULT_ERROR signal!
			return
		end

		// lock the VAD list now

		process@ MmVADListLock drop

		// double check that the PTE is still zero.

		if (pteaddr@@ MmPTEIsZero ~~)
			// it's not! oops!

			if (ptpfdbe@)
				ptpfdbe@ process@ MmPTEDereference
			end

			process@ MmVADListUnlock

			STATUS_REFAULT signal!

			return
		end
	end

	// we've determined the PTE is either zero or doesn't exist, so go forth
	// and either create a private page or locate a shared page depending on
	// what kind of mapping this is.

	vaddr@ // vaddr
	process@ // process
	MmNormalFault signal!

	if (ptpfdbe@)
		ptpfdbe@ process@ MmPTEDereference
	end

	if (kernelmapping@)
		process@ MmVADListUnlock
	end

	if (signal@ ~~)
		if (writing@)
			STATUS_REFAULT signal!
		end
	end
end

fn MmFaultParameters { vaddr process -- offset object vad ok }
	vaddr@ // vaddr
	0 // length
	0 // mustbestart
	process@ // processobject
	MmVADFind ok! vad!

	if (ok@)
		return
	end

	if (vaddr@ vad@ MmVAD_FurthestExtentMapped + @ >)
		vaddr@ PAGENUMBERMASK & vad@ MmVAD_FurthestExtentMapped + !
	end

	vad@ MmVAD_MappedObject + @ object!
	vaddr@ vad@ MmVAD_StartVA + @ - vad@ MmVAD_OffsetInSection + @ + offset!
end

fn MmNormalFault { vaddr process -- signal }
	0 signal!

	auto offset
	auto object
	auto vad
	auto ok
	auto flags
	auto pteaddr
	auto wsli
	auto wsleptr

	auto phyaddr
	auto asid
	process@ KeProcess_ASID + @ asid!

	auto kernelmapping
	process@ PsSystemProcess@ == kernelmapping!

	vaddr@ // vaddr
	process@ // process
	MmFaultParameters ok! vad! object! offset!

	if (ok@)
		OSSIGNAL_SEGV signal!
		return
	end

	if (vad@ MmVAD_PageProtection + @ ~~)
		// guard region
		OSSIGNAL_SEGV signal!
		return
	end

	vad@ MmVAD_Flags + @ flags!

	auto capturedfcb

	if (flags@ MMVADFLAG_FILE &)
		object@ IOFile_FileControlBlock + @ capturedfcb!

		if (capturedfcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
			vaddr@ // vaddr
			process@ // process
			object@ // fileobject
			offset@ // offset
			vad@ // vad
			MmSatisfyCharFault ok!

			if (ok@)
				OSSIGNAL_KILL signal!
			end

			return
		end
	end

	if (kernelmapping@ ~~)
		vaddr@ // vaddr
		process@ // process
		MmPTECreate ok! pteaddr!

		if (ok@)
			OSSIGNAL_KILL signal!
			return
		end
	end else
		vaddr@ // vaddr
		process@ KeProcess_PageDirectory + @ // pagemap
		MmVirtualtoPTEAddress pteaddr!
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	// ensure that referencing this page won't starve the system.

	auto waited

	if (kernelmapping@)
		process@ // process
		TRYFOREVER CANBLOCK | // priority
		MmPageWait ok! waited!
	end else
		process@ // process
		CANBLOCK // priority
		MmPageWait ok! waited!
	end

	if (ok@)
		ipl@ KeIPLLower

		if (kernelmapping@ ~~)
			1 // deref
			pteaddr@ // pteaddr
			vaddr@ // vaddr
			process@ // process
			MmPTEDelete drop
		end

		OSSIGNAL_KILL signal!
		return
	end

	if (waited@)
		ipl@ KeIPLLower

		if (kernelmapping@ ~~)
			1 // deref
			pteaddr@ // pteaddr
			vaddr@ // vaddr
			process@ // process
			MmPTEDelete drop
		end

		STATUS_REFAULT signal!
		return
	end

	process@ // process
	MmWorkingSetEntryReserve ok! wsleptr! wsli!

	if (ok@)
		ipl@ KeIPLLower

		if (kernelmapping@ ~~)
			1 // deref
			pteaddr@ // pteaddr
			vaddr@ // vaddr
			process@ // process
			MmPTEDelete drop
		end

		OSSIGNAL_KILL signal!
		return
	end

	if (object@ ~~)
		process@ // process
		vaddr@ // vaddr
		pteaddr@ // pteaddr
		MmSatisfyPrivatePageFault ok! phyaddr!
	end elseif (flags@ MMVADFLAG_FILE &)
		process@ // process
		capturedfcb@ // fcb
		offset@ // offset
		pteaddr@ // pteaddr
		MmSatisfyFileFault ok! phyaddr!
	end else
		vaddr@ // vaddr
		process@ // process
		object@ // section
		offset@ // offset
		pteaddr@ // pteaddr
		MmSatisfyAnonFault ok! phyaddr!
	end

	if (ok@)
		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetEntryFree
	end else
		phyaddr@ // phyaddr
		PTE_V // flags
		vaddr@ // vaddr
		pteaddr@ // pteaddr
		asid@ // asid
		MmPTEUpdate drop drop drop

		vaddr@ PAGENUMBERMASK & // vaddr
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetEntryInsert
	end

	ipl@ KeIPLLower

	if (ok@)
		if (kernelmapping@ ~~)
			1 // deref
			pteaddr@ // pteaddr
			vaddr@ // vaddr
			process@ // process
			MmPTEDelete drop
		end

		if (ok@ STATUS_REFAULT ==)
			STATUS_REFAULT signal!
		end else
			OSSIGNAL_KILL signal!
		end

		return
	end
end

fn MmSatisfyCharFault { vaddr process fileobject offset vad -- ok }
	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	auto getpagefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_GetPageAddress + @ getpagefunc!

	if (DEBUGCHECKS)
		if (getpagefunc@ ~~)
			"MmSatisfyCharFault: no GetPageAddress\n" KeCrash
		end
	end

	auto phyaddr
	offset@ // offset
	fcb@ // fcb
	getpagefunc@ IODispatchGetPageAddressFunction ok! phyaddr!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmSatisfyCharFault: failed to get page address (%i)\n" KeCrash
		end
	end

	auto flags
	PTE_V flags!

	if (vad@ MmVAD_PageProtection + @ PAGEACCESS_WRITE &)
		PTE_W flags |=
	end

	if (vad@ MmVAD_PageProtection + @ PAGEACCESS_NONCACHED &)
		PTE_NC flags |=
	end

	if (process@ PsSystemProcess@ ~=)
		auto pteaddr
		vaddr@ // vaddr
		process@ // process
		MmPTECreate ok! pteaddr!

		if (ok@)
			return
		end
	end else
		vaddr@ // vaddr
		process@ KeProcess_PageDirectory + @ // pagemap
		MmVirtualtoPTEAddress pteaddr!
	end

	phyaddr@ // phyaddr
	flags@ // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	process@ KeProcess_ASID + @ // asid
	MmPTEUpdate drop drop drop
end

fn MmSatisfyFileFault { process fcb offset pteaddr -- phyaddr ok }
	auto kflags
	IOKFLAG_PAGEAC kflags!

	if (process@ PsSystemProcess@ ==)
		IOKFLAG_SWAPIN kflags |=
	end

	pteaddr@ // localpteaddr
	0 // flags
	kflags@ // kflags
	offset@ PAGENUMBERMASK & // offset
	fcb@ // fcb
	IOCachePageRead ok! drop phyaddr!

	if (ok@)
		return
	end

	IDENTITYSPACEMASK phyaddr &=
end

fn MmSatisfyAnonFault { vaddr process section offset pteaddr -- phyaddr ok }
	auto pri
	0 pri!

	if (process@ PsSystemProcess@ ==)
		TRYFOREVER pri!
	end

	pteaddr@ // localpteaddr
	pri@ // pri
	offset@ // sectionoffset
	section@ // sectionobject
	MmSectionPageGet ok! drop phyaddr!

	if (ok@)
		return
	end
end

fn MmSatisfyPrivatePageFault { process vaddr pteaddr -- phyaddr ok }
	SWAPPTE_DEMANDZERO // dzpte
	MMEVICTFLAG_PRIVATE // evictflag
	0 // refpfdbe
	process@ // process
	0 // pri
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	0 // localpteaddr
	MmAnonymousPageReferenceByPTE ok! phyaddr! drop
end

fn MmWriteFault { pteaddr vaddr process -- signal }
	// COW, dirty fault, or segfault. lets find out which one

	0 signal!

	auto phyaddr

	auto cowpfdbe
	auto cowaddr
	0 cowaddr!

	auto vad
	0 vad!

	auto pageprot
	0 pageprot!

	if (process@ PsSystemProcess@ ==)
		process@ MmVADListLock drop
	end

	// first check if this is a private page in order to determine if we
	// need to look up the VAD or not. private PTEs are "sticky" so we can
	// determine this regardless of trimming, so we don't need to lock the
	// working set lock to check this. we want to do this first so we can
	// look up the VAD without locking the working set, which could cause
	// a deadlock since they're allocated in paged pool.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	pteaddr@ // pteaddr
	MmPTEInterpret ok! drop phyaddr!

	if (ok@)
		// invalid

		ipl@ KeIPLLower

		if (process@ PsSystemProcess@ ==)
			process@ MmVADListUnlock
		end

		STATUS_REFAULT signal!

		return
	end

	phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE &)
		-1 vad!
		PAGEACCESS_READ PAGEACCESS_WRITE | pageprot!
	end

	ipl@ KeIPLLower

	if (vad@ ~~)
		vaddr@ // vaddr
		process@ // process
		MmFaultParameters ok! vad! section! drop

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "MmWriteFault: failed to look up VAD (%i)\n" KeCrash
			end

			if (vad@ MmVAD_PageProtection + @ ~~)
				"MmWriteFault: VAD was guard region\n" KeCrash
			end
		end

		vad@ MmVAD_PageProtection + @ pageprot!
	end

	while (1)
		IPLDPC KeIPLRaise ipl!

		// re-check the PTE with the working set mutex held, since it may have
		// been trimmed since we decided it was valid. we know that it's the same
		// PTE if it's still valid, and hasn't been switched out with something
		// else, because the VAD list mutex is held during all such events.
		// the loss of this convenient assumption is one reason that it sounds
		// hard to allow multiple threads to take a page fault per process without
		// waiting for eachother.

		auto section
		auto ok
		auto pfdbe
		auto wsli
		auto wsleptr

		pteaddr@ // pteaddr
		MmPTEInterpret ok! drop phyaddr!

		if (ok@)
			// invalid

			STATUS_REFAULT signal!

			break
		end

		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		if (pageprot@ PAGEACCESS_WRITECOPY &)
			// COW, allocate a page frame and copy the old page frame into it.

			if (cowaddr@ ~~)
				auto waited

				if (process@ PsSystemProcess@ ==)
					process@ // process
					TRYFOREVER CANBLOCK | // priority
					MmPageWait ok! waited!
				end else
					process@ // process
					CANBLOCK // priority
					MmPageWait ok! waited!
				end

				if (waited@)
					STATUS_REFAULT signal!
					break
				end

				pteaddr@ // pte
				FREEFIRST // pri
				MmAnonymousPageGet ok! cowaddr! cowpfdbe!

				ipl@ KeIPLLower

				if (ok@)
					if (process@ PsSystemProcess@ ==)
						process@ MmVADListUnlock
					end

					OSSIGNAL_KILL signal!

					return
				end

				if (process@ PsSystemProcess@ ==)
					SWAPPTE_DEMANDZERO PTE_TLBHACK | cowpfdbe@ MmPageFrameEntryAnonymous_SwapPTE + |=
				end

				cowpfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED |
				cowpfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

				// we unlocked the working set mutex so we have to recheck
				// everything...

				continue
			end

			cowpfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE |
			cowpfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

			process@ cowpfdbe@ MmPageFrameEntryAnonymous_Process + !
			vaddr@ cowpfdbe@ MmPageFrameEntryAnonymous_VirtualAddress + !

			PAGESHIFT cowaddr <<=

			cowaddr@ IDENTITYSPACE | // dest
			phyaddr@ IDENTITYSPACE | // src
			PAGESIZE // size
			memcpy

			cowaddr@ // phyaddr
			PTE_V PTE_W | // flags
			vaddr@ // vaddr
			pteaddr@ // pteaddr
			process@ KeProcess_ASID + @ // asid
			MmPTEUpdate drop drop drop

			// we COW'd over top of the old page frame and no longer have it
			// mapped, so dereference it
			pfdbe@ MmEvictablePageDereference drop

			ipl@ KeIPLLower

			1 vad@ MmVAD_COWCount + +=

			if (process@ PsSystemProcess@ ==)
				process@ MmVADListUnlock
			end

			return
		end elseif (pageprot@ PAGEACCESS_WRITE & ~~)
			// privilege violation
			OSSIGNAL_SEGV signal!
			break
		end else
			pfdbe@ // pfdbe
			process@ // process
			MmEvictablePageModify

			phyaddr@ // phyaddr
			PTE_V PTE_W | // flags
			vaddr@ // vaddr
			pteaddr@ // pteaddr
			process@ KeProcess_ASID + @ // asid
			MmPTEUpdate drop drop drop

			break
		end

		if (DEBUGCHECKS)
			"MmWriteFault: unreachable\n" KeCrash
		end
	end

	if (cowaddr@)
		cowpfdbe@ MmEvictablePageDereference drop

		ipl@ // ipl
		cowpfdbe@ // pfdbe
		MmAnonymousPageDelete
	end else
		ipl@ KeIPLLower
	end

	if (process@ PsSystemProcess@ ==)
		process@ MmVADListUnlock
	end
end