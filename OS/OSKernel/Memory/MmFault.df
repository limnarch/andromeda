#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALInterrupt.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

var MmPageFaultCount 0
public MmPageFaultCount

fn (HALPageFaultHandler) MmPageFault { writing badaddr trapframe -- handled }
	HALCPUInterruptEnable

	if (KeIPLCurrentGet IPLDPC >=)
		0 handled!
		return
	end

	auto signal
	0 signal!

	if (badaddr@ PAGESIZE <)
		OSSIGNAL_SEGV signal!
	end else
		if (trapframe@ HALCPUIsUserTrapFrame)
			if (badaddr@ MMHIGHESTUSERADDRESS >)
				OSSIGNAL_SEGV signal!
			end
		end elseif (badaddr@ MMLOWESTSYSTEMADDRESS >=)
			// kernel mode fault on kernel mode address... bad
			-1 signal!
		end
	end

	if (signal@ ~~)
		// too complex to deal with being murdered here
		KeThreadCurrent@ KeThreadIgnoreKill drop

		writing@ // writing
		badaddr@ // vaddr
		trapframe@ // trapframe
		MmSatisfyFault signal!

		KeThreadCurrent@ KeThreadAcceptKill drop
	end

	if (signal@ -1 ==)
		// system error happened
		0 handled!
	end elseif (signal@)
		// generate signal or cause return from safecopy.
		1 handled!

		if (trapframe@ HALCPUIsUserTrapFrame)
			// user mode

			badaddr@ signal@ "MmPageFault: TODO: generate signal sig=%d vaddr=%x\n" KeCrash
		end else
			// kernel mode

			auto abort
			KeThreadCurrent@ KeThread_SafeAccessAbort + @ abort!

			if (abort@ ~~)
				// happened at an unexpected time!
				0 handled!
			end else
				// thought this might happen.
				abort@ trapframe@ HALCPUTrapFrameAbort
			end
		end
	end else
		auto rs
		HALCPUInterruptDisable rs!
		1 MmPageFaultCount +=
		rs@ HALCPUInterruptRestore

		// handled successfully
		1 handled!
	end

	HALCPUInterruptDisable drop
end

fn MmSatisfyFault { writing vaddr trapframe -- signal }
	0 signal!

	auto process
	KeProcessCurrent process!

	process@ MmVADListLock drop // this will NEVER fail since we ignored kill

	auto ok
	auto pteaddr
	auto phyaddr
	auto flags
	auto pfdbe
	auto wsleptr
	auto wsli

	vaddr@ // vaddr
	process@ KeProcess_PageDirectory + @ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (ok@ ~~)
		pteaddr@ // pteaddr
		MmPTEInterpret ok! flags! phyaddr!

		if (ok@ ~~)
			// valid

			if (flags@ PTE_W &)
				// no work to do
				process@ MmVADListUnlock
				return
			end elseif (writing@)
				vaddr@ // vaddr
				process@ // process
				MmWriteFault signal!

				if (signal@ -1 ~=)
					process@ MmVADListUnlock
					return
				end else
					0 signal!
				end
			end else
				// no work to do
				process@ MmVADListUnlock
				return
			end
		end else
			// hold PTE contents in flags temporarily
			pteaddr@@ flags!

			if (flags@ PTE_TRANSITION PTE_INSWAP | &)
				// COW page. we need to do work here

				auto vad
				vaddr@ // vaddr
				process@ // process
				MmFaultParameters drop vad! drop drop

				flags@ PAGENUMBERMASK & phyaddr!

				process@ MmWorkingSetLock drop // will NEVER fail

				process@ // process
				MmWorkingSetEntryReserve ok! wsleptr! wsli!

				if (ok@)
					process@ MmWorkingSetUnlock
					process@ MmVADListUnlock

					OSSIGNAL_KILL signal!

					return
				end

				if (flags@ PTE_TRANSITION &)
					// just soft-fault it in

					phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

					if (DEBUGCHECKS)
						if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + @ MMEVICTFLAG_COW & ~~)
							"MmSatisfyFault: transition PTE wasn't COW\n" KeCrash
						end
					end

					pfdbe@ MmEvictablePageReference drop
				end else
					// must have PTE_INSWAP flag.
					// swap it in. unlock and relock the working set to avoid
					// deadlock.

					process@ MmWorkingSetUnlock

					process@ // sectionobject
					pteaddr@ // pte
					phyaddr@ PAGESHIFT >> // pno
					MmAnonymousSwapIn ok! phyaddr! pfdbe!

					process@ MmWorkingSetLock drop

					if (ok@)
						wsli@ // wsli
						wsleptr@ // wsleptr
						process@ // process
						MmWorkingSetEntryFree

						process@ MmWorkingSetUnlock
						process@ MmVADListUnlock

						OSSIGNAL_KILL signal!

						return
					end

					MMEVICTFLAG_COW pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + |=

					PAGESHIFT phyaddr <<=
				end

				wsli@ pfdbe@ MmPageFrameEntryEvictable_WorkingSetIndexHint + !

				PTE_V flags!

				if (vad@ MmVAD_PageProtection + @ PAGEACCESS_WRITECOPY PAGEACCESS_WRITE | &)
					PTE_W flags |=
				end

				phyaddr@ // phyaddr
				flags@ // flags
				vaddr@ // vaddr
				pteaddr@ // pteaddr
				process@ KeProcess_ASID + @ // asid
				MmPTEUpdate drop drop drop

				vaddr@ PAGENUMBERMASK & // vaddr
				0 // isfilepage
				wsleptr@ // wsleptr
				process@ // process
				MmWorkingSetEntryInsert

				process@ MmWorkingSetUnlock
				process@ MmVADListUnlock

				return
			end
		end
	end

	vaddr@ // vaddr
	process@ // process
	MmNormalFault signal!

	process@ MmVADListUnlock
end

fn MmFaultParameters { vaddr process -- offset section vad ok }
	vaddr@ // vaddr
	0 // length
	0 // mustbestart
	process@ // processobject
	MmVADFind ok! vad!

	if (ok@)
		return
	end

	if (vaddr@ vad@ MmVAD_FurthestExtentMapped + @ >)
		vaddr@ PAGENUMBERMASK & vad@ MmVAD_FurthestExtentMapped + !
	end

	vad@ MmVAD_SectionObject + @ section!
	vaddr@ vad@ MmVAD_StartVA + @ - vad@ MmVAD_OffsetInSection + @ + offset!
end

fn MmNormalFault { vaddr process -- signal }
	0 signal!

	auto offset
	auto section
	auto vad
	auto ok
	auto isfilepage
	auto flags
	auto phyaddr
	auto pfdbe
	auto pteaddr
	auto wsli
	auto wsleptr

	vaddr@ // vaddr
	process@ // process
	MmFaultParameters ok! vad! section! offset!

	if (ok@)
		OSSIGNAL_SEGV signal!
		return
	end

	if (section@ MmSection_FileObject + @)
		if (section@ MmSection_FileObject + @ IOFile_FileControlBlock + @ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
			vaddr@ // vaddr
			process@ // process
			section@ // section
			offset@ // offset
			vad@ // vad
			MmSatisfyCharFault ok!

			if (ok@)
				OSSIGNAL_KILL signal!
			end

			return
		end
	end

	vaddr@ // vaddr
	process@ KeProcess_PageDirectory + @ // pagemap
	1 // canblock
	MmPTECreate ok! pteaddr!

	if (ok@)
		OSSIGNAL_KILL signal!
		return
	end

	process@ MmWorkingSetLock drop // will NEVER fail

	process@ // process
	MmWorkingSetEntryReserve ok! wsleptr! wsli!

	process@ MmWorkingSetUnlock

	if (ok@)
		pteaddr@ // pteaddr
		vaddr@ // vaddr
		process@ KeProcess_PageDirectory + @ // pagemap
		MmPTEDelete drop

		OSSIGNAL_KILL signal!
		return
	end

	if (section@ MmSection_FileObject + @)
		1 isfilepage!
		section@ // section
		offset@ // offset
		vad@ // vad
		MmSatisfyFileFault ok! phyaddr! pfdbe! flags!
	end else
		0 isfilepage!
		section@ // section
		offset@ // offset
		vad@ // vad
		MmSatisfyAnonFault ok! phyaddr! pfdbe! flags!
	end

	process@ MmWorkingSetLock drop

	if (ok@)
		wsli@ // wsli
		wsleptr@ // wsleptr
		process@ // process
		MmWorkingSetEntryFree

		process@ MmWorkingSetUnlock

		pteaddr@ // pteaddr
		vaddr@ // vaddr
		process@ KeProcess_PageDirectory + @ // pagemap
		MmPTEDelete drop

		OSSIGNAL_KILL signal!
		return
	end

	1 process@ PsProcess_ThrottleFaultCount + +=

	wsli@ pfdbe@ MmPageFrameEntryEvictable_WorkingSetIndexHint + !

	phyaddr@ // phyaddr
	flags@ // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	process@ KeProcess_ASID + @ // asid
	MmPTEUpdate drop drop drop

	vaddr@ PAGENUMBERMASK & // vaddr
	isfilepage@ // isfilepage
	wsleptr@ // wsleptr
	process@ // process
	MmWorkingSetEntryInsert

	process@ MmWorkingSetUnlock
end

fn MmSatisfyCharFault { vaddr process section offset vad -- ok }
	auto fcb
	section@ MmSection_FileObject + @ IOFile_FileControlBlock + @ fcb!

	auto getpagefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_GetPageAddress + @ getpagefunc!

	if (DEBUGCHECKS)
		if (getpagefunc@ ~~)
			"MmSatisfyCharFault: no GetPageAddress\n" KeCrash
		end
	end

	auto phyaddr
	offset@ // offset
	fcb@ // fcb
	getpagefunc@ IODispatchGetPageAddressFunction ok! phyaddr!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmSatisfyCharFault: failed to get page address (%i)\n" KeCrash
		end
	end

	auto flags
	PTE_V flags!

	if (vad@ MmVAD_PageProtection + @ PAGEACCESS_WRITE &)
		PTE_W flags |=
	end

	if (vad@ MmVAD_PageProtection + @ PAGEACCESS_NONCACHED &)
		PTE_NC flags |=
	end

	auto pteaddr
	vaddr@ // vaddr
	process@ KeProcess_PageDirectory + @ // pagemap
	1 // canblock
	MmPTECreate ok! pteaddr!

	if (ok@)
		return
	end

	phyaddr@ // phyaddr
	flags@ // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	process@ KeProcess_ASID + @ // asid
	MmPTEUpdate drop drop drop
end

fn MmSatisfyFileFault { section offset vad -- flags pfdbe phyaddr ok }
	auto fcb
	section@ MmSection_FileObject + @ IOFile_FileControlBlock + @ fcb!

	0 // kflags
	0 // flags
	offset@ PAGENUMBERMASK & // offset
	fcb@ // fcb
	IOCachePageRead ok! pfdbe! drop

	if (ok@)
		return
	end

	pfdbe@ MmPageFrameEntry_PFN + @ PAGESHIFT << phyaddr!

	PTE_V flags!
end

fn MmSatisfyAnonFault { section offset vad -- flags pfdbe phyaddr ok }
	offset@ // sectionoffset
	section@ // sectionobject
	MmSectionPageGet ok! pfdbe! phyaddr!

	if (ok@)
		return
	end

	PTE_V flags!

	if (vad@ MmVAD_PageProtection + @ PAGEACCESS_WRITE &)
		PTE_W flags |=
	end
end

fn MmWriteFault { vaddr process -- signal }
	// COW or dirty fault. lets find out which one

	0 signal!

	auto pteaddr
	auto phyaddr

	process@ MmWorkingSetLock drop

	// re-check the PTE with the working set mutex held, since it may have
	// been trimmed since we decided it was valid. we know that it's the same
	// PTE if it's still valid, and hasn't been switched out with something
	// else, because the VAD list mutex is held during all such events.
	// the loss of this convenient assumption is one reason that it sounds
	// hard to allow multiple threads to take a page fault per process without
	// waiting for eachother.

	vaddr@ // vaddr
	process@ KeProcess_PageDirectory + @ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (ok@)
		// invalid
		process@ MmWorkingSetUnlock
		-1 signal!
		return
	end

	pteaddr@ // pteaddr
	MmPTEInterpret ok! drop phyaddr!

	if (ok@)
		// invalid
		process@ MmWorkingSetUnlock
		-1 signal!
		return
	end

	auto section
	auto vad
	auto ok
	auto pfdbe
	auto wsli
	auto wsleptr

	vaddr@ // vaddr
	process@ // process
	MmFaultParameters ok! vad! section! drop

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmWriteFault: failed to look up VAD (%i)\n" KeCrash
		end
	end

	phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	if (vad@ MmVAD_PageProtection + @ PAGEACCESS_WRITECOPY &)
		// COW, allocate a page frame and copy the old page frame into it.

		// XXX this is a unique situation where a page allocation occurs
		// with the working set mutex held. this could prevent the process's
		// working set from being trimmed while it's blocked waiting for a
		// page to become available, which could lead to an unnecessary
		// early demise for the process.

		auto cowpfdbe
		auto cowaddr

		process@ // sectionobject
		pteaddr@ // pte
		FREEFIRST // pri
		MmAnonymousPageAlloc ok! cowaddr! cowpfdbe!

		if (ok@)
			OSSIGNAL_KILL signal!
			return
		end

		MMEVICTFLAG_COW cowpfdbe@ MmPageFrameEntryEvictable_EvictionFlags + |=

		PAGESHIFT cowaddr <<=

		cowaddr@ IDENTITYSPACE | // dest
		phyaddr@ IDENTITYSPACE | // src
		PAGESIZE // size
		memcpy

		cowaddr@ // phyaddr
		PTE_V PTE_W | // flags
		vaddr@ // vaddr
		pteaddr@ // pteaddr
		process@ KeProcess_ASID + @ // asid
		MmPTEUpdate drop drop drop

		// we COW'd over top of the old page frame and no longer have it
		// mapped, so dereference it
		pfdbe@ MmEvictablePageDereference drop
	end elseif (vad@ MmVAD_PageProtection + @ PAGEACCESS_WRITE & ~~)
		// privilege violation
		OSSIGNAL_SEGV signal!
	end else
		// dirty fault. mark the file page modified.

		if (DEBUGCHECKS)
			if (section@ MmSection_FileObject + @ ~~)
				"MmWriteFault: no fileobject\n" KeCrash
			end
		end

		KeProcessCurrent PsProcess_QuotaBlock + @ // quotablock
		pfdbe@ // pfdbe
		IOCachePageModifyQuotaCharge drop

		auto ipl
		IPLDPC KeIPLRaise ipl!

		pfdbe@ IOCachePageModifyFunction ok!

		if (DEBUGCHECKS)
			if (ok@)
				"MmWriteFault: failed to modify page\n" KeCrash
			end
		end

		phyaddr@ // phyaddr
		PTE_V PTE_W | // flags
		vaddr@ // vaddr
		pteaddr@ // pteaddr
		process@ KeProcess_ASID + @ // asid
		MmPTEUpdate drop drop drop

		if (pfdbe@ IOPageFrameEntryCache_ModifiedPTE + @)
			pfdbe@ IOPageFrameEntryCache_ModifiedPTE + @ MmPTEUnmodify
		end

		pteaddr@ pfdbe@ IOPageFrameEntryCache_ModifiedPTE + !

		ipl@ KeIPLLower
	end

	process@ MmWorkingSetUnlock
end