//
// Implements memory manager support for the executive process object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn MmProcessInitialize { sectionobject process -- ok }
	// initialize virtual memory related fields

	0 process@ PsProcess_SwapOutNext + !
	0 process@ PsProcess_SwapOutPrev + !
	0 process@ PsProcess_SwappedOut + !

	0 process@ PsProcess_MappedMMIOCount + !

	0 process@ PsProcess_ModifiedPages + !

	0 process@ PsProcess_PageFaultCount + !
	0 process@ PsProcess_ThrottleFaultCount + !

	0 process@ PsProcess_VADListHead + !
	0 process@ PsProcess_VADListTail + !

	0 process@ PsProcess_VADListLRUHead + !

	0 process@ PsProcess_PinnedPageCount + !

	0 process@ PsProcess_CommittedPageTablesCount + !

	"PsProcessVADListMutex" // name
	KERNELMODE // mode
	process@ PsProcess_VADListMutex + // mutex
	KeMutexInitialize

	// size is 64 assuming a 32-bit address space, but this entire method of
	// keeping track of page table commit will have to change with a 64-bit
	// port anyway.
	process@ PsProcess_CommittedPageTablesBitmap + // ptr
	64 // size
	0 // word
	memset

	process@ MmWorkingSetListInitialize ok!

	if (ok@)
		return
	end

	auto okc

	auto info
	PsOSDLLInformation info!

	// create mappings for OSDLL and PEB section

	// map text section
	info@ PsOSDLLInfo_TextSize + @ // length
	info@ PsOSDLLInfo_TextVAddr + @ // startva
	info@ PsOSDLLInfo_TextOffset + @ // sectionoffset
	PsOSDLLFileObject@ // sectionobject
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_EXEC | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmMapViewProcessObject ok! drop

	if (ok@)
		process@ MmWorkingSetListFree
		process@ MmProcessUnchargePageTables

		return
	end

	// map data section
	info@ PsOSDLLInfo_DataSize + @ // length
	info@ PsOSDLLInfo_DataVAddr + @ // startva
	info@ PsOSDLLInfo_DataOffset + @ // sectionoffset
	PsOSDLLFileObject@ // sectionobject
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_WRITECOPY | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmMapViewProcessObject ok! drop

	if (ok@)
		// me when no goto

		info@ PsOSDLLInfo_TextSize + @ // length
		info@ PsOSDLLInfo_TextVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 1 (%i)\n" KeCrash
			end
		end

		process@ MmWorkingSetListFree
		process@ MmProcessUnchargePageTables

		return
	end

	// map bss section
	info@ PsOSDLLInfo_BSSSize + @ // length
	info@ PsOSDLLInfo_BSSVAddr + @ // startva
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmAllocateProcessObject ok! drop

	if (ok@)
		info@ PsOSDLLInfo_TextSize + @ // length
		info@ PsOSDLLInfo_TextVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 4 (%i)\n" KeCrash
			end
		end

		info@ PsOSDLLInfo_DataSize + @ // length
		info@ PsOSDLLInfo_DataVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 5 (%i)\n" KeCrash
			end
		end

		process@ MmWorkingSetListFree
		process@ MmProcessUnchargePageTables

		return
	end

	if (sectionobject@)
		// map PEB
		OSPEBSIZE // length
		OSPEB // startva
		0 // sectionoffset
		sectionobject@ // sectionobject
		process@ // processobject
		PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
		OSMAPFLAG_FIXEDADDRESS // flags
		MmMapViewProcessObject ok! drop

		if (ok@)
			info@ PsOSDLLInfo_TextSize + @ // length
			info@ PsOSDLLInfo_TextVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 6 (%i)\n" KeCrash
				end
			end

			info@ PsOSDLLInfo_DataSize + @ // length
			info@ PsOSDLLInfo_DataVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 7 (%i)\n" KeCrash
				end
			end

			info@ PsOSDLLInfo_BSSSize + @ // length
			info@ PsOSDLLInfo_BSSVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 8 (%i)\n" KeCrash
				end
			end

			process@ MmWorkingSetListFree
			process@ MmProcessUnchargePageTables

			return
		end
	end

	// create process page directory
	auto pdir
	process@ MmPageDirectoryAlloc ok! pdir!

	if (ok@)
		info@ PsOSDLLInfo_TextSize + @ // length
		info@ PsOSDLLInfo_TextVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 9 (%i)\n" KeCrash
			end
		end

		info@ PsOSDLLInfo_DataSize + @ // length
		info@ PsOSDLLInfo_DataVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 10 (%i)\n" KeCrash
			end
		end

		info@ PsOSDLLInfo_BSSSize + @ // length
		info@ PsOSDLLInfo_BSSVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 11 (%i)\n" KeCrash
			end
		end

		if (sectionobject@)
			OSPEBSIZE // length
			OSPEB // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 12 (%i)\n" KeCrash
				end
			end
		end

		process@ MmWorkingSetListFree
		process@ MmProcessUnchargePageTables

		return
	end

	pdir@ process@ PsProcess_PCB + KeProcess_PageDirectory + !
end

fn MmProcessUninitialize { process -- ok }
	// destroy all VADs, free page tables, etc

	KeThreadCurrent@ KeThreadIgnoreKill drop

	process@ MmVADListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmProcessUninitialize: failed to lock VAD list (%i)\n" KeCrash
		end
	end

	auto vad
	process@ PsProcess_VADListHead + @ vad!

	while (vad@)
		vad@ // vad
		process@ // processobject
		MmVADUnmap

		process@ PsProcess_VADListHead + @ vad!
	end

	if (DEBUGCHECKS)
		if (process@ PsProcess_WorkingSetSize + @)
			"MmProcessUninitialize: unmapped all VADs yet working set size non-zero\n" KeCrash
		end
	end

	process@ MmVADListUnlock

	// lock the working set to avoid a race condition with the process swapper
	process@ MmWorkingSetLock drop
	process@ MmWorkingSetListFree
	process@ MmWorkingSetUnlock

	process@ MmProcessUnchargePageTables

	KeThreadCurrent@ KeThreadAcceptKill drop
end

fn MmProcessSwapOut { process -- }
	// invalidate and free the process's working set structures.

	process@ MmWorkingSetLock drop

	process@ MmWorkingSetPurge
	process@ MmWorkingSetListFree

	process@ MmWorkingSetUnlock

	// dereference the page directory so it can get swapped out.

	process@ KeProcess_PageDirectory + @ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
	MmEvictablePageDereference drop
end

fn MmProcessSwapIn { process -- }
	// entered at IPLDPC. must leave at IPLDPC.

	0 process@ PsProcess_SwappedOut + !

	// make the page directory resident again if it was swapped out.

	process@ MmPageDirectorySwapIn
end

fn MmProcessChargePageTables { startva endva process -- ok }
	// charge VM quota for page tables.
	// assumes the caller has the VAD list mutex held.
	// currently this will never get uncharged until the process exits.

	// page tables are "stickier" than other pages so we charge kernel heap
	// quota too to reflect that, as we do for all pages whose swapout is
	// conditional on some relatively extraordinary circumstance (kernel stack,
	// etc)

	auto firstpt
	startva@ PERPAGETABLESHIFT >> firstpt!

	auto lastpt
	endva@ PERPAGETABLESHIFT >> lastpt!

	auto bmp
	process@ PsProcess_CommittedPageTablesBitmap + bmp!

	auto quotablock
	process@ PsProcess_QuotaBlock + @ quotablock!

	0 ok!

	while (firstpt@ lastpt@ <=)
		if (bmp@ firstpt@ 3 >> + gb 1 firstpt@ 7 & << & ~~)
			// bit not set, set & charge page

			PAGESIZE // quota
			quotablock@ // quotablock
			MmQuotaBlockChargeVM ok!

			if (ok@)
				return
			end

			PAGESIZE // quota
			quotablock@ // quotablock
			MmQuotaBlockCharge ok!

			if (ok@)
				PAGESIZE // quota
				quotablock@ // quotablock
				MmQuotaBlockUnchargeVM

				return
			end

			bmp@ firstpt@ 3 >> + gb 1 firstpt@ 7 & << |
			bmp@ firstpt@ 3 >> + sb

			1 process@ PsProcess_CommittedPageTablesCount + +=
		end

		1 firstpt +=
	end 
end

fn MmProcessUnchargePageTables { process -- }
	// uncharge quota for all the page tables the process committed in its
	// lifetime.

	process@ PsProcess_CommittedPageTablesCount + @ PAGESHIFT << // quota
	process@ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeVM

	process@ PsProcess_CommittedPageTablesCount + @ PAGESHIFT << // quota
	process@ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUncharge

	0 process@ PsProcess_CommittedPageTablesCount + !
end

fn MmThreadInitialize { thread -- ok }
	auto process
	thread@ KeThread_Process + @ process!

	// map usermode stack

	auto ustackbottom
	USTACKSZ // length
	USTACKS // startva
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
	0 // flags
	MmAllocateProcessObject ok! ustackbottom!

	if (ok@)
		return
	end

	ustackbottom@ thread@ PsThread_UserStackBottom + !
	ustackbottom@ USTACKSZ + thread@ PsThread_UserStackTop + !
end

fn MmThreadUninitialize { thread -- ok }
	auto process
	thread@ KeThread_Process + @ process!

	// unmap usermode stack
	USTACKSZ // length
	thread@ PsThread_UserStackBottom + @ // vaddr
	process@ // processobject
	MmUnmapViewProcess ok!
end