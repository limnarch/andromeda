//
// Implements memory manager support for the executive process object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALRTC.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

buffer MmSystemProcessHeader PAGESIZE

fn MmProcessInitialize { sectionobject process -- ok }
	fnsection "PAGE$text"

	// initialize virtual memory related fields

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	0 pagedarea@ PsProcessPaged_MappedMMIOCount + !

	0 process@ PsProcess_PageFaultCount + !

	0 pagedarea@ PsProcessPaged_VADTreeRoot + !

	0 process@ PsProcess_PinnedPageCount + !

	0 process@ PsProcess_TrimListNext + !
	0 process@ PsProcess_TrimListPrev + !

	"PsProcessVADListMutex" // name
	KERNELMODE // mode
	process@ PsProcess_VADListMutex + // mutex
	KeMutexInitialize

	// size is 64 assuming a 32-bit address space, but this entire method of
	// keeping track of page table commit will have to change with a 64-bit
	// port anyway.
	pagedarea@ PsProcessPaged_CommittedPageTablesBitmap + // ptr
	64 // size
	0 // word
	memset

	0 pagedarea@ PsProcessPaged_CommittedPageTablesCount + !

	0 pagedarea@ PsProcessPaged_PTECountTableListHead + !

	if (PsSystemProcess@ ~~)
		MmSystemProcessHeader process@ PsProcess_MmHeader + !
	end else
		process@ MmProcessHeaderCreate ok! drop drop

		if (ok@)
			return
		end
	end

	process@ MmWorkingSetListInitialize ok!

	if (ok@)
		process@ MmProcessHeaderDestroy

		return
	end

	if (PsSystemProcess@ ~~)
		// thats enough for the system process
		return
	end

	auto okc

	auto info
	PsOSDLLInformation info!

	// create mappings for OSDLL and PEB section

	// map text section
	info@ PsOSDLLInfo_TextSize + @ // length
	info@ PsOSDLLInfo_TextVAddr + @ // startva
	info@ PsOSDLLInfo_TextOffset + @ // sectionoffset
	PsOSDLLFileObject@ // sectionobject
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_EXEC | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmMapViewProcessObject ok! drop

	if (ok@)
		process@ MmWorkingSetListFree
		process@ MmProcessHeaderDestroy
		process@ MmProcessUnchargePageTables

		return
	end

	// map data section
	info@ PsOSDLLInfo_DataSize + @ // length
	info@ PsOSDLLInfo_DataVAddr + @ // startva
	info@ PsOSDLLInfo_DataOffset + @ // sectionoffset
	PsOSDLLFileObject@ // sectionobject
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_WRITECOPY | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmMapViewProcessObject ok! drop

	if (ok@)
		// me when no goto

		info@ PsOSDLLInfo_TextSize + @ // length
		info@ PsOSDLLInfo_TextVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 1 (%i)\n" KeCrash
			end
		end

		process@ MmWorkingSetListFree
		process@ MmProcessHeaderDestroy
		process@ MmProcessUnchargePageTables

		return
	end

	// map bss section
	info@ PsOSDLLInfo_BSSSize + @ // length
	info@ PsOSDLLInfo_BSSVAddr + @ // startva
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmAllocateProcessObject ok! drop

	if (ok@)
		info@ PsOSDLLInfo_TextSize + @ // length
		info@ PsOSDLLInfo_TextVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 4 (%i)\n" KeCrash
			end
		end

		info@ PsOSDLLInfo_DataSize + @ // length
		info@ PsOSDLLInfo_DataVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 5 (%i)\n" KeCrash
			end
		end

		process@ MmWorkingSetListFree
		process@ MmProcessHeaderDestroy
		process@ MmProcessUnchargePageTables

		return
	end

	if (sectionobject@)
		// map PEB
		OSPEBSIZE // length
		OSPEB // startva
		0 // sectionoffset
		sectionobject@ // sectionobject
		process@ // processobject
		PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
		OSMAPFLAG_FIXEDADDRESS // flags
		MmMapViewProcessObject ok! drop

		if (ok@)
			info@ PsOSDLLInfo_TextSize + @ // length
			info@ PsOSDLLInfo_TextVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 6 (%i)\n" KeCrash
				end
			end

			info@ PsOSDLLInfo_DataSize + @ // length
			info@ PsOSDLLInfo_DataVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 7 (%i)\n" KeCrash
				end
			end

			info@ PsOSDLLInfo_BSSSize + @ // length
			info@ PsOSDLLInfo_BSSVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 8 (%i)\n" KeCrash
				end
			end

			process@ MmWorkingSetListFree
			process@ MmProcessHeaderDestroy
			process@ MmProcessUnchargePageTables

			return
		end
	end
end

fn MmProcessPTECountGet { pri vaddr process -- ptect ok }
	fnsection "PAGE$text"

	// assumes VAD list locked

	0 ok!

	auto ptn
	vaddr@ PERPAGETABLESHIFT >> MMPTECOUNTSPERTABLE / ptn!

	process@ PsProcess_PagedArea + @ PsProcessPaged_PTECountTableListHead + @ ptect!

	while (ptect@)
		if (ptect@ MmPTECountTableHeader_Number + @ ptn@ ==)
			break
		end

		ptect@ MmPTECountTableHeader_Next + @ ptect!
	end

	if (ptect@ ~~)
		// create

		MmPTECountTableHeader_SIZEOF MMPTECOUNTTABLESIZE + // bytes
		'MmPC' // tag
		pri@ CANBLOCK | // flags
		MmAllocWithTag ok! ptect!

		if (ok@)
			return
		end

		process@ PsProcess_PagedArea + @ PsProcessPaged_PTECountTableListHead + @ ptect@ MmPTECountTableHeader_Next + !
		ptn@ ptect@ MmPTECountTableHeader_Number + !

		ptect@ process@ PsProcess_PagedArea + @ PsProcessPaged_PTECountTableListHead + !

		ptect@ MmPTECountTableHeader_SIZEOF + // ptr
		MMPTECOUNTTABLESIZE // size
		0 // word
		memset
	end

	ptect@ MmPTECountTableHeader_SIZEOF +
	vaddr@ PERPAGETABLESHIFT >> MMPTECOUNTSPERTABLE % 1 << +
	ptect!
end

fn MmProcessPTECountDestroy { process -- }
	fnsection "PAGE$text"

	auto ptect
	process@ PsProcess_PagedArea + @ PsProcessPaged_PTECountTableListHead + @ ptect!

	while (ptect@)
		auto nptect
		ptect@ MmPTECountTableHeader_Next + @ nptect!

		ptect@ MmFree

		nptect@ ptect!
	end
end

fn MmProcessUninitialize { process -- ok }
	fnsection "PAGE$text"

	// destroy all VADs, free page tables, etc

	KeThreadCurrent@ KeThreadIgnoreKill drop

	process@ MmVADListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmProcessUninitialize: failed to lock VAD list (%i)\n" KeCrash
		end
	end

	auto vad
	process@ PsProcess_PagedArea + @ PsProcessPaged_VADTreeRoot + @ vad!

	while (vad@)
		MmVAD_Parent vad -=

		vad@ // vad
		process@ // processobject
		MmVADUnmap

		process@ PsProcess_PagedArea + @ PsProcessPaged_VADTreeRoot + @ vad!
	end

	if (DEBUGCHECKS)
		if (process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetSize + @)
			"MmProcessUninitialize: unmapped all VADs yet working set size non-zero\n" KeCrash
		end
	end

	process@ MmVADListUnlock

	// lock the working set to avoid a race condition with the process swapper
	// process@ MmWorkingSetLock drop
	process@ MmWorkingSetListFree
	// process@ MmWorkingSetUnlock

	process@ MmProcessPTECountDestroy
	process@ MmProcessUnchargePageTables

	KeThreadCurrent@ KeThreadAcceptKill drop
end

fn MmProcessSwapOut { process -- }
	// invalidate and free the process's working set structures.
	// lock the VAD list to synchronize against remote unmapping.

	process@ MmVADListLock drop

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto workingsetmin
	process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetMinimum + @ workingsetmin!

	process@ MmWorkingSetSwapOut

	ipl@ KeIPLLower

	process@ MmVADListUnlock

	// dereference the page directory so it can get swapped out.

	process@ MmProcessHeaderDereference
	process@ MmPageDirectoryDereference

	0 workingsetmin@ - MmPhysicalCommitUsage KeInterlockedIncrement drop
end

fn MmProcessSwapIn { process -- }
	// make the page directory resident again if it was swapped out.

	auto ok
	TRYFOREVER // pri
	process@ // process
	MmPageDirectoryReference ok!

	if (ok@)
		ok@ "MmProcessSwapIn: failed to reference page directory (%i)\n" KeCrash
	end

	TRYFOREVER // pri
	process@ // process
	MmProcessHeaderReference ok!

	if (ok@)
		ok@ "MmProcessSwapIn: failed to reference process header (%i)\n" KeCrash
	end

	auto workingsetmin
	process@ PsProcess_MmHeader + @ MmProcessHeader_WorkingSetMinimum + @ workingsetmin!

	workingsetmin@ MmPhysicalCommitUsage KeInterlockedIncrement drop
end

fn MmProcessChargePageTables { startva endva process -- ok }
	fnsection "PAGE$text"

	// charge VM quota for page tables.
	// assumes the caller has the VAD list mutex held.
	// currently this will never get uncharged until the process exits.

	// page tables are "stickier" than other pages so we charge kernel heap
	// quota too to reflect that, as we do for all pages whose swapout is
	// conditional on some relatively extraordinary circumstance (kernel stack,
	// etc)

	auto firstpt
	startva@ PERPAGETABLESHIFT >> firstpt!

	auto lastpt
	endva@ PERPAGETABLESHIFT >> lastpt!

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	auto bmp
	pagedarea@ PsProcessPaged_CommittedPageTablesBitmap + bmp!

	auto quotablock
	pagedarea@ PsProcessPaged_QuotaBlock + @ quotablock!

	0 ok!

	while (firstpt@ lastpt@ <=)
		if (bmp@ firstpt@ 3 >> + gb 1 firstpt@ 7 & << & ~~)
			// bit not set, set & charge page

			PAGESIZE // quota
			quotablock@ // quotablock
			MmQuotaBlockChargeVM ok!

			if (ok@)
				return
			end

if (0)
			1 // quota
			quotablock@ // quotablock
			MmQuotaBlockChargeWS ok!

			if (ok@)
				PAGESIZE // quota
				quotablock@ // quotablock
				MmQuotaBlockUnchargeVM

				return
			end
end

			bmp@ firstpt@ 3 >> + gb 1 firstpt@ 7 & << |
			bmp@ firstpt@ 3 >> + sb

			1 pagedarea@ PsProcessPaged_CommittedPageTablesCount + +=
		end

		1 firstpt +=
	end 
end

fn MmProcessUnchargePageTables { process -- }
	fnsection "PAGE$text"

	// uncharge quota for all the page tables the process committed in its
	// lifetime.

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	pagedarea@ PsProcessPaged_CommittedPageTablesCount + @ PAGESHIFT << // quota
	pagedarea@ PsProcessPaged_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeVM

if (0)
	pagedarea@ PsProcessPaged_CommittedPageTablesCount + @ // quota
	pagedarea@ PsProcessPaged_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeWS
end

	pagedarea@ PsProcessPaged_CommittedPageTablesBitmap + // ptr
	64 // size
	0 // word
	memset

	0 pagedarea@ PsProcessPaged_CommittedPageTablesCount + !
end

fn MmThreadInitialize { thread -- ok }
	fnsection "PAGE$text"

	auto process
	thread@ KeThread_Process + @ process!

	0 thread@ PsThread_StackHasGuardPage + !

	// allocate TEB

	auto uteb
	OSThreadEnvironmentBlock_SIZEOF // length
	HEAPSTART // startva
	process@ // processobject
	ACCESS_READ ACCESS_WRITE | // pageprotection
	0 // flags
	MmAllocateProcessObject ok! uteb!

	if (ok@)
		return
	end

	// allocate guard page for stack

	auto ustackbottom
	OSPAGESIZE // length
	USTACKS // startva
	process@ // processobject
	0 // pageprotection
	0 // flags
	MmAllocateProcessObject ok! ustackbottom!

	while (1)
		if (ok@ ~~)
			// try to allocate the stack right after the guard page

			USTACKSZ // length
			ustackbottom@ OSPAGESIZE + // startva
			process@ // processobject
			ACCESS_READ ACCESS_WRITE | // pageprotection
			OSMAPFLAG_FIXEDADDRESS // flags
			MmAllocateProcessObject ok! drop

			if (ok@)
				// didn't work. deallocate guard page and retry anywhere

				OSPAGESIZE // length
				ustackbottom@ // vaddr
				process@ // processobject
				MmUnmapViewProcess drop

				continue
			end

			1 thread@ PsThread_StackHasGuardPage + !

			OSPAGESIZE ustackbottom +=
		end else
			// something broke, just allocate the stack anywhere

			USTACKSZ // length
			USTACKS // startva
			process@ // processobject
			ACCESS_READ ACCESS_WRITE | // pageprotection
			0 // flags
			MmAllocateProcessObject ok! ustackbottom!
		end

		break
	end

	if (ok@)
		// failed, deallocate TEB

		OSThreadEnvironmentBlock_SIZEOF // length
		uteb@ // vaddr
		process@ // processobject
		MmUnmapViewProcess drop

		return
	end

	ustackbottom@ thread@ PsThread_StackBottom + !
	ustackbottom@ USTACKSZ + thread@ PsThread_StackTop + !

	uteb@ thread@ PsThread_UTEB + !
end

fn MmThreadUninitialize { thread -- ok }
	fnsection "PAGE$text"

	auto process
	thread@ KeThread_Process + @ process!

	// deallocate TEB
	OSThreadEnvironmentBlock_SIZEOF // length
	thread@ PsThread_UTEB + @ // vaddr
	process@ // processobject
	MmUnmapViewProcess drop

	// unmap usermode stack

	if (thread@ PsThread_StackHasGuardPage + @)
		PAGESIZE // length
		thread@ PsThread_StackBottom + @ PAGESIZE - // vaddr
		process@ // processobject
		MmUnmapViewProcess drop
	end

	USTACKSZ // length
	thread@ PsThread_StackBottom + @ // vaddr
	process@ // processobject
	MmUnmapViewProcess ok!
end