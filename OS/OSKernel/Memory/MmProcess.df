//
// Implements memory manager support for the executive process object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn MmProcessInitialize { sectionobject process -- ok }
	// initialize virtual memory related fields

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	0 process@ PsProcess_SwapOutNext + !
	0 process@ PsProcess_SwapOutPrev + !
	0 process@ PsProcess_SwappedOut + !

	0 pagedarea@ PsProcessPaged_MappedMMIOCount + !

	0 process@ PsProcess_ModifiedPages + !

	0 process@ PsProcess_PageFaultCount + !
	0 process@ PsProcess_ThrottleFaultCount + !

	0 process@ PsProcess_VADTreeRoot + !

	0 process@ PsProcess_PinnedPageCount + !

	"PsProcessVADListMutex" // name
	KERNELMODE // mode
	process@ PsProcess_VADListMutex + // mutex
	KeMutexInitialize

	// size is 64 assuming a 32-bit address space, but this entire method of
	// keeping track of page table commit will have to change with a 64-bit
	// port anyway.
	pagedarea@ PsProcessPaged_CommittedPageTablesBitmap + // ptr
	64 // size
	0 // word
	memset

	0 pagedarea@ PsProcessPaged_CommittedPageTablesCount + !

	process@ PsProcess_PageTableEntryCounts + // ptr
	1024 // size
	0 // word
	memset

	process@ MmWorkingSetListInitialize ok!

	if (ok@)
		return
	end

	if (PsSystemProcess@ ~~)
		// thats enough for the system process
		return
	end

	auto okc

	auto info
	PsOSDLLInformation info!

	// create mappings for OSDLL and PEB section

	// map text section
	info@ PsOSDLLInfo_TextSize + @ // length
	info@ PsOSDLLInfo_TextVAddr + @ // startva
	info@ PsOSDLLInfo_TextOffset + @ // sectionoffset
	PsOSDLLFileObject@ // sectionobject
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_EXEC | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmMapViewProcessObject ok! drop

	if (ok@)
		process@ MmWorkingSetListFree
		process@ MmProcessUnchargePageTables

		return
	end

	// map data section
	info@ PsOSDLLInfo_DataSize + @ // length
	info@ PsOSDLLInfo_DataVAddr + @ // startva
	info@ PsOSDLLInfo_DataOffset + @ // sectionoffset
	PsOSDLLFileObject@ // sectionobject
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_WRITECOPY | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmMapViewProcessObject ok! drop

	if (ok@)
		// me when no goto

		info@ PsOSDLLInfo_TextSize + @ // length
		info@ PsOSDLLInfo_TextVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 1 (%i)\n" KeCrash
			end
		end

		process@ MmWorkingSetListFree
		process@ MmProcessUnchargePageTables

		return
	end

	// map bss section
	info@ PsOSDLLInfo_BSSSize + @ // length
	info@ PsOSDLLInfo_BSSVAddr + @ // startva
	process@ // processobject
	PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
	OSMAPFLAG_FIXEDADDRESS // flags
	MmAllocateProcessObject ok! drop

	if (ok@)
		info@ PsOSDLLInfo_TextSize + @ // length
		info@ PsOSDLLInfo_TextVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 4 (%i)\n" KeCrash
			end
		end

		info@ PsOSDLLInfo_DataSize + @ // length
		info@ PsOSDLLInfo_DataVAddr + @ // vaddr
		process@ // processobject
		MmUnmapViewProcess okc!

		if (DEBUGCHECKS)
			if (okc@)
				okc@ "MmProcessInitialize: couldn't unmap 5 (%i)\n" KeCrash
			end
		end

		process@ MmWorkingSetListFree
		process@ MmProcessUnchargePageTables

		return
	end

	if (sectionobject@)
		// map PEB
		OSPEBSIZE // length
		OSPEB // startva
		0 // sectionoffset
		sectionobject@ // sectionobject
		process@ // processobject
		PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
		OSMAPFLAG_FIXEDADDRESS // flags
		MmMapViewProcessObject ok! drop

		if (ok@)
			info@ PsOSDLLInfo_TextSize + @ // length
			info@ PsOSDLLInfo_TextVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 6 (%i)\n" KeCrash
				end
			end

			info@ PsOSDLLInfo_DataSize + @ // length
			info@ PsOSDLLInfo_DataVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 7 (%i)\n" KeCrash
				end
			end

			info@ PsOSDLLInfo_BSSSize + @ // length
			info@ PsOSDLLInfo_BSSVAddr + @ // vaddr
			process@ // processobject
			MmUnmapViewProcess okc!

			if (DEBUGCHECKS)
				if (okc@)
					okc@ "MmProcessInitialize: couldn't unmap 8 (%i)\n" KeCrash
				end
			end

			process@ MmWorkingSetListFree
			process@ MmProcessUnchargePageTables

			return
		end
	end
end

fn MmProcessUninitialize { process -- ok }
	// destroy all VADs, free page tables, etc

	KeThreadCurrent@ KeThreadIgnoreKill drop

	process@ MmVADListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmProcessUninitialize: failed to lock VAD list (%i)\n" KeCrash
		end
	end

	auto vad
	process@ PsProcess_VADTreeRoot + @ vad!

	while (vad@)
		MmVAD_Parent vad -=

		vad@ // vad
		process@ // processobject
		MmVADUnmap

		process@ PsProcess_VADTreeRoot + @ vad!
	end

	if (DEBUGCHECKS)
		if (process@ PsProcess_WorkingSetSize + @)
			"MmProcessUninitialize: unmapped all VADs yet working set size non-zero\n" KeCrash
		end
	end

	process@ MmVADListUnlock

	// lock the working set to avoid a race condition with the process swapper
	process@ MmWorkingSetLock drop
	process@ MmWorkingSetListFree
	process@ MmWorkingSetUnlock

	process@ MmProcessUnchargePageTables

	KeThreadCurrent@ KeThreadAcceptKill drop
end

fn MmProcessSwapOut { process -- }
	// invalidate and free the process's working set structures.

	process@ MmWorkingSetLock drop

	process@ MmWorkingSetPurge
	process@ MmWorkingSetListFree

	process@ MmWorkingSetUnlock

	// dereference the page directory so it can get swapped out.

	process@ MmPageDirectoryDereference
end

fn MmProcessSwapIn { process -- }
	// entered at IPLDPC. must leave at IPLDPC.

	0 process@ PsProcess_SwappedOut + !

	// make the page directory resident again if it was swapped out.

	IPLLOW KeIPLLower

	auto ok

	TRYFOREVER // pri
	process@ // process
	MmPageDirectoryReference ok!

	if (ok@)
		ok@ "MmProcessSwapIn: failed to reference page directory (%i)\n" KeCrash
	end

	IPLDPC KeIPLRaise drop
end

fn MmProcessChargePageTables { startva endva process -- ok }
	// charge VM quota for page tables.
	// assumes the caller has the VAD list mutex held.
	// currently this will never get uncharged until the process exits.

	// page tables are "stickier" than other pages so we charge kernel heap
	// quota too to reflect that, as we do for all pages whose swapout is
	// conditional on some relatively extraordinary circumstance (kernel stack,
	// etc)

	auto firstpt
	startva@ PERPAGETABLESHIFT >> firstpt!

	auto lastpt
	endva@ PERPAGETABLESHIFT >> lastpt!

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	auto bmp
	pagedarea@ PsProcessPaged_CommittedPageTablesBitmap + bmp!

	auto quotablock
	pagedarea@ PsProcessPaged_QuotaBlock + @ quotablock!

	0 ok!

	while (firstpt@ lastpt@ <=)
		if (bmp@ firstpt@ 3 >> + gb 1 firstpt@ 7 & << & ~~)
			// bit not set, set & charge page

			PAGESIZE // quota
			quotablock@ // quotablock
			MmQuotaBlockChargeVM ok!

			if (ok@)
				return
			end

			PAGESIZE // quota
			quotablock@ // quotablock
			MmQuotaBlockCharge ok!

			if (ok@)
				PAGESIZE // quota
				quotablock@ // quotablock
				MmQuotaBlockUnchargeVM

				return
			end

			bmp@ firstpt@ 3 >> + gb 1 firstpt@ 7 & << |
			bmp@ firstpt@ 3 >> + sb

			1 pagedarea@ PsProcessPaged_CommittedPageTablesCount + +=
		end

		1 firstpt +=
	end 
end

fn MmProcessUnchargePageTables { process -- }
	// uncharge quota for all the page tables the process committed in its
	// lifetime.

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	pagedarea@ PsProcessPaged_CommittedPageTablesCount + @ PAGESHIFT << // quota
	pagedarea@ PsProcessPaged_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeVM

	pagedarea@ PsProcessPaged_CommittedPageTablesCount + @ PAGESHIFT << // quota
	pagedarea@ PsProcessPaged_QuotaBlock + @ // quotablock
	MmQuotaBlockUncharge

	pagedarea@ PsProcessPaged_CommittedPageTablesBitmap + // ptr
	64 // size
	0 // word
	memset

	0 pagedarea@ PsProcessPaged_CommittedPageTablesCount + !
end

fn MmThreadInitialize { thread -- ok }
	auto process
	thread@ KeThread_Process + @ process!

	0 thread@ PsThread_StackHasGuardPage + !

	// allocate TEB

	auto uteb
	OSThreadEnvironmentBlock_SIZEOF // length
	HEAPSTART // startva
	process@ // processobject
	ACCESS_READ ACCESS_WRITE | // pageprotection
	0 // flags
	MmAllocateProcessObject ok! uteb!

	if (ok@)
		return
	end

	// allocate guard page for stack

	auto ustackbottom
	OSPAGESIZE // length
	USTACKS // startva
	process@ // processobject
	0 // pageprotection
	0 // flags
	MmAllocateProcessObject ok! ustackbottom!

	while (1)
		if (ok@ ~~)
			// try to allocate the stack right after the guard page

			USTACKSZ // length
			ustackbottom@ OSPAGESIZE + // startva
			process@ // processobject
			ACCESS_READ ACCESS_WRITE | // pageprotection
			OSMAPFLAG_FIXEDADDRESS // flags
			MmAllocateProcessObject ok! drop

			if (ok@)
				// didn't work. deallocate guard page and retry anywhere

				OSPAGESIZE // length
				ustackbottom@ // vaddr
				process@ // processobject
				MmUnmapViewProcess drop

				continue
			end

			1 thread@ PsThread_StackHasGuardPage + !

			OSPAGESIZE ustackbottom +=
		end else
			// something broke, just allocate the stack anywhere

			USTACKSZ // length
			USTACKS // startva
			process@ // processobject
			ACCESS_READ ACCESS_WRITE | // pageprotection
			0 // flags
			MmAllocateProcessObject ok! ustackbottom!
		end

		break
	end

	if (ok@)
		// failed, deallocate TEB

		OSThreadEnvironmentBlock_SIZEOF // length
		uteb@ // vaddr
		process@ // processobject
		MmUnmapViewProcess drop

		return
	end

	ustackbottom@ thread@ PsThread_StackBottom + !
	ustackbottom@ USTACKSZ + thread@ PsThread_StackTop + !

	uteb@ thread@ PsThread_UTEB + !
end

fn MmThreadUninitialize { thread -- ok }
	auto process
	thread@ KeThread_Process + @ process!

	// deallocate TEB
	OSThreadEnvironmentBlock_SIZEOF // length
	thread@ PsThread_UTEB + @ // vaddr
	process@ // processobject
	MmUnmapViewProcess drop

	// unmap usermode stack

	if (thread@ PsThread_StackHasGuardPage + @)
		PAGESIZE // length
		thread@ PsThread_StackBottom + @ PAGESIZE - // vaddr
		process@ // processobject
		MmUnmapViewProcess drop
	end

	USTACKSZ // length
	thread@ PsThread_StackBottom + @ // vaddr
	process@ // processobject
	MmUnmapViewProcess ok!
end