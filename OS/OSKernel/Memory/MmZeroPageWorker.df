//
// Implements the zero page worker thread.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "MmInternal.h"

var MiOkToUnwire 0
public MiOkToUnwire

fn MmZeroPageWorker { -- }
	// The fate of the idle thread is to endlessly spin and check for page
	// frames in the free list. If it finds any, it zeroes them out and places
	// them on the zero list. If it doesn't, it halts the processor until next
	// interrupt.

	1 MiOkToUnwire!

	while (1)
		if (MiFreeListCount@ MiZeroingThreshold@ >=)
			// More than 150 pages have accumulated on the free list.
			// Zero them out and place them on the zeroed list.

			MiZeroFreePages
		end

		HALCPUHalt
	end
end

fn MiZeroFreePages { -- }
	auto listhead
	auto listtail
	auto count

	auto pooladdr
	MiZeroingPage@ pooladdr!

	auto pteaddr
	pooladdr@ MmVirtualtoPTEAddress pteaddr!

	// We grab the entire free list, zero it out, then insert it at once onto
	// the zeroed list. This has a small risk of starving people for free
	// pages, but they will just block, and when they've all blocked, we will
	// get a chance to finish, so that situation is self-limiting.

	auto rs
	HALCPUInterruptDisable rs!

	MiFreeListCount@ count!

	if (count@ MiZeroingThreshold@ <)
		rs@ HALCPUInterruptRestore

		return
	end

	if (MmAvailablePageCount@ count@ - MMNORMALTHRESH 16 + <)
		rs@ HALCPUInterruptRestore

		return
	end

	MiPageFreeListHead@ listhead!
	0 MiPageFreeListHead!

	0 MiFreeListCount!
	count@ MmAvailablePageCount -=

	rs@ HALCPUInterruptRestore

	if (count@ ~~)
		return
	end

	auto pfdbe
	listhead@ pfdbe!

	while (pfdbe@)
		// Map the page.

		pfdbe@ MiPageFrameDatabase@ - MiPageFrameEntry_SIZEOF / PAGESHIFT << // phyaddr
		PTE_V PTE_W | PTE_NC | // flags
		pteaddr@ // pteaddr
		MiPTEUpdate drop drop

		// Zero it out.

		pooladdr@ // ptr
		PAGESIZE // size
		0 // word
		memset

		// Get a new one and loop.

		pfdbe@ listtail!
		pfdbe@ MiPageFrameEntryFree_Next + @ pfdbe!
	end

#ifdef XRSTATION
	// We mapped the pages noncached, so we have to flush the data cache.
	// We do this once instead of continuously trashing the cache the whole
	// time we zero out pages. The value of doing it this way should be
	// carefully re-assessed when moving to MP systems, where this may do an
	// IPI and/or kill multiple levels of cache.

	HALDcacheExpunge
#endif

	// Place all the pages on the zeroed list at once and update the events
	// appropriately.

	HALCPUInterruptDisable rs!

	MiPageZeroListHead@ listtail@ MiPageFrameEntryFree_Next + !
	listhead@ MiPageZeroListHead!

	count@ MmAvailablePageCount +=
	count@ MiZeroListCount +=

	rs@ HALCPUInterruptRestore

	// Make sure that the page available events are signalled correctly.

	if (MmAvailablePageCount@ MMNORMALTHRESH >=)
		if (MiPageAvailableEvent KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			0 // priboost
			MiPageAvailableEvent // event
			KeEventSignal
		end
	end elseif (MiMustSucceedEvent KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
		0 // priboost
		MiMustSucceedEvent // event
		KeEventSignal
	end
end