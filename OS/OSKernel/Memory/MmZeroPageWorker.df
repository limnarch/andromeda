//
// Implements the zero page worker thread.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "MmInternal.h"

var MiOkToUnwire 0
public MiOkToUnwire

fn MmZeroPageWorker { -- }
	// the fate of the idle thread is to endlessly spin and check for page
	// frames in the free list. if it finds any, it zeroes them out and places
	// them on the zero list. if it doesn't, it halts the processor until next
	// interrupt.

	1 MiOkToUnwire!

	auto pooladdr
	MiThreadGetPoolAddress pooladdr!

	auto pteaddr
	pooladdr@ // vaddr
	MmVirtualtoPTEAddress pteaddr!

	while (1)
		auto pfdbe
		MiPageFreeListHead@ pfdbe!

		if (pfdbe@)
			// there's a page, zero it

			auto rs
			HALCPUInterruptDisable rs!

			MiPageFreeListHead@ pfdbe!

			// make sure the free list didnt become empty in that brief timespan

			if (pfdbe@ ~~)
				rs@ HALCPUInterruptRestore

				continue
			end

			// yoink off the list

			pfdbe@ MiPageFrameEntryFree_Next + @ MiPageFreeListHead!
			0 pfdbe@ MiPageFrameEntryFree_Next + !

			1 MmPageFreeCount -=

			rs@ HALCPUInterruptRestore

			pfdbe@ MiPageFrameDatabase@ - MiPageFrameEntry_SIZEOF / PAGESHIFT << // phyaddr
			PTE_V PTE_W | // flags
			pteaddr@ // pteaddr
			MiPTEUpdate drop drop

			// zero out this page frame

			pooladdr@ // ptr
			PAGESIZE // size
			0 // word
			memset

			HALCPUInterruptDisable rs!

			// place on zero list

			MiPageZeroListHead@ pfdbe@ MiPageFrameEntryFree_Next + !
			pfdbe@ MiPageZeroListHead!

			1 MmPageFreeCount +=

			auto ipl

			if (MmPageFreeCount@ MmEvictablePageCount@ + MMNORMALTHRESH ==)
				IPLDPC KeIPLRaise ipl!
				rs@ HALCPUInterruptRestore

				0 // priboost
				MiEventPageAvailable // event
				KeEventSignal

				ipl@ KeIPLLower
			end elseif (MmPageFreeCount@ MmEvictablePageCount@ + MMNORMALTHRESH <)
				IPLDPC KeIPLRaise ipl!
				rs@ HALCPUInterruptRestore

				0 // priboost
				MiEventMSPageAvailable // event
				KeEventSignal

				ipl@ KeIPLLower
			end else
				rs@ HALCPUInterruptRestore
			end
		end else
			// there are no free list pages for now, halt

			HALCPUHalt
		end
	end
end