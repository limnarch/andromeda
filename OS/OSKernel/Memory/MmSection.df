//
// Implements the executive section object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMSECTIONMULTILEVELTHRESHOLD 0x200000

fn (ObTypeDeleteFunction) MmSectionObjectDelete { object -- }
	fnsection "PAGE$text"

	// free all associated page frames (in main memory and in swap).

	auto anonsize
	object@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (anonsize@ ~~)
			"MmSectionObjectDelete: anonymous section had no anonsize\n" KeCrash
		end
	end

	auto quotablock
	object@ MmSection_QuotaBlock + @ quotablock!

	if (DEBUGCHECKS)
		if (quotablock@ ~~)
			"MmSectionObjectDelete: no quotablock\n" KeCrash
		end
	end

	// walk the prototype page tables and free all pages, in swap or in
	// RAM. then free the prototype page tables.

	auto multilevel
	anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

	auto ppt
	object@ MmSection_AnonPrototypePageTable + @ ppt!

	auto ipl

	if (ppt@)
		auto ppte

		auto count

		auto rs

		if (multilevel@)
			PAGESIZE 2 >> count!

			// iterate top level table
			while (count@)
				auto ppde
				ppt@@ ppde!

				if (ppde@)
					ppde@ // ppt
					PAGESIZE 2 >> // count
					MmSectionDeletePPT

					ppde@ MmFree
				end

				4 ppt +=
				1 count -=
			end
		end else
			ppt@ // ppt
			anonsize@ PAGESHIFT >> // count
			MmSectionDeletePPT
		end

		object@ MmSection_AnonPrototypePageTable + @ MmFree
	end

	anonsize@ // charge
	quotablock@ // quota
	MmQuotaBlockUnchargeVM

	quotablock@ MmQuotaBlockDereference

	object@ MmSection_Mutex + @ MmFree
end

fn MmSectionDeletePPT { ppt count -- }
	while (count@)
		0 // deletepte
		ppt@ // pteaddr
		0 // vaddr
		0 // process
		MmAnonymousPageDeleteByPTE

		4 ppt +=
		1 count -=
	end
end

fn MmSectionPPTLock { sectionobject -- ok }
	fnsection "PAGE$text"

	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	sectionobject@ MmSection_Mutex + @ // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTTryLock { sectionobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	sectionobject@ MmSection_Mutex + @ // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTUnlock { sectionobject -- }
	fnsection "PAGE$text"

	0 // abandon
	sectionobject@ MmSection_Mutex + @ // mutex
	KeMutexRelease drop
end

fn MmSectionCreateObject { pageprotection anonsize permissions name -- sectionobject ok }
	fnsection "PAGE$text"

	if (anonsize@ ~~)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	auto quotablock
	KeProcessCurrent PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	// round up to next page boundary
	anonsize@ PAGEOFFSETMASK + PAGENUMBERMASK & anonsize!

	if (anonsize@ ~~)
		// overflowed
		STATUS_OVERFLOW ok!

		return
	end

	if (pageprotection@ PAGEACCESS_WRITECOPY &)
		if (pageprotection@ PAGEACCESS_WRITE &)
			STATUS_INVALID_ARGUMENT ok!

			return
		end
	end

	// no quotabias -- PPT size is limited by VM quota already.

	name@ // name
	0 // flags
	permissions@ // permissions
	KeMutex_SIZEOF // npquotabias
	0 // pquotabias
	MmSection_SIZEOF // bodysize
	MmSectionObjectType@ // type
	ObObjectCreate ok! sectionobject!

	if (ok@)
		return
	end

	pageprotection@ sectionobject@ MmSection_PageProtection + !
	anonsize@ sectionobject@ MmSection_AnonSize + !
	0 sectionobject@ MmSection_AnonPrototypePageTable + !
	0 sectionobject@ MmSection_NoCommit + !
	0 sectionobject@ MmSection_QuotaBlock + !

	auto mutex
	KeMutex_SIZEOF // bytes
	'SeMu' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! mutex!

	if (ok@)
		sectionobject@ ObObjectDeallocate

		return
	end

	"MmSectionPrototypePageTableMutex" // name
	KERNELMODE // mode
	mutex@ // mutex
	KeMutexInitialize

	mutex@ sectionobject@ MmSection_Mutex + !

	anonsize@ // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		sectionobject@ ObObjectDeallocate

		mutex@ MmFree

		return
	end

	quotablock@ sectionobject@ MmSection_QuotaBlock + !
	quotablock@ MmQuotaBlockReference
end

fn MmSectionCreate { pageprotection anonsize permissions name -- sectionhandle ok }
	fnsection "PAGE$text"

	auto access
	auto sectionobject

	pageprotection@ // pageprotection
	anonsize@ // anonsize
	permissions@ // permissions
	name@ // name
	MmSectionCreateObject ok! sectionobject!

	if (ok@)
		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	sectionobject@ // object
	ObObjectOpen ok! sectionhandle!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end
end

fn MmSectionPageGet { pri sectionoffset sectionobject -- phyaddr pfdbe ok }
	// get specified page frame from section. will read it in if in swap, or
	// demand zero if non-existent, or just return if resident.

	if (DEBUGCHECKS)
		if (sectionobject@ MmSection_AnonSize + @ ~~)
			"MmSectionPageGet: anonsize==0\n" KeCrash
		end
	end

	sectionobject@ MmSectionPPTLock ok!

	if (ok@)
		return
	end

	auto anonsize
	sectionobject@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (sectionoffset@ anonsize@ >=)
			"MmSectionPageGet: offset>=anonsize\n" KeCrash
		end
	end
	
	auto multilevel
	anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

	auto ppt
	sectionobject@ MmSection_AnonPrototypePageTable + @ ppt!

	if (ppt@ ~~)
		// needs to be created

		if (multilevel@)
			// nonpaged pool respects ZEROMUST when doing page-aligned allocs
			PAGESIZE // bytes
			'mPPT' // tag
			ZEROMUST CANBLOCK | pri@ | // flags
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end
		end else
			// create linearly
			anonsize@ PAGESHIFT >> 2 << // bytes
			'lPPT' // tag
			CANBLOCK pri@ | // flags
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			ppt@ // ptr
			anonsize@ PAGESHIFT >> 2 << // size
			0 // word
			memset
		end

		ppt@ sectionobject@ MmSection_AnonPrototypePageTable + !
	end

	if (multilevel@)
		auto pde
		sectionoffset@ PDSHIFT >> 2 << ppt@ + pde!

		if (pde@@ ~~)
			// nonpaged pool respects ZEROMUST when doing page-aligned allocs
			PAGESIZE // bytes
			'sPPT' // tag
			ZEROMUST CANBLOCK | pri@ | // flags
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			ppt@ pde@!
		end

		pde@@ sectionoffset@ PAGESHIFT >> 2 << PAGEOFFSETMASK & + ppt!
	end else
		sectionoffset@ PAGESHIFT >> 2 << ppt +=
	end

	sectionobject@ MmSectionPPTUnlock

	auto ipl
	IPLDPC KeIPLRaise ipl!

	// ensure that referencing this page won't starve the system.

	pri@ CANBLOCK |
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	0 // dzpte
	0 // evictflag
	0 // refpfdbe
	0 // process
	pri@ // pri
	0 // vaddr
	ppt@ // pteaddr
	MmAnonymousPageReferenceByPTE ok! phyaddr! pfdbe!

	ipl@ KeIPLLower
end