//
// Implements the executive section object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMSECTIONMULTILEVELTHRESHOLD 0x200000

var MmAnonymousPageCount 0
public MmAnonymousPageCount

fn (ObTypeDeleteFunction) MmSectionObjectDelete { object -- }
	// free all associated page frames (in main memory and in swap).

	auto anonsize
	object@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (anonsize@ ~~)
			"MmSectionObjectDelete: anonymous section had no anonsize\n" KeCrash
		end
	end

	auto quotablock
	object@ MmSection_QuotaBlock + @ quotablock!

	if (DEBUGCHECKS)
		if (quotablock@ ~~)
			"MmSectionObjectDelete: no quotablock\n" KeCrash
		end
	end

	anonsize@ // charge
	quotablock@ // quota
	MmQuotaBlockUnchargeVM

	quotablock@ MmQuotaBlockDereference

	auto ok
	object@ MmSectionPPTLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmSectionObjectDelete: failed to lock PPT (%i)\n" KeCrash
		end
	end

	// walk the prototype page tables and free all pages, in swap or in
	// RAM. then free the prototype page tables.

	auto multilevel
	anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

	auto ppt
	object@ MmSection_AnonPrototypePageTable + @ ppt!

	auto ipl

	if (ppt@)
		auto ppte

		auto count

		auto rs

		if (multilevel@)
			PAGESIZE 2 >> count!

			// iterate top level table
			while (count@)
				auto ppde
				ppt@@ ppde!

				if (ppde@)
					ppde@ // ppt
					PAGESIZE 2 >> // count
					MmSectionDeletePPT

					ppde@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFree
				end

				4 ppt +=
				1 count -=
			end

			object@ MmSection_AnonPrototypePageTable + @ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFree
		end else
			ppt@ // ppt
			anonsize@ PAGESHIFT >> // count
			MmSectionDeletePPT

			object@ MmSection_AnonPrototypePageTable + @ MmFree
		end
	end

	object@ MmSectionPPTUnlock

	object@ MmSection_Mutex + @ MmFree
end

fn MmAnonymousPageDelete { ipl pfdbe -- }
	pfdbe@ MmEvictablePageReference drop
	pfdbe@ MmEvictablePageDelete

	1 MmAnonymousPageCount -=

	ipl@ KeIPLLower

	if (pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ PTE_INSWAP &)
		// free in swap
		pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ IOSwapPageFreePTE
	end

	pfdbe@ MmEvictablePageDereference drop
end

fn MmSectionDeletePPT { ppt count -- }
	while (count@)
		auto ipl
		IPLDPC KeIPLRaise ipl!

		auto ppte
		ppt@@ ppte!

		if (ppte@ PTE_V &)
			// free in RAM

			ipl@ // ipl
			ppte@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + // pfdbe
			MmAnonymousPageDelete
		end elseif (ppte@ PTE_INSWAP &)
			ipl@ KeIPLLower

			// free in swap
			ppte@ IOSwapPageFreePTE
		end else
			ipl@ KeIPLLower
		end

		4 ppt +=
		1 count -=
	end
end

fn MmSectionPPTLock { sectionobject -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	sectionobject@ MmSection_Mutex + @ // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTTryLock { sectionobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	sectionobject@ MmSection_Mutex + @ // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTUnlock { sectionobject -- }
	0 // abandon
	sectionobject@ MmSection_Mutex + @ // mutex
	KeMutexRelease drop
end

fn MmSectionObjectCreateObject { pageprotection anonsize permissions name -- sectionobject ok }
	if (anonsize@ ~~)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	auto quotablock
	KeProcessCurrent PsProcess_QuotaBlock + @ quotablock!

	// round up to next page boundary
	anonsize@ PAGEOFFSETMASK + PAGENUMBERMASK & anonsize!

	if (anonsize@ ~~)
		// overflowed
		STATUS_OVERFLOW ok!

		return
	end

	if (pageprotection@ PAGEACCESS_WRITECOPY &)
		if (pageprotection@ PAGEACCESS_WRITE &)
			STATUS_INVALID_ARGUMENT ok!

			return
		end
	end

	// no quotabias -- PPT size is limited by VM quota already.

	name@ // name
	0 // flags
	permissions@ // permissions
	KeMutex_SIZEOF // npquotabias
	0 // pquotabias
	MmSection_SIZEOF // bodysize
	MmSectionObjectType@ // type
	ObObjectCreate ok! sectionobject!

	if (ok@)
		return
	end

	pageprotection@ sectionobject@ MmSection_PageProtection + !
	anonsize@ sectionobject@ MmSection_AnonSize + !
	0 sectionobject@ MmSection_AnonPrototypePageTable + !
	0 sectionobject@ MmSection_NoCommit + !
	0 sectionobject@ MmSection_QuotaBlock + !

	auto mutex
	KeMutex_SIZEOF // bytes
	'SeMu' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! mutex!

	if (ok@)
		sectionobject@ ObObjectDeallocate

		return
	end

	"MmSectionPrototypePageTableMutex" // name
	KERNELMODE // mode
	mutex@ // mutex
	KeMutexInitialize

	mutex@ sectionobject@ MmSection_Mutex + !

	anonsize@ // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		sectionobject@ ObObjectDeallocate

		mutex@ MmFree

		return
	end

	quotablock@ sectionobject@ MmSection_QuotaBlock + !
	quotablock@ MmQuotaBlockReference
end

fn MmSectionObjectCreate { pageprotection anonsize permissions name -- sectionhandle ok }
	auto access
	auto sectionobject

	pageprotection@ // pageprotection
	anonsize@ // anonsize
	permissions@ // permissions
	name@ // name
	MmSectionObjectCreateObject ok! sectionobject!

	if (ok@)
		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	sectionobject@ // object
	ObObjectOpen ok! sectionhandle!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end
end

fn (MmEvictionFunction) MmAnonymousEvictionFunction { pfdbe -- }
	auto pte
	pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ pte!

	auto ppte
	pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ ppte!

	auto ef
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb ef!

	pte@ ppte@!

	auto ptpfdbe

	if (ef@ MMEVICTFLAG_PRIVATE &)
		if (pfdbe@ MmPageFrameEntryAnonymous_Process + @ PsSystemProcess@ ~=)
			// dereference the page table.

			ppte@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + ptpfdbe!

			if (pte@ SWAPPTE_DEMANDZERO ==)
				// let it be known that this IF statement was the fix to a bug
				// that took me 2 weeks to resolve.

				1 // deref
				ppte@ // pteaddr
				pfdbe@ MmPageFrameEntryAnonymous_VirtualAddress + @ // vaddr
				pfdbe@ MmPageFrameEntryAnonymous_Process + @ // process
				MmPTEDelete drop
			end else
				ptpfdbe@ MmEvictablePageDereference drop
			end
		end
	end elseif (ef@ MMEVICTFLAG_PAGETABLE &)
		ppte@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + ptpfdbe!
		ptpfdbe@ MmEvictablePageDereference drop
	end

	1 MmAnonymousPageCount -=
end

fn MmAnonymousPageGet { pte pri -- pfdbe pfn ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousPageGet: ipl != IPLDPC\n" KeCrash
		end
	end

	// caller must set COW flag in pfdbe if applicable.

	// caller must also set MMEVICTFLAG_MODIFIED and set SwapPageNumber to
	// MMSWAPPAGE_NONE if this isn't a demand-zero page.

	MMEVICTFLAG_WORKINGSET // flags
	MMEVICTTYPE_ANON // evictabletype
	pri@ // priority
	MmEvictablePageGet ok! pfn! pfdbe!

	if (ok@)
		return
	end

	SWAPPTE_DEMANDZERO pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

	pte@ pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + !

	auto rs
	HALCPUInterruptDisable rs!
	1 MmAnonymousPageCount +=
	rs@ HALCPUInterruptRestore
end

fn MmAnonymousPageAlloc { pte pri -- pfdbe pfn ok }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	pri@ CANBLOCK |
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	pte@ pri@ MmAnonymousPageGet ok! pfn! pfdbe!

	ipl@ KeIPLLower
end

fn MmAnonymousSwapIn { pri pte pno -- pfdbe pfn ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousSwapIn: ipl != IPLDPC\n" KeCrash
		end
	end

	pte@ // pte
	pri@ FREEFIRST | // pri
	MmAnonymousPageGet ok! pfn! pfdbe!

	IPLLOW KeIPLLower

	if (ok@)
		return
	end

	auto kflags
	IOKFLAG_PAGEIN kflags!

	if (pri@ TRYFOREVER &)
		IOKFLAG_SWAPIN kflags |=
	end

	kflags@ // kflags
	pfn@ PAGESHIFT << IDENTITYSPACE | // pageframe
	pte@@ // pte
	IOSwapPageReadPTE ok!

	if (ok@)
		auto ipl
		IPLDPC KeIPLRaise ipl!

		pfdbe@ MmEvictablePageDereference drop

		ipl@ // ipl
		pfdbe@ // pfdbe
		MmAnonymousPageDelete

		return
	end

	pte@@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
end

fn MmSectionPageGet { pri sectionoffset sectionobject -- phyaddr pfdbe ok }
	// get specified page frame from section. will read it in if in swap, or
	// demand zero if non-existent, or just return if resident.

	if (DEBUGCHECKS)
		if (sectionobject@ MmSection_AnonSize + @ ~~)
			"MmSectionPageGet: anonsize==0\n" KeCrash
		end
	end

	sectionobject@ MmSectionPPTLock ok!

	if (ok@)
		return
	end

	auto anonsize
	sectionobject@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (sectionoffset@ anonsize@ >=)
			"MmSectionPageGet: offset>=anonsize\n" KeCrash
		end
	end
	
	auto multilevel
	anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

	auto ppt
	sectionobject@ MmSection_AnonPrototypePageTable + @ ppt!

	if (ppt@ ~~)
		// needs to be created

		if (multilevel@)
			ZEROMUST CANBLOCK | pri@ | // priority
			MmPageAlloc ok! ppt! drop

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			PAGESHIFT ppt <<=
			IDENTITYSPACE ppt |=
		end else
			// create linearly
			anonsize@ PAGESHIFT >> 2 << // bytes
			'lPPT' // tag
			CANBLOCK POOLALLOC | pri@ | // flags
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			ppt@ // ptr
			anonsize@ PAGESHIFT >> 2 << // size
			0 // word
			memset
		end

		ppt@ sectionobject@ MmSection_AnonPrototypePageTable + !
	end

	if (multilevel@)
		auto pde
		sectionoffset@ PDSHIFT >> 2 << ppt@ + pde!

		if (pde@@ ~~)
			ZEROMUST CANBLOCK | pri@ | // priority
			MmPageAlloc ok! ppt! drop

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			PAGESHIFT ppt <<=
			IDENTITYSPACE ppt |=

			ppt@ pde@!
		end

		pde@@ sectionoffset@ PAGESHIFT >> 2 << PAGEOFFSETMASK & + ppt!
	end else
		sectionoffset@ PAGESHIFT >> 2 << ppt +=
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	// ensure that referencing this page won't starve the system.

	pri@ CANBLOCK |
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		sectionobject@ MmSectionPPTUnlock
		return
	end

	auto ppte
	ppt@@ ppte!

	if (ppte@ PTE_V &)
		// already present, return

		ppte@ PAGENUMBERMASK & phyaddr!
		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end elseif (ppte@ ~~)
		// non-existent, demand zero

		ppt@ // pte
		ZEROMUST pri@ | // pri
		MmAnonymousPageGet ok! phyaddr! pfdbe!

		ipl@ KeIPLLower

		if (ok@)
			sectionobject@ MmSectionPPTUnlock
			return
		end

		PAGESHIFT phyaddr <<=

		phyaddr@ PTE_V | ppt@!
	end elseif (ppte@ PTE_INSWAP &)
		// swapped out, bring back in

		pri@ // pri
		ppt@ // pte
		ppte@ PAGESHIFT >> // pno
		MmAnonymousSwapIn ok! phyaddr! pfdbe!

		if (ok@)
			sectionobject@ MmSectionPPTUnlock
			return
		end

		PAGESHIFT phyaddr <<=

		phyaddr@ PTE_V | ppt@!
	end elseif (DEBUGCHECKS)
		"MmSectionPageGet: unreachable\n" KeCrash
	end

	sectionobject@ MmSectionPPTUnlock
end