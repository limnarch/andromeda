//
// Implements the executive section object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMSECTIONMULTILEVELTHRESHOLD 0x200000

var MmAnonymousPageCount 0
public MmAnonymousPageCount

fn (ObTypeDeleteFunction) MmSectionObjectDelete { object -- }
	// if anonymous, free all associated page frames (in main memory and in swap).
	// if memory-mapped file, dereference the file object.

	auto fileobject
	object@ MmSection_FileObject + @ fileobject!

	auto anonsize
	object@ MmSection_AnonSize + @ anonsize!

	if (fileobject@)
		// file-backed

		if (DEBUGCHECKS)
			if (anonsize@)
				"MmSectionObjectDelete: file-backed section had anonsize\n" KeCrash
			end
		end

		fileobject@ ObObjectDereferenceByPointer drop
	end else
		// anonymous

		if (DEBUGCHECKS)
			if (anonsize@ ~~)
				"MmSectionObjectDelete: anonymous section had no anonsize\n" KeCrash
			end
		end

		auto quotablock
		object@ MmSection_QuotaBlock + @ quotablock!

		if (DEBUGCHECKS)
			if (quotablock@ ~~)
				"MmSectionObjectDelete: no quotablock\n" KeCrash
			end
		end

		anonsize@ // charge
		quotablock@ // quota
		MmQuotaBlockUnchargeVM

		quotablock@ MmQuotaBlockDereference

		auto ok
		object@ MmSectionPPTLock ok!

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "MmSectionObjectDelete: failed to lock PPT (%i)\n" KeCrash
			end
		end

		// walk the prototype page tables and free all pages, in swap or in
		// RAM. then free the prototype page tables.

		auto multilevel
		anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

		auto ppt
		object@ MmSection_AnonPrototypePageTable + @ ppt!

		auto ipl

		if (ppt@)
			auto ppte

			auto count

			auto rs

			if (multilevel@)
				PAGESIZE 2 >> count!

				// iterate top level table
				while (count@)
					auto ppde
					ppt@@ ppde!

					if (ppde@)
						ppde@ // ppt
						PAGESIZE 2 >> // count
						MmSectionDeletePPT

						ppde@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFree
					end

					4 ppt +=
					1 count -=
				end

				object@ MmSection_AnonPrototypePageTable + @ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFree
			end else
				ppt@ // ppt
				anonsize@ PAGESHIFT >> // count
				MmSectionDeletePPT

				object@ MmSection_AnonPrototypePageTable + @ MmFree
			end
		end

		object@ MmSectionPPTUnlock
	end
end

fn MmSectionDeletePPT { ppt count -- }
	while (count@)
		auto ipl
		IPLDPC KeIPLRaise ipl!

		auto ppte
		ppt@@ ppte!

		if (ppte@ PTE_V &)
			// free in RAM

			auto pfdbe
			ppte@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

			if (DEBUGCHECKS)
				if (pfdbe@ MmPageFrameEntryEvictable_References + @)
					pfdbe@ MmPageFrameEntryEvictable_References + @
					"MmSectionDeletePPT: 2 tried to delete page with %d references\n" KeCrash
				end
			end

			pfdbe@ MmEvictablePageRemoveForDeletion
			1 MmAnonymousPageCount -=

			ipl@ KeIPLLower

			if (pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + @ 0 s>=)
				// free in swap
				pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + @ IOSwapPageFree
			end

			ppte@ PAGESHIFT >> MmPageFree
		end elseif (ppte@ PTE_INSWAP &)
			ipl@ KeIPLLower

			// free in swap
			ppte@ PAGESHIFT >> IOSwapPageFree
		end else
			ipl@ KeIPLLower
		end

		4 ppt +=
		1 count -=
	end
end

fn MmSectionPPTLock { sectionobject -- ok }
	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	sectionobject@ MmSection_PrototypePageTableMutex + // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTTryLock { sectionobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	sectionobject@ MmSection_PrototypePageTableMutex + // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTUnlock { sectionobject -- }
	0 // abandon
	sectionobject@ MmSection_PrototypePageTableMutex + // mutex
	KeMutexRelease drop
end

fn MmSectionObjectCreateObject { pageprotection anonsize fileobject permissions name -- sectionobject ok }
	auto fcb

	auto quotablock
	KeProcessCurrent PsProcess_QuotaBlock + @ quotablock!

	if (anonsize@)
		if (fileobject@)
			STATUS_INVALID_ARGUMENT ok!

			return
		end

		// round up to next page boundary
		anonsize@ PAGEOFFSETMASK + PAGENUMBERMASK & anonsize!

		if (anonsize@ ~~)
			// overflowed
			STATUS_OVERFLOW ok!

			return
		end

		if (pageprotection@ PAGEACCESS_WRITECOPY &)
			if (pageprotection@ PAGEACCESS_WRITE &)
				STATUS_INVALID_ARGUMENT ok!

				return
			end
		end
	end elseif (fileobject@)
		fileobject@ IOFile_FileControlBlock + @ fcb!

		if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ==)
			STATUS_IS_A_DIRECTORY ok!

			return
		end

		if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
			// character devices need a GetPageAddress function to be mappable

			if (fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_GetPageAddress + @ ~~)
				STATUS_NOT_SUPPORTED ok!

				return
			end
		end
	end else
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	// no quotabias -- PPT size is limited by VM quota already.

	name@ // name
	0 // flags
	permissions@ // permissions
	0 // quotabias
	MmSection_SIZEOF // bodysize
	MmSectionObjectType@ // type
	ObObjectCreate ok! sectionobject!

	if (ok@)
		return
	end

	pageprotection@ sectionobject@ MmSection_PageProtection + !
	fileobject@ sectionobject@ MmSection_FileObject + !
	anonsize@ sectionobject@ MmSection_AnonSize + !
	0 sectionobject@ MmSection_AnonPrototypePageTable + !
	0 sectionobject@ MmSection_NoCommit + !
	0 sectionobject@ MmSection_QuotaBlock + !

	"MmSectionPrototypePageTableMutex" // name
	KERNELMODE // mode
	sectionobject@ MmSection_PrototypePageTableMutex + // mutex
	KeMutexInitialize

	if (fileobject@)
		// memory-mapped file. ref the file object and force caching.

		fileobject@ ObObjectReferenceByPointer drop

		if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ~=)
			if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
				1 // wantcaching
				fcb@ // fcb
				IOFileControlBlockCacheCheck ok! drop

				if (ok@)
					// failed to initialize caching

					sectionobject@ ObObjectDeallocate

					return
				end
			end
		end else
			1 sectionobject@ MmSection_NoCommit + !
		end
	end else
		anonsize@ // charge
		quotablock@ // quotablock
		MmQuotaBlockChargeVM ok!

		if (ok@)
			sectionobject@ ObObjectDeallocate

			return
		end

		quotablock@ sectionobject@ MmSection_QuotaBlock + !
		quotablock@ MmQuotaBlockReference
	end
end

fn MmSectionObjectCreate { pageprotection anonsize filehandle permissions name -- sectionhandle ok }
	auto access
	auto fileobject
	0 fileobject!

	if (filehandle@ OSNONE ~=)
		IOFileTypeObject@ // type
		filehandle@ // handle
		ObObjectReferenceByHandle ok! fileobject! access!

		if (ok@)
			return
		end

		access@ // access
		pageprotection@ ACCESS_ALL & // permission
		SeCheckAccess ok!

		if (ok@)
			fileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end

	auto sectionobject

	pageprotection@ // pageprotection
	anonsize@ // anonsize
	fileobject@ // fileobject
	permissions@ // permissions
	name@ // name
	MmSectionObjectCreateObject ok! sectionobject!

	if (filehandle@ OSNONE ~=)
		fileobject@ ObObjectDereferenceByPointer drop
	end

	if (ok@)
		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	sectionobject@ // object
	ObObjectOpen ok! sectionhandle!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end
end

table MmAnonymousEvictableFunctions
	pointerof MmAnonymousEvictionFunction // EvictionFunc
	0 // ReferenceFunc
	0 // DereferenceFunc
	pointerof MmAnonymousWriteFunction // WriteModifiedFunc
	0 // Reserved2
	0 // Reserved3
	0 // Reserved4
	0 // Reserved5
endtable
public MmAnonymousEvictableFunctions

fn (MmWriteModifiedFunction) MmAnonymousWriteFunction { pfdbe -- written dropped ok }
	0 written!
	0 dropped!
	0 ok!

	if (DEBUGCHECKS)
		if (pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + @ MMSWAPPAGE_NONE ~=)
			"MmAnonymousWriteFunction: swap page exists\n" KeCrash
		end
	end

	MMEVICTFLAG_MODIFIED ~ pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + &=

	IPLLOW KeIPLLower

	1 dropped!

	auto pno
	pfdbe@ MmPageFrameEntry_PFN + @ PAGESHIFT << IDENTITYSPACE | // pageframe
	IOSwapPageWrite ok! pno!

	IPLDPC KeIPLRaise drop

	if (ok@ ~~)
		// swapout worked
		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + @ MMEVICTFLAG_MODIFIED & ~~)
			// still not modified
			pno@ pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + !
			1 written!
		end else
			// was modified, free the swap page we just put hard work into
			// writing!
			pno@ IOSwapPageFree
		end
	end
end

fn (MmEvictionFunction) MmAnonymousEvictionFunction { pfdbe -- }
	auto pno
	pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + @ pno!

	if (DEBUGCHECKS)
		if (pno@ MMSWAPPAGE_NONE ==)
			"MmAnonymousEvictionFunction: no swap page\n" KeCrash
		end
	end

	auto ppte
	pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ ppte!

	if (pno@ MMSWAPPAGE_DEMANDZERO ==)
		// was an undirtied demand-zero page.
		// simply discard it.
		0 ppte@!
	end else
		pno@ PAGESHIFT << PTE_INSWAP | ppte@!
	end

	1 MmAnonymousPageCount -=
end

fn MmAnonymousPageModify { pfdbe process -- }
	auto pno

	auto rs
	HALCPUInterruptDisable rs!
	pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + @ pno!
	MMSWAPPAGE_NONE pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + !
	MMEVICTFLAG_MODIFIED pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + |=
	rs@ HALCPUInterruptRestore

	HALCPUInterruptDisable rs!
	1 process@ PsProcess_ModifiedPages + +=
	rs@ HALCPUInterruptRestore

	if (pno@ 0 s<)
		// nothing to do
		return
	end

	pno@ IOSwapPageFree
end

fn MmAnonymousPageAlloc { pte pri -- pfdbe pfn ok }
	// caller must set COW flag in pfdbe if applicable.

	// caller must also set MMEVICTFLAG_MODIFIED and set SwapPageNumber to
	// MMSWAPPAGE_NONE if this isn't a demand-zero page.

	MMEVICTFLAG_WORKINGSET // flags
	MmAnonymousEvictableFunctions // evictablefuncs
	pri@ CANBLOCK | // priority
	MmEvictablePageAlloc ok! pfn! pfdbe!

	if (ok@)
		return
	end

	MMSWAPPAGE_DEMANDZERO pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + !
	pte@ pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + !

	auto rs
	HALCPUInterruptDisable rs!
	1 MmAnonymousPageCount +=
	rs@ HALCPUInterruptRestore
end

fn MmAnonymousSwapIn { pte pno -- pfdbe pfn ok }
	pte@ // pte
	FREEFIRST // pri
	MmAnonymousPageAlloc ok! pfn! pfdbe!

	if (ok@)
		return
	end

	pfn@ PAGESHIFT << IDENTITYSPACE | // pageframe
	pno@ // pno
	IOSwapPageRead ok!

	if (ok@)
		pfn@ MmPageFree

		return
	end

	pno@ pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + !
	MMEVICTFLAG_MODIFIED ~ pfdbe@ MmPageFrameEntryEvictable_EvictionFlags + &=
end

fn MmSectionPageGet { sectionoffset sectionobject -- phyaddr pfdbe ok }
	// get specified page frame from section. will read it in if in swap, or
	// demand zero if non-existent, or just return if resident.

	if (DEBUGCHECKS)
		if (sectionobject@ MmSection_AnonSize + @ ~~)
			"MmSectionPageGet: anonsize==0\n" KeCrash
		end
	end

	sectionobject@ MmSectionPPTLock ok!

	if (ok@)
		return
	end

	auto anonsize
	sectionobject@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (sectionoffset@ anonsize@ >=)
			"MmSectionPageGet: offset>=anonsize\n" KeCrash
		end
	end
	
	auto multilevel
	anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

	auto ppt
	sectionobject@ MmSection_AnonPrototypePageTable + @ ppt!

	if (ppt@ ~~)
		// needs to be created

		if (multilevel@)
			ZEROMUST CANBLOCK | // priority
			MmPageAlloc ok! ppt! drop

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			PAGESHIFT ppt <<=
			IDENTITYSPACE ppt |=
		end else
			// create linearly
			anonsize@ PAGESHIFT >> 2 << // bytes
			'lPPT' // tag
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			ppt@ // ptr
			anonsize@ PAGESHIFT >> 2 << // size
			0 // word
			memset
		end

		ppt@ sectionobject@ MmSection_AnonPrototypePageTable + !
	end

	if (multilevel@)
		auto pde
		sectionoffset@ PDSHIFT >> 2 << ppt@ + pde!

		if (pde@@ ~~)
			ZEROMUST CANBLOCK | // priority
			MmPageAlloc ok! ppt! drop

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			PAGESHIFT ppt <<=
			IDENTITYSPACE ppt |=

			ppt@ pde@!
		end

		pde@@ sectionoffset@ PAGESHIFT >> 2 << PAGEOFFSETMASK & + ppt!
	end else
		sectionoffset@ PAGESHIFT >> 2 << ppt +=
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto ppte
	ppt@@ ppte!

	if (ppte@ PTE_V &)
		// already present, return

		ppte@ PAGENUMBERMASK & phyaddr!
		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end elseif (ppte@ ~~)
		ipl@ KeIPLLower

		// non-existent, demand zero

		ppt@ // pte
		ZEROMUST // pri
		MmAnonymousPageAlloc ok! phyaddr! pfdbe!

		if (ok@)
			sectionobject@ MmSectionPPTUnlock
			return
		end

		PAGESHIFT phyaddr <<=

		phyaddr@ PTE_V | ppt@!
	end elseif (ppte@ PTE_INSWAP &)
		ipl@ KeIPLLower

		// swapped out, bring back in

		ppt@ // pte
		ppte@ PAGESHIFT >> // pno
		MmAnonymousSwapIn ok! phyaddr! pfdbe!

		if (ok@)
			sectionobject@ MmSectionPPTUnlock
			return
		end

		PAGESHIFT phyaddr <<=

		phyaddr@ PTE_V | ppt@!
	end elseif (DEBUGCHECKS)
		"MmSectionPageGet: unreachable\n" KeCrash
	end

	sectionobject@ MmSectionPPTUnlock
end