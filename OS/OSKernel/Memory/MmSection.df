//
// Implements the executive section object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn (ObTypeDeleteFunction) MmSectionObjectDelete { object -- }
	fnsection "PAGE$text"

	// free all associated page frames (in main memory and in swap).

	auto anonsize
	object@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (anonsize@ ~~)
			"MmSectionObjectDelete: anonymous section had no anonsize\n" KeCrash
		end
	end

	auto quotablock
	object@ MmSection_QuotaBlock + @ quotablock!

	if (DEBUGCHECKS)
		if (quotablock@ ~~)
			"MmSectionObjectDelete: no quotablock\n" KeCrash
		end
	end

	// walk the prototype page tables and free all pages, in swap or in
	// RAM. then free the prototype page tables.

	auto count
	anonsize@ PAGESHIFT >> count!

	auto ppt
	object@ MmSection_SIZEOF + ppt!

	while (count@)
		0 // deletepte
		ppt@ // pteaddr
		0 // vaddr
		0 // process
		MmAnonymousPageDeleteByPTE

		4 ppt +=
		1 count -=
	end

	anonsize@ // charge
	quotablock@ // quota
	MmQuotaBlockUnchargeVM

	quotablock@ MmQuotaBlockDereference
end

fn MmSectionCreateObject { pageprotection anonsize permissions name -- sectionobject ok }
	fnsection "PAGE$text"

	if (anonsize@ ~~)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	auto quotablock
	KeProcessCurrent PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	// round up to next page boundary
	anonsize@ PAGEOFFSETMASK + PAGENUMBERMASK & anonsize!

	if (anonsize@ ~~)
		// overflowed
		STATUS_OVERFLOW ok!

		return
	end

	if (pageprotection@ PAGEACCESS_WRITECOPY &)
		if (pageprotection@ PAGEACCESS_WRITE &)
			STATUS_INVALID_ARGUMENT ok!

			return
		end
	end

	auto pptsize
	anonsize@ PAGESHIFT >> 4 * pptsize!

	name@ // name
	0 // flags
	permissions@ // permissions
	0 // npquotabias
	0 // pquotabias
	MmSection_SIZEOF pptsize@ + // bodysize
	MmSectionObjectType@ // type
	ObObjectCreate ok! sectionobject!

	if (ok@)
		return
	end

	pageprotection@ sectionobject@ MmSection_PageProtection + !
	anonsize@ sectionobject@ MmSection_AnonSize + !
	0 sectionobject@ MmSection_QuotaBlock + !

	sectionobject@ MmSection_SIZEOF + // ptr
	pptsize@ // sz
	0 // word
	memset

	anonsize@ // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		sectionobject@ ObObjectDeallocate

		return
	end

	quotablock@ sectionobject@ MmSection_QuotaBlock + !
	quotablock@ MmQuotaBlockReference
end

fn MmSectionCreate { pageprotection anonsize permissions name -- sectionhandle ok }
	fnsection "PAGE$text"

	auto access
	auto sectionobject

	pageprotection@ // pageprotection
	anonsize@ // anonsize
	permissions@ // permissions
	name@ // name
	MmSectionCreateObject ok! sectionobject!

	if (ok@)
		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	sectionobject@ // object
	ObObjectOpen ok! sectionhandle!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end
end

fn MmSectionPageGet { localpteaddr pri sectionoffset sectionobject -- phyaddr pfdbe ok }
	// get specified page frame from section. will read it in if in swap, or
	// demand zero if non-existent, or just return if resident.
	// assumes the caller did an MmPageWait already.

	auto anonsize
	sectionobject@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (anonsize@ ~~)
			"MmSectionPageGet: anonsize==0\n" KeCrash
		end

		if (sectionoffset@ anonsize@ >=)
			"MmSectionPageGet: offset>=anonsize\n" KeCrash
		end

		if (KeIPLCurrentGet IPLDPC ~=)
			"MmSectionPageGet: IPL != IPLDPC\n" KeCrash
		end
	end

	auto ppt
	sectionobject@ MmSection_SIZEOF + ppt!

	sectionoffset@ PAGESHIFT >> 2 << ppt +=

	0 // dzpte
	0 // evictflag
	0 // refpfdbe
	0 // process
	pri@ // pri
	0 // vaddr
	ppt@ // pteaddr
	localpteaddr@ // localpteaddr
	MmAnonymousPageReferenceByPTE ok! phyaddr! pfdbe!
end