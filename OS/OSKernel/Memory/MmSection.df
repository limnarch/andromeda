//
// Implements the executive section object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

const MMSECTIONMULTILEVELTHRESHOLD 0x200000

fn (ObTypeDeleteFunction) MmSectionObjectDelete { object -- }
	fnsection "PAGE$text"

	// free all associated page frames (in main memory and in swap).

	auto anonsize
	object@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (anonsize@ ~~)
			"MmSectionObjectDelete: anonymous section had no anonsize\n" KeCrash
		end
	end

	auto quotablock
	object@ MmSection_QuotaBlock + @ quotablock!

	if (DEBUGCHECKS)
		if (quotablock@ ~~)
			"MmSectionObjectDelete: no quotablock\n" KeCrash
		end
	end

	// walk the prototype page tables and free all pages, in swap or in
	// RAM. then free the prototype page tables.

	auto multilevel
	anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

	auto ppt
	object@ MmSection_AnonPrototypePageTable + @ ppt!

	auto ipl

	if (ppt@)
		auto ppte

		auto count

		auto rs

		if (multilevel@)
			PAGESIZE 2 >> count!

			// iterate top level table
			while (count@)
				auto ppde
				ppt@@ ppde!

				if (ppde@)
					ppde@ // ppt
					PAGESIZE 2 >> // count
					MmSectionDeletePPT

					ppde@ MmFree
				end

				4 ppt +=
				1 count -=
			end
		end else
			ppt@ // ppt
			anonsize@ PAGESHIFT >> // count
			MmSectionDeletePPT
		end

		object@ MmSection_AnonPrototypePageTable + @ MmFree
	end

	anonsize@ // charge
	quotablock@ // quota
	MmQuotaBlockUnchargeVM

	quotablock@ MmQuotaBlockDereference

	object@ MmSection_Mutex + @ MmFree
end

fn MmSectionDeletePPT { ppt count -- }
	while (count@)
		auto ipl
		IPLDPC KeIPLRaise ipl!

		auto ppte
		ppt@@ ppte!

		if (ppte@ PTE_V PTE_TRANSITION | &)
			// free in RAM

			ipl@ // ipl
			ppte@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + // pfdbe
			MmAnonymousPageDelete
		end elseif (ppte@ PTE_INSWAP &)
			ipl@ KeIPLLower

			// free in swap
			ppte@ IOSwapPageFreePTE
		end else
			ipl@ KeIPLLower
		end

		4 ppt +=
		1 count -=
	end
end

fn MmSectionPPTLock { sectionobject -- ok }
	fnsection "PAGE$text"

	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	sectionobject@ MmSection_Mutex + @ // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTTryLock { sectionobject -- ok }
	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	sectionobject@ MmSection_Mutex + @ // object
	KeThreadWaitForObject ok!
end

fn MmSectionPPTUnlock { sectionobject -- }
	fnsection "PAGE$text"

	0 // abandon
	sectionobject@ MmSection_Mutex + @ // mutex
	KeMutexRelease drop
end

fn MmSectionCreateObject { pageprotection anonsize permissions name -- sectionobject ok }
	fnsection "PAGE$text"

	if (anonsize@ ~~)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	auto quotablock
	KeProcessCurrent PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	// round up to next page boundary
	anonsize@ PAGEOFFSETMASK + PAGENUMBERMASK & anonsize!

	if (anonsize@ ~~)
		// overflowed
		STATUS_OVERFLOW ok!

		return
	end

	if (pageprotection@ PAGEACCESS_WRITECOPY &)
		if (pageprotection@ PAGEACCESS_WRITE &)
			STATUS_INVALID_ARGUMENT ok!

			return
		end
	end

	// no quotabias -- PPT size is limited by VM quota already.

	name@ // name
	0 // flags
	permissions@ // permissions
	KeMutex_SIZEOF // npquotabias
	0 // pquotabias
	MmSection_SIZEOF // bodysize
	MmSectionObjectType@ // type
	ObObjectCreate ok! sectionobject!

	if (ok@)
		return
	end

	pageprotection@ sectionobject@ MmSection_PageProtection + !
	anonsize@ sectionobject@ MmSection_AnonSize + !
	0 sectionobject@ MmSection_AnonPrototypePageTable + !
	0 sectionobject@ MmSection_NoCommit + !
	0 sectionobject@ MmSection_QuotaBlock + !

	auto mutex
	KeMutex_SIZEOF // bytes
	'SeMu' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! mutex!

	if (ok@)
		sectionobject@ ObObjectDeallocate

		return
	end

	"MmSectionPrototypePageTableMutex" // name
	KERNELMODE // mode
	mutex@ // mutex
	KeMutexInitialize

	mutex@ sectionobject@ MmSection_Mutex + !

	anonsize@ // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		sectionobject@ ObObjectDeallocate

		mutex@ MmFree

		return
	end

	quotablock@ sectionobject@ MmSection_QuotaBlock + !
	quotablock@ MmQuotaBlockReference
end

fn MmSectionCreate { pageprotection anonsize permissions name -- sectionhandle ok }
	fnsection "PAGE$text"

	auto access
	auto sectionobject

	pageprotection@ // pageprotection
	anonsize@ // anonsize
	permissions@ // permissions
	name@ // name
	MmSectionCreateObject ok! sectionobject!

	if (ok@)
		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	sectionobject@ // object
	ObObjectOpen ok! sectionhandle!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end
end

fn MmSectionPageGet { pri sectionoffset sectionobject -- phyaddr pfdbe ok }
	// get specified page frame from section. will read it in if in swap, or
	// demand zero if non-existent, or just return if resident.

	if (DEBUGCHECKS)
		if (sectionobject@ MmSection_AnonSize + @ ~~)
			"MmSectionPageGet: anonsize==0\n" KeCrash
		end
	end

	sectionobject@ MmSectionPPTLock ok!

	if (ok@)
		return
	end

	auto anonsize
	sectionobject@ MmSection_AnonSize + @ anonsize!

	if (DEBUGCHECKS)
		if (sectionoffset@ anonsize@ >=)
			"MmSectionPageGet: offset>=anonsize\n" KeCrash
		end
	end
	
	auto multilevel
	anonsize@ MMSECTIONMULTILEVELTHRESHOLD >= multilevel!

	auto ppt
	sectionobject@ MmSection_AnonPrototypePageTable + @ ppt!

	if (ppt@ ~~)
		// needs to be created

		if (multilevel@)
			// nonpaged pool respects ZEROMUST when doing page-aligned allocs
			PAGESIZE // bytes
			'mPPT' // tag
			ZEROMUST CANBLOCK | pri@ | // flags
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end
		end else
			// create linearly
			anonsize@ PAGESHIFT >> 2 << // bytes
			'lPPT' // tag
			CANBLOCK pri@ | // flags
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			ppt@ // ptr
			anonsize@ PAGESHIFT >> 2 << // size
			0 // word
			memset
		end

		ppt@ sectionobject@ MmSection_AnonPrototypePageTable + !
	end

	if (multilevel@)
		auto pde
		sectionoffset@ PDSHIFT >> 2 << ppt@ + pde!

		if (pde@@ ~~)
			// nonpaged pool respects ZEROMUST when doing page-aligned allocs
			PAGESIZE // bytes
			'sPPT' // tag
			ZEROMUST CANBLOCK | pri@ | // flags
			MmAllocWithTag ok! ppt!

			if (ok@)
				sectionobject@ MmSectionPPTUnlock
				return
			end

			ppt@ pde@!
		end

		pde@@ sectionoffset@ PAGESHIFT >> 2 << PAGEOFFSETMASK & + ppt!
	end else
		sectionoffset@ PAGESHIFT >> 2 << ppt +=
	end

	sectionobject@ MmSectionPPTUnlock

	auto ipl
	IPLDPC KeIPLRaise ipl!

	// ensure that referencing this page won't starve the system.

	pri@ CANBLOCK |
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	auto ppte
	ppt@@ ppte!

	if (ppte@ PTE_V &)
		// already present, return

		ppte@ PAGENUMBERMASK & phyaddr!
		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		1 MmSoftPageFaultCount +=

		ipl@ KeIPLLower
	end elseif (ppte@ ~~)
		// non-existent, demand zero

		ppt@ // pte
		ZEROMUST pri@ | // pri
		MmAnonymousPageGet ok! phyaddr! pfdbe!

		if (ok@)
			ipl@ KeIPLLower
			return
		end

		1 MmSoftPageFaultCount +=

		PAGESHIFT phyaddr <<=

		phyaddr@ PTE_V | ppt@!

		ipl@ KeIPLLower
	end elseif (ppte@ PTE_TRANSITION &)
		// being paged in, wait

		ppte@ PAGENUMBERMASK & phyaddr!
		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		pri@ CANBLOCK | // pri
		pfdbe@ // pfdbe
		MmEvictablePageWait ok!

		if (ok@)
			ipl@ KeIPLLower

			pfdbe@ MmEvictablePageDereference drop

			return
		end

		ppt@@ ppte!

		if (ppte@ PTE_V & ~~)
			pfdbe@ MmEvictablePageDereference drop

			STATUS_REFAULT ok!
		end

		ipl@ KeIPLLower
	end elseif (ppte@ PTE_INSWAP &)
		// swapped out, bring back in

		ppt@ // pte
		pri@ FREEFIRST | // pri
		MmAnonymousPageGet ok! phyaddr! pfdbe!

		if (ok@)
			ipl@ KeIPLLower
			return
		end

		PAGESHIFT phyaddr <<=

		pfdbe@ MmEvictablePageStartIO
		phyaddr@ PTE_TRANSITION | ppt@!

		IPLLOW KeIPLLower

		auto kflags
		IOKFLAG_PAGEIN kflags!

		if (pri@ TRYFOREVER &)
			IOKFLAG_SWAPIN kflags |=
		end

		kflags@ // kflags
		phyaddr@ IDENTITYSPACE | // pageframe
		ppte@ // pte
		IOSwapPageReadPTE ok!

		IPLDPC KeIPLRaise ipl!

		pfdbe@ MmEvictablePageSatisfy

		if (ok@)
			ppte@ ppt@!

			pfdbe@ MmEvictablePageDereference drop

			ipl@ // ipl
			pfdbe@ // pfdbe
			MmAnonymousPageDelete

			return
		end

		1 MmHardPageFaultCount +=
		1 MmPageInCount +=

		ppte@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		phyaddr@ PTE_V | ppt@!

		ipl@ KeIPLLower
	end elseif (DEBUGCHECKS)
		"MmSectionPageGet: unreachable\n" KeCrash
	end
end