//
// Implements allocation of various memory objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OSStatus.h"

fn MmKernelStackAlloc { -- kstack ok }
	// reserve enough pages in POOLSPACE for the size of our kernel stack and
	// for a guard page.

	auto offset
	KETHREADSTACKSIZE PAGESHIFT >> 1 + // pagesneeded
	MmPoolSpaceReserve ok! offset!

	if (ok@)
		return
	end

	// allocate all the page frames needed for our kernel stack.

	auto stackpagestab
	KETHREADSTACKSIZE PAGESHIFT >> 2 << alloc stackpagestab!

	auto i
	0 i!

	auto ptr
	stackpagestab@ ptr!

	while (i@ KETHREADSTACKSIZE PAGESHIFT >> <)
		auto pfdbe
		auto phyaddr

		FREEFIRST CANBLOCK | // priority
		MmPageAlloc ok! phyaddr! pfdbe!

		if (ok@)
			// failed, free the ones we just allocated

			while (i@)
				4 stackpagestab -=
				1 i -=

				stackpagestab@@ MmPageFree
			end

			KETHREADSTACKSIZE PAGESHIFT >> 1 + // pages
			offset@ // offset
			MmPoolSpaceRelease

			return
		end

		phyaddr@ ptr@!

		4 ptr +=
		1 i +=
	end

	auto kdir
	HALPlatformKernelPageDirectory@ kdir!

	auto vaddr
	POOLSPACE offset@ PAGESHIFT << + vaddr!

	// map the guard page at the bottom

	auto pteaddr
	vaddr@ // vaddr
	kdir@ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmKernelStackAlloc: failed to get guard page PTE (%i)\n" KeCrash
		end
	end

	// set special guard page magic pte
	MMGUARDPTE pteaddr@!

	// as a separate step, map in the page frames for our kernel stack.

	PAGESIZE vaddr +=

	vaddr@ kstack!

	stackpagestab@ ptr!

	0 i!

	while (i@ KETHREADSTACKSIZE PAGESHIFT >> <)
		ptr@@ PAGESHIFT << // phyaddr
		PTE_V PTE_W | PTE_K | PTE_G | // flags
		vaddr@ // vaddr
		kdir@ // pagemap
		0 // asid
		MmPTEUpdateByVirtual ok! drop drop

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "MmKernelStackAlloc: failed to map (%i)\n" KeCrash
			end
		end

		PAGESIZE vaddr +=
		4 ptr +=
		1 i +=
	end
end

fn MmKernelStackFree { kstack -- }
	PAGESIZE kstack -=

	auto kdir
	HALPlatformKernelPageDirectory@ kdir!

	// unmap guard page

	auto pteaddr

	kstack@ // vaddr
	kdir@ // pagemap
	MmVirtualtoPTEAddress ok! pteaddr!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "MmKernelStackFree: failed to get guard page PTE (%i)\n" KeCrash
		end

		if (pteaddr@@ MMGUARDPTE ~=)
			ok@ "MmKernelStackFree: not a kernel stack\n" KeCrash
		end
	end

	// clear special guard page magic pte
	0 pteaddr@!

	auto offset
	kstack@ POOLSPACE - PAGESHIFT >> offset!

	// unmap and free all the kernel stack page frames.

	PAGESIZE kstack +=

	auto i
	0 i!

	while (i@ KETHREADSTACKSIZE PAGESHIFT >> <)
		auto phyaddr
		auto ok

		0 // phyaddr
		0 // flags
		kstack@ // vaddr
		kdir@ // pagemap
		0 // asid
		MmPTEUpdateByVirtual ok! drop phyaddr!

		if (DEBUGCHECKS)
			if (ok@)
				"MmKernelStackFree: failed to unmap\n" KeCrash
			end
		end

		phyaddr@ PAGESHIFT >> MmPageFree

		PAGESIZE kstack +=
		1 i +=
	end

	// release the POOLSPACE.

	KETHREADSTACKSIZE PAGESHIFT >> 1 + // pages
	offset@ // offset
	MmPoolSpaceRelease
end

fn MmPageDirectoryAlloc { -- pdir ok }
	// XXX theres an arch-dependent assumption here that a page directory is
	// one pageframe in size

	ZEROMUST CANBLOCK | // priority
	MmPageAlloc ok! pdir! drop

	if (ok@)
		return
	end

	PAGESHIFT pdir <<=

	pdir@ // pagemap
	MmPageDirectoryInitialize
end

fn MmPageDirectoryFree { pdir -- }
	IDENTITYSPACE ~ pdir &=
	pdir@ PAGESHIFT >> MmPageFree
end