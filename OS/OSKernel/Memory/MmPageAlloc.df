//
// Implements page frame allocation.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALResource.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Process.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn MmPageGet { priority threshold -- pfdbe pfn ok }
	STATUS_NO_MEMORY ok!

	if (DEBUGCHECKS)
		if (MmInited@ ~~)
			"MmPageGet: used before MmInit called\n" KeCrash
		end
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (MmPageFreeCount@ MMMUSTSUCCEEDPAGES <)
		0 // priboost
		MmAsyncEvictEvent // event
		KeEventSignal
	end

	if (MmPageFreeCount@ MmEvictablePageCount@ + threshold@ <)
		if (priority@ CACHEALLOC & ~~)
			0 // priboost
			MmEventLowMemory // event
			KeEventSignal

			0 // priboost
			MmModifiedPageEvent // event
			KeEventSignal
		end

		ipl@ KeIPLLower

		return
	end

	if (priority@ 0xFF & FREEFIRST ==)
		// attempt to get a page from the free list first.
		// if its empty, try to get one from the zero list.

		MmPageFreeListHead@ pfdbe!

		if (pfdbe@)
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			1 MmPageFreeCount -=

			ipl@ KeIPLLower

			0 ok!

			return
		end else
			// resort to a zero page

			MmPageZeroListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmPageFrameEntry_PFN + @ pfn!
				pfdbe@ MmPageFrameEntryFree_Next + @ MmPageZeroListHead!
				0 pfdbe@ MmPageFrameEntryFree_Next + !

				1 MmPageFreeCount -=

				ipl@ KeIPLLower

				0 ok!

				return
			end
		end
	end elseif (priority@ 0xFF & ZEROMUST ==)
		// attempt to get one from the zero list first.
		// if its empty, get one from the free list, and zero it out.

		MmPageZeroListHead@ pfdbe!

		if (pfdbe@)
			pfdbe@ MmPageFrameEntry_PFN + @ pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageZeroListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			1 MmPageFreeCount -=

			ipl@ KeIPLLower

			0 ok!

			return
		end else
			// resort to a free page

			MmPageFreeListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmPageFrameEntry_PFN + @ pfn!
				pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
				0 pfdbe@ MmPageFrameEntryFree_Next + !

				1 MmPageFreeCount -=

				ipl@ KeIPLLower

				0 ok!

				// zero the free page out

				pfn@ PAGESHIFT << IDENTITYSPACE |
				PAGESIZE
				0
				memset

				return
			end
		end
	end elseif (DEBUGCHECKS)
		priority@ "MmPageGet: unknown priority %d\n" KeCrash
	end

	// none in free or zero list, get one from standby list

	MmEvictSinglePage ok! pfdbe!

	ipl@ KeIPLLower

	if (ok@ ~~)
		pfdbe@ MmPageFrameEntry_PFN + @ pfn!

		if (priority@ 0xFF & ZEROMUST ==)
			pfn@ PAGESHIFT << IDENTITYSPACE |
			PAGESIZE
			0
			memset
		end

		return
	end
end

fn MmPageAlloc { priority -- pfdbe pfn ok }
	0 ok!

	if (DEBUGCHECKS)
		if (MmInited@ ~~)
			"MmPageAlloc: used before MmInit called\n" KeCrash
		end
	end

	auto blockon
	auto alertable
	auto tries

	if (priority@ MUSTSUCCEED &)
		// CANBLOCK page allocations have different wait rules if MUSTSUCCEED
		// is also specified:

		0 blockon! // can dip into MUSTSUCCEED page pool
		0 alertable! // wait can't be interrupted
		-1 tries! // try forever for a page
	end elseif (priority@ MUSTSUCCEEDL2 &)
		MMMUSTSUCCEEDL2PAGES blockon! // can dip into MUSTSUCCEEDL2 page pool
		0 alertable! // wait can't be interrupted
		-1 tries! // try forever for a page
	end else
		// normal rules:

		if (priority@ CACHEALLOC &)
			MmPageFreeCountLow@ blockon! // don't go below low watermark
		end else
			MMMUSTSUCCEEDPAGES blockon! // don't dip into MUSTSUCCEED page pool
		end

		1 alertable! // wait can be interrupted
		200 tries! // try 200 times to get a page (about 10 seconds)
	end

	if (priority@ TRYFOREVER &)
		-1 tries!
	end

	while (1)
		priority@ // priority
		blockon@ // threshold
		MmPageGet ok! pfn! pfdbe!

		auto ipl

		if (ok@ ~~)
			return
		end

		if (DEBUGCHECKS)
			if (ok@ STATUS_NO_MEMORY ~=)
				ok@ "MmPageAlloc: MmPageGet returned weird status (%i)\n" KeCrash
			end
		end

		if (priority@ CANBLOCK & ~~)
			return
		end

		KERNELMODE // waitmode
		alertable@ // alertable
		50 // timeout
		MmEventPageAvailable // object
		KeThreadWaitForObject ok!

		if (ok@ STATUS_WAIT_TIMEOUT ==)
			if (tries@ -1 ~=)
				1 tries -=

				if (tries@ ~~)
					STATUS_NO_MEMORY ok!

					return
				end
			end
		end elseif (ok@)
			return
		end
	end
end

fn MmPageFree { pfn -- }
	// insert a page frame into the free list

	auto pfdbe

	pfn@ MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto rs
	HALCPUInterruptDisable rs!

	MmPageFreeListHead@ pfdbe@ MmPageFrameEntryFree_Next + !
	pfdbe@ MmPageFreeListHead!

	1 MmPageFreeCount +=

	if (MmEventPageAvailable KeEvent_DispatchHeader + KeDispatchHeader_WaitBlockListHead + @)
		// there's a waiter for a free page, wake him up

		// restore interrupts and go to IPLDPC since this is a much lengthier
		// operation...

		auto ipl
		IPLDPC KeIPLRaise ipl!

		rs@ HALCPUInterruptRestore

		0 // priboost
		MmEventPageAvailable // event
		KeEventSignal

		ipl@ KeIPLLower
	end else
		rs@ HALCPUInterruptRestore
	end
end