//
// Implements page frame allocation.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALResource.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Process.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn MmKflagToPriority { kflags -- pri }
	0 pri!

	if (kflags@ IOKFLAG_SWAPOUT &)
		MUSTSUCCEED pri!
	end elseif (kflags@ IOKFLAG_URGENT &)
		MUSTSUCCEEDL2 pri!
	end

	if (kflags@ IOKFLAG_SWAPIN &)
		TRYFOREVER pri |=
	end
end

fn MmPageGet { priority -- pfdbe pfn ok }
	0 ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (priority@ 0xFF & FREEFIRST ==)
		// attempt to get a page from the free list first.
		// if its empty, try to get one from the zero list.

		MmPageFreeListHead@ pfdbe!

		if (pfdbe@)
			pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			1 MmPageFreeCount -=
		end else
			// resort to a zero page

			MmPageZeroListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / pfn!
				pfdbe@ MmPageFrameEntryFree_Next + @ MmPageZeroListHead!
				0 pfdbe@ MmPageFrameEntryFree_Next + !

				1 MmPageFreeCount -=
			end
		end
	end elseif (priority@ 0xFF & ZEROMUST ==)
		// attempt to get one from the zero list first.
		// if its empty, get one from the free list, and zero it out.

		MmPageZeroListHead@ pfdbe!

		if (pfdbe@)
			pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / pfn!
			pfdbe@ MmPageFrameEntryFree_Next + @ MmPageZeroListHead!
			0 pfdbe@ MmPageFrameEntryFree_Next + !

			1 MmPageFreeCount -=
		end else
			// resort to a free page

			MmPageFreeListHead@ pfdbe!

			if (pfdbe@)
				pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / pfn!
				pfdbe@ MmPageFrameEntryFree_Next + @ MmPageFreeListHead!
				0 pfdbe@ MmPageFrameEntryFree_Next + !

				1 MmPageFreeCount -=

				ipl@ KeIPLLower

				// zero the free page out

				pfn@ PAGESHIFT << IDENTITYSPACE |
				PAGESIZE
				0
				memset

				IPLDPC KeIPLRaise ipl!
			end
		end
	end elseif (DEBUGCHECKS)
		priority@ "MmPageGet: unknown priority %d\n" KeCrash
	end

	if (pfdbe@ ~~)
		// none in free or zero list, get one from standby list

		MmEvictSinglePage ok! pfdbe!

		if (ok@ ~~)
			pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / pfn!

			if (priority@ 0xFF & ZEROMUST ==)
				// zero out the standby page

				ipl@ KeIPLLower

				pfn@ PAGESHIFT << IDENTITYSPACE |
				PAGESIZE
				0
				memset

				IPLDPC KeIPLRaise ipl!
			end
		end
	end

	if (MmEvictablePageCount@ MmPageFreeCount@ + MmPageFreeCountLow@ <)
		0 // priboost
		MmEventLowMemory // event
		KeEventSignal
	end

	ipl@ KeIPLLower
end

fn MmPageAlloc { priority -- pfdbe pfn ok }
	0 ok!

	if (DEBUGCHECKS)
		if (MmInited@ ~~)
			"MmPageAlloc: used before MmInit called\n" KeCrash
		end
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	0 priority@ MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	priority@ MmPageGet ok! pfn! pfdbe!

	ipl@ KeIPLLower
end

fn MmPageWait { process priority -- waited ok }
	// wait until the appropriate available page threshold is reached.

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmPageWait: ipl != IPLDPC\n" KeCrash
		end

		if (process@)
			if (KeThreadCurrent@ KeThread_IgnoreKill + @ ~~)
				"MmPageWait: kill not ignored\n" KeCrash
			end
		end
	end

	0 waited!

	if (MmPageFreeCount@ MmEvictablePageCount@ + MMNORMALTHRESH >=)
		0 ok!
		return
	end

	auto wprocess
	KeThreadCurrent@ KeThread_Process + @ wprocess!

	auto blockon
	auto alertable

	if (priority@ MUSTSUCCEED &)
		// CANBLOCK page allocations have different wait rules if MUSTSUCCEED
		// is also specified:

		MMMUSTSUCCEEDTHRESH blockon!
		0 alertable!
	end elseif (priority@ MUSTSUCCEEDL2 &)
		MMMUSTSUCCEEDL2THRESH blockon!
		0 alertable!
	end elseif (priority@ POOLALLOC &)
		MMPOOLTHRESH blockon!
		0 alertable!
	end else
		// normal rules:
		MMNORMALTHRESH blockon! // don't dip into MUSTSUCCEED page pool
	end

	if (wprocess@ PsSystemInitProcess@ ==)
		0 alertable!
	end elseif (wprocess@ PsSystemProcess@ ==)
		0 alertable!
	end else
		1 alertable!
	end

	if (KeThreadCurrent@ PsThread_MemoryPrivilegedCount + @)
		MMMUSTSUCCEEDTHRESH blockon!
	end

	if (priority@ CANBLOCK & ~~)
		// check this now instead of doing it every iteration in the while
		// loop

		if (MmPageFreeCount@ MmEvictablePageCount@ + blockon@ <)
			STATUS_NO_MEMORY ok!
			return
		end
	end

	auto timeouts
	600 timeouts!

	auto event

	if (blockon@ MMNORMALTHRESH >=)
		MmEventPageAvailable event!
	end else
		MmEventMSPageAvailable event!
	end

	while (MmPageFreeCount@ MmEvictablePageCount@ + blockon@ <)
		event@ // event
		KeEventReset drop

		IPLAPC KeIPLLower

		if (process@)
			process@ MmVADListUnlock
		end

		1 waited!

		KERNELMODE // waitmode
		alertable@ // alertable
		100 // timeout
		event@ // object
		KeThreadWaitForObject ok!

		if (process@)
			process@ MmVADListLock drop
		end

		IPLDPC KeIPLRaise drop

		if (ok@)
			if (ok@ STATUS_WAIT_TIMEOUT ==)
				if (timeouts@ ~~)
					MmModifiedPageCount@
					MmPageFreeCount@
					MmEvictablePageCount@
					"Many timeouts, MPW is likely deadlocked (evic=%d,free=%d,mod=%d)\n" KeCrash
				end

				1 timeouts -=

				// recheck this since it may have changed

				if (KeThreadCurrent@ PsThread_MemoryPrivilegedCount + @)
					MMMUSTSUCCEEDTHRESH blockon!
					MmEventMSPageAvailable event!
				end
			end else
				return
			end
		end else
			600 timeouts!
		end
	end

	0 ok!
end

fn MmPageFreeByEntry { pfdbe -- }
	// insert a page frame into the free list

	auto rs
	HALCPUInterruptDisable rs!

	MmPageFreeListHead@ pfdbe@ MmPageFrameEntryFree_Next + !
	pfdbe@ MmPageFreeListHead!

	1 MmPageFreeCount +=

	auto ipl

	if (MmPageFreeCount@ MmEvictablePageCount@ + MMNORMALTHRESH ==)
		IPLDPC KeIPLRaise ipl!
		rs@ HALCPUInterruptRestore

		0 // priboost
		MmEventPageAvailable // event
		KeEventSignal

		ipl@ KeIPLLower
	end elseif (MmPageFreeCount@ MmEvictablePageCount@ + MMNORMALTHRESH <)
		IPLDPC KeIPLRaise ipl!
		rs@ HALCPUInterruptRestore

		0 // priboost
		MmEventMSPageAvailable // event
		KeEventSignal

		ipl@ KeIPLLower
	end else
		rs@ HALCPUInterruptRestore
	end
end

fn MmPageFree { pfn -- }
	auto pfdbe
	pfn@ MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	pfdbe@ MmPageFreeByEntry
end