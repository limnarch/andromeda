//
// Implements page directory management for the limn2600 architecture.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OSStatus.h"

fn MmPageDirectoryDestroy { process -- }
	auto pagemap
	process@ KeProcess_PageDirectory + @ pagemap!

	auto pfdbe
	pagemap@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	// MmAnonymousPageDelete wants to be entered at IPLDPC...

	auto count
	PAGESIZE 3 >> count!

	auto ptr
	pagemap@ IDENTITYSPACE | ptr!

	while (count@)
		// this is ALL WRONG and is a workaround to a horrible longstanding
		// bug that I spent a full week on at one point.

		auto pde
		ptr@@ pde!

		if (pde@ PTE_V &)
			auto ptpfdbe
			pde@ 5 >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + ptpfdbe!

			IPLDPC KeIPLRaise ipl!

			// debug prints intentionally left here
			"freeing " Printf

			if (ptpfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ PTE_INSWAP &)
				"PTE " Printf
				ptpfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ IOSwapPageFreePTE
			end

			ptpfdbe@ MmPageFrameEntryPageTable_HoldCount + @ "%d " Printf

			while (ptpfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi)
				"ref " Printf
				ptpfdbe@ MmEvictablePageDereference drop
			end

			"\n" Printf

			ipl@ // ipl
			ptpfdbe@ // pfdbe
			MmAnonymousPageDelete
		end elseif (pde@ PTE_INSWAP &)
			IPLDPC KeIPLRaise ipl!

			"freept\n" Printf

			ipl@ KeIPLLower

			pde@ IOSwapPageFreePTE
		end elseif (pde@)
			IPLDPC KeIPLRaise ipl!

			pde@ "hmm %x\n" Printf

			ipl@ KeIPLLower
		end

		1 count -=
		4 ptr +=
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi 1 ~=)
		pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi "too many ref=%d\n" Printf
	end

	while (pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi)
		// WRONG, it should have only ONE reference by this point
		pfdbe@ MmEvictablePageDereference drop
	end

	if (0)
		if (DEBUGCHECKS)
			PAGESIZE 3 >> count!
			pagemap@ IDENTITYSPACE | ptr!
		
			while (count@)
				ptr@@ pde!

				if (pde@)
					pde@ 5 >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + ptpfdbe!

					PAGESIZE 2 >> count!

					auto ptptr
					pde@ 5 >> PAGESHIFT << IDENTITYSPACE | ptptr!

					while (count@)
						if (ptptr@@)
							ptptr@@
							ptpfdbe@ MmPageFrameEntryPageTable_PTECount + @
							ptpfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi
							pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi
							pde@ ptptr@ 2 >> 1023 & 22 << "MmPageDirectoryDestroy: %x: broken %x (%d, %d, %d) %x\n" KeCrash
						end

						1 count -=
						4 ptptr +=
					end

					ptpfdbe@ MmPageFrameEntryPageTable_HoldCount + @
					ptpfdbe@ MmPageFrameEntryPageTable_PTECount + @
					ptpfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi
					pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi
					pde@ ptr@ 2 >> 1023 & 22 << "MmPageDirectoryDestroy: %x: broken %x (%d, %d, %d, %d)\n" KeCrash
				end

				1 count -=
				4 ptr +=
			end
		end
	end

	if (0)
	if (DEBUGCHECKS)
		if (pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi)
			pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi
			"MmPageDirectoryDestroy: page directory had %d references\n" KeCrash
		end
	end
	end

	ipl@ // ipl
	pfdbe@ // pfdbe
	MmAnonymousPageDelete

	// ...but it leaves at the provided IPL

	PAGESIZE // charge
	process@ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeVM

	PAGESIZE // charge
	process@ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUncharge
end

fn MmPageDirectoryAlloc { process -- pdir ok }
	PAGESIZE // charge
	process@ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		return
	end

	PAGESIZE // charge
	process@ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockCharge ok!

	if (ok@)
		PAGESIZE // charge
		process@ PsProcess_QuotaBlock + @ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	auto pfdbe
	process@ KeProcess_PageDirectory + // pte
	ZEROMUST // priority
	MmAnonymousPageAlloc ok! pdir! pfdbe!

	if (ok@)
		PAGESIZE // charge
		process@ PsProcess_QuotaBlock + @ // quotablock
		MmQuotaBlockUnchargeVM

		PAGESIZE // charge
		process@ PsProcess_QuotaBlock + @ // quotablock
		MmQuotaBlockUncharge

		return
	end

	pfdbe@ // pfdbe
	0 // process
	MmEvictablePageModify

	PAGESHIFT pdir <<=

	pdir@ IDENTITYSPACE | 2048 + // dest
	HALPlatformKernelPageDirectory@ IDENTITYSPACE | 2048 + // src
	2048 // size
	memcpy
end

fn MmPageDirectoryReference { pri process -- ok }
	if (DEBUGCHECKS)
		if (KeThreadCurrent@ KeThread_IgnoreKill + @ ~~)
			"MmPageDirectoryReference: thread could be killed\n" KeCrash
		end
	end

	0 ok!

	auto pfdbe

	process@ MmWorkingSetLock drop

	auto ipl
	IPLDPC KeIPLRaise ipl!

	pri@ CANBLOCK |
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		process@ MmWorkingSetUnlock
		return
	end

	if (process@ KeProcess_PageDirectory + @ PTE_INSWAP &)
		auto pt

		pri@ // priority
		process@ KeProcess_PageDirectory + // pte
		process@ KeProcess_PageDirectory + @ PAGESHIFT >> // pno
		MmAnonymousSwapIn ok! pt! pfdbe!

		if (ok@)
			process@ MmWorkingSetUnlock
			return
		end

		pt@ PAGESHIFT << process@ KeProcess_PageDirectory + !
	end else
		process@ KeProcess_PageDirectory + @ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!
		
		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		pfdbe@ // pfdbe
		0 // process
		MmEvictablePageModify
	end

	process@ MmWorkingSetUnlock
end

fn MmPageDirectoryDereference { process -- }
	process@ KeProcess_PageDirectory + @ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
	MmEvictablePageDereference drop
end