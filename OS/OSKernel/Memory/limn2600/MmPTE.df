//
// Implements page table entry (PTE) management for the limn2600 architecture.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

extern HALLimn2500TLBFlush { vpn asid -- }
extern HALLimn2500TLBFlushAll { -- }

fn MmFlushUserTLBAll { -- }
	// XXX we might be able to have this function flush only the userspace
	// part of the TLB at some point.

	HALLimn2500TLBFlushAll
end

// PTE addresses are given and returned as virtual addresses.
// pagemap addresses are given as physical addresses.
// synchronization regarding the pagemap is a responsibility of the caller.

fn MmPTECreate { vaddr pagemap -- pteaddr ok }
	// create an empty PTE for the vaddr in the given pagemap.
	// if the page table exists, it is referenced. otherwise it is created and
	// initialized with a refcount of 1.

	IDENTITYSPACE pagemap |=

	0 ok!

	auto ent
	vaddr@ 22 >> 2 << pagemap@ + ent!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (DEBUGCHECKS)
		if (ent@@ PTE_INSWAP &)
			"MmPTECreate: PTE swapped out\n" KeCrash
		end
	end

	auto pt
	ent@@ 5 >> PAGESHIFT << pt!

	auto pfdbe

	if (pt@ 0 ==)
		// need to allocate this page table.

		ipl@ KeIPLLower

		ent@ // pte
		ZEROMUST // priority
		MmAnonymousPageAlloc ok! pt! pfdbe!

		if (ok@)
			return
		end

		1 pfdbe@ MmPageFrameEntryPageTable_PTECount + !
		0 pfdbe@ MmPageFrameEntryPageTable_HoldCount + !

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PAGETABLE |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		pt@ 5 << PTE_V | ent@!

		pagemap@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
		MmEvictablePageReference drop

		PAGESHIFT pt <<=
	end else
		pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		if (DEBUGCHECKS)
			if (pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi ~~)
				"MmPTECreate: page table had no references\n" KeCrash
			end
		end

		1 pfdbe@ MmPageFrameEntryPageTable_PTECount + +=

		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmPTEDelete { deref pteaddr vaddr pagemap -- ok }
	// delete a PTE from the pagemap and dereference the page table.
	// free the page table if its refcount hits 0.

	IDENTITYSPACE pagemap |=

	0 ok!

	if (DEBUGCHECKS)
		if (pteaddr@@)
			pteaddr@@ vaddr@ "MmPTEDelete: vaddr=0x%08x pte=0x%08x\n" KeCrash
		end
	end

	auto pfn
	pteaddr@ IDENTITYSPACEMASK & PAGESHIFT >> pfn!

	auto pfdbe
	pfn@ MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto oldcount
	pfdbe@ MmPageFrameEntryPageTable_PTECount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ ~~)
			"MmPTEDelete: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - pfdbe@ MmPageFrameEntryPageTable_PTECount + !

	if (deref@)
		pfdbe@ MmEvictablePageDereference drop
	end

	if (oldcount@ 1 ==)
		// last PTE. free the page table.

		if (pfdbe@ MmPageFrameEntryPageTable_HoldCount + @ ~~)
			// zero out the pde for the page table.
			0 pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ !

			ipl@ // ipl
			pfdbe@ // pfdbe
			MmAnonymousPageDelete

			pagemap@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
			MmEvictablePageDereference drop
		end else
			ipl@ KeIPLLower
		end
	end else
		ipl@ KeIPLLower
	end
end

fn MmPTEReference { pri vaddr pagemap -- pfdbe pteaddr ok }
	// works like MmVirtualToPTEAddress but will swap in PTEs that are swapped
	// out and will return a referenced page table pfdbe.

	// returns -1 if the PTE is known not to exist. may succeed erroneously
	// if the PTE hasn't been Create'd if the related page table already
	// exists, because it's simply based here on whether the page table exists
	// or not. to be sure, check that the returned PTE has the PTE_V flag with
	// MmPTEInterpret.

	// MUST have VAD list mutex held.

	if (DEBUGCHECKS)
		if (vaddr@ MMHIGHESTUSERADDRESS >)
			vaddr@ "MmPTEReference: used on system address 0x%08x\n" KeCrash
		end
	end

	IDENTITYSPACE pagemap |=

	0 ok!

	vaddr@ 22 >> 2 << pagemap@ + pteaddr!

	auto pt

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto pde
	pteaddr@@ pde!

	if (pde@ PTE_V &)
		pde@ 5 >> PAGESHIFT << pt!

		pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop
		1 pfdbe@ MmPageFrameEntryPageTable_HoldCount + +=

		ipl@ KeIPLLower
	end elseif (pde@ PTE_INSWAP &)
		// swap in the PTE

		ipl@ KeIPLLower

		pri@ // pri
		pteaddr@ // pte
		pde@ PAGESHIFT >> // pno
		MmAnonymousSwapIn ok! pt! pfdbe!

		if (ok@)
			return
		end

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PAGETABLE |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		pde@ 2 >> 1023 & 1 + pfdbe@ MmPageFrameEntryPageTable_PTECount + !
		1 pfdbe@ MmPageFrameEntryPageTable_HoldCount + !

		pt@ 5 << PTE_V | pteaddr@!

		PAGESHIFT pt <<=

		pagemap@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
		MmEvictablePageReference drop
	end elseif (pde@ ~~)
		// no such PTE.
		ipl@ KeIPLLower
		-1 ok!
		return
	end else
		"MmPTEReference: weird state\n" KeCrash
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		pfdbe@ // pfdbe
		0 // process
		MmEvictablePageModify
	end

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmPTEDereference { pfdbe -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto oldcount
	pfdbe@ MmPageFrameEntryPageTable_HoldCount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ ~~)
			"MmPTEDereference: underflow\n" KeCrash
		end
	end

	pfdbe@ MmEvictablePageDereference drop

	oldcount@ 1 - pfdbe@ MmPageFrameEntryPageTable_HoldCount + !

	if (oldcount@ 1 ==)
		if (pfdbe@ MmPageFrameEntryPageTable_PTECount + @ ~~)
			// perform deferred deletion of page table

			auto pde
			pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ pde!

			// zero out the pde for the page table.
			0 pde@!

			auto pagemap
			pde@ PAGENUMBERMASK & pagemap!

			ipl@ // ipl
			pfdbe@ // pfdbe
			MmAnonymousPageDelete

			pagemap@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
			MmEvictablePageDereference drop

			return
		end
	end

	ipl@ KeIPLLower
end

fn MmVirtualtoPTEAddressUser { vaddr pagemap -- pteaddr }
	// fast path -- use only when you know FOR SURE that the PTE is present,
	// i.e. in working set trimming.

	if (DEBUGCHECKS)
		if (vaddr@ MMHIGHESTUSERADDRESS >)
			vaddr@ "MmVirtualtoPTEAddressUser: used on system address 0x%08x\n" KeCrash
		end
	end

	IDENTITYSPACE pagemap |=

	vaddr@ 22 >> 2 << pagemap@ + pteaddr!

	if (DEBUGCHECKS)
		if (pteaddr@@ PTE_INSWAP &)
			"MmVirtualtoPTEAddressUser: PTE swapped out\n" KeCrash
		end
	end

	if (DEBUGCHECKS)
		if (pteaddr@@ ~~)
			"MmVirtualtoPTEAddressUser: no PTE\n" KeCrash
		end
	end

	auto pt
	pteaddr@@ 5 >> PAGESHIFT << pt!

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmVirtualtoPTEAddress { vaddr pagemap -- pteaddr }
	// get the address of a PTE based on a vaddr and pagemap.

	if (DEBUGCHECKS)
		if (vaddr@ MMLOWESTSYSTEMADDRESS <)
			vaddr@ "MmVirtualtoPTEAddress: used on user address 0x%08x\n" KeCrash
		end
	end

	IDENTITYSPACE pagemap |=

	vaddr@ 22 >> 2 << pagemap@ + pteaddr!

	if (DEBUGCHECKS)
		if (pteaddr@@ PTE_INSWAP &)
			"MmVirtualtoPTEAddress: PTE was swapped out\n" KeCrash
			return
		end
	end

	if (DEBUGCHECKS)
		if (pteaddr@@ ~~)
			"MmVirtualtoPTEAddress: no PTE\n" KeCrash
		end
	end

	auto pt
	pteaddr@@ 5 >> PAGESHIFT << pt!

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmPTEInterpret { pteaddr -- phyaddr flags ok }
	// interpret arch-specific PTE contents into physical address and generic
	// flags. returns -1 if the PTE is not valid.

	0 ok!

	auto pte
	pteaddr@@ pte!

	if (pte@ 1 & ~~)
		0 flags!
		-1 ok!
		return
	end

	// limn2600 PTEs JUST SO HAPPEN to line up with the generic PTE flags, so
	// just mask those off and return them directly.
	pte@ 31 & flags!

	pte@ 5 >> PAGESHIFT << phyaddr!
end

fn MmPTEUpdateByVirtual { phyaddr flags vaddr pagemap asid -- oldphyaddr oldflags ok }
	auto pteaddr

	vaddr@ // vaddr
	pagemap@ // pagemap
	MmVirtualtoPTEAddress pteaddr!

	phyaddr@ // phyaddr
	flags@ // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	asid@ // asid
	MmPTEUpdate ok! oldflags! oldphyaddr!
end

fn MmPTEUpdate { phyaddr flags vaddr pteaddr asid -- oldphyaddr oldflags ok }
	// update a PTE based on a physical address and generic flags. this could
	// do a number of things:
	// 1. mapping   - pte was invalid and flags are valid.
	// 2. unmapping - pte was valid and flags are invalid.
	// 3. remapping - pte was valid and flags are valid.

	0 ok!

	auto pte
	pteaddr@@ pte!

	pte@ 31 & oldflags!
	pte@ 5 >> PAGESHIFT << oldphyaddr!

	phyaddr@ PAGESHIFT >> 5 << flags@ 31 & | pteaddr@!

	if (pte@ 1 &)
		// either remapping or unmapping, flush

		if (asid@ 0 ==)
			vaddr@ PAGESHIFT >> // vpn
			0 // asid
			HALLimn2500TLBFlush
		end else
			vaddr@ PAGESHIFT >> // vpn
			asid@ 255 & 1 + // asid
			HALLimn2500TLBFlush
		end
	end elseif (flags@ PTE_V &)
		// mapping, don't flush
	end else
		// invalidated but was already invalid
	end
end

fn MmPTEValid { pteaddr -- valid }
	pteaddr@@ PTE_V & valid!
end

fn MmPTECountSave { pfdbe pde -- }
	// save the PTE count for a page table in the pde itself.
	// this is sort of black magic and works by storing the 10-bit PTE count
	// shifted left by 2 bits to avoid the PTE_INSWAP and PTE_V bits, and just
	// barely reaching up to the 20-bit swap page number.

	if (DEBUGCHECKS)
		if (pfdbe@ MmPageFrameEntryPageTable_PTECount + @ ~~)
			"MmPTECountSave: PTE count == 0\n" KeCrash
		end
	end

	pfdbe@ MmPageFrameEntryPageTable_PTECount + @ 1 - 2 << pde@ |=
end