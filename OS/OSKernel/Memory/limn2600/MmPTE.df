//
// Implements page table entry (PTE) management for the limn2600 architecture.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

extern HALLimn2500TLBFlush { vpn asid -- }
extern HALLimn2500TLBFlushAll { -- }

fn MmFlushUserTLBAll { -- }
	// XXX we might be able to have this function flush only the userspace
	// part of the TLB at some point.

	HALLimn2500TLBFlushAll
end

// PTE addresses are given and returned as virtual addresses.
// pagemap addresses are given as physical addresses.
// synchronization regarding the pagemap is a responsibility of the caller.

fn MmPTECreate { vaddr pagemap canblock -- pteaddr ok }
	// create an empty PTE for the vaddr in the given pagemap.
	// if the page table exists, it is referenced. otherwise it is created and
	// initialized with a refcount of 1.

	IDENTITYSPACE pagemap |=

	0 ok!

	auto ent
	vaddr@ 22 >> 2 << pagemap@ + ent!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (DEBUGCHECKS)
		if (ent@@ PTE_INSWAP &)
			"MmPTECreate: PTE swapped out\n" KeCrash
		end
	end

	auto pt
	ent@@ 5 >> PAGESHIFT << pt!

	auto pfdbe

	if (pt@ 0 ==)
		// need to allocate this page table.
		// dip into MUSTSUCCEEDL2 pool to increase odds of successfully
		// satisfying a page fault in high memory pressure conditions.

		ipl@ KeIPLLower

		auto flags

		if (canblock@)
			ZEROMUST CANBLOCK | flags!
		end else
			ZEROMUST MUSTSUCCEEDL2 | flags!
		end

		ent@ // pte
		flags@ // priority
		MmAnonymousPageAlloc ok! pt! pfdbe!

		if (ok@)
			return
		end

		pfdbe@ // pfdbe
		0 // process
		MmEvictablePageModify

		1 pfdbe@ MmPageFrameEntryPageTable_PTECount + !

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PAGETABLE |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		pt@ 5 << PTE_V | ent@!

		pagemap@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
		MmEvictablePageReference drop

		PAGESHIFT pt <<=
	end else
		pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		1 pfdbe@ MmPageFrameEntryPageTable_PTECount + +=

		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmPTEDelete { deref pteaddr vaddr pagemap -- ok }
	// delete a PTE from the pagemap and dereference the page table.
	// free the page table if its refcount hits 0.

	IDENTITYSPACE pagemap |=

	0 ok!

	if (DEBUGCHECKS)
		if (pteaddr@@)
			pteaddr@@ vaddr@ "MmPTEDelete: vaddr=0x%08x pte=0x%08x\n" KeCrash
		end
	end

	auto pfn
	pteaddr@ IDENTITYSPACEMASK & PAGESHIFT >> pfn!

	auto pfdbe
	pfn@ MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto oldcount
	pfdbe@ MmPageFrameEntryPageTable_PTECount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ ~~)
			"MmPTEDelete: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - pfdbe@ MmPageFrameEntryPageTable_PTECount + !

	if (deref@)
		pfdbe@ MmEvictablePageDereference drop
	end

	if (oldcount@ 1 ==)
		// last PTE. free the page table.

		auto count
		PAGESIZE 2 >> count!

		auto ptr
		pfn@ PAGESHIFT << IDENTITYSPACE | ptr!

		if (DEBUGCHECKS)
			while (count@)
				auto pde
				ptr@@ pde!

				if (pde@)
					pde@ "MmPTEDelete: broken %x\n" KeCrash
				end

				1 count -=
				4 ptr +=
			end
		end

		auto ent
		vaddr@ 22 >> 2 << pagemap@ + ent!

		// zero out the pde for the page table.
		0 ent@!

		ipl@ // ipl
		pfdbe@ // pfdbe
		MmAnonymousPageDelete

		pagemap@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
		MmEvictablePageDereference drop
	end else
		ipl@ KeIPLLower
	end
end

fn MmPTEReference { vaddr pagemap -- pfdbe pteaddr ok }
	// works like MmVirtualToPTEAddress but will swap in PTEs that are swapped
	// out and will return a referenced page table pfdbe.

	// returns -1 if the PTE is known not to exist. may succeed erroneously
	// if the PTE hasn't been Create'd if the related page table already
	// exists, because it's simply based here on whether the page table exists
	// or not. to be sure, check that the returned PTE has the PTE_V flag with
	// MmPTEInterpret.

	if (DEBUGCHECKS)
		if (vaddr@ MMHIGHESTUSERADDRESS >)
			vaddr@ "MmPTEReference: used on system address 0x%08x\n" KeCrash
		end
	end

	IDENTITYSPACE pagemap |=

	0 ok!

	vaddr@ 22 >> 2 << pagemap@ + pteaddr!

	auto pt

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (pteaddr@@ PTE_INSWAP &)
		// swap in the PTE

		ipl@ KeIPLLower

		0 // pri
		pteaddr@ // pte
		pteaddr@@ PAGESHIFT >> // pno
		MmAnonymousSwapIn ok! pt! pfdbe!

		if (ok@)
			return
		end

		pfdbe@ // pfdbe
		0 // process
		MmEvictablePageModify

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PAGETABLE |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		pteaddr@@ 2 >> 1023 & pfdbe@ MmPageFrameEntryPageTable_PTECount + !

		pt@ 5 << PTE_V | pteaddr@!

		PAGESHIFT pt <<=

		pagemap@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
		MmEvictablePageReference drop
	end elseif (pteaddr@@ ~~)
		// no such PTE.
		ipl@ KeIPLLower
		-1 ok!
		return
	end else
		pteaddr@@ 5 >> PAGESHIFT << pt!

		pt@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmVirtualtoPTEAddressUser { vaddr pagemap -- pteaddr }
	// fast path -- use only when you know FOR SURE that the PTE is present,
	// i.e. in working set trimming.

	if (DEBUGCHECKS)
		if (vaddr@ MMHIGHESTUSERADDRESS >)
			vaddr@ "MmVirtualtoPTEAddressUser: used on system address 0x%08x\n" KeCrash
		end
	end

	IDENTITYSPACE pagemap |=

	vaddr@ 22 >> 2 << pagemap@ + pteaddr!

	if (DEBUGCHECKS)
		if (pteaddr@@ PTE_INSWAP &)
			"MmVirtualtoPTEAddressUser: PTE swapped out\n" KeCrash
		end
	end

	if (DEBUGCHECKS)
		if (pteaddr@@ ~~)
			"MmVirtualtoPTEAddressUser: no PTE\n" KeCrash
		end
	end

	auto pt
	pteaddr@@ 5 >> PAGESHIFT << pt!

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmVirtualtoPTEAddress { vaddr pagemap -- pteaddr }
	// get the address of a PTE based on a vaddr and pagemap.

	if (DEBUGCHECKS)
		if (vaddr@ MMLOWESTSYSTEMADDRESS <)
			vaddr@ "MmVirtualtoPTEAddress: used on user address 0x%08x\n" KeCrash
		end
	end

	IDENTITYSPACE pagemap |=

	vaddr@ 22 >> 2 << pagemap@ + pteaddr!

	if (DEBUGCHECKS)
		if (pteaddr@@ PTE_INSWAP &)
			"MmVirtualtoPTEAddress: PTE was swapped out\n" KeCrash
			return
		end
	end

	if (DEBUGCHECKS)
		if (pteaddr@@ ~~)
			"MmVirtualtoPTEAddress: no PTE\n" KeCrash
		end
	end

	auto pt
	pteaddr@@ 5 >> PAGESHIFT << pt!

	vaddr@ PAGESHIFT >> 1023 & 2 << pt@ + IDENTITYSPACE | pteaddr!
end

fn MmPTEInterpret { pteaddr -- phyaddr flags ok }
	// interpret arch-specific PTE contents into physical address and generic
	// flags. returns -1 if the PTE is not valid.

	0 ok!

	auto pte
	pteaddr@@ pte!

	if (pte@ 1 & ~~)
		0 flags!
		-1 ok!
		return
	end

	// limn2600 PTEs JUST SO HAPPEN to line up with the generic PTE flags, so
	// just mask those off and return them directly.
	pte@ 31 & flags!

	pte@ 5 >> PAGESHIFT << phyaddr!
end

fn MmPTEUpdateByVirtual { phyaddr flags vaddr pagemap asid -- oldphyaddr oldflags ok }
	auto pteaddr

	vaddr@ // vaddr
	pagemap@ // pagemap
	MmVirtualtoPTEAddress pteaddr!

	phyaddr@ // phyaddr
	flags@ // flags
	vaddr@ // vaddr
	pteaddr@ // pteaddr
	asid@ // asid
	MmPTEUpdate ok! oldflags! oldphyaddr!
end

fn MmPTEUpdate { phyaddr flags vaddr pteaddr asid -- oldphyaddr oldflags ok }
	// update a PTE based on a physical address and generic flags. this could
	// do a number of things:
	// 1. mapping   - pte was invalid and flags are valid.
	// 2. unmapping - pte was valid and flags are invalid.
	// 3. remapping - pte was valid and flags are valid.

	0 ok!

	auto pte
	pteaddr@@ pte!

	pte@ 31 & oldflags!
	pte@ 5 >> PAGESHIFT << oldphyaddr!

	phyaddr@ PAGESHIFT >> 5 << flags@ 31 & | pteaddr@!

	if (pte@ 1 &)
		// either remapping or unmapping, flush

		if (asid@ 0 ==)
			vaddr@ PAGESHIFT >> // vpn
			0 // asid
			HALLimn2500TLBFlush
		end else
			vaddr@ PAGESHIFT >> // vpn
			asid@ 255 & 1 + // asid
			HALLimn2500TLBFlush
		end
	end elseif (flags@ PTE_V &)
		// mapping, don't flush
	end else
		// invalidated but was already invalid
	end
end

fn MmPTEValid { pteaddr -- valid }
	pteaddr@@ PTE_V & valid!
end

fn MmPTECountSave { pfdbe pde -- }
	// save the PTE count for a page table in the pde itself.
	// this is sort of black magic and works by storing the 10-bit PTE count
	// shifted left by 2 bits to avoid the PTE_INSWAP and PTE_V bits, and just
	// barely reaching up to the 20-bit swap page number.

	pfdbe@ MmPageFrameEntryPageTable_PTECount + @ 2 << pde@ |=
end