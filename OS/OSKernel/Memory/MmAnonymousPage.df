//
// Implements anonymous page management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

var MmAnonymousPageCount 0
public MmAnonymousPageCount

fn (MmEvictionFunction) MmAnonymousEvictionFunction { pfdbe -- }
	auto pte
	pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ pte!

	auto ppte
	pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ ppte!

	auto ef
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb ef!

	// remember the location of this page in swap by writing that to the PTE,
	// which may be in a section object's prototype page table in the case of
	// a shared anonymous page, or in the process's page table in the case of
	// a private anonymous page. this may be zero if the page is a never-
	// -written demand-zero page since we just discard those.

	auto ptpfdbe

	if (ef@ MMEVICTFLAG_PRIVATE &)
		// this is a private page. these are tracked in real page tables, so
		// we need to do some accounting with those.

		// private pages have physical prototype PTE pointers, so we
		// have to map the page table in now since it may not belong to
		// this process. note that the page table may actually be the
		// page directory if this pageframe is a page table itself.

		auto qp
		ppte@ MmMapQuickPage qp!

		auto rppte
		qp@ ppte@ PAGEOFFSETMASK & + rppte!

		pte@ rppte@!

		qp@ MmUnmapQuickPage

		if (pfdbe@ MmPageFrameEntryAnonymous_Process + @ PsSystemProcess@ ~=)
			// dereference the page table. this may allow the page table to be
			// swapped out as well.

			ppte@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + ptpfdbe!

			ptpfdbe@ MmEvictablePageDereference drop
		end
	end else
		pte@ ppte@!
	end

	1 MmAnonymousPageCount -=
end

fn MmAnonymousPageGet { pte pri -- pfdbe pfn ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousPageGet: ipl != IPLDPC\n" KeCrash
		end
	end

	// caller must set PRIVATE flag in pfdbe if applicable.

	// caller must also set MMEVICTFLAG_MODIFIED and set SwapPageNumber to
	// MMSWAPPAGE_NONE if this isn't a demand-zero page.

	MMEVICTFLAG_WORKINGSET // flags
	MMEVICTTYPE_ANON // evictabletype
	pri@ // priority
	MmEvictablePageGet ok! pfn! pfdbe!

	if (ok@)
		return
	end

	SWAPPTE_DEMANDZERO pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

	pte@ pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + !

	auto rs
	HALCPUInterruptDisable rs!
	1 MmAnonymousPageCount +=
	rs@ HALCPUInterruptRestore
end

fn MmAnonymousPageAlloc { pte pri -- pfdbe pfn ok }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	0 // process
	pri@ CANBLOCK | // priority
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	pte@ pri@ MmAnonymousPageGet ok! pfn! pfdbe!

	ipl@ KeIPLLower
end

fn MmAnonymousSwapIn { pri pte pno ipl -- pfdbe pfn ok }
	// XXX this needs to go away

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousSwapIn: ipl != IPLDPC\n" KeCrash
		end
	end

	pte@ // pte
	pri@ FREEFIRST | // pri
	MmAnonymousPageGet ok! pfn! pfdbe!

	ipl@ KeIPLLower

	if (ok@)
		return
	end

	auto kflags
	IOKFLAG_PAGEIN kflags!

	if (pri@ TRYFOREVER &)
		IOKFLAG_SWAPIN kflags |=
	end

	kflags@ // kflags
	pfdbe@ // pageframe
	pte@@ // pte
	IOSwapPageReadPTE ok!

	if (ok@)
		pfdbe@ MmAnonymousPageDelete

		pfdbe@ MmEvictablePageDereference drop

		return
	end

	pte@@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
end

fn MmAnonymousPageDeleteByPTE { deletepte pteaddr vaddr process -- }
	auto pfdbe

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto capturedpte
	pteaddr@@ capturedpte!

	if (capturedpte@ MmPTEIsZero ~~)
		auto deref
		1 deref!

		if (capturedpte@ PTE_V &)
			auto phyaddr
			pteaddr@ MmPTEInterpret drop drop phyaddr!

			phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

			if (process@)
				0 // phyaddr
				0 // flags
				pteaddr@ // pteaddr
				MmPTEUpdate drop drop

				if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE & ~~)
					pfdbe@ MmEvictablePageReference drop

					ipl@ KeIPLLower

					pfdbe@ MmAnonymousPageDelete

					pfdbe@ MmEvictablePageDereference drop
				end
			end else
				0 pteaddr@!

				pfdbe@ MmEvictablePageReference drop

				ipl@ KeIPLLower

				pfdbe@ MmAnonymousPageDelete

				pfdbe@ MmEvictablePageDereference drop
			end
		end else
			if (process@)
				0 // phyaddr
				0 // flags
				pteaddr@ // pteaddr
				MmPTEUpdate drop drop
			end else
				0 pteaddr@!
			end

			if (capturedpte@ PTE_INSWAP &)
				// free private page in swap

				ipl@ KeIPLLower

				0 deref!

				capturedpte@ IOSwapPageFreePTE
			end elseif (capturedpte@ PTE_TRANSITION &)
				// free private page

				capturedpte@ PAGENUMBERMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

				if (process@)
					// this page may actually be a shared page currently
					// undergoing page-in, in which case we do not want to
					// delete that page, or in fact delete the PTE, since the
					// former isn't our responsibility and the latter will be
					// done by the faulting thread when it realizes this PTE
					// was unmapped while it was blocked.

					if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE &)
						pfdbe@ MmEvictablePageReference drop

						ipl@ KeIPLLower

						pfdbe@ MmAnonymousPageDelete

						pfdbe@ MmEvictablePageDereference drop
					end else
						ipl@ KeIPLLower

						0 deletepte!
					end
				end else
					pfdbe@ MmEvictablePageReference drop

					ipl@ KeIPLLower

					pfdbe@ MmAnonymousPageDelete

					pfdbe@ MmEvictablePageDereference drop
				end
			end elseif (DEBUGCHECKS)
				capturedpte@ "MmAnonymousPageDeleteByPTE: strange PTE %08x\n" KeCrash
			end
		end

		if (deletepte@)
			// there was a PTE containing some information, so delete it.

			deref@ // deref
			pteaddr@ // pteaddr
			MmPTEDelete
		end
	end else
		ipl@ KeIPLLower
	end
end

fn MmAnonymousPageReferenceByPTE { dzpte evictflag refpfdbe process pri vaddr pteaddr localpteaddr -- pfdbe phyaddr ok }
	// assumes caller already did a MmPageWait and determined that the PTE is
	// not valid if it wants to do its own processing in that case.

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousPageReference: ipl != IPLDPC\n" KeCrash
		end
	end

	auto lockprocess
	0 lockprocess!

	if (localpteaddr@)
		if (pri@ TRYFOREVER &)
			PsSystemProcess@ lockprocess!
		end else
			KeProcessCurrent lockprocess!
		end

		if (localpteaddr@ -1 ==)
			0 localpteaddr!
		end
	end

	0 ok!

	auto capturedpte
	pteaddr@@ capturedpte!

	if (capturedpte@ PTE_V &)
		// already present, return

		pteaddr@ MmPTEInterpret ok! drop phyaddr!

		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		1 MmSoftPageFaultCount +=
	end elseif (capturedpte@ dzpte@ ==)
		// demand-zero PTE.

		if (dzpte@ PTE_KERNEL_DEMANDZERO ==)
			pteaddr@ // pte
			FREEFIRST pri@ | // pri
			MmAnonymousPageGet ok! phyaddr! pfdbe!
		end else
			pteaddr@ // pte
			ZEROMUST pri@ | // pri
			MmAnonymousPageGet ok! phyaddr! pfdbe!
		end

		if (ok@)
			return
		end

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb evictflag@ | MMEVICTFLAG_MODIFIED |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		dzpte@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

		1 MmSoftPageFaultCount +=

		PAGESHIFT phyaddr <<=

		if (evictflag@ MMEVICTFLAG_PRIVATE &)
			process@ pfdbe@ MmPageFrameEntryAnonymous_Process + !
			vaddr@ pfdbe@ MmPageFrameEntryAnonymous_VirtualAddress + !

			pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ MmVirtualToPhysical
			pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + !
		end

		if (refpfdbe@)
			refpfdbe@ MmEvictablePageReference drop
		end

		// unconditionally setting the PTE writable is okay since this is
		// either a private fault where we're writing the PTE directly here,
		// in which case it will definitely be writable, or this is a shared
		// anon fault where we're writing the prototype PTE, in which case
		// these PTE flags are irrelevant.

		phyaddr@ // phyaddr
		PTE_V PTE_W | PTE_D | // flags
		pteaddr@ // pteaddr
		MmPTEUpdate drop drop
	end elseif (capturedpte@ PTE_TRANSITION &)
		// page is in transition.
		// if IO is in progress, wait for that to finish.

		if (DEBUGCHECKS)
			if (capturedpte@ PTE_KERNELSTACK &)
				if (process@)
					"Faulted on a transition kernel stack\n" KeCrash
				end
			end
		end

		capturedpte@ PAGENUMBERMASK & phyaddr!
		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
			lockprocess@ // process
			pri@ CANBLOCK | // pri
			pfdbe@ // pfdbe
			MmEvictablePageWait ok!

			pfdbe@ MmEvictablePageDereference drop

			if (ok@)
				return
			end

			// say to refault so that the caller doesn't insert into the
			// working set since the owner of this IO is going to do that.

			STATUS_REFAULT ok!
		end else
			if (vaddr@ PAGETABLE >= vaddr@ SYSPAGETABLE < &&)
				phyaddr@ // phyaddr
				PTE_V PTE_W | PTE_D | // flags
				pteaddr@ // pteaddr
				MmPTEUpdate drop drop
			end else
				phyaddr@ // phyaddr
				PTE_V // flags
				pteaddr@ // pteaddr
				MmPTEUpdate drop drop
			end
		end
	end elseif (capturedpte@ PTE_INSWAP &)
		// page was written to swap and then evicted. we are responsible
		// for bringing it in now.

		if (DEBUGCHECKS)
			if (capturedpte@ PTE_KERNELSTACK &)
				if (process@)
					"Faulted on a swapped-out kernel stack\n" KeCrash
				end
			end
		end

		pteaddr@ // pte
		pri@ FREEFIRST | // pri
		MmAnonymousPageGet ok! phyaddr! pfdbe!

		if (ok@)
			return
		end

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb evictflag@ |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		capturedpte@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

		if (refpfdbe@)
			refpfdbe@ MmEvictablePageReference drop
		end

		PAGESHIFT phyaddr <<=

		pfdbe@ MmEvictablePageStartIO

		auto transitionpte

		if (process@ PsSystemProcess@ ==)
			phyaddr@ PTE_TRANSITION | PTE_TLBHACK | transitionpte!
		end else
			phyaddr@ PTE_TRANSITION | transitionpte!
		end

		transitionpte@ pteaddr@!

		auto capturedlocalpte

		if (localpteaddr@)
			localpteaddr@@ capturedlocalpte!
			transitionpte@ localpteaddr@!
		end

		IPLAPC KeIPLLower

		if (evictflag@ MMEVICTFLAG_PRIVATE &)
			if (vaddr@ PAGETABLE >= vaddr@ SYSPAGETABLE < &&)
				vaddr@ // vaddr
				pfdbe@ // pfdbe
				process@ // process
				MmPTEInitializePageTable
			end else
				process@ pfdbe@ MmPageFrameEntryAnonymous_Process + !
				vaddr@ pfdbe@ MmPageFrameEntryAnonymous_VirtualAddress + !
			end

			pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ MmVirtualToPhysical
			pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + !
		end

		if (lockprocess@)
			lockprocess@ MmVADListUnlock
		end

		auto kflags
		IOKFLAG_PAGEIN kflags!

		if (pri@ TRYFOREVER &)
			IOKFLAG_SWAPIN kflags |=
		end

		kflags@ // kflags
		pfdbe@ // pfdbe
		capturedpte@ // pte
		IOSwapPageReadPTE ok!

		if (lockprocess@)
			lockprocess@ MmVADListLock drop
		end

		IPLDPC KeIPLRaise drop

		pfdbe@ MmEvictablePageSatisfy

		if (ok@ ~~)
			// check that the PTE didn't get deleted.

			if (pteaddr@@ transitionpte@ ~=)
				// it got deleted. do NOT delete the pfdbe since it was
				// deleted already.

				STATUS_REFAULT ok!
			end

			if (localpteaddr@)
				if (localpteaddr@@ transitionpte@ ~=)
					STATUS_REFAULT ok!
				end
			end
		end elseif (pteaddr@@ transitionpte@ ==)
			// the PTE didn't get deleted, but there was an error, so reset.
			// delete the pfdbe since that hasn't been done.

			// prevent the swap page from being deleted.
			SWAPPTE_DEMANDZERO pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

			// restore the old PTE.
			capturedpte@ pteaddr@!

			pfdbe@ MmAnonymousPageDelete
		end

		if (ok@)
			if (localpteaddr@)
				if (localpteaddr@@ transitionpte@ ==)
					capturedlocalpte@ pteaddr@!
				end
			end

			if (refpfdbe@)
				refpfdbe@ MmEvictablePageDereference drop
			end

			pfdbe@ MmEvictablePageDereference drop

			return
		end

		1 MmHardPageFaultCount +=
		1 MmPageInCount +=

		if (vaddr@ PAGETABLE >= vaddr@ SYSPAGETABLE < &&)
			phyaddr@ // phyaddr
			PTE_V PTE_W | PTE_D | // flags
			pteaddr@ // pteaddr
			MmPTEUpdate drop drop
		end else
			phyaddr@ // phyaddr
			PTE_V // flags
			pteaddr@ // pteaddr
			MmPTEUpdate drop drop
		end
	end elseif (DEBUGCHECKS)
		capturedpte@ "MmAnonymousPageReference: odd PTE %x\n" KeCrash
	end
end

fn MmAnonymousPageDelete { pfdbe -- }
	pfdbe@ MmEvictablePageDelete

	-1 MmAnonymousPageCount KeInterlockedIncrement drop

	if (pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ PTE_INSWAP &)
		// free in swap
		pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ IOSwapPageFreePTE
	end
end