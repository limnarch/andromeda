//
// Implements anonymous page management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

var MmAnonymousPageCount 0
public MmAnonymousPageCount

fn (MmEvictionFunction) MmAnonymousEvictionFunction { pfdbe -- }
	auto pte
	pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ pte!

	auto ppte
	pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + @ ppte!

	auto ef
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb ef!

	// remember the location of this page in swap by writing that to the PTE,
	// which may be in a section object's prototype page table in the case of
	// a shared anonymous page, or in the process's page table in the case of
	// a private anonymous page. this may be zero if the page is a never-
	// -written demand-zero page since we just discard those.

	pte@ ppte@!

	auto ptpfdbe

	if (ef@ MMEVICTFLAG_PRIVATE &)
		// this is a private page. these are tracked in real page tables, so
		// we need to do some accounting with those. do not do this accounting
		// with system pages because kernel page tables must never be swapped
		// to disk or otherwise disappear, as they are shared by memcpy'ing
		// the upper entries of the kernel page directory to that of new
		// processes, and doing so would break that association (there is no
		// guarantee the system page table would reappear at the same physical
		// address).

		if (pfdbe@ MmPageFrameEntryAnonymous_Process + @ PsSystemProcess@ ~=)
			// dereference the page table.

			ppte@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + ptpfdbe!

			if (pte@ SWAPPTE_DEMANDZERO ==)
				// this was a demand-zero page, so it's just going to be
				// discarded now. officially delete the PTE, which may be able
				// to free up the page table as well.
				//
				// let it be known that this was the fix to a bug that took me
				// 2 weeks to resolve. previously, this would unconditionally
				// dereference the page table, which broke things later as the
				// PTE would end up never being properly deleted.

				1 // deref
				ppte@ // pteaddr
				pfdbe@ MmPageFrameEntryAnonymous_VirtualAddress + @ // vaddr
				pfdbe@ MmPageFrameEntryAnonymous_Process + @ // process
				MmPTEDelete drop
			end else
				// dereference the page table since the PTE contains some
				// information about the location of this page in swap. this
				// may allow the page table to be swapped out as well.

				ptpfdbe@ MmEvictablePageDereference drop
			end
		end
	end elseif (ef@ MMEVICTFLAG_PAGETABLE &)
		// this is a page table page, dereference the page directory that
		// points to it so we might be able to swap that out.

		ppte@ IDENTITYSPACEMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + ptpfdbe!
		ptpfdbe@ MmEvictablePageDereference drop
	end

	1 MmAnonymousPageCount -=
end

fn MmAnonymousPageGet { pte pri -- pfdbe pfn ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousPageGet: ipl != IPLDPC\n" KeCrash
		end
	end

	// caller must set PRIVATE flag in pfdbe if applicable.

	// caller must also set MMEVICTFLAG_MODIFIED and set SwapPageNumber to
	// MMSWAPPAGE_NONE if this isn't a demand-zero page.

	MMEVICTFLAG_WORKINGSET // flags
	MMEVICTTYPE_ANON // evictabletype
	pri@ // priority
	MmEvictablePageGet ok! pfn! pfdbe!

	if (ok@)
		return
	end

	SWAPPTE_DEMANDZERO pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

	pte@ pfdbe@ MmPageFrameEntryAnonymous_PrototypePTE + !

	auto rs
	HALCPUInterruptDisable rs!
	1 MmAnonymousPageCount +=
	rs@ HALCPUInterruptRestore
end

fn MmAnonymousPageAlloc { pte pri -- pfdbe pfn ok }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	0 // process
	pri@ CANBLOCK | // priority
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	pte@ pri@ MmAnonymousPageGet ok! pfn! pfdbe!

	ipl@ KeIPLLower
end

fn MmAnonymousSwapIn { pri pte pno -- pfdbe pfn ok }
	// XXX this needs to go away

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousSwapIn: ipl != IPLDPC\n" KeCrash
		end
	end

	pte@ // pte
	pri@ FREEFIRST | // pri
	MmAnonymousPageGet ok! pfn! pfdbe!

	IPLLOW KeIPLLower

	if (ok@)
		return
	end

	auto kflags
	IOKFLAG_PAGEIN kflags!

	if (pri@ TRYFOREVER &)
		IOKFLAG_SWAPIN kflags |=
	end

	kflags@ // kflags
	pfn@ PAGESHIFT << IDENTITYSPACE | // pageframe
	pte@@ // pte
	IOSwapPageReadPTE ok!

	if (ok@)
		auto ipl
		IPLDPC KeIPLRaise ipl!

		pfdbe@ MmEvictablePageDereference drop

		ipl@ // ipl
		pfdbe@ // pfdbe
		MmAnonymousPageDelete

		return
	end

	pte@@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
end

fn MmAnonymousPageDeleteByPTE { deletepte pteaddr vaddr process -- }
	auto pfdbe

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto capturedpte
	pteaddr@@ capturedpte!

	if (capturedpte@ MmPTEIsZero ~~)
		auto deref
		1 deref!

		if (capturedpte@ PTE_V &)
			auto phyaddr
			pteaddr@ MmPTEInterpret drop drop phyaddr!

			phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

			if (process@)
				0 // phyaddr
				0 // flags
				vaddr@ // vaddr
				pteaddr@ // pteaddr
				process@ KeProcess_ASID + @ // asid
				MmPTEUpdate drop drop drop
			end else
				0 pteaddr@!
			end

			ipl@ // ipl
			pfdbe@ // pfdbe
			MmAnonymousPageDelete
		end else
			if (process@)
				0 // phyaddr
				0 // flags
				vaddr@ // vaddr
				pteaddr@ // pteaddr
				process@ KeProcess_ASID + @ // asid
				MmPTEUpdate drop drop drop
			end else
				0 pteaddr@!
			end

			if (capturedpte@ PTE_INSWAP &)
				// free private page in swap

				ipl@ KeIPLLower

				0 deref!

				capturedpte@ IOSwapPageFreePTE
			end elseif (capturedpte@ PTE_TRANSITION &)
				// free private page

				capturedpte@ PAGENUMBERMASK & PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

				if (process@)
					// this page may actually be a shared page currently
					// undergoing page-in, in which case we do not want to
					// delete that page, or in fact delete the PTE, since the
					// former isn't our responsibility and the latter will be
					// done by the faulting thread when it realizes this PTE
					// was unmapped while it was blocked.

					if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_PRIVATE &)
						ipl@ // ipl
						pfdbe@ // pfdbe
						MmAnonymousPageDelete
					end else
						0 deletepte!
					end
				end else
					ipl@ // ipl
					pfdbe@ // pfdbe
					MmAnonymousPageDelete
				end
			end elseif (DEBUGCHECKS)
				capturedpte@ "MmAnonymousPageDeleteByPTE: strange PTE %08x\n" KeCrash
			end
		end

		if (deletepte@)
			// there was a PTE containing some information, so delete it.

			deref@ // deref
			pteaddr@ // pteaddr
			vaddr@ // vaddr
			process@ // process
			MmPTEDelete drop
		end
	end else
		ipl@ KeIPLLower
	end
end

fn MmAnonymousPageReferenceByPTE { dzpte evictflag refpfdbe process pri vaddr pteaddr localpteaddr -- pfdbe phyaddr ok }
	// assumes caller already did a MmPageWait and determined that the PTE is
	// not valid if it wants to do its own processing in that case.

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmAnonymousPageReference: ipl != IPLDPC\n" KeCrash
		end
	end

	0 ok!

	auto createdpage
	0 createdpage!

	auto asid

	if (process@)
		process@ KeProcess_ASID + @ asid!
	end else
		-1 asid!
	end

	auto capturedpte
	pteaddr@@ capturedpte!

	if (capturedpte@ PTE_V &)
		// already present, return

		pteaddr@ MmPTEInterpret ok! drop phyaddr!

		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		1 MmSoftPageFaultCount +=
	end elseif (capturedpte@ dzpte@ ==)
		// demand-zero PTE.

		if (dzpte@ PTE_KERNEL_DEMANDZERO ==)
			pteaddr@ // pte
			FREEFIRST pri@ | // pri
			MmAnonymousPageGet ok! phyaddr! pfdbe!
		end else
			pteaddr@ // pte
			ZEROMUST pri@ | // pri
			MmAnonymousPageGet ok! phyaddr! pfdbe!
		end

		if (ok@)
			return
		end

		dzpte@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

		1 MmSoftPageFaultCount +=

		PAGESHIFT phyaddr <<=

		1 createdpage!

		phyaddr@ // phyaddr
		PTE_V // flags
		vaddr@ // vaddr
		pteaddr@ // pteaddr
		asid@ // asid
		MmPTEUpdate drop drop drop
	end elseif (capturedpte@ PTE_TRANSITION &)
		// page is in transition.
		// if IO is in progress, wait for that to finish.

		capturedpte@ PAGENUMBERMASK & phyaddr!
		phyaddr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

		pfdbe@ MmEvictablePageReference drop

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
			pri@ CANBLOCK | // pri
			pfdbe@ // pfdbe
			MmEvictablePageWait ok!

			pfdbe@ MmEvictablePageDereference drop

			if (ok@)
				return
			end

			// say to refault so that the caller doesn't insert into the
			// working set since the owner of this IO is going to do that.

			STATUS_REFAULT ok!
		end else
			phyaddr@ // phyaddr
			PTE_V // flags
			vaddr@ // vaddr
			pteaddr@ // pteaddr
			asid@ // asid
			MmPTEUpdate drop drop drop
		end
	end elseif (capturedpte@ PTE_INSWAP &)
		// page was written to swap and then evicted. we are responsible
		// for bringing it in now.

		pteaddr@ // pte
		pri@ FREEFIRST | // pri
		MmAnonymousPageGet ok! phyaddr! pfdbe!

		if (ok@)
			return
		end

		capturedpte@ pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

		PAGESHIFT phyaddr <<=

		pfdbe@ MmEvictablePageStartIO

		auto transitionpte

		if (process@ PsSystemProcess@ ==)
			phyaddr@ PTE_TRANSITION | PTE_TLBHACK | transitionpte!
		end else
			phyaddr@ PTE_TRANSITION | transitionpte!
		end

		transitionpte@ pteaddr@!

		auto capturedlocalpte

		if (localpteaddr@)
			localpteaddr@@ capturedlocalpte!
			transitionpte@ localpteaddr@!
		end

		IPLLOW KeIPLLower

		auto kflags
		IOKFLAG_PAGEIN kflags!

		if (pri@ TRYFOREVER &)
			IOKFLAG_SWAPIN kflags |=
		end

		kflags@ // kflags
		phyaddr@ IDENTITYSPACE | // pageframe
		capturedpte@ // pte
		IOSwapPageReadPTE ok!

		IPLDPC KeIPLRaise drop

		pfdbe@ MmEvictablePageSatisfy

		if (ok@ ~~)
			// check that the PTE didn't get deleted.

			if (pteaddr@@ transitionpte@ ~=)
				// it got deleted. do NOT delete the pfdbe since it was
				// deleted already.

				STATUS_REFAULT ok!
			end

			if (localpteaddr@)
				if (localpteaddr@@ transitionpte@ ~=)
					STATUS_REFAULT ok!
				end
			end
		end elseif (pteaddr@@ transitionpte@ ==)
			// the PTE didn't get deleted, but there was an error, so reset.
			// delete the pfdbe since that hasn't been done.

			// prevent the swap page from being deleted.
			SWAPPTE_DEMANDZERO pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !

			// restore the old PTE.
			capturedpte@ pteaddr@!

			if (localpteaddr@)
				if (localpteaddr@@ transitionpte@ ==)
					capturedlocalpte@ pteaddr@!
				end
			end

			IPLDPC // ipl
			pfdbe@ // pfdbe
			MmAnonymousPageDelete
		end

		if (ok@)
			pfdbe@ MmEvictablePageDereference drop

			return
		end

		1 MmHardPageFaultCount +=
		1 MmPageInCount +=

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		phyaddr@ // phyaddr
		PTE_V // flags
		vaddr@ // vaddr
		pteaddr@ // pteaddr
		asid@ // asid
		MmPTEUpdate drop drop drop

		1 createdpage!
	end elseif (DEBUGCHECKS)
		capturedpte@ "MmAnonymousPageReference: odd PTE %x\n" Printf
	end

	if (createdpage@)
		if (evictflag@)
			// this is a private page or a page table

			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb evictflag@ |
			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

			if (evictflag@ MMEVICTFLAG_PRIVATE &)
				process@ pfdbe@ MmPageFrameEntryAnonymous_Process + !
				vaddr@ pfdbe@ MmPageFrameEntryAnonymous_VirtualAddress + !
			end
		end

		if (refpfdbe@)
			refpfdbe@ MmEvictablePageReference drop
		end
	end
end

fn MmAnonymousPageDelete { ipl pfdbe -- }
	pfdbe@ MmEvictablePageReference drop
	pfdbe@ MmEvictablePageDelete

	1 MmAnonymousPageCount -=

	ipl@ KeIPLLower

	if (pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ PTE_INSWAP &)
		// free in swap
		pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ IOSwapPageFreePTE
	end

	pfdbe@ MmEvictablePageDereference drop
end