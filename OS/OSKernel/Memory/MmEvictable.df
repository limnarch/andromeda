//
// Implements evictable page frame management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "MmInternal.h"

var MiEvictablePageListHead 0
public MiEvictablePageListHead

var MiEvictablePageListTail 0
public MiEvictablePageListTail

var MmEvictablePageCount 0
public MmEvictablePageCount

var MiModifiedPageListHead 0
public MiModifiedPageListHead

var MiModifiedPageListTail 0
public MiModifiedPageListTail

var MmModifiedPageCount 0
public MmModifiedPageCount

var MmModifiedFilePageCount 0
public MmModifiedFilePageCount

var MmTotalWorkingSetSize 0
public MmTotalWorkingSetSize

var MmPeakWorkingSetSize 0
public MmPeakWorkingSetSize

extern IOCachePageEvictionFunction { pfdbe -- }
extern MiAnonymousEvictionFunction { pfdbe -- }

table MiEvictableFunctionsTable
	// file
	pointerof IOCachePageEvictionFunction

	// anon
	pointerof MiAnonymousEvictionFunction
endtable

fn MmEvictablePageGet { flags evictabletype priority -- pfdbe pfn ok }
	priority@ // priority
	MmPageGet ok! pfn! pfdbe!

	if (ok@)
		return
	end

	1 pfdbe@ MiPageFrameEntryEvictable_ReferencesI + si

	0 pfdbe@ MiPageFrameEntryEvictable_Next + !
	0 pfdbe@ MiPageFrameEntryEvictable_Prev + !

	flags@ pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + sb
	evictabletype@ pfdbe@ MiPageFrameEntryEvictable_EvictionTypeB + sb

	if (flags@ MMEVICTFLAG_WORKINGSET &)
		auto rs
		HALCPUInterruptDisable rs!

		// allocation of evictable page implies addition to a working set.

		1 MmTotalWorkingSetSize +=

		if (MmTotalWorkingSetSize@ MmPeakWorkingSetSize@ >)
			MmTotalWorkingSetSize@ MmPeakWorkingSetSize!
		end

		rs@ HALCPUInterruptRestore
	end
end

fn MmEvictablePageDelete { pfdbe -- }
	auto rs
	HALCPUInterruptDisable rs!

	if (DEBUGCHECKS)
		if (pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi ~~)
			"MmEvictablePageDelete: page frame will leak\n" KeCrash
		end

		if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_DELETED &)
			"MmEvictablePageDelete: page frame already deleted\n" KeCrash
		end
	end

	pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_DELETED |
	pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + sb

	rs@ HALCPUInterruptRestore
end

fn MiEvictablePageInsert { pfdbe -- }
	// assumes IPLDPC or equivalent

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
		// insertion to evictable list implies removal from a working set.
		1 MmTotalWorkingSetSize -=
	end

	auto t

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
		if (pfdbe@ MiPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_FILE ==)
			1 MmModifiedFilePageCount +=
		end

		1 MmModifiedPageCount +=

		MiModifiedPageListTail@ t!

		if (t@ ~~)
			0 pfdbe@ MiPageFrameEntryEvictable_Next + !
			0 pfdbe@ MiPageFrameEntryEvictable_Prev + !

			pfdbe@ MiModifiedPageListHead!
			pfdbe@ MiModifiedPageListTail!
		end else
			0 pfdbe@ MiPageFrameEntryEvictable_Next + !

			t@ pfdbe@ MiPageFrameEntryEvictable_Prev + !
			pfdbe@ t@ MiPageFrameEntryEvictable_Next + !
			pfdbe@ MiModifiedPageListTail!
		end
	end else
		1 MmEvictablePageCount +=

		MiEvictablePageListTail@ t!

		if (t@ ~~)
			0 pfdbe@ MiPageFrameEntryEvictable_Next + !
			0 pfdbe@ MiPageFrameEntryEvictable_Prev + !

			pfdbe@ MiEvictablePageListHead!
			pfdbe@ MiEvictablePageListTail!
		end else
			0 pfdbe@ MiPageFrameEntryEvictable_Next + !

			t@ pfdbe@ MiPageFrameEntryEvictable_Prev + !
			pfdbe@ t@ MiPageFrameEntryEvictable_Next + !
			pfdbe@ MiEvictablePageListTail!
		end
	end
end

fn MmEvictablePageDereference { pfdbe -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmEvictablePageDereference: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - pfdbe@ MiPageFrameEntryEvictable_ReferencesI + si

	if (oldcount@ 1 ==)
		if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_DELETED &)
			if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
				1 MmTotalWorkingSetSize -=
			end

			rs@ HALCPUInterruptRestore

			// page frame was marked deleted, free it instead of putting it on
			// evictable list.

			pfdbe@ MiPageFreeByEntry

			return
		end

		// no refs now, add to back of evictable page LRU list

		pfdbe@ MiEvictablePageInsert
	end

	auto ipl

	if (oldcount@ 1 ==)
		if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
			if (MmModifiedPageCount@ MmModifiedPageMaximum@ >=)
				IPLDPC KeIPLRaise ipl!
				rs@ HALCPUInterruptRestore

				0 // priboost
				MmModifiedPageEvent // event
				KeEventSignal

				ipl@ KeIPLLower
			end else
				rs@ HALCPUInterruptRestore
			end
		end elseif (MmPageFreeCount@ MmEvictablePageCount@ + MMNORMALTHRESH ==)
			IPLDPC KeIPLRaise ipl!
			rs@ HALCPUInterruptRestore

			0 // priboost
			MiEventPageAvailable // event
			KeEventSignal

			ipl@ KeIPLLower
		end elseif (MmPageFreeCount@ MmEvictablePageCount@ + MMNORMALTHRESH <)
			IPLDPC KeIPLRaise ipl!
			rs@ HALCPUInterruptRestore

			0 // priboost
			MiEventMSPageAvailable // event
			KeEventSignal

			ipl@ KeIPLLower
		end else
			rs@ HALCPUInterruptRestore
		end
	end else
		rs@ HALCPUInterruptRestore
	end
end

fn MiEvictablePageRemove { pfdbe -- }
	// assumes IPLDPC or equivalent

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
		// removal from evictable list implies addition to a working set.
		1 MmTotalWorkingSetSize +=

		if (MmTotalWorkingSetSize@ MmPeakWorkingSetSize@ >)
			MmTotalWorkingSetSize@ MmPeakWorkingSetSize!
		end
	end

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
		if (pfdbe@ MiPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_FILE ==)
			1 MmModifiedFilePageCount -=
		end

		1 MmModifiedPageCount -=
	end else
		1 MmEvictablePageCount -=
	end

	auto ls
	pfdbe@ MiPageFrameEntryEvictable_Prev + @ ls!

	auto ns
	pfdbe@ MiPageFrameEntryEvictable_Next + @ ns!

	if (ls@)
		ns@ ls@ MiPageFrameEntryEvictable_Next + !
	end else
		if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
			ns@ MiModifiedPageListHead!
		end else
			ns@ MiEvictablePageListHead!
		end
	end

	if (ns@)
		ls@ ns@ MiPageFrameEntryEvictable_Prev + !
	end else
		if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
			ls@ MiModifiedPageListTail!
		end else
			ls@ MiEvictablePageListTail!
		end
	end

	0 pfdbe@ MiPageFrameEntryEvictable_Prev + !
	0 pfdbe@ MiPageFrameEntryEvictable_Next + !
end

fn MmEvictablePageReference { pfdbe -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi oldcount!

	oldcount@ 1 + pfdbe@ MiPageFrameEntryEvictable_ReferencesI + si

	if (oldcount@ 0 ==)
		// ref'd, remove from evictable page LRU list

		pfdbe@ MiEvictablePageRemove
	end

	rs@ HALCPUInterruptRestore
end

fn MmEvictablePageModify { pfdbe process -- }
	if (DEBUGCHECKS)
		if (pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi ~~)
			"MmEvictablePageModify: modified a page with no references\n" KeCrash
		end
	end

	auto rs

	if (process@)
		// charge the process for the modified page (used for fault throttling)

		HALCPUInterruptDisable rs!

		if (process@ KeProcess_MemoryStateB + gb PROCESSSTATE_RESIDENT ==)
			1 process@ PsProcess_MmHeader + @ MiProcessHeader_ModifiedPageCount + +=
		end

		rs@ HALCPUInterruptRestore
	end
	
	auto tx

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_FILE ==)
		// mark the page modified & valid, call into IO cache layer to add
		// cacheblock to dirty list.

		HALCPUInterruptDisable rs!

		pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb tx!

		tx@ MMEVICTFLAG_MODIFIED | MMEVICTFLAG_VALID |
		pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + sb

		rs@ HALCPUInterruptRestore

		if (tx@ MMEVICTFLAG_MODIFIED & ~~)
			pfdbe@ IOCachePageModified
		end
	end elseif (pfdbe@ MiPageFrameEntryEvictable_EvictionTypeB + gb MMEVICTTYPE_ANON ==)
		// mark the page modified, set the saved swap PTE to DEMANDZERO, and
		// free the associated pagefile page (if any).

		HALCPUInterruptDisable rs!

		pfdbe@ MiPageFrameEntryAnonymous_SwapPTE + @ tx!

		SWAPPTE_DEMANDZERO
		tx@ PTE_TLBHACK & |
#ifdef DEBUGCHECKS
		tx@ PTE_KERNELSTACK & |
#endif
		pfdbe@ MiPageFrameEntryAnonymous_SwapPTE + !

		pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED |
		pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + sb

		rs@ HALCPUInterruptRestore

		if (tx@ PTE_INSWAP & ~~)
			// nothing to do
			return
		end

		tx@ IOSwapPageFreePTE
	end elseif (DEBUGCHECKS)
		"MmEvictablePageModify: modified a page type that doesn't like to be modified\n" KeCrash
	end
end

fn MiEvictSinglePage { -- pfdbe ok }
	// assumes IPLDPC

	MiEvictablePageListHead@ pfdbe!

	if (pfdbe@ ~~)
		STATUS_NO_MEMORY ok!
		return
	end

	// call the appropriate eviction function for the page type.

	pfdbe@ // pfdbe
	[pfdbe@ MiPageFrameEntryEvictable_EvictionTypeB + gb]MiEvictableFunctionsTable@ MmEvictionFunction

	if (DEBUGCHECKS)
		if (pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi 0 ~=)
			pfdbe@ MiPageFrameEntryEvictable_ReferencesI + gi
			"MmEvictSingleFastPage: attempt to evict a page with %d references\n" KeCrash
		end
	end

	// remove the page from the evictable list.

	pfdbe@ MiEvictablePageRemove

	if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
		1 MmTotalWorkingSetSize -=
	end

	0 ok!
end

fn MmEvictablePageWait { process pri pfdbe -- ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmEvictablePageWait: ipl != IPLDPC\n" KeCrash
		end

		if (process@)
			if (KeThreadCurrent@ KeThread_IgnoreKill + @ ~~)
				"MmEvictablePageWait: kill not ignored\n" KeCrash
			end
		end

		if (pri@ CANBLOCK & ~~)
			"MmEvictablePageWait: CANBLOCK not specified\n" KeCrash
		end
	end

	auto current
	KeThreadCurrent@ current!

	// wait for IO to complete on a cache page.

	// entered at IPLDPC

	0 ok!

	auto eventblock
	pfdbe@ MiPageFrameEntryWaitable_EventBlock + @ eventblock!

	if (eventblock@ ~~)
		// allocate an event block.
		// some odd but harmless interactions can happen here.

		IPLAPC KeIPLLower

		if (process@)
			process@ MmVADListUnlock
		end

		MiEvictablePageEvent_SIZEOF // bytes
		'IOCE' // tag
		pri@ // flags
		MmAllocWithTag ok! eventblock!

		if (process@)
			process@ MmVADListLock drop
		end

		IPLDPC KeIPLRaise drop

		if (ok@)
			return
		end

		if (pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS & ~~)
			// IO completed while doing that allocation, free our eventblock
			// and go home.

			eventblock@ MmFree

			return
		end

		if (pfdbe@ MiPageFrameEntryWaitable_EventBlock + @)
			// awkward, someone allocated one while we were trying to.
			// free ours and use theirs.

			eventblock@ MmFree
			pfdbe@ MiPageFrameEntryWaitable_EventBlock + @ eventblock!
		end else
			eventblock@ pfdbe@ MiPageFrameEntryWaitable_EventBlock + !

			0 // signaled
			OSEVENT_NOTIF // type
			"MmEvictablePageWaitEvent" // name
			eventblock@ MiEvictablePageEvent_Event + // event
			KeEventInitialize

			0 eventblock@ MiEvictablePageEvent_References + !
			0 eventblock@ MiEvictablePageEvent_WasMemoryPrivileged + !
		end
	end

	if (DEBUGCHECKS)
		if (pfdbe@ MiPageFrameEntryWaitable_OwningThread + @ KeThreadCurrent@ ==)
			"MmEvictablePageWait: self-collision\n" Printf
		end
	end

	if (KeThreadCurrent@ PsThread_MemoryPrivilegedCount + @)
		// i am a memory privileged thread! before i block and potentially
		// deadlock the system, sneeze on the thread performing IO on this
		// page and give it the memory privilege sickness temporarily.

		if (eventblock@ MiEvictablePageEvent_WasMemoryPrivileged + @ ~~)
			1 eventblock@ MiEvictablePageEvent_WasMemoryPrivileged + !
			1 pfdbe@ MiPageFrameEntryWaitable_OwningThread + @ PsThread_MemoryPrivilegedCount + +=
		end
	end

	1 eventblock@ MiEvictablePageEvent_References + +=

	IPLAPC KeIPLLower

	if (process@)
		process@ MmVADListUnlock
	end

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	eventblock@ MiEvictablePageEvent_Event + // object
	KeThreadWaitForObject drop

	if (process@)
		process@ MmVADListLock drop
	end

	IPLDPC KeIPLRaise drop

	1 eventblock@ MiEvictablePageEvent_References + -=

	if (eventblock@ MiEvictablePageEvent_References + @ ~~)
		eventblock@ MmFree
	end
end

fn MmEvictablePageSatisfy { pfdbe -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"MmEvictablePageSatisfy: ipl != IPLDPC \n" KeCrash
		end

		if (pfdbe@ MiPageFrameEntryWaitable_OwningThread + @ KeThreadCurrent@ ~=)
			"MmEvictablePageSatisfy: IO satisfied from other context\n" KeCrash
		end
	end

	pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS ~ &
	pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + sb

	auto eventblock
	pfdbe@ MiPageFrameEntryWaitable_EventBlock + @ eventblock!

	if (eventblock@)
		if (eventblock@ MiEvictablePageEvent_WasMemoryPrivileged + @)
			1 KeThreadCurrent@ PsThread_MemoryPrivilegedCount + -=
		end

		0 // priboost
		eventblock@ MiEvictablePageEvent_Event + // event
		KeEventSignal
	end
end

fn MmEvictablePageStartIO { pfdbe -- }
	pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS |
	pfdbe@ MiPageFrameEntryEvictable_EvictionFlagsB + sb

	KeThreadCurrent@ pfdbe@ MiPageFrameEntryWaitable_OwningThread + !
	0 pfdbe@ MiPageFrameEntryWaitable_EventBlock + !
end