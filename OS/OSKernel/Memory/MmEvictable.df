//
// Implements evictable page frame management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OSStatus.h"

var MmEvictablePageListHead 0
public MmEvictablePageListHead

var MmEvictablePageListTail 0
public MmEvictablePageListTail

var MmEvictablePageCount 0
public MmEvictablePageCount

var MmModifiedPageListHead 0
public MmModifiedPageListHead

var MmModifiedPageListTail 0
public MmModifiedPageListTail

var MmModifiedPageCount 0
public MmModifiedPageCount

var MmTotalWorkingSetSize 0
public MmTotalWorkingSetSize

var MmPeakWorkingSetSize 0
public MmPeakWorkingSetSize

extern IOCachePageReferenceFunction { oldcount pfdbe -- }
extern IOCachePageDereferenceFunction { oldcount pfdbe -- }
extern IOCachePageEvictionFunction { pfdbe -- }

extern MmAnonymousEvictionFunction { pfdbe -- }

extern MmSlabEvictionFunction { pfdbe -- }

table MmEvictableFunctionsTable
	// file
	pointerof IOCachePageEvictionFunction
	pointerof IOCachePageReferenceFunction
	pointerof IOCachePageDereferenceFunction

	// anon
	pointerof MmAnonymousEvictionFunction
	0
	0

	// slab
	pointerof MmSlabEvictionFunction
	0
	0
endtable

struct MmEvictableFunctions
	4 EvictionFunc
	4 ReferenceFunc
	4 DereferenceFunc
endstruct

fn MmEvictablePageAlloc { flags evictabletype priority -- pfdbe pfn ok }
	priority@ // priority
	MmPageAlloc ok! pfn! pfdbe!

	if (ok@)
		return
	end

	1 pfdbe@ MmPageFrameEntryEvictable_ReferencesI + si

	0 pfdbe@ MmPageFrameEntryEvictable_Next + !
	0 pfdbe@ MmPageFrameEntryEvictable_Prev + !

	flags@ pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
	evictabletype@ pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + sb

	if (flags@ MMEVICTFLAG_WORKINGSET &)
		auto rs
		HALCPUInterruptDisable rs!

		// allocation of evictable page implies addition to a working set.

		1 MmTotalWorkingSetSize +=

		if (MmTotalWorkingSetSize@ MmPeakWorkingSetSize@ >)
			MmTotalWorkingSetSize@ MmPeakWorkingSetSize!
		end

		rs@ HALCPUInterruptRestore
	end
end

fn MmEvictablePageDelete { pfdbe -- }
	auto rs
	HALCPUInterruptDisable rs!

	if (DEBUGCHECKS)
		if (pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi ~~)
			"MmEvictablePageDelete: page frame will leak\n" KeCrash
		end
	end

	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_DELETED |
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

	rs@ HALCPUInterruptRestore
end

fn MmEvictablePageInsert { pfdbe -- }
	// assumes IPLDPC or equivalent

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
		// insertion to evictable list implies removal from a working set.
		1 MmTotalWorkingSetSize -=
	end

	auto t

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
		1 MmModifiedPageCount +=

		MmModifiedPageListTail@ t!

		if (t@ ~~)
			0 pfdbe@ MmPageFrameEntryEvictable_Next + !
			0 pfdbe@ MmPageFrameEntryEvictable_Prev + !

			pfdbe@ MmModifiedPageListHead!
			pfdbe@ MmModifiedPageListTail!
		end else
			0 pfdbe@ MmPageFrameEntryEvictable_Next + !

			t@ pfdbe@ MmPageFrameEntryEvictable_Prev + !
			pfdbe@ t@ MmPageFrameEntryEvictable_Next + !
			pfdbe@ MmModifiedPageListTail!
		end
	end else
		1 MmEvictablePageCount +=

		MmEvictablePageListTail@ t!

		if (t@ ~~)
			0 pfdbe@ MmPageFrameEntryEvictable_Next + !
			0 pfdbe@ MmPageFrameEntryEvictable_Prev + !

			pfdbe@ MmEvictablePageListHead!
			pfdbe@ MmEvictablePageListTail!
		end else
			0 pfdbe@ MmPageFrameEntryEvictable_Next + !

			t@ pfdbe@ MmPageFrameEntryEvictable_Prev + !
			pfdbe@ t@ MmPageFrameEntryEvictable_Next + !
			pfdbe@ MmEvictablePageListTail!
		end
	end
end

fn MmEvictablePageDereference { pfdbe -- oldcount }
	auto evictionfuncs
	MmEvictableFunctionsTable
	pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb
	MmEvictableFunctions_SIZEOF * + evictionfuncs!

	auto dereffunc
	evictionfuncs@ MmEvictableFunctions_DereferenceFunc + @ dereffunc!

	if (dereffunc@)
		pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi // oldcount (not guaranteed to be accurate...)
		pfdbe@ // pfdbe
		dereffunc@ MmDereferenceFunction
	end

	auto rs
	HALCPUInterruptDisable rs!

	pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"MmEvictablePageDereference: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - pfdbe@ MmPageFrameEntryEvictable_ReferencesI + si

	if (oldcount@ 1 ==)
		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_DELETED &)
			if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
				1 MmTotalWorkingSetSize -=
			end

			rs@ HALCPUInterruptRestore

			// page frame was marked deleted, free it instead of putting it on
			// evictable list.

			pfdbe@ MmPageFreeByEntry

			return
		end

		// no refs now, add to back of evictable page LRU list

		pfdbe@ MmEvictablePageInsert
	end

	rs@ HALCPUInterruptRestore

	if (oldcount@ 1 ==)
		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
			if (MmModifiedPageCount@ MmModifiedPageMaximum@ >=)
				0 // priboost
				MmModifiedPageEvent // event
				KeEventSignal
			end
		end else
			0 // priboost
			MmEventPageAvailable // event
			KeEventSignal
		end
	end
end

fn MmEvictablePageRemoveForDeletion { pfdbe -- }
	// assumes IPLDPC or equivalent

	pfdbe@ MmEvictablePageRemove

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
		1 MmTotalWorkingSetSize -=
	end
end

fn MmEvictablePageRemove { pfdbe -- }
	// assumes IPLDPC or equivalent

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_WORKINGSET &)
		// removal from evictable list implies addition to a working set.
		1 MmTotalWorkingSetSize +=

		if (MmTotalWorkingSetSize@ MmPeakWorkingSetSize@ >)
			MmTotalWorkingSetSize@ MmPeakWorkingSetSize!
		end
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
		1 MmModifiedPageCount -=
	end else
		1 MmEvictablePageCount -=
	end

	auto ls
	pfdbe@ MmPageFrameEntryEvictable_Prev + @ ls!

	auto ns
	pfdbe@ MmPageFrameEntryEvictable_Next + @ ns!

	if (ls@)
		ns@ ls@ MmPageFrameEntryEvictable_Next + !
	end else
		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
			ns@ MmModifiedPageListHead!
		end else
			ns@ MmEvictablePageListHead!
		end
	end

	if (ns@)
		ls@ ns@ MmPageFrameEntryEvictable_Prev + !
	end else
		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
			ls@ MmModifiedPageListTail!
		end else
			ls@ MmEvictablePageListTail!
		end
	end

	0 pfdbe@ MmPageFrameEntryEvictable_Prev + !
	0 pfdbe@ MmPageFrameEntryEvictable_Next + !
end

fn MmEvictablePageReference { pfdbe -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi oldcount!

	oldcount@ 1 + pfdbe@ MmPageFrameEntryEvictable_ReferencesI + si

	if (oldcount@ 0 ==)
		// ref'd, remove from evictable page LRU list

		pfdbe@ MmEvictablePageRemove
	end

	rs@ HALCPUInterruptRestore

	auto evictionfuncs
	MmEvictableFunctionsTable
	pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb
	MmEvictableFunctions_SIZEOF * + evictionfuncs!

	auto reffunc
	evictionfuncs@ MmEvictableFunctions_ReferenceFunc + @ reffunc!

	if (reffunc@)
		oldcount@ // oldcount
		pfdbe@ // pfdbe
		reffunc@ MmReferenceFunction
	end
end

fn MmEvictSinglePage { -- pfdbe ok }
	// assumes IPLDPC

	MmEvictablePageListHead@ pfdbe!

	if (pfdbe@ ~~)
		STATUS_NO_MEMORY ok!
		return
	end

	auto evictionfuncs
	MmEvictableFunctionsTable
	pfdbe@ MmPageFrameEntryEvictable_EvictionTypeB + gb
	MmEvictableFunctions_SIZEOF * + evictionfuncs!

	pfdbe@ // pfdbe
	evictionfuncs@
	MmEvictableFunctions_EvictionFunc + @ MmEvictionFunction

	// evicted, yoink

	if (DEBUGCHECKS)
		if (pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi 0 ~=)
			pfdbe@ MmPageFrameEntryEvictable_ReferencesI + gi
			"MmEvictSingleFastPage: attempt to evict a page with %d references\n" KeCrash
		end
	end

	pfdbe@ MmEvictablePageRemoveForDeletion

	0 ok!
end