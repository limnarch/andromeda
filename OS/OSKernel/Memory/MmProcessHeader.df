//
// Implements the pageable process header.
// It stores things that only need to be resident while the process has
// runnable threads, such as the working set list and other information.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn MmProcessHeaderCreate { process -- phdr pfdbe ok }
	fnsection "PAGE$text"

	auto quotablock
	process@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	PAGESIZE // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		return
	end

	1 // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeWS ok!

	if (ok@)
		PAGESIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	auto offset
	1 // pagesneeded
	MmPoolSpaceReserve ok! offset!

	if (ok@)
		PAGESIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		1 // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeWS

		return
	end

	auto vaddr
	POOLSPACE offset@ PAGESHIFT << + vaddr!

	process@ PsProcess_MmHeaderPTE + // pte
	FREEFIRST // priority
	MmAnonymousPageAlloc ok! phdr! pfdbe!

	if (ok@)
		1 // pages
		offset@ // offset
		MmPoolSpaceRelease

		PAGESIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		1 // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeWS

		return
	end

	pfdbe@ // pfdbe
	0 // process
	MmEvictablePageModify

	phdr@ PAGESHIFT << phdr!

	phdr@ process@ PsProcess_MmHeaderPTE + !
	vaddr@ process@ PsProcess_MmHeader + !

	phdr@ // phyaddr
	PTE_V PTE_W | PTE_K | PTE_G | // flags
	vaddr@ // vaddr
	MmPTEUpdateByVirtual drop drop
end

fn MmProcessHeaderDestroy { process -- }
	auto phdr
	process@ PsProcess_MmHeaderPTE + @ phdr!

	auto pfdbe
	phdr@ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!

	auto vaddr
	process@ PsProcess_MmHeader + @ vaddr!

	0 // phyaddr
	0 // flags
	vaddr@ // vaddr
	MmPTEUpdateByVirtual drop drop

	1 // pages
	vaddr@ POOLSPACE - PAGESHIFT >> // offset
	MmPoolSpaceRelease

	// MmAnonymousPageDelete wants to be entered at IPLDPC...

	auto ipl
	IPLDPC KeIPLRaise ipl!

	pfdbe@ MmEvictablePageDereference drop

	ipl@ // ipl
	pfdbe@ // pfdbe
	MmAnonymousPageDelete

	// ...but it leaves at the provided IPL

	auto quotablock
	process@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	PAGESIZE // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargeVM

	1 // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargeWS
end

fn MmProcessHeaderReference { pri process -- ok }
	if (DEBUGCHECKS)
		if (KeThreadCurrent@ KeThread_IgnoreKill + @ ~~)
			"MmProcessHeaderReference: thread could be killed\n" KeCrash
		end
	end

	0 ok!

	auto pfdbe

	auto ipl
	IPLDPC KeIPLRaise ipl!

	0 // process
	pri@ CANBLOCK | // priority
	MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower
		return
	end

	if (process@ PsProcess_MmHeaderPTE + @ PTE_INSWAP &)
		auto pt

		pri@ // priority
		process@ PsProcess_MmHeaderPTE + // pte
		process@ PsProcess_MmHeaderPTE + @ PAGESHIFT >> // pno
		ipl@ // ipl
		MmAnonymousSwapIn ok! pt! pfdbe!

		if (ok@)
			return
		end

		pt@ PAGESHIFT << process@ PsProcess_MmHeaderPTE + !

		pt@ PAGESHIFT << // phyaddr
		PTE_V PTE_W | PTE_K | PTE_G | // flags
		process@ PsProcess_MmHeader + @ // vaddr
		MmPTEUpdateByVirtual drop drop
	end else
		process@ PsProcess_MmHeaderPTE + @ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ + pfdbe!
		
		pfdbe@ MmEvictablePageReference drop

		ipl@ KeIPLLower
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		pfdbe@ // pfdbe
		0 // process
		MmEvictablePageModify
	end
end

fn MmProcessHeaderDereference { process -- }
	process@ PsProcess_MmHeaderPTE + @ PAGESHIFT >> MmPageFrameEntry_SIZEOF * MmPageFrameDatabase@ +
	MmEvictablePageDereference drop
end