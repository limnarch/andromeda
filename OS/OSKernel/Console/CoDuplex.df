//
// Implements the duplex pseudodevice driver.
// Acts like a unix pty or named pipe depending on flags.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Console.h"

#include "<ll>/OSDLL/OS.h"

#include "<ll>/OSDLL/OSConsoleControl.h"

struct CoDuplexBuffer
	4 Buffer
	4 Size
	4 ReadIndex
	4 WriteIndex
	4 RemainingSpace

	4 UserBuffer
	4 UserBufferIndex
	4 UserBufferLength
endstruct

struct CoDuplex
	CoConsoleHeader_SIZEOF ConsoleHeader

	// the buffers are named for their perspective to the client in a PTY
	// set-up.

	CoDuplexBuffer_SIZEOF ReceiveBuffer  // read by client, written by server
	CoDuplexBuffer_SIZEOF TransmitBuffer // written by client, read by server

	KeMutex_SIZEOF Mutex // only used if paged buffers, otherwise IPL sync

	4 Paged
	4 QuotaBlock

	4 Flags

	4 Headless

	4 ServerFCB

	4 ServerReadListHead
	4 ServerReadListTail

	4 ClientReadListHead
	4 ClientReadListTail

	4 ClientWriteListHead
	4 ClientWriteListTail
endstruct

table CoDuplexDriver
	IOVERSION_MAJOR                      // ioversion major
	IOVERSION_MINOR                      // ioversion minor

	"Duplex"                             // name
	OSFILETYPE_CHARDEVICE                // type
	pointerof CoDuplexDispatch           // dispatch table
	CoDuplex_SIZEOF                      // extension size

	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

table CoDuplexDispatch
	0                                    // open
	0                                    // close
	pointerof CoDuplexIOControl          // iocontrol
	pointerof CoDuplexRead               // read
	pointerof CoDuplexWrite              // write
	0                                    // unlink
	0                                    // parse
	0                                    // delete
	0                                    // flush
	pointerof CoDuplexDeleteFileObject   // delete object
	0                                    // poke
	0                                    // setsecurity
	0                                    // rename
	0                                    // readblock
	0                                    // writeblock
	0                                    // truncate
	0                                    // readdirectory
	0                                    // getpageaddr
	pointerof CoDuplexDeleteObject       // delete device object
	0                                    // reclaim fcb
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

fn CoDuplexBufferInitialize { size pri quotablock header -- ok }
	fnsection "PAGE$text"

	0 header@ CoDuplexBuffer_Buffer + !
	size@ header@ CoDuplexBuffer_Size + !
	0 header@ CoDuplexBuffer_ReadIndex + !
	0 header@ CoDuplexBuffer_WriteIndex + !
	size@ header@ CoDuplexBuffer_RemainingSpace + !

	0 header@ CoDuplexBuffer_UserBuffer + !
	0 header@ CoDuplexBuffer_UserBufferIndex + !
	0 header@ CoDuplexBuffer_UserBufferLength + !

	auto qcharge
	size@ MmChargeBytesGet qcharge!

	0 ok!

	if (quotablock@)
		// charge quota for buffer

		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockChargePaged ok!
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockCharge ok!
		end

		if (ok@)
			return
		end
	end

	// allocate buffer

	auto buf
	size@ // size
	'DxBf' // tag
	pri@ // flags
	MmAllocWithTag ok! buf!

	if (ok@)
		if (quotablock@)
			if (pri@ PAGED &)
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUnchargePaged
			end else
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUncharge
			end
		end

		return
	end

	buf@ header@ CoDuplexBuffer_Buffer + !
end

fn CoDuplexBufferUninitialize { pri quotablock header -- }
	fnsection "PAGE$text"

	auto buf
	header@ CoDuplexBuffer_Buffer + @ buf!

	auto bufsize
	header@ CoDuplexBuffer_Size + @ bufsize!

	auto qcharge
	bufsize@ MmChargeBytesGet qcharge!

	if (quotablock@)
		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargePaged
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUncharge
		end
	end

	buf@ MmFree
end

fn CoDuplexLock { duplex -- ipl ok }
	if (duplex@ CoDuplex_Flags + @ PAGED &)
		KERNELMODE // waitmode
		1 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		duplex@ CoDuplex_Mutex + // object
		KeThreadWaitForObject ok!
	end else
		IPLDPC KeIPLRaise ipl!
		0 ok!
	end
end

fn CoDuplexUnlock { ipl duplex -- }
	if (duplex@ CoDuplex_Flags + @ PAGED &)
		0 // abandon
		duplex@ CoDuplex_Mutex + // mutex
		KeMutexRelease drop
	end else
		ipl@ KeIPLLower
	end
end

fn CoDuplexObjectCreate { flags pri quotablock permanent name permissions -- duplexobject fileobject ok }
	fnsection "PAGE$text"

	if (flags@ OSDUPLEXFLAG_CONSOLE &)
		if (flags@ OSDUPLEXFLAG_SIMPLEX &)
			STATUS_INVALID_ARGUMENT ok!
			return
		end
	end

	name@ // name
	0 // sizeinbytes
	CoDuplexDriver // driver
	permissions@ // permissions
	permanent@ // permanent
	IODeviceCreateEx ok! duplexobject!

	if (ok@)
		return
	end

	auto duplex
	duplexobject@ IODeviceGetExtension duplex!

	flags@ duplex@ CoDuplex_Flags + !
	pri@ duplex@ CoDuplex_Paged + !
	0 duplex@ CoDuplex_Headless + !

	0 duplex@ CoDuplex_ServerReadListHead + !
	0 duplex@ CoDuplex_ServerReadListTail + !

	0 duplex@ CoDuplex_ClientReadListHead + !
	0 duplex@ CoDuplex_ClientReadListTail + !

	0 duplex@ CoDuplex_ClientWriteListHead + !
	0 duplex@ CoDuplex_ClientWriteListTail + !

	if (flags@ OSDUPLEXFLAG_CONSOLE &)
		duplex@ CoDuplex_ConsoleHeader + CoConsoleInitialize
		duplex@ CoDuplex_ConsoleHeader + duplexobject@ IODevice_ConsoleHeader + !
	end

	128 // size
	pri@ // pri
	quotablock@ // quotablock
	duplex@ CoDuplex_ReceiveBuffer + // header
	CoDuplexBufferInitialize ok!

	if (ok@)
		duplexobject@ IODeviceDeallocateObject

		return
	end

	if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
		128 // size
		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_TransmitBuffer + // header
		CoDuplexBufferInitialize ok!

		if (ok@)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_ReceiveBuffer + // header
			CoDuplexBufferUninitialize

			duplexobject@ IODeviceDeallocateObject

			return
		end
	end

	if (pri@ PAGED &)
		"CoDuplexMutex" // name
		KERNELMODE // mode
		duplex@ CoDuplex_Mutex + // mutex
		KeMutexInitialize
	end

	auto serverfcb
	CoDuplexDispatch // dispatchtable
	duplexobject@ // devobj
	OSFILETYPE_CHARDEVICE // filetype
	0 // flags
	IOFileControlBlockCreate ok! serverfcb!

	if (ok@)
		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_ReceiveBuffer + // header
		CoDuplexBufferUninitialize

		if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_TransmitBuffer + // header
			CoDuplexBufferUninitialize
		end

		duplexobject@ IODeviceDeallocateObject

		return
	end

	serverfcb@ duplex@ CoDuplex_ServerFCB + !

	"DUPLEXSERVER" // openedpath
	0 // flags
	ACCESS_OWNER_ALL // permissions
	serverfcb@ // fcb
	IOFileCreateObject ok! fileobject!

	if (ok@)
		-1 // writeout
		serverfcb@ // fcb
		IOFileControlBlockDelete

		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_ReceiveBuffer + // header
		CoDuplexBufferUninitialize

		if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_TransmitBuffer + // header
			CoDuplexBufferUninitialize
		end

		duplexobject@ IODeviceDeallocateObject

		return
	end

	// bias refcounts for server fileobject
	duplexobject@ ObObjectReferenceByPointer drop
	serverfcb@ IOFileControlBlockReference drop

	quotablock@ MmQuotaBlockReference

	quotablock@ duplex@ CoDuplex_QuotaBlock + !
end

fn (IODispatchIOControlFunction) CoDuplexIOControl { arg2 arg1 access fcb lastmode -- ret ok }
	fnsection "PAGE$text"

	0 ok!
	0 ret!

	auto duplex
	fcb@ IOFileControlBlockGetDeviceObject IODeviceGetExtension duplex!

	auto console
	duplex@ IODevice_ConsoleHeader + @ console!

	if (arg1@ OSCONSOLEIOCONTROL_QUERY ==)
		auto query

		if (lastmode@ USERMODE ==)
			OSConsoleQuery_SIZEOF alloc query!

			query@ // ptr
			OSConsoleQuery_SIZEOF // size
			0 // word
			memset
		end else
			arg2@ query!
		end

		console@ CoConsoleHeader_WidthI + gi query@ OSConsoleQuery_Columns + !
		console@ CoConsoleHeader_HeightI + gi query@ OSConsoleQuery_Rows + !
		console@ CoConsoleHeader_Mode + @ query@ OSConsoleQuery_Mode + !

		if (lastmode@ USERMODE ==)
			arg2@ // dest
			query@ // src
			OSConsoleQuery_SIZEOF // size
			KeSafeCopyOut ok!
		end
	end elseif (arg1@ OSCONSOLEIOCONTROL_SETMODE ==)
		arg2@ console@ CoConsoleHeader_Mode + !
	end elseif (arg1@ OSCONSOLEIOCONTROL_RESETMODE ==)
		0 console@ CoConsoleHeader_Mode + !
	end else
		STATUS_NOT_SUPPORTED ok!
	end
end

fn (IODispatchReadFunction) CoDuplexRead { timeout flags kflags offset mdl fcb -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (mdl@ MmMDLHeader_Length + @ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	1 // lockforwrite
	mdl@ // mdl
	MmMDLPin ok!

	if (ok@)
		return
	end

	auto buf

	if (mdl@ MmMDLHeader_Pages + @ 1 >)
		mdl@ MmMDLMap ok!

		if (ok@)
			return
		end

		mdl@ MmMDLHeader_MappedAddress + @ buf!
	end else
		// only one page, copy thru identityspace as a time saver
		mdl@ MmMDLHeader_SIZEOF + @ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE |
		mdl@ MmMDLHeader_VirtualAddress + @ PAGEOFFSETMASK & + buf!
	end

	auto duplex
	fcb@ IOFileControlBlock_DeviceObject + @ IODeviceGetExtension duplex!

	// here, cooked defines whether encountering a \n or ^D causes an instant
	// completion or not.

	auto cooked

	if (fcb@ IOFileControlBlock_FSContext + @)
		0 cooked!
	end elseif (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
		0 cooked!
	end else
		1 cooked!
	end

	auto header

	auto ipl
	duplex@ CoDuplexLock ok! ipl!

	if (ok@)
		return
	end

	if (fcb@ IOFileControlBlock_FSContext + @)
		// server fcb, reading from the transmit buffer. this may pend.
		duplex@ CoDuplex_TransmitBuffer + header!		
	end else
		// client fcb, reading from the receive buffer. this may pend.
		duplex@ CoDuplex_ReceiveBuffer + header!
	end

	// read as much as possible from the buffer. if this completes, cool.
	// if it does not complete, then we need to enqueue the request.

	auto rp
	header@ CoDuplexBuffer_ReadIndex + @ rp!

	auto bytecnt
	header@ CoDuplexBuffer_WriteIndex + @ rp@ - bytecnt! // bytes available

	if (mdl@ MmMDLHeader_Length + @ bytecnt@ <)
		mdl@ MmMDLHeader_Length + @ bytecnt!
	end elseif (mdl@ MmMDLHeader_Length + @ bytecnt@ >)
		if (timeout@)
			STATUS_OTHER_CONDITION ok!
		end else
			STATUS_RING_EMPTY ok!
		end
	end

	if (bytecnt@)
		auto bufp
		header@ CoDuplexBuffer_Buffer + @ bufp!

		auto bufsize
		header@ CoDuplexBuffer_Size + @ bufsize!

		auto bufmask
		bufsize@ 1 - bufmask!

		auto endp
		rp@ bytecnt@ + endp!

		// TODO do a special copy if cooked to be able to catch \n and ^D

		if (rp@ bufmask@ ~ & endp@ bufmask@ ~ & ==)
			// doesn't cross the boundary, do a single copy

			buf@ // dest
			bufp@ rp@ bufmask@ & + // src
			bytecnt@ // sz
			memcpy
		end else
			// crosses the boundary, do two copies

			buf@ // dest
			bufp@ rp@ bufmask@ & + // src
			bufsize@ rp@ bufmask@ & - // sz
			memcpy

			buf@ bufsize@ rp@ bufmask@ & - + // dest
			bufp@ // src
			endp@ bufmask@ & // sz
			memcpy
		end

		endp@ header@ CoDuplexBuffer_ReadIndex + !
		bytecnt@ header@ CoDuplexBuffer_RemainingSpace + +=
	end

	if (ok@ STATUS_OTHER_CONDITION ==)
		// switch to user buffer.

		buf@ bytecnt@ + header@ CoDuplexBuffer_UserBuffer + !
		0 header@ CoDuplexBuffer_UserBufferIndex + !
		mdl@ MmMDLHeader_Length + @ bytecnt@ - header@ CoDuplexBuffer_UserBufferLength + !

		// enqueue the request.

		// TODO enqueue the request
	end elseif (ok@ ~~)
		// TODO unlock the duplex & complete the request
	end

	ipl@ duplex@ CoDuplexUnlock
end

fn (IODispatchWriteFunction) CoDuplexWrite { flags kflags offset mdl fcb -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (fcb@ IOFileControlBlock_FSContext + @)
		// server fcb, writing to the receive buffer, or directly into the
		// client's buffer. this does not pend since clients can't be trusted
		// to read data in a timely manner. if necessary it will just
		// overwrite old data.
		//
		// if echo is enabled, that must be performed here.
		// ^C, ^D, ^U, etc processing is also needed.


	end else
		// client fcb, writing to the transmit buffer, or directly into the
		// server's buffer. this may pend because the server is assumed to be
		// trusted to read and process the data in a timely manner.
		//
		// if cooked, processing such as \n -> \r\n is required.
	end

	0 // status
	0 // priboost
	mdl@ // mdl
	MmMDLComplete
end

fn (IODispatchDeleteObjectFunction) CoDuplexDeleteFileObject { object -- ok }
	fnsection "PAGE$text"

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	auto deviceobject
	fcb@ IOFileControlBlock_DeviceObject + @ deviceobject!

	auto duplex
	deviceobject@ IODeviceGetExtension duplex!

	if (fcb@ IOFileControlBlock_FSContext + @)
		// server fcb! mark duplex headless
		1 duplex@ CoDuplex_Headless + !

		if (deviceobject@ IODevice_ConsoleHeader + @)
			OSSIGNAL_HUP // signal
			deviceobject@ IODevice_ConsoleHeader + @ // console
			CoConsoleSignal
		end
	end

	// forward to generic function
	object@ IODeviceDeleteFileObject ok!
end

fn (IODispatchDeleteDeviceObjectFunction) CoDuplexDeleteObject { object -- }
	fnsection "PAGE$text"

	auto duplex
	object@ IODeviceGetExtension duplex!

	-1 // writeout
	duplex@ CoDuplex_ServerFCB + @ // fcb
	IOFileControlBlockDelete

	duplex@ CoDuplex_Paged + @ // pri
	duplex@ CoDuplex_QuotaBlock + @ // quotablock
	duplex@ CoDuplex_ReceiveBuffer + // header
	CoDuplexBufferUninitialize

	if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_SIMPLEX & ~~)
		duplex@ CoDuplex_Paged + @ // pri
		duplex@ CoDuplex_QuotaBlock + @ // quotablock
		duplex@ CoDuplex_TransmitBuffer + // header
		CoDuplexBufferUninitialize
	end

	duplex@ CoDuplex_QuotaBlock + @ MmQuotaBlockDereference
end