//
// Implements the duplex pseudodevice driver.
// Acts like a unix pty or named pipe depending on flags.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Console.h"

#include "<ll>/OSDLL/OS.h"

#include "<ll>/OSDLL/OSConsoleControl.h"

struct CoDuplexBuffer
	4 Buffer
	4 Size
	4 ReadIndex
	4 WriteIndex
	4 RemainingSpace

	4 UserBuffer
	4 UserBufferIndex
	4 UserBufferLength
endstruct

struct CoDuplex
	CoConsoleHeader_SIZEOF ConsoleHeader

	// the buffers are named for their perspective to the client in a PTY
	// set-up.

	CoDuplexBuffer_SIZEOF ReceiveBuffer  // read by client, written by server
	CoDuplexBuffer_SIZEOF TransmitBuffer // written by client, read by server

	KeMutex_SIZEOF Mutex // only used if paged buffers, otherwise IPL sync

	4 Paged
	4 QuotaBlock

	4 Flags

	4 Headless

	4 ServerFCB

	4 ServerReadListHead
	4 ServerReadListTail

	4 ClientReadListHead
	4 ClientReadListTail

	4 ClientWriteListHead
	4 ClientWriteListTail
endstruct

table CoDuplexDriver
	IOVERSION_MAJOR                      // ioversion major
	IOVERSION_MINOR                      // ioversion minor

	"Duplex"                             // name
	OSFILETYPE_CHARDEVICE                // type
	pointerof CoDuplexDispatch           // dispatch table
	CoDuplex_SIZEOF                      // extension size

	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

table CoDuplexDispatch
	0                                    // open
	0                                    // close
	pointerof CoDuplexIOControl          // iocontrol
	pointerof CoDuplexRead               // read
	pointerof CoDuplexWrite              // write
	0                                    // unlink
	0                                    // parse
	0                                    // delete
	0                                    // flush
	pointerof CoDuplexDeleteFileObject   // delete object
	0                                    // poke
	0                                    // setsecurity
	0                                    // rename
	0                                    // readblock
	0                                    // writeblock
	0                                    // truncate
	0                                    // readdirectory
	0                                    // getpageaddr
	pointerof CoDuplexDeleteObject       // delete device object
	0                                    // reclaim fcb
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

fn CoDuplexBufferInitialize { size pri quotablock header -- ok }
	fnsection "PAGE$text"

	0 header@ CoDuplexBuffer_Buffer + !
	size@ header@ CoDuplexBuffer_Size + !
	0 header@ CoDuplexBuffer_ReadIndex + !
	0 header@ CoDuplexBuffer_WriteIndex + !
	size@ header@ CoDuplexBuffer_RemainingSpace + !

	0 header@ CoDuplexBuffer_UserBuffer + !
	0 header@ CoDuplexBuffer_UserBufferIndex + !
	0 header@ CoDuplexBuffer_UserBufferLength + !

	auto qcharge
	size@ MmChargeBytesGet qcharge!

	0 ok!

	if (quotablock@)
		// charge quota for buffer

		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockChargePaged ok!
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockCharge ok!
		end

		if (ok@)
			return
		end
	end

	// allocate buffer

	auto buf
	size@ // size
	'DxBf' // tag
	pri@ // flags
	MmAllocWithTag ok! buf!

	if (ok@)
		if (quotablock@)
			if (pri@ PAGED &)
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUnchargePaged
			end else
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUncharge
			end
		end

		return
	end

	buf@ header@ CoDuplexBuffer_Buffer + !
end

fn CoDuplexBufferUninitialize { pri quotablock header -- }
	fnsection "PAGE$text"

	auto buf
	header@ CoDuplexBuffer_Buffer + @ buf!

	auto bufsize
	header@ CoDuplexBuffer_Size + @ bufsize!

	auto qcharge
	bufsize@ MmChargeBytesGet qcharge!

	if (quotablock@)
		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargePaged
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUncharge
		end
	end

	buf@ MmFree
end

fn CoDuplexLock { duplex -- ipl ok }
	if (duplex@ CoDuplex_Flags + @ PAGED &)
		KERNELMODE // waitmode
		1 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		duplex@ CoDuplex_Mutex + // object
		KeThreadWaitForObject ok!
	end else
		IPLDPC KeIPLRaise ipl!
		0 ok!
	end
end

fn CoDuplexUnlock { ipl duplex -- }
	if (duplex@ CoDuplex_Flags + @ PAGED &)
		0 // abandon
		duplex@ CoDuplex_Mutex + // mutex
		KeMutexRelease drop
	end else
		ipl@ KeIPLLower
	end
end

fn CoDuplexObjectCreate { flags pri quotablock permanent name permissions -- duplexobject fileobject ok }
	fnsection "PAGE$text"

	if (flags@ OSDUPLEXFLAG_CONSOLE &)
		if (flags@ OSDUPLEXFLAG_SIMPLEX &)
			STATUS_INVALID_ARGUMENT ok!
			return
		end
	end

	name@ // name
	0 // sizeinbytes
	CoDuplexDriver // driver
	permissions@ // permissions
	permanent@ // permanent
	IODeviceCreateEx ok! duplexobject!

	if (ok@)
		return
	end

	auto duplex
	duplexobject@ IODeviceGetExtension duplex!

	flags@ duplex@ CoDuplex_Flags + !
	pri@ duplex@ CoDuplex_Paged + !
	0 duplex@ CoDuplex_Headless + !

	0 duplex@ CoDuplex_ServerReadListHead + !
	0 duplex@ CoDuplex_ServerReadListTail + !

	0 duplex@ CoDuplex_ClientReadListHead + !
	0 duplex@ CoDuplex_ClientReadListTail + !

	0 duplex@ CoDuplex_ClientWriteListHead + !
	0 duplex@ CoDuplex_ClientWriteListTail + !

	if (flags@ OSDUPLEXFLAG_CONSOLE &)
		duplex@ CoDuplex_ConsoleHeader + CoConsoleInitialize
		duplex@ CoDuplex_ConsoleHeader + duplexobject@ IODevice_ConsoleHeader + !
	end

	128 // size
	pri@ // pri
	quotablock@ // quotablock
	duplex@ CoDuplex_ReceiveBuffer + // header
	CoDuplexBufferInitialize ok!

	if (ok@)
		duplexobject@ IODeviceDeallocateObject

		return
	end

	if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
		128 // size
		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_TransmitBuffer + // header
		CoDuplexBufferInitialize ok!

		if (ok@)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_ReceiveBuffer + // header
			CoDuplexBufferUninitialize

			duplexobject@ IODeviceDeallocateObject

			return
		end
	end

	if (pri@ PAGED &)
		"CoDuplexMutex" // name
		KERNELMODE // mode
		duplex@ CoDuplex_Mutex + // mutex
		KeMutexInitialize
	end

	auto serverfcb
	CoDuplexDispatch // dispatchtable
	duplexobject@ // devobj
	OSFILETYPE_CHARDEVICE // filetype
	0 // flags
	IOFileControlBlockCreate ok! serverfcb!

	if (ok@)
		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_ReceiveBuffer + // header
		CoDuplexBufferUninitialize

		if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_TransmitBuffer + // header
			CoDuplexBufferUninitialize
		end

		duplexobject@ IODeviceDeallocateObject

		return
	end

	serverfcb@ duplex@ CoDuplex_ServerFCB + !

	"DUPLEXSERVER" // openedpath
	0 // flags
	ACCESS_OWNER_ALL // permissions
	serverfcb@ // fcb
	IOFileCreateObject ok! fileobject!

	if (ok@)
		-1 // writeout
		serverfcb@ // fcb
		IOFileControlBlockDelete

		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_ReceiveBuffer + // header
		CoDuplexBufferUninitialize

		if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_TransmitBuffer + // header
			CoDuplexBufferUninitialize
		end

		duplexobject@ IODeviceDeallocateObject

		return
	end

	// bias refcounts for server fileobject
	duplexobject@ ObObjectReferenceByPointer drop
	serverfcb@ IOFileControlBlockReference drop

	quotablock@ MmQuotaBlockReference

	quotablock@ duplex@ CoDuplex_QuotaBlock + !
end

fn (IODispatchIOControlFunction) CoDuplexIOControl { arg2 arg1 access fcb lastmode -- ret ok }
	fnsection "PAGE$text"

	0 ok!
	0 ret!

	auto duplex
	fcb@ IOFileControlBlockGetDeviceObject IODeviceGetExtension duplex!

	auto console
	duplex@ IODevice_ConsoleHeader + @ console!

	if (arg1@ OSCONSOLEIOCONTROL_QUERY ==)
		auto query

		if (lastmode@ USERMODE ==)
			OSConsoleQuery_SIZEOF alloc query!

			query@ // ptr
			OSConsoleQuery_SIZEOF // size
			0 // word
			memset
		end else
			arg2@ query!
		end

		console@ CoConsoleHeader_WidthI + gi query@ OSConsoleQuery_Columns + !
		console@ CoConsoleHeader_HeightI + gi query@ OSConsoleQuery_Rows + !
		console@ CoConsoleHeader_Mode + @ query@ OSConsoleQuery_Mode + !

		if (lastmode@ USERMODE ==)
			arg2@ // dest
			query@ // src
			OSConsoleQuery_SIZEOF // size
			KeSafeCopyOut ok!
		end
	end elseif (arg1@ OSCONSOLEIOCONTROL_SETMODE ==)
		arg2@ console@ CoConsoleHeader_Mode + !
	end elseif (arg1@ OSCONSOLEIOCONTROL_RESETMODE ==)
		0 console@ CoConsoleHeader_Mode + !
	end else
		STATUS_NOT_SUPPORTED ok!
	end
end

struct CoDuplexRequest
	4 Next
	4 Prev

	4 Flags
	4 MDL
	4 Duplex
	4 LengthDone
	4 Buffer
	4 Length
endstruct

const REQFLAG_WRITE  1

fn CoDuplexEnqueueRequest { buf length flags isserver mdl duplex -- }
	auto req
	mdl@ MmMDLHeader_DriverGoWild + req!

	flags@ req@ CoDuplexRequest_Flags + !
	mdl@ req@ CoDuplexRequest_MDL + !
	duplex@ req@ CoDuplexRequest_Duplex + !
	0 req@ CoDuplexRequest_LengthDone + !
	0 req@ CoDuplexRequest_Next + !
	buf@ req@ CoDuplexRequest_Buffer + !
	length@ req@ CoDuplexRequest_Length + !

	auto t

	if (isserver@)
		if (DEBUGCHECKS)
			if (flags@ REQFLAG_WRITE &)
				"CoDuplexEnqueueRequest: server write enqueue attempt\n" KeCrash
			end
		end

		duplex@ CoDuplex_ServerReadListTail + @ t!

		t@ req@ CoDuplexRequest_Prev + !

		if (t@ ~~)
			req@ duplex@ CoDuplex_ServerReadListHead + !
		end else
			req@ t@ CoDuplexRequest_Next + !
		end

		req@ duplex@ CoDuplex_ServerReadListTail + !
	end else
		if (flags@ REQFLAG_WRITE &)
			duplex@ CoDuplex_ClientWriteListTail + @ t!

			t@ req@ CoDuplexRequest_Prev + !

			if (t@ ~~)
				req@ duplex@ CoDuplex_ClientWriteListHead + !
			end else
				req@ t@ CoDuplexRequest_Next + !
			end

			req@ duplex@ CoDuplex_ClientWriteListTail + !
		end else
			duplex@ CoDuplex_ClientReadListTail + @ t!

			t@ req@ CoDuplexRequest_Prev + !

			if (t@ ~~)
				req@ duplex@ CoDuplex_ClientReadListHead + !
			end else
				req@ t@ CoDuplexRequest_Next + !
			end

			req@ duplex@ CoDuplex_ClientReadListTail + !
		end
	end
end

const DONE_NORMAL 1
const DONE_CTRLD  2

fn CoDuplexCookedCopy { dest src sz -- bytecnt done }
	0 done!
	0 bytecnt!

	while (sz@)
		1 bytecnt +=

		if (src@ gb 4 ==) // ^D
			DONE_CTRLD done!
			return
		end

		src@ gb dest@ sb

		1 dest +=
		1 src +=

		if (src@ gb '\n' ==)
			DONE_NORMAL done!
			return
		end

		1 sz -=
	end
end

fn CoDuplexCookedCopyClient { dest src sz -- bytecnt done }
	0 done!
	0 bytecnt!

	while (sz@)
		if (src@ gb '\n' ==)
			// needs to be turned into \r\n.

			if (sz@ 2 <)
				// not enough room in server buffer!
				// finish early so we don't lose this.

				DONE_NORMAL done!
				return
			end

			'\r' dest@ sb
			'\n' dest@ 1 + sb

			1 dest +=
			2 bytecnt +=
			2 sz -=
		end else
			src@ gb dest@ sb
			1 bytecnt +=
			1 dest +=
			1 sz -=
		end

		1 src +=
	end
end

fn CoDuplexServerRead { buf timeout mdl duplex -- ok }
	// duplex is locked (which means IPL may be >=IPLDPC).
	// MDL is pinned.

	// server fcb, reading from the transmit buffer and/or client buffers.
	// this may pend.

	auto done
	0 done!

	0 ok!

	auto bytecnt
	0 bytecnt!

	if (duplex@ CoDuplex_ServerReadListHead + @)
		// if there's a pending request already, then that means the transmit
		// buffer and any client buffers have all been drained.

		if (timeout@)
			STATUS_OTHER_CONDITION ok!
		end else
			STATUS_RING_EMPTY ok!
		end
	end else
		// read as much as possible from the buffer. if this completes, cool.
		// if it does not complete, then we need to look for pending client
		// buffers. if that completes, cool. if not, we need to enqueue the
		// request.

		auto header
		duplex@ CoDuplex_TransmitBuffer + header!

		auto rp
		header@ CoDuplexBuffer_ReadIndex + @ rp!

		header@ CoDuplexBuffer_WriteIndex + @ rp@ - bytecnt! // bytes available

		if (mdl@ MmMDLHeader_Length + @ bytecnt@ <)
			mdl@ MmMDLHeader_Length + @ bytecnt!
			1 done!
		end

		if (bytecnt@)
			auto bufp
			header@ CoDuplexBuffer_Buffer + @ bufp!

			auto bufsize
			header@ CoDuplexBuffer_Size + @ bufsize!

			auto bufmask
			bufsize@ 1 - bufmask!

			if (rp@ bufmask@ ~ & rp@ bytecnt@ + bufmask@ ~ & ==)
				// doesn't cross the boundary, do a single copy

				buf@ // dest
				bufp@ rp@ bufmask@ & + // src
				bytecnt@ // sz
				memcpy
			end else
				// crosses the boundary, do two copies

				buf@ // dest
				bufp@ rp@ bufmask@ & + // src
				bufsize@ rp@ bufmask@ & - // sz
				memcpy

				buf@ bufsize@ rp@ bufmask@ & - + // dest
				bufp@ // src
				rp@ bytecnt@ + bufmask@ & // sz
				memcpy
			end

			rp@ bytecnt@ + header@ CoDuplexBuffer_ReadIndex + !
			bytecnt@ header@ CoDuplexBuffer_RemainingSpace + +=
		end

		// bytecnt now contains the amount of bytes that have been read.

		// try to complete as many client writes as possible by reading
		// from their buffer.

		while (done@ ~~)
			auto req
			duplex@ CoDuplex_ClientWriteListHead + @ req!

			if (req@ ~~)
				break
			end

			// calculate available bytes in buffer.

			header@ CoDuplexBuffer_UserBufferLength + @
			header@ CoDuplexBuffer_UserBufferIndex + @ - rp!

			if (mdl@ MmMDLHeader_Length + @ bytecnt@ - rp@ <)
				mdl@ MmMDLHeader_Length + @ bytecnt@ - rp!
				1 done!
			end

			if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
				buf@ bytecnt@ + // dest
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + // src
				rp@ // sz
				memcpy
			end else
				buf@ bytecnt@ + // dest
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + // src
				rp@ // sz
				CoDuplexCookedCopyClient done |= rp!
			end

			rp@ bytecnt +=
			rp@ header@ CoDuplexBuffer_UserBufferIndex + +=

			if (header@ CoDuplexBuffer_UserBufferIndex + @
				header@ CoDuplexBuffer_UserBufferLength + @ ==)

				// complete the client MDL.

				0 // status
				0 // priboost
				req@ CoDuplexRequest_MDL + @ // mdl
				MmMDLComplete

				// unlink the client request.

				req@ CoDuplexRequest_Next + @ req!

				req@ duplex@ CoDuplex_ClientWriteListHead + !

				if (req@)
					0 req@ CoDuplexRequest_Prev + !

					req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
					0 header@ CoDuplexBuffer_UserBufferIndex + !
					req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
				end else
					0 duplex@ CoDuplex_ClientWriteListTail + !
				end
			end
		end

		if (done@ ~~)
			if (timeout@)
				// switch to user buffer.

				buf@ bytecnt@ + header@ CoDuplexBuffer_UserBuffer + !
				0 header@ CoDuplexBuffer_UserBufferIndex + !
				mdl@ MmMDLHeader_Length + @ bytecnt@ - header@ CoDuplexBuffer_UserBufferLength + !

				STATUS_OTHER_CONDITION ok!
			end else
				STATUS_RING_EMPTY ok!
			end
		end
	end

	if (ok@ STATUS_OTHER_CONDITION ==)
		// enqueue the request at the tail of the appropriate queue.

		buf@ bytecnt@ + // buf
		mdl@ MmMDLHeader_Length + @ bytecnt@ - // length
		0 // flags
		1 // isserver
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexEnqueueRequest
	end
end

fn CoDuplexClientRead { buf timeout mdl duplex -- ok }
	// duplex is locked (which means IPL may be >=IPLDPC).
	// MDL is pinned.

	// client fcb, reading from the receive buffer.
	// this may pend.

	auto done
	0 done!

	0 ok!

	auto bytecnt
	0 bytecnt!

	if (duplex@ CoDuplex_ClientReadListHead + @)
		// if there's a pending request already, then that means the receive
		// buffer has been drained.

		if (timeout@)
			STATUS_OTHER_CONDITION ok!
		end else
			STATUS_RING_EMPTY ok!
		end
	end else
		// read as much as possible from the buffer. if this completes, cool.
		// if it does not complete, then we need to enqueue the request.

		auto header
		duplex@ CoDuplex_ReceiveBuffer + header!

		auto rp
		header@ CoDuplexBuffer_ReadIndex + @ rp!

		header@ CoDuplexBuffer_WriteIndex + @ rp@ - bytecnt! // bytes available

		if (mdl@ MmMDLHeader_Length + @ bytecnt@ <)
			mdl@ MmMDLHeader_Length + @ bytecnt!
			1 done!
		end

		if (bytecnt@)
			auto bufp
			header@ CoDuplexBuffer_Buffer + @ bufp!

			auto bufsize
			header@ CoDuplexBuffer_Size + @ bufsize!

			auto bufmask
			bufsize@ 1 - bufmask!

			if (rp@ bufmask@ ~ & rp@ bytecnt@ + bufmask@ ~ & ==)
				// doesn't cross the boundary, do a single copy

				if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bytecnt@ // sz
					memcpy
				end else
					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bufsize@ rp@ bufmask@ & - // sz
					CoDuplexCookedCopy done |= bytecnt!
				end
			end else
				// crosses the boundary, do two copies

				if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bufsize@ rp@ bufmask@ & - // sz
					memcpy

					buf@ bufsize@ rp@ bufmask@ & - + // dest
					bufp@ // src
					rp@ bytecnt@ + bufmask@ & // sz
					memcpy
				end else
					auto bc

					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bufsize@ rp@ bufmask@ & - // sz
					CoDuplexCookedCopy done |= bc!

					if (done@ ~~)
						buf@ bufsize@ rp@ bufmask@ & - + // dest
						bufp@ // src
						rp@ bytecnt@ + bufmask@ & // sz
						CoDuplexCookedCopy done |= bc +=
					end

					bc@ bytecnt!
				end
			end

			if (done@ DONE_CTRLD &)
				if (bytecnt@ 1 >)
					rp@ bytecnt@ + 1 - header@ CoDuplexBuffer_ReadIndex + !
				end else
					rp@ bytecnt@ + header@ CoDuplexBuffer_ReadIndex + !
				end
			end else
				rp@ bytecnt@ + header@ CoDuplexBuffer_ReadIndex + !
			end

			bytecnt@ header@ CoDuplexBuffer_RemainingSpace + +=
		end

		// bytecnt now contains the amount of bytes that have been read.

		if (done@ ~~)
			if (timeout@)
				// switch to user buffer.

				buf@ bytecnt@ + header@ CoDuplexBuffer_UserBuffer + !
				0 header@ CoDuplexBuffer_UserBufferIndex + !
				mdl@ MmMDLHeader_Length + @ bytecnt@ - header@ CoDuplexBuffer_UserBufferLength + !

				STATUS_OTHER_CONDITION ok!
			end else
				STATUS_RING_EMPTY ok!
			end
		end else
			if (done@ DONE_CTRLD &)
				1 bytecnt -=
			end

			bytecnt@ mdl@ MmMDLHeader_Length + !
		end
	end

	if (ok@ STATUS_OTHER_CONDITION ==)
		// enqueue the request at the tail of the appropriate queue.

		buf@ bytecnt@ + // buf
		mdl@ MmMDLHeader_Length + @ bytecnt@ - // length
		0 // flags
		0 // isserver
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexEnqueueRequest
	end
end

fn (IODispatchReadFunction) CoDuplexRead { timeout flags kflags offset mdl fcb -- ok }
	fnsection "PAGE$text"

	0 ok!

	auto duplex
	fcb@ IOFileControlBlock_DeviceObject + @ IODeviceGetExtension duplex!

	if (mdl@ MmMDLHeader_Length + @ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	if (fcb@ IOFileControlBlock_FSContext + @)
		if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_SIMPLEX &)
			STATUS_FORBIDDEN_OPERATION ok!
			return
		end
	end

	1 // lockforwrite
	mdl@ // mdl
	MmMDLPin ok!

	if (ok@)
		return
	end

	auto buf

	if (mdl@ MmMDLHeader_Pages + @ 1 >)
		mdl@ MmMDLMap ok!

		if (ok@)
			return
		end

		mdl@ MmMDLHeader_MappedAddress + @ buf!
	end else
		// only one page, copy thru identityspace as a time saver
		mdl@ MmMDLHeader_SIZEOF + @ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE |
		mdl@ MmMDLHeader_VirtualAddress + @ PAGEOFFSETMASK & + buf!
	end

	auto ipl
	duplex@ CoDuplexLock ok! ipl!

	if (ok@)
		return
	end

	if (fcb@ IOFileControlBlock_FSContext + @)
		buf@ // buf
		timeout@ // timeout
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexServerRead ok!
	end else
		buf@ // buf
		timeout@ // timeout
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexClientRead ok!
	end

	ipl@ duplex@ CoDuplexUnlock

	if (ok@ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end elseif (ok@ STATUS_OTHER_CONDITION ==)
		// this means the request was enqueued successfully, so report success
		0 ok!
	end
end

fn (IODispatchWriteFunction) CoDuplexWrite { flags kflags offset mdl fcb -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (fcb@ IOFileControlBlock_FSContext + @)
		// server fcb, writing to the receive buffer, or directly into the
		// client's buffer. this does not pend since clients can't be trusted
		// to read data in a timely manner. if necessary it will just
		// overwrite old data.
		//
		// if echo is enabled, that must be performed here.
		// ^C, ^D, ^U, etc processing is also needed.


	end else
		// client fcb, writing to the transmit buffer, or directly into the
		// server's buffer. this may pend because the server is assumed to be
		// trusted to read and process the data in a timely manner.
		//
		// if cooked, processing such as \n -> \r\n is required.
	end

	0 // status
	0 // priboost
	mdl@ // mdl
	MmMDLComplete
end

fn (IODispatchDeleteObjectFunction) CoDuplexDeleteFileObject { object -- ok }
	fnsection "PAGE$text"

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	auto deviceobject
	fcb@ IOFileControlBlock_DeviceObject + @ deviceobject!

	auto duplex
	deviceobject@ IODeviceGetExtension duplex!

	if (fcb@ IOFileControlBlock_FSContext + @)
		// server fcb! mark duplex headless
		1 duplex@ CoDuplex_Headless + !

		if (deviceobject@ IODevice_ConsoleHeader + @)
			OSSIGNAL_HUP // signal
			deviceobject@ IODevice_ConsoleHeader + @ // console
			CoConsoleSignal
		end
	end

	// forward to generic function
	object@ IODeviceDeleteFileObject ok!
end

fn (IODispatchDeleteDeviceObjectFunction) CoDuplexDeleteObject { object -- }
	fnsection "PAGE$text"

	auto duplex
	object@ IODeviceGetExtension duplex!

	-1 // writeout
	duplex@ CoDuplex_ServerFCB + @ // fcb
	IOFileControlBlockDelete

	duplex@ CoDuplex_Paged + @ // pri
	duplex@ CoDuplex_QuotaBlock + @ // quotablock
	duplex@ CoDuplex_ReceiveBuffer + // header
	CoDuplexBufferUninitialize

	if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_SIMPLEX & ~~)
		duplex@ CoDuplex_Paged + @ // pri
		duplex@ CoDuplex_QuotaBlock + @ // quotablock
		duplex@ CoDuplex_TransmitBuffer + // header
		CoDuplexBufferUninitialize
	end

	duplex@ CoDuplex_QuotaBlock + @ MmQuotaBlockDereference
end