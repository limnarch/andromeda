//
// Implements the duplex pseudodevice driver.
// Acts like a unix pty or named pipe depending on flags.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Console.h"

#include "<ll>/OSDLL/OS.h"

#include "<ll>/OSDLL/OSConsoleControl.h"

struct CoDuplexBuffer
	4 Buffer
	4 Size
	4 ReadIndex
	4 WriteIndex
	4 RemainingSpace

	4 UserBuffer
	4 UserBufferIndex
	4 UserBufferLength
endstruct

struct CoDuplex
	CoConsoleHeader_SIZEOF ConsoleHeader

	// the buffers are named for their perspective to the client in a PTY
	// set-up.

	CoDuplexBuffer_SIZEOF ReceiveBuffer  // read by client, written by server
	CoDuplexBuffer_SIZEOF TransmitBuffer // written by client, read by server

	KeMutex_SIZEOF Mutex // only used if paged buffers, otherwise IPL sync

	KeEvent_SIZEOF StoppedEvent

	4 Paged
	4 QuotaBlock

	4 Flags
	4 InternalFlags

	4 Disconnected

	4 ServerFCB

	4 ServerReadListHead
	4 ServerReadListTail

	4 ServerWriteListHead
	4 ServerWriteListTail

	4 ClientReadListHead
	4 ClientReadListTail

	4 ClientWriteListHead
	4 ClientWriteListTail

	4 Context

	4 TXFunc
	4 FlushFunc
endstruct

table CoDuplexDriver
	IOVERSION_MAJOR                      // ioversion major
	IOVERSION_MINOR                      // ioversion minor

	"Duplex"                             // name
	OSFILETYPE_CHARDEVICE                // type
	pointerof CoDuplexDispatch           // dispatch table
	CoDuplex_SIZEOF                      // extension size

	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

table CoDuplexDispatch
	0                                    // open
	0                                    // close
	pointerof CoDuplexIOControl          // iocontrol
	pointerof CoDuplexRead               // read
	pointerof CoDuplexWrite              // write
	0                                    // unlink
	0                                    // parse
	0                                    // delete
	0                                    // flush
	pointerof CoDuplexDeleteFileObject   // delete object
	0                                    // poke
	0                                    // setsecurity
	0                                    // rename
	0                                    // readblock
	0                                    // writeblock
	0                                    // truncate
	0                                    // readdirectory
	0                                    // getpageaddr
	pointerof CoDuplexDeleteObject       // delete device object
	0                                    // reclaim fcb
	pointerof CoDuplexCancel             // cancel operation
	0                                    // reserved
	0                                    // reserved
endtable

const DUPLEXFLAG_PENDING_LF 0x80000000
const DUPLEXFLAG_STOPPED    0x40000000

fn CoDuplexBufferInitialize { size pri quotablock header -- ok }
	fnsection "PAGE$text"

	0 header@ CoDuplexBuffer_Buffer + !
	size@ header@ CoDuplexBuffer_Size + !
	0 header@ CoDuplexBuffer_ReadIndex + !
	0 header@ CoDuplexBuffer_WriteIndex + !
	size@ header@ CoDuplexBuffer_RemainingSpace + !

	0 header@ CoDuplexBuffer_UserBuffer + !
	0 header@ CoDuplexBuffer_UserBufferIndex + !
	0 header@ CoDuplexBuffer_UserBufferLength + !

	auto qcharge
	size@ MmChargeBytesGet qcharge!

	0 ok!

	if (quotablock@)
		// charge quota for buffer

		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockChargePaged ok!
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockCharge ok!
		end

		if (ok@)
			return
		end
	end

	// allocate buffer

	auto buf
	size@ // size
	'DxBf' // tag
	pri@ CANBLOCK | // flags
	MmAllocWithTag ok! buf!

	if (ok@)
		if (quotablock@)
			if (pri@ PAGED &)
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUnchargePaged
			end else
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUncharge
			end
		end

		return
	end

	buf@ header@ CoDuplexBuffer_Buffer + !
end

fn CoDuplexBufferUninitialize { pri quotablock header -- }
	fnsection "PAGE$text"

	auto buf
	header@ CoDuplexBuffer_Buffer + @ buf!

	auto bufsize
	header@ CoDuplexBuffer_Size + @ bufsize!

	auto qcharge
	bufsize@ MmChargeBytesGet qcharge!

	if (quotablock@)
		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargePaged
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUncharge
		end
	end

	buf@ MmFree
end

fn CoDuplexLock { duplex alertable -- ipl ok }
	if (duplex@ CoDuplex_Paged + @ PAGED &)
		KERNELMODE // waitmode
		alertable@ // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		duplex@ CoDuplex_Mutex + // object
		KeThreadWaitForObject ok!
	end else
		IPLDPC KeIPLRaise ipl!
		0 ok!
	end
end

fn CoDuplexUnlock { ipl duplex -- }
	if (duplex@ CoDuplex_Paged + @ PAGED &)
		0 // abandon
		duplex@ CoDuplex_Mutex + // mutex
		KeMutexRelease drop
	end else
		ipl@ KeIPLLower
	end
end

fn CoDuplexObjectCreate { context txfunc flushfunc flags pri quotablock permanent name permissions -- duplexobject fileobject ok }
	fnsection "PAGE$text"

	if (flags@ OSDUPLEXFLAG_CONSOLE &)
		if (flags@ OSDUPLEXFLAG_SIMPLEX &)
			STATUS_INVALID_ARGUMENT ok!
			return
		end
	end

	if (flags@ OSDUPLEXFLAG_SIMPLEX &)
		if (name@)
			STATUS_INVALID_ARGUMENT ok!
			return
		end
	end

	name@ // name
	0 // sizeinbytes
	CoDuplexDriver // driver
	permissions@ // permissions
	permanent@ // permanent
	IODeviceCreateEx ok! duplexobject!

	if (ok@)
		return
	end

	auto duplex
	duplexobject@ IODeviceGetExtension duplex!

	context@ duplex@ CoDuplex_Context + !

	txfunc@ duplex@ CoDuplex_TXFunc + !
	flushfunc@ duplex@ CoDuplex_FlushFunc + !

	0 duplex@ CoDuplex_InternalFlags + !

	flags@ duplex@ CoDuplex_Flags + !
	pri@ duplex@ CoDuplex_Paged + !
	0 duplex@ CoDuplex_Disconnected + !

	0 duplex@ CoDuplex_ServerReadListHead + !
	0 duplex@ CoDuplex_ServerReadListTail + !

	0 duplex@ CoDuplex_ServerWriteListHead + !
	0 duplex@ CoDuplex_ServerWriteListTail + !

	0 duplex@ CoDuplex_ClientReadListHead + !
	0 duplex@ CoDuplex_ClientReadListTail + !

	0 duplex@ CoDuplex_ClientWriteListHead + !
	0 duplex@ CoDuplex_ClientWriteListTail + !

	if (flags@ OSDUPLEXFLAG_CONSOLE &)
		duplex@ CoDuplex_ConsoleHeader + CoConsoleInitialize
		duplex@ CoDuplex_ConsoleHeader + duplexobject@ IODevice_ConsoleHeader + !
	end else
		OSCONSOLEMODE_RAW OSCONSOLEMODE_NOECHO | duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + !
	end

	128 // size
	pri@ // pri
	quotablock@ // quotablock
	duplex@ CoDuplex_ReceiveBuffer + // header
	CoDuplexBufferInitialize ok!

	if (ok@)
		duplexobject@ IODeviceDeallocateObject

		return
	end

	if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
		512 // size
		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_TransmitBuffer + // header
		CoDuplexBufferInitialize ok!

		if (ok@)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_ReceiveBuffer + // header
			CoDuplexBufferUninitialize

			duplexobject@ IODeviceDeallocateObject

			return
		end
	end

	if (pri@ PAGED &)
		"CoDuplexMutex" // name
		KERNELMODE // mode
		duplex@ CoDuplex_Mutex + // mutex
		KeMutexInitialize
	end

	0 // signaled
	OSEVENT_NOTIF // type
	"CoDuplexStoppedEvent" // name
	duplex@ CoDuplex_StoppedEvent + // event
	KeEventInitialize

	auto serverfcb
	CoDuplexDispatch // dispatchtable
	duplexobject@ // devobj
	OSFILETYPE_CHARDEVICE // filetype
	0 // flags
	IOFileControlBlockCreate ok! serverfcb!

	if (ok@)
		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_ReceiveBuffer + // header
		CoDuplexBufferUninitialize

		if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_TransmitBuffer + // header
			CoDuplexBufferUninitialize
		end

		duplexobject@ IODeviceDeallocateObject

		return
	end

	1 serverfcb@ IOFileControlBlockSetContext

	serverfcb@ duplex@ CoDuplex_ServerFCB + !

	"DUPLEXSERVER" // openedpath
	0 // flags
	ACCESS_OWNER_ALL // permissions
	serverfcb@ // fcb
	IOFileCreateObject ok! fileobject!

	if (ok@)
		-1 // writeout
		serverfcb@ // fcb
		IOFileControlBlockDelete drop

		pri@ // pri
		quotablock@ // quotablock
		duplex@ CoDuplex_ReceiveBuffer + // header
		CoDuplexBufferUninitialize

		if (flags@ OSDUPLEXFLAG_SIMPLEX & ~~)
			pri@ // pri
			quotablock@ // quotablock
			duplex@ CoDuplex_TransmitBuffer + // header
			CoDuplexBufferUninitialize
		end

		duplexobject@ IODeviceDeallocateObject

		return
	end

	// bias refcounts for server fileobject
	duplexobject@ ObObjectReferenceByPointer drop

	if (quotablock@)
		quotablock@ MmQuotaBlockReference
	end

	quotablock@ duplex@ CoDuplex_QuotaBlock + !
end

fn CoDuplexCreate { flags name permissions -- duplexhandle filehandle ok }
	fnsection "PAGE$text"

	auto fileobject
	auto duplexobject

	0 // context
	0 // txfunc
	0 // flushfunc
	flags@ // flags
	PAGED // pri
	KeProcessCurrent PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ // quotablock
	0 // permanent
	name@ // name
	permissions@ // permissions
	CoDuplexObjectCreate ok! fileobject! duplexobject!

	if (ok@)
		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	fileobject@ // object
	ObObjectOpen ok! filehandle!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop
		duplexobject@ ObObjectDereferenceByPointer drop

		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	duplexobject@ // object
	ObObjectOpen ok! duplexhandle!

	if (ok@)
		filehandle@ ObObjectClose drop

		duplexobject@ ObObjectDereferenceByPointer drop

		return
	end
end

fn CoDuplexGetContext { duplex -- context }
	duplex@ CoDuplex_Context + @ context!
end

fn (IODispatchIOControlFunction) CoDuplexIOControl { arg2 arg1 access fcb lastmode -- ret ok }
	fnsection "PAGE$text"

	0 ok!
	0 ret!

	auto duplex
	fcb@ IOFileControlBlockGetDeviceObject IODeviceGetExtension duplex!

	auto console
	fcb@ IOFileControlBlockGetDeviceObject IODevice_ConsoleHeader + @ console!

	if (console@ ~~)
		STATUS_NOT_SUPPORTED ok!
		return
	end

	if (arg1@ OSCONSOLEIOCONTROL_QUERY ==)
		auto query

		if (lastmode@ USERMODE ==)
			OSConsoleQuery_SIZEOF alloc query!

			query@ // ptr
			OSConsoleQuery_SIZEOF // size
			0 // word
			memset
		end else
			arg2@ query!
		end

		console@ CoConsoleHeader_WidthI + gi query@ OSConsoleQuery_Columns + !
		console@ CoConsoleHeader_HeightI + gi query@ OSConsoleQuery_Rows + !
		console@ CoConsoleHeader_Mode + @ query@ OSConsoleQuery_Mode + !

		if (lastmode@ USERMODE ==)
			arg2@ // dest
			query@ // src
			OSConsoleQuery_SIZEOF // size
			KeSafeCopyOut ok!
		end
	end elseif (arg1@ OSCONSOLEIOCONTROL_SETMODE ==)
		arg2@ console@ CoConsoleHeader_Mode + !
	end elseif (arg1@ OSCONSOLEIOCONTROL_RESETMODE ==)
		0 console@ CoConsoleHeader_Mode + !
	end elseif (arg1@ OSCONSOLEIOCONTROL_EXPEDITE ==)
		if (duplex@ CoVideoConsole@ ==)
			CoVideoConsoleExpediteRedraw
		end
	end else
		STATUS_NOT_SUPPORTED ok!
	end
end

struct CoDuplexRequest
	4 Next
	4 Prev

	4 Flags
	4 MDL
	4 Duplex
	4 LengthDone
	4 Buffer
	4 Length
endstruct

const REQFLAG_WRITE     1
const REQFLAG_SERVER    2
const REQFLAG_RETURNANY 4

fn CoDuplexEnqueueRequest { lengthdone buf length flags mdl duplex -- }
	auto req
	mdl@ MmMDLHeader_DriverGoWild + req!

	flags@ req@ CoDuplexRequest_Flags + !
	mdl@ req@ CoDuplexRequest_MDL + !
	duplex@ req@ CoDuplexRequest_Duplex + !
	lengthdone@ req@ CoDuplexRequest_LengthDone + !
	0 req@ CoDuplexRequest_Next + !
	buf@ req@ CoDuplexRequest_Buffer + !
	length@ req@ CoDuplexRequest_Length + !

	auto header
	0 header!

	auto t

	if (flags@ REQFLAG_SERVER &)
		if (flags@ REQFLAG_WRITE &)
			if (DEBUGCHECKS)
				if (duplex@ CoDuplex_ClientReadListHead + @)
					"CoDuplexEnqueueRequest: server write & client read collide\n" KeCrash
				end
			end

			duplex@ CoDuplex_ServerWriteListTail + @ t!

			t@ req@ CoDuplexRequest_Prev + !

			if (t@ ~~)
				req@ duplex@ CoDuplex_ServerWriteListHead + !
				duplex@ CoDuplex_ReceiveBuffer + header!
			end else
				req@ t@ CoDuplexRequest_Next + !
			end

			req@ duplex@ CoDuplex_ServerWriteListTail + !
		end else
			if (DEBUGCHECKS)
				if (duplex@ CoDuplex_ClientWriteListHead + @)
					"CoDuplexEnqueueRequest: server read & client write collide\n" KeCrash
				end
			end

			duplex@ CoDuplex_ServerReadListTail + @ t!

			t@ req@ CoDuplexRequest_Prev + !

			if (t@ ~~)
				req@ duplex@ CoDuplex_ServerReadListHead + !
				duplex@ CoDuplex_TransmitBuffer + header!
			end else
				req@ t@ CoDuplexRequest_Next + !
			end

			req@ duplex@ CoDuplex_ServerReadListTail + !
		end
	end else
		if (flags@ REQFLAG_WRITE &)
			if (DEBUGCHECKS)
				if (duplex@ CoDuplex_ServerReadListHead + @)
					"CoDuplexEnqueueRequest: client write & server read collide\n" KeCrash
				end
			end

			duplex@ CoDuplex_ClientWriteListTail + @ t!

			t@ req@ CoDuplexRequest_Prev + !

			if (t@ ~~)
				req@ duplex@ CoDuplex_ClientWriteListHead + !
				duplex@ CoDuplex_TransmitBuffer + header!
			end else
				req@ t@ CoDuplexRequest_Next + !
			end

			req@ duplex@ CoDuplex_ClientWriteListTail + !
		end else
			if (DEBUGCHECKS)
				if (duplex@ CoDuplex_ServerWriteListHead + @)
					"CoDuplexEnqueueRequest: client read & server write collide\n" KeCrash
				end
			end

			duplex@ CoDuplex_ClientReadListTail + @ t!

			t@ req@ CoDuplexRequest_Prev + !

			if (t@ ~~)
				req@ duplex@ CoDuplex_ClientReadListHead + !
				duplex@ CoDuplex_ReceiveBuffer + header!
			end else
				req@ t@ CoDuplexRequest_Next + !
			end

			req@ duplex@ CoDuplex_ClientReadListTail + !
		end
	end

	if (header@)
		buf@ header@ CoDuplexBuffer_UserBuffer + !
		0 header@ CoDuplexBuffer_UserBufferIndex + !
		length@ header@ CoDuplexBuffer_UserBufferLength + !
	end
end

const DONE_NORMAL 1
const DONE_CTRLD  2
const DONE_LF     4

fn CoDuplexCookedCopy { dest src sz -- bytecnt done }
	0 done!
	0 bytecnt!

	while (sz@)
		1 bytecnt +=

		if (src@ gb 4 ==) // ^D
			DONE_CTRLD done!
			return
		end

		src@ gb dest@ sb

		if (src@ gb '\n' ==)
			DONE_NORMAL done!
			return
		end

		1 dest +=
		1 src +=

		1 sz -=
	end
end

fn CoDuplexCookedCopyClient { dest src maxdest maxsrc duplex -- bufread bytecnt }
	0 bytecnt!
	0 bufread!

	while (1)
		if (bufread@ maxsrc@ >=)
			break
		end

		if (bytecnt@ maxdest@ >=)
			break
		end

		if (src@ gb '\n' ==)
			if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_PENDING_LF &)
				DUPLEXFLAG_PENDING_LF ~ duplex@ CoDuplex_InternalFlags + &=

				'\n' dest@ sb
				1 bytecnt +=
				1 dest +=
			end else
				// needs to be turned into \r\n.

				if (maxdest@ bytecnt@ - 2 <)
					// not enough room in server buffer!
					// finish early so we don't lose this.

					'\r' dest@ sb

					DUPLEXFLAG_PENDING_LF duplex@ CoDuplex_InternalFlags + |=

					1 bytecnt +=

					return
				end

				'\r' dest@ sb
				'\n' dest@ 1 + sb

				2 dest +=
				2 bytecnt +=
			end
		end else
			DUPLEXFLAG_PENDING_LF ~ duplex@ CoDuplex_InternalFlags + &=

			src@ gb dest@ sb

			1 bytecnt +=
			1 dest +=
		end

		1 bufread +=
		1 src +=
	end
end

fn CoDuplexServerRead { flags buf timeout mdl duplex -- ok }
	// duplex is locked (which means IPL may be >=IPLDPC).
	// MDL is pinned.

	// server fcb, reading from the transmit buffer and/or client buffers.
	// this may pend.

	if (flags@ OSACCESSFLAG_RETURNANY &)
		REQFLAG_RETURNANY flags!
	end else
		0 flags!
	end

	auto done
	0 done!

	0 ok!

	auto bytecnt
	0 bytecnt!

	if (duplex@ CoDuplex_ServerReadListHead + @)
		// if there's a pending request already, then that means the transmit
		// buffer and any client buffers have all been drained.

		if (timeout@)
			STATUS_OTHER_CONDITION ok!
		end else
			0 mdl@ MmMDLHeader_Length + !

			STATUS_RING_EMPTY ok!
		end
	end else
		// read as much as possible from the buffer. if this completes, cool.
		// if it does not complete, then we need to look for pending client
		// buffers. if that completes, cool. if not, we need to enqueue the
		// request.

		auto header
		duplex@ CoDuplex_TransmitBuffer + header!

		auto rp
		header@ CoDuplexBuffer_ReadIndex + @ rp!

		header@ CoDuplexBuffer_WriteIndex + @ rp@ - bytecnt! // bytes available

		if (mdl@ MmMDLHeader_Length + @ bytecnt@ <)
			mdl@ MmMDLHeader_Length + @ bytecnt!
		end

		if (bytecnt@)
			auto bufp
			header@ CoDuplexBuffer_Buffer + @ bufp!

			auto bufsize
			header@ CoDuplexBuffer_Size + @ bufsize!

			auto bufmask
			bufsize@ 1 - bufmask!

			if (rp@ bufmask@ ~ & rp@ bytecnt@ + bufmask@ ~ & ==)
				// doesn't cross the boundary, do a single copy

				buf@ // dest
				bufp@ rp@ bufmask@ & + // src
				bytecnt@ // sz
				memcpy
			end else
				// crosses the boundary, do two copies

				buf@ // dest
				bufp@ rp@ bufmask@ & + // src
				bufsize@ rp@ bufmask@ & - // sz
				memcpy

				buf@ bufsize@ rp@ bufmask@ & - + // dest
				bufp@ // src
				rp@ bytecnt@ + bufmask@ & // sz
				memcpy
			end

			rp@ bytecnt@ + header@ CoDuplexBuffer_ReadIndex + !
			bytecnt@ header@ CoDuplexBuffer_RemainingSpace + +=

			if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
				DONE_NORMAL done |=
			end
		end

		// bytecnt now contains the amount of bytes that have been read.

		// try to complete as many client writes as possible by reading
		// from their buffer.

		while (done@ ~~)
			auto req
			duplex@ CoDuplex_ClientWriteListHead + @ req!

			if (req@ ~~)
				break
			end

			// calculate available bytes in buffer.

			header@ CoDuplexBuffer_UserBufferLength + @
			header@ CoDuplexBuffer_UserBufferIndex + @ - rp!

			if (mdl@ MmMDLHeader_Length + @ bytecnt@ - rp@ <)
				mdl@ MmMDLHeader_Length + @ bytecnt@ - rp!
			end

			auto bufread

			if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
				buf@ bytecnt@ + // dest
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + // src
				rp@ // sz
				memcpy

				rp@ bufread!
			end else
				buf@ bytecnt@ + // dest
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + // src
				mdl@ MmMDLHeader_Length + @ bytecnt@ - // maxdest
				header@ CoDuplexBuffer_UserBufferLength + @
				header@ CoDuplexBuffer_UserBufferIndex + @ - // maxsrc
				duplex@ // duplex
				CoDuplexCookedCopyClient rp! bufread!
			end

			bufread@ header@ CoDuplexBuffer_UserBufferIndex + +=

			rp@ bytecnt +=

			if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
				DONE_NORMAL done |=
			end

			if (header@ CoDuplexBuffer_UserBufferIndex + @
				header@ CoDuplexBuffer_UserBufferLength + @ ==)

				// complete the client MDL.

				header@ CoDuplexBuffer_UserBufferIndex + @
				req@ CoDuplexRequest_LengthDone + @ +
				req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !

				// unlink the client request.

				auto nreq
				req@ CoDuplexRequest_Next + @ nreq!

				0 // status
				0 // priboost
				req@ CoDuplexRequest_MDL + @ // mdl
				MmMDLComplete

				nreq@ req!

				req@ duplex@ CoDuplex_ClientWriteListHead + !

				if (req@)
					0 req@ CoDuplexRequest_Prev + !

					req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
					0 header@ CoDuplexBuffer_UserBufferIndex + !
					req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
				end else
					0 duplex@ CoDuplex_ClientWriteListTail + !
				end
			end
		end

		if (flags@ REQFLAG_RETURNANY &)
			if (bytecnt@)
				DONE_NORMAL done |=
				bytecnt@ mdl@ MmMDLHeader_Length + !
			end
		end

		if (done@ ~~)
			if (timeout@)
				// switch to user buffer.

				STATUS_OTHER_CONDITION ok!
			end else
				bytecnt@ mdl@ MmMDLHeader_Length + !

				STATUS_RING_EMPTY ok!
			end
		end
	end

	if (ok@ STATUS_OTHER_CONDITION ==)
		// enqueue the request at the tail of the appropriate queue.

		bytecnt@ // lengthdone
		buf@ bytecnt@ + // buf
		mdl@ MmMDLHeader_Length + @ bytecnt@ - // length
		REQFLAG_SERVER flags@ | // flags
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexEnqueueRequest
	end
end

fn CoDuplexClientRead { flags buf timeout mdl duplex -- ok }
	// duplex is locked (which means IPL may be >=IPLDPC).
	// MDL is pinned.

	// client fcb, reading from the receive buffer.
	// this may pend.

	if (flags@ OSACCESSFLAG_RETURNANY &)
		REQFLAG_RETURNANY flags!
	end else
		0 flags!
	end

	auto done
	0 done!

	0 ok!

	auto bytecnt
	0 bytecnt!

	if (duplex@ CoDuplex_ClientReadListHead + @)
		// if there's a pending request already, then that means the receive
		// buffer has been drained.

		if (timeout@)
			STATUS_OTHER_CONDITION ok!
		end else
			0 mdl@ MmMDLHeader_Length + !

			STATUS_RING_EMPTY ok!
		end
	end else
		// read as much as possible from the buffer. if this completes, cool.
		// if it does not complete, then we need to enqueue the request.

		auto header
		duplex@ CoDuplex_ReceiveBuffer + header!

		auto rp
		header@ CoDuplexBuffer_ReadIndex + @ rp!

		header@ CoDuplexBuffer_WriteIndex + @ rp@ - bytecnt! // bytes available

		if (mdl@ MmMDLHeader_Length + @ bytecnt@ <)
			mdl@ MmMDLHeader_Length + @ bytecnt!
		end

		if (bytecnt@)
			auto bufp
			header@ CoDuplexBuffer_Buffer + @ bufp!

			auto bufsize
			header@ CoDuplexBuffer_Size + @ bufsize!

			auto bufmask
			bufsize@ 1 - bufmask!

			if (rp@ bufmask@ ~ & rp@ bytecnt@ + bufmask@ ~ & ==)
				// doesn't cross the boundary, do a single copy

				if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bytecnt@ // sz
					memcpy
				end else
					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bytecnt@ // sz
					CoDuplexCookedCopy done |= bytecnt!
				end
			end else
				// crosses the boundary, do two copies

				if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bufsize@ rp@ bufmask@ & - // sz
					memcpy

					buf@ bufsize@ rp@ bufmask@ & - + // dest
					bufp@ // src
					rp@ bytecnt@ + bufmask@ & // sz
					memcpy
				end else
					auto bc

					buf@ // dest
					bufp@ rp@ bufmask@ & + // src
					bufsize@ rp@ bufmask@ & - // sz
					CoDuplexCookedCopy done |= bc!

					if (done@ ~~)
						buf@ bufsize@ rp@ bufmask@ & - + // dest
						bufp@ // src
						rp@ bytecnt@ + bufmask@ & // sz
						CoDuplexCookedCopy done |= bc +=
					end

					bc@ bytecnt!
				end
			end

			if (done@ DONE_CTRLD &)
				if (bytecnt@ 1 >)
					rp@ bytecnt@ + 1 - header@ CoDuplexBuffer_ReadIndex + !
					bytecnt@ 1 - header@ CoDuplexBuffer_RemainingSpace + +=
				end else
					rp@ bytecnt@ + header@ CoDuplexBuffer_ReadIndex + !
					bytecnt@ header@ CoDuplexBuffer_RemainingSpace + +=
				end
			end else
				rp@ bytecnt@ + header@ CoDuplexBuffer_ReadIndex + !
				bytecnt@ header@ CoDuplexBuffer_RemainingSpace + +=
			end

			if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
				DONE_NORMAL done |=
			end
		end

		// bytecnt now contains the amount of bytes that have been read.

		// try to complete as many server writes as possible by reading
		// from their buffer.

		while (done@ ~~)
			auto req
			duplex@ CoDuplex_ServerWriteListHead + @ req!

			if (req@ ~~)
				break
			end

			if (DEBUGCHECKS)
				if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_CONSOLE &)
					"CoDuplexClientRead: console read of enqueued server write\n" KeCrash
				end
			end

			// calculate available bytes in buffer.

			header@ CoDuplexBuffer_UserBufferLength + @
			header@ CoDuplexBuffer_UserBufferIndex + @ - rp!

			if (mdl@ MmMDLHeader_Length + @ bytecnt@ - rp@ <)
				mdl@ MmMDLHeader_Length + @ bytecnt@ - rp!
			end

			buf@ bytecnt@ + // dest
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + // src
			rp@ // sz
			memcpy

			rp@ header@ CoDuplexBuffer_UserBufferIndex + +=

			rp@ bytecnt +=

			if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
				DONE_NORMAL done |=
			end

			if (header@ CoDuplexBuffer_UserBufferIndex + @
				header@ CoDuplexBuffer_UserBufferLength + @ ==)

				// complete the server MDL.

				header@ CoDuplexBuffer_UserBufferIndex + @
				req@ CoDuplexRequest_LengthDone + @ +
				req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !

				// unlink the server request.

				auto nreq
				req@ CoDuplexRequest_Next + @ nreq!

				0 // status
				0 // priboost
				req@ CoDuplexRequest_MDL + @ // mdl
				MmMDLComplete

				nreq@ req!

				req@ duplex@ CoDuplex_ServerWriteListHead + !

				if (req@)
					0 req@ CoDuplexRequest_Prev + !

					req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
					0 header@ CoDuplexBuffer_UserBufferIndex + !
					req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
				end else
					0 duplex@ CoDuplex_ServerWriteListTail + !
				end
			end
		end

		if (flags@ REQFLAG_RETURNANY &)
			if (bytecnt@)
				DONE_NORMAL done |=
				bytecnt@ mdl@ MmMDLHeader_Length + !
			end
		end

		if (done@ ~~)
			if (timeout@ duplex@ CoDuplex_Disconnected + @ ~~ &&)
				// switch to user buffer.

				buf@ bytecnt@ + header@ CoDuplexBuffer_UserBuffer + !
				0 header@ CoDuplexBuffer_UserBufferIndex + !
				mdl@ MmMDLHeader_Length + @ bytecnt@ - header@ CoDuplexBuffer_UserBufferLength + !

				STATUS_OTHER_CONDITION ok!
			end else
				bytecnt@ mdl@ MmMDLHeader_Length + !

				STATUS_RING_EMPTY ok!
			end
		end else
			if (done@ DONE_CTRLD &)
				1 bytecnt -=
			end

			bytecnt@ mdl@ MmMDLHeader_Length + !
		end
	end

	if (ok@ STATUS_OTHER_CONDITION ==)
		// enqueue the request at the tail of the appropriate queue.

		bytecnt@ // lengthdone
		buf@ bytecnt@ + // buf
		mdl@ MmMDLHeader_Length + @ bytecnt@ - // length
		flags@ // flags
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexEnqueueRequest
	end
end

fn CoDuplexTXCharacter { c txfunc duplex -- done }
	auto ok

	0 done!

	if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_STOPPED &)
		return
	end

	if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
		c@ // c
		duplex@ // duplex
		txfunc@ CoDuplexTXFunction ok!

		if (ok@ ~~)
			DONE_NORMAL done!
		end
	end elseif (c@ '\n' ==)
		if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_PENDING_LF &)
			'\n' // c
			duplex@ // duplex
			txfunc@ CoDuplexTXFunction ok!

			if (ok@ ~~)
				DUPLEXFLAG_PENDING_LF ~ duplex@ CoDuplex_InternalFlags + &=
				DONE_NORMAL done!
			end
		end else
			'\r' // c
			duplex@ // duplex
			txfunc@ CoDuplexTXFunction ok!

			if (ok@ ~~)
				'\n' // c
				duplex@ // duplex
				txfunc@ CoDuplexTXFunction ok!

				if (ok@)
					DUPLEXFLAG_PENDING_LF duplex@ CoDuplex_InternalFlags + |=
				end else
					DONE_NORMAL done!
				end
			end
		end
	end else
		c@ // c
		duplex@ // duplex
		txfunc@ CoDuplexTXFunction ok!

		if (ok@ ~~)
			DONE_NORMAL done!
		end
	end
end

fn CoDuplexWriteCharacter { c duplex -- ok }
	auto ipl
	duplex@ // duplex
	1 // alertable
	CoDuplexLock ok! ipl!

	if (ok@)
		return
	end

	// client fcb, writing to the transmit buffer and/or server buffers.
	// this may pend.

	0 ok!

	// try to satisfy as many server reads as possible.
	// then resort to filling the transmit buffer.

	auto done
	0 done!

	auto txfunc
	duplex@ CoDuplex_TXFunc + @ txfunc!

	if (txfunc@)
		c@ // c
		txfunc@ // txfunc
		duplex@ // duplex
		CoDuplexTXCharacter done |=
	end

	auto header
	duplex@ CoDuplex_TransmitBuffer + header!

	auto bufwritten
	1 bufwritten!

	auto rp

	while (done@ ~~)
		auto req
		duplex@ CoDuplex_ServerReadListHead + @ req!

		if (req@ ~~)
			break
		end

		if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
			c@
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + sb

			DONE_NORMAL done!
		end elseif (c@ '\n' ==)
			if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_PENDING_LF &)
				'\n'
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + sb

				DUPLEXFLAG_PENDING_LF ~ duplex@ CoDuplex_InternalFlags + &=

				DONE_NORMAL done!
			end elseif (header@ CoDuplexBuffer_UserBufferLength + @
						header@ CoDuplexBuffer_UserBufferIndex + @ - 1 >)
				'\r'
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + sb

				'\n'
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + 1 + sb

				2 bufwritten!

				DONE_NORMAL done!
			end else
				'\r'
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + sb

				DUPLEXFLAG_PENDING_LF duplex@ CoDuplex_InternalFlags + |=
			end
		end else
			c@
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + sb

			DONE_NORMAL done!
		end

		bufwritten@ header@ CoDuplexBuffer_UserBufferIndex + +=

		if (header@ CoDuplexBuffer_UserBufferIndex + @
			header@ CoDuplexBuffer_UserBufferLength + @ ==
			req@ CoDuplexRequest_Flags + @ REQFLAG_RETURNANY & ||)

			// complete the server MDL.

			header@ CoDuplexBuffer_UserBufferIndex + @
			req@ CoDuplexRequest_LengthDone + @ +
			req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !

			// unlink the server request.

			auto nreq
			req@ CoDuplexRequest_Next + @ nreq!

			0 // status
			0 // priboost
			req@ CoDuplexRequest_MDL + @ // mdl
			MmMDLComplete

			nreq@ req!

			req@ duplex@ CoDuplex_ServerReadListHead + !

			if (req@)
				0 req@ CoDuplexRequest_Prev + !

				req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
				0 header@ CoDuplexBuffer_UserBufferIndex + !
				req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
			end else
				0 duplex@ CoDuplex_ServerReadListTail + !
			end
		end
	end

	if (done@ ~~)
		// try to copy to the transmit buffer.

		auto bufp
		header@ CoDuplexBuffer_Buffer + @ bufp!

		header@ CoDuplexBuffer_RemainingSpace + @ rp!

		if (rp@)
			auto bufsize
			header@ CoDuplexBuffer_Size + @ bufsize!

			auto bufmask
			bufsize@ 1 - bufmask!

			auto index
			header@ CoDuplexBuffer_WriteIndex + @ index!

			if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
				c@
				bufp@ index@ bufmask@ & + sb

				DONE_NORMAL done!
			end elseif (c@ '\n' ==)
				if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_PENDING_LF &)
					'\n'
					bufp@ index@ bufmask@ & + sb

					DUPLEXFLAG_PENDING_LF ~ duplex@ CoDuplex_InternalFlags + &=

					DONE_NORMAL done!
				end elseif (rp@ 1 >)
					'\r'
					bufp@ index@ bufmask@ & + sb

					'\n'
					bufp@ index@ 1 + bufmask@ & + sb

					2 bufwritten!

					DONE_NORMAL done!
				end
			end else
				c@
				bufp@ index@ bufmask@ & + sb

				DONE_NORMAL done!
			end

			index@ bufwritten@ + header@ CoDuplexBuffer_WriteIndex + !
			bufwritten@ header@ CoDuplexBuffer_RemainingSpace + -=
		end
	end

	ipl@ duplex@ CoDuplexUnlock
end

fn CoDuplexReadTransmitCharacter { duplex -- c ok }
	// duplex is locked (which means IPL may be >=IPLDPC).

	0 ok!

	if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_STOPPED &)
		-1 ok!
		return
	end

	// read as much as possible from the buffer. if this completes, cool.
	// if it does not complete, then we need to look for pending client
	// buffers. if that completes, cool.

	auto header
	duplex@ CoDuplex_TransmitBuffer + header!

	auto rp
	header@ CoDuplexBuffer_ReadIndex + @ rp!

	if (header@ CoDuplexBuffer_WriteIndex + @ rp@ -)
		auto bufp
		header@ CoDuplexBuffer_Buffer + @ bufp!

		auto bufsize
		header@ CoDuplexBuffer_Size + @ bufsize!

		auto bufmask
		bufsize@ 1 - bufmask!

		bufp@ rp@ bufmask@ & + gb c!

		rp@ 1 + header@ CoDuplexBuffer_ReadIndex + !
		1 header@ CoDuplexBuffer_RemainingSpace + +=

		return
	end

	// try to complete as many client writes as possible by reading
	// from their buffer.

	auto req
	duplex@ CoDuplex_ClientWriteListHead + @ req!

	if (req@)
		if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + gb c!

			1 header@ CoDuplexBuffer_UserBufferIndex + +=
		end else
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + gb c!

			if (c@ '\n' ==)
				if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_PENDING_LF &)
					'\n' c!
					1 header@ CoDuplexBuffer_UserBufferIndex + +=
					DUPLEXFLAG_PENDING_LF ~ duplex@ CoDuplex_InternalFlags + &=
				end else
					'\r' c!
					DUPLEXFLAG_PENDING_LF duplex@ CoDuplex_InternalFlags + |=
				end
			end else
				1 header@ CoDuplexBuffer_UserBufferIndex + +=
			end
		end

		if (header@ CoDuplexBuffer_UserBufferIndex + @
			header@ CoDuplexBuffer_UserBufferLength + @ ==)

			// complete the client MDL.

			header@ CoDuplexBuffer_UserBufferIndex + @
			req@ CoDuplexRequest_LengthDone + @ +
			req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !

			// unlink the client request.

			auto nreq
			req@ CoDuplexRequest_Next + @ nreq!

			0 // status
			0 // priboost
			req@ CoDuplexRequest_MDL + @ // mdl
			MmMDLComplete

			nreq@ req!

			req@ duplex@ CoDuplex_ClientWriteListHead + !

			if (req@)
				0 req@ CoDuplexRequest_Prev + !

				req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
				0 header@ CoDuplexBuffer_UserBufferIndex + !
				req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
			end else
				0 duplex@ CoDuplex_ClientWriteListTail + !
			end
		end

		return
	end

	-1 ok!
end

fn CoDuplexInputCharacter { c duplex -- ok }
	auto ipl
	duplex@ // duplex
	1 // alertable
	CoDuplexLock ok! ipl!

	if (ok@)
		return
	end

	// duplex is locked (which means IPL may be >=IPLDPC).

	0 ok!

	if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW & ~~)
		if (c@ 3 ==) // ^C
			OSSIGNAL_INT // signal
			duplex@ CoDuplex_ConsoleHeader + // console
			CoConsoleSignal

			3 duplex@ CoDuplexEcho

			ipl@ duplex@ CoDuplexUnlock

			return
		end elseif (c@ 19 ==) // ^S
			if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_STOPPED & ~~)
				DUPLEXFLAG_STOPPED duplex@ CoDuplex_InternalFlags + |=

				duplex@ CoDuplex_StoppedEvent + KeEventReset drop
			end

			ipl@ duplex@ CoDuplexUnlock

			return
		end
	end

	if (c@ 17 ==) // ^Q
		if (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_STOPPED &)
			DUPLEXFLAG_STOPPED ~ duplex@ CoDuplex_InternalFlags + &=

			0 // priboost
			duplex@ CoDuplex_StoppedEvent + // event
			KeEventSignal

			if (duplex@ CoDuplex_FlushFunc + @)
				duplex@ // duplex
				duplex@ CoDuplex_FlushFunc + @ CoDuplexFlushFunction
			end

			ipl@ duplex@ CoDuplexUnlock

			return
		end

		if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW & ~~)
			ipl@ duplex@ CoDuplexUnlock

			return
		end
	end

	// server fcb, writing to the receive buffer and/or client buffers.
	// if this is a console, this will not pend because the client can't be
	// expected to read characters promptly. otherwise it may pend.
	// also if it is a console, it will echo to the transmit buffer. if the
	// transmit buffer fills up, characters will be dropped.

	// try to satisfy as many client reads as possible.
	// then resort to filling the receive buffer. then, if we still have
	// characters, enqueue our own request.

	auto header
	duplex@ CoDuplex_ReceiveBuffer + header!

	auto done
	0 done!

	auto rp

	auto req
	duplex@ CoDuplex_ClientReadListHead + @ req!

	if (req@)
		auto clientdone
		0 clientdone!

		if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
			c@
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + sb

			1 header@ CoDuplexBuffer_UserBufferIndex + +=

			DONE_NORMAL done |=
		end elseif (c@ '\r' ==)
			'\n'
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + sb

			1 header@ CoDuplexBuffer_UserBufferIndex + +=

			'\n' duplex@ CoDuplexEcho

			DONE_NORMAL clientdone |=
			DONE_NORMAL done |=
		end elseif (c@ '\b' ==)
			// backspace.

			if (header@ CoDuplexBuffer_UserBufferIndex + @)
				1 header@ CoDuplexBuffer_UserBufferIndex + -=

				req@ CoDuplexRequest_Buffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + gb // c
				duplex@ // duplex
				CoDuplexEchoRubout
			end elseif (req@ CoDuplexRequest_LengthDone + @)
				1 req@ CoDuplexRequest_LengthDone + -=
				1 req@ CoDuplexRequest_Buffer + -=
				1 header@ CoDuplexBuffer_UserBuffer + -=
				1 req@ CoDuplexRequest_Length + +=

				req@ CoDuplexRequest_Buffer + @ gb // c
				duplex@ // duplex
				CoDuplexEchoRubout
			end

			DONE_NORMAL done |=
		end elseif (c@ 21 ==) // ^U
			// erase line.

			while (1)
				if (header@ CoDuplexBuffer_UserBufferIndex + @)
					1 header@ CoDuplexBuffer_UserBufferIndex + -=

					req@ CoDuplexRequest_Buffer + @
					header@ CoDuplexBuffer_UserBufferIndex + @ + gb // c
					duplex@ // duplex
					CoDuplexEchoRubout
				end elseif (req@ CoDuplexRequest_LengthDone + @)
					1 req@ CoDuplexRequest_LengthDone + -=
					1 req@ CoDuplexRequest_Buffer + -=
					1 header@ CoDuplexBuffer_UserBuffer + -=
					1 req@ CoDuplexRequest_Length + +=

					req@ CoDuplexRequest_Buffer + @ gb // c
					duplex@ // duplex
					CoDuplexEchoRubout
				end else
					break
				end
			end

			DONE_NORMAL done |=
		end elseif (c@ 4 ==) // ^D
			DONE_CTRLD clientdone |=
		end else
			c@
			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + sb

			1 header@ CoDuplexBuffer_UserBufferIndex + +=

			c@ duplex@ CoDuplexEcho

			DONE_NORMAL done |=
		end

		if (clientdone@ DONE_CTRLD &)
			if (header@ CoDuplexBuffer_UserBufferIndex + @
				req@ CoDuplexRequest_LengthDone + @ + ~~)
				DONE_NORMAL done |=

				c@ duplex@ CoDuplexEcho
			end
		end

		if (header@ CoDuplexBuffer_UserBufferIndex + @
			header@ CoDuplexBuffer_UserBufferLength + @ ==)
			DONE_NORMAL clientdone |=
		end elseif (req@ CoDuplexRequest_Flags + @ REQFLAG_RETURNANY &)
			DONE_NORMAL clientdone |=
		end

		if (clientdone@)
			// complete the client MDL.

			header@ CoDuplexBuffer_UserBufferIndex + @
			req@ CoDuplexRequest_LengthDone + @ +
			req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !

			// unlink the client request.

			auto nreq
			req@ CoDuplexRequest_Next + @ nreq!

			0 // status
			0 // priboost
			req@ CoDuplexRequest_MDL + @ // mdl
			MmMDLComplete

			nreq@ req!

			req@ duplex@ CoDuplex_ClientReadListHead + !

			if (req@)
				0 req@ CoDuplexRequest_Prev + !

				req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
				0 header@ CoDuplexBuffer_UserBufferIndex + !
				req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
			end else
				0 duplex@ CoDuplex_ClientReadListTail + !
			end
		end
	end

	if (done@ ~~)
		// try to copy to the receive buffer.

		auto bufp
		header@ CoDuplexBuffer_Buffer + @ bufp!

		header@ CoDuplexBuffer_RemainingSpace + @ rp!

		auto allow
		0 allow!

		if (rp@)
			1 allow!
		end elseif (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW & ~~)
			if (c@ '\b' == c@ 21 == ||)
				1 allow!
			end
		end

		if (allow@)
			auto bufsize
			header@ CoDuplexBuffer_Size + @ bufsize!

			auto bufmask
			bufsize@ 1 - bufmask!

			auto index
			header@ CoDuplexBuffer_WriteIndex + @ index!

			if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
				c@
				bufp@ index@ bufmask@ & + sb

				index@ 1 + header@ CoDuplexBuffer_WriteIndex + !
				1 header@ CoDuplexBuffer_RemainingSpace + -=
			end elseif (c@ '\b' ==)
				if (header@ CoDuplexBuffer_RemainingSpace + @ bufsize@ <)
					if (bufp@ index@ 1 - bufmask@ & + gb '\n' ~=)
						index@ 1 - header@ CoDuplexBuffer_WriteIndex + !
						1 header@ CoDuplexBuffer_RemainingSpace + +=

						bufp@ index@ 1 - bufmask@ & + gb // c
						duplex@ // duplex
						CoDuplexEchoRubout
					end
				end
			end elseif (c@ 21 ==) // ^U
				while (header@ CoDuplexBuffer_RemainingSpace + @ bufsize@ <)
					if (bufp@ header@ CoDuplexBuffer_WriteIndex + @ 1 - bufmask@ & + gb '\n' ~=)
						1 header@ CoDuplexBuffer_WriteIndex + -=
						1 header@ CoDuplexBuffer_RemainingSpace + +=

						bufp@ header@ CoDuplexBuffer_WriteIndex + @ bufmask@ & + gb // c
						duplex@ // duplex
						CoDuplexEchoRubout
					end else
						break
					end
				end
			end elseif (c@ '\r' ==)
				'\n'
				bufp@ index@ bufmask@ & + sb

				index@ 1 + header@ CoDuplexBuffer_WriteIndex + !
				1 header@ CoDuplexBuffer_RemainingSpace + -=

				'\n' duplex@ CoDuplexEcho
			end else
				c@
				bufp@ index@ bufmask@ & + sb

				index@ 1 + header@ CoDuplexBuffer_WriteIndex + !
				1 header@ CoDuplexBuffer_RemainingSpace + -=

				c@ duplex@ CoDuplexEcho
			end
		end
	end

	ipl@ duplex@ CoDuplexUnlock
end

fn CoDuplexEcho { c duplex -- }
	if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_NOECHO &)
		return
	end

	1 duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Echoed + !

	if (c@ '\r' ==)
		'\r' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop
	end elseif (c@ '\n' ==)
		'\n' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop
	end elseif (c@ 0x20 <)
		'^' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		c@ 0x40 + // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop
	end elseif (c@ 0x7F <)
		c@ // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop
	end
end

fn CoDuplexEchoRubout { c duplex -- }
	if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_NOECHO &)
		return
	end

	1 duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Echoed + !

	if (c@ 0x20 <)
		'\b' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		' ' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		'\b' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		'\b' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		' ' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		'\b' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop
	end elseif (c@ 0x7F <)
		'\b' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		' ' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop

		'\b' // c
		duplex@ // duplex
		CoDuplexWriteCharacter drop
	end
end

fn CoDuplexServerWriteCooked { buf mdl duplex -- ok }
	// duplex is locked (which means IPL may be >=IPLDPC).
	// MDL is pinned.

	auto len
	mdl@ MmMDLHeader_Length + @ len!

	auto done
	0 done!

	while (len@)
		buf@ gb // c
		duplex@ // duplex
		CoDuplexInputCharacter ok!

		if (ok@)
			done@ mdl@ MmMDLHeader_Length + !

			return
		end

		1 done +=
		1 len -=
		1 buf +=
	end
end

fn CoDuplexServerWriteRaw { buf mdl duplex -- ok }
	// duplex is locked (which means IPL may be >=IPLDPC).
	// MDL is pinned.

	// server fcb, writing to the receive buffer and/or client buffers.
	// if this is a console, this will not pend because the client can't be
	// expected to read characters promptly. otherwise it may pend.
	// also if it is a console, it will echo to the transmit buffer. if the
	// transmit buffer fills up, characters will be dropped.

	0 ok!

	auto bytecnt
	0 bytecnt!

	if (duplex@ CoDuplex_ServerWriteListHead + @)
		// there's already a pending request, so add ours to the end and return.

		0 // lengthdone
		buf@ // buf
		mdl@ MmMDLHeader_Length + @ // length
		REQFLAG_WRITE REQFLAG_SERVER | // flags
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexEnqueueRequest

		STATUS_OTHER_CONDITION ok!
	end else
		// try to satisfy as many client reads as possible.
		// then resort to filling the receive buffer. then, if we still have
		// characters, enqueue our own request.

		auto header
		duplex@ CoDuplex_ReceiveBuffer + header!

		auto done
		0 done!

		auto rp

		while (done@ ~~)
			auto req
			duplex@ CoDuplex_ClientReadListHead + @ req!

			if (req@ ~~)
				break
			end

			// calculate available bytes in buffer.

			auto clientdone
			0 clientdone!

			header@ CoDuplexBuffer_UserBufferLength + @
			header@ CoDuplexBuffer_UserBufferIndex + @ - rp!

			if (mdl@ MmMDLHeader_Length + @ bytecnt@ - rp@ <)
				mdl@ MmMDLHeader_Length + @ bytecnt@ - rp!
			end

			header@ CoDuplexBuffer_UserBuffer + @
			header@ CoDuplexBuffer_UserBufferIndex + @ + // dest
			buf@ bytecnt@ + // src
			rp@ // sz
			memcpy

			rp@ header@ CoDuplexBuffer_UserBufferIndex + +=
			rp@ bytecnt +=

			if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
				DONE_NORMAL done |=
			end

			if (header@ CoDuplexBuffer_UserBufferIndex + @
				header@ CoDuplexBuffer_UserBufferLength + @ ==)
				DONE_NORMAL clientdone |=
			end elseif (req@ CoDuplexRequest_Flags + @ REQFLAG_RETURNANY &)
				DONE_NORMAL clientdone |=
			end

			if (clientdone@)
				// complete the client MDL.

				header@ CoDuplexBuffer_UserBufferIndex + @
				req@ CoDuplexRequest_LengthDone + @ +
				req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !

				// unlink the client request.

				auto nreq
				req@ CoDuplexRequest_Next + @ nreq!

				0 // status
				0 // priboost
				req@ CoDuplexRequest_MDL + @ // mdl
				MmMDLComplete

				nreq@ req!

				req@ duplex@ CoDuplex_ClientReadListHead + !

				if (req@)
					0 req@ CoDuplexRequest_Prev + !

					req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
					0 header@ CoDuplexBuffer_UserBufferIndex + !
					req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
				end else
					0 duplex@ CoDuplex_ClientReadListTail + !
				end
			end
		end

		if (done@ ~~)
			// try to copy to the receive buffer.

			auto bufp
			header@ CoDuplexBuffer_Buffer + @ bufp!

			header@ CoDuplexBuffer_RemainingSpace + @ rp!

			if (mdl@ MmMDLHeader_Length + @ bytecnt@ - rp@ <)
				mdl@ MmMDLHeader_Length + @ bytecnt@ - rp!
			end

			if (rp@)
				auto bufsize
				header@ CoDuplexBuffer_Size + @ bufsize!

				auto bufmask
				bufsize@ 1 - bufmask!

				auto index
				header@ CoDuplexBuffer_WriteIndex + @ index!

				auto endp
				index@ rp@ + endp!

				if (index@ bufmask@ ~ & endp@ bufmask@ ~ & ==)
					// doesn't cross the boundary, do a single copy

					bufp@ index@ bufmask@ & + // dest
					buf@ // src
					rp@ // sz
					memcpy
				end else
					// crosses the boundary, do two copies

					bufp@ index@ bufmask@ & + // dest
					buf@ // src
					bufsize@ index@ bufmask@ & - // sz
					memcpy

					bufp@ // dest
					buf@ bufsize@ index@ bufmask@ & - + // src
					endp@ bufmask@ & // sz
					memcpy
				end

				index@ rp@ + header@ CoDuplexBuffer_WriteIndex + !
				rp@ header@ CoDuplexBuffer_RemainingSpace + -=

				rp@ bytecnt +=

				if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
					DONE_NORMAL done |=
				end
			end
		end

		if (done@ ~~)
			if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_CONSOLE & ~~)
				// enqueue the request.

				bytecnt@ // lengthdone
				buf@ bytecnt@ + // buf
				mdl@ MmMDLHeader_Length + @ bytecnt@ - // length
				REQFLAG_WRITE REQFLAG_SERVER | // flags
				mdl@ // mdl
				duplex@ // duplex
				CoDuplexEnqueueRequest

				STATUS_OTHER_CONDITION ok!
			end else
				DONE_NORMAL done!
			end
		end
	end

	if (done@)
		bytecnt@ mdl@ MmMDLHeader_Length + !
	end
end

fn CoDuplexClientWrite { buf mdl duplex -- ok }
	// duplex is locked (which means IPL may be >=IPLDPC).
	// MDL is pinned.

	// client fcb, writing to the transmit buffer and/or server buffers.
	// this may pend.

	0 ok!

	auto bytecnt
	0 bytecnt!

	if (duplex@ CoDuplex_ClientWriteListHead + @)
		// there's already a pending request, so add ours to the end and return.

		0 // lengthdone
		buf@ // buf
		mdl@ MmMDLHeader_Length + @ // length
		REQFLAG_WRITE // flags
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexEnqueueRequest

		STATUS_OTHER_CONDITION ok!
	end else
		auto done
		0 done!

		auto txfunc
		duplex@ CoDuplex_TXFunc + @ txfunc!

		if (txfunc@)
			while (1)
				if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
					DONE_NORMAL done |=
					break
				end

				buf@ bytecnt@ + gb // c
				txfunc@ // txfunc
				duplex@ // duplex
				CoDuplexTXCharacter ok!

				if (ok@ ~~)
					break
				end

				0 ok!

				1 bytecnt +=
			end
		end

		// try to satisfy as many server reads as possible.
		// then resort to filling the transmit buffer. then, if we still have
		// characters, enqueue our own request.

		auto header
		duplex@ CoDuplex_TransmitBuffer + header!

		auto rp

		while (done@ ~~)
			auto req
			duplex@ CoDuplex_ServerReadListHead + @ req!

			if (req@ ~~)
				break
			end

			// calculate available bytes in buffer.

			header@ CoDuplexBuffer_UserBufferLength + @
			header@ CoDuplexBuffer_UserBufferIndex + @ - rp!

			if (mdl@ MmMDLHeader_Length + @ bytecnt@ - rp@ <)
				mdl@ MmMDLHeader_Length + @ bytecnt@ - rp!
			end

			auto bufwritten

			if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + // dest
				buf@ bytecnt@ + // src
				rp@ // sz
				memcpy

				rp@ bufwritten!
			end else
				header@ CoDuplexBuffer_UserBuffer + @
				header@ CoDuplexBuffer_UserBufferIndex + @ + // dest
				buf@ bytecnt@ + // src
				header@ CoDuplexBuffer_UserBufferLength + @
				header@ CoDuplexBuffer_UserBufferIndex + @ - // maxdest
				mdl@ MmMDLHeader_Length + @ bytecnt@ - // maxsrc
				duplex@ // duplex
				CoDuplexCookedCopyClient rp! bufwritten!
			end

			rp@ header@ CoDuplexBuffer_UserBufferIndex + +=

			bufwritten@ bytecnt +=

			if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
				DONE_NORMAL done |=
			end

			if (header@ CoDuplexBuffer_UserBufferIndex + @
				header@ CoDuplexBuffer_UserBufferLength + @ ==
				req@ CoDuplexRequest_Flags + @ REQFLAG_RETURNANY & ||)

				// complete the server MDL.

				header@ CoDuplexBuffer_UserBufferIndex + @
				req@ CoDuplexRequest_LengthDone + @ +
				req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !

				// unlink the server request.

				auto nreq
				req@ CoDuplexRequest_Next + @ nreq!

				0 // status
				0 // priboost
				req@ CoDuplexRequest_MDL + @ // mdl
				MmMDLComplete

				nreq@ req!

				req@ duplex@ CoDuplex_ServerReadListHead + !

				if (req@)
					0 req@ CoDuplexRequest_Prev + !

					req@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
					0 header@ CoDuplexBuffer_UserBufferIndex + !
					req@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
				end else
					0 duplex@ CoDuplex_ServerReadListTail + !
				end
			end
		end

		if (done@ ~~)
			// try to copy to the transmit buffer.

			auto bufp
			header@ CoDuplexBuffer_Buffer + @ bufp!

			header@ CoDuplexBuffer_RemainingSpace + @ rp!

			if (mdl@ MmMDLHeader_Length + @ bytecnt@ - rp@ <)
				mdl@ MmMDLHeader_Length + @ bytecnt@ - rp!
			end

			if (rp@)
				auto bufsize
				header@ CoDuplexBuffer_Size + @ bufsize!

				auto bufmask
				bufsize@ 1 - bufmask!

				auto index
				header@ CoDuplexBuffer_WriteIndex + @ index!

				if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
					auto endp
					index@ rp@ + endp!

					if (index@ bufmask@ ~ & endp@ bufmask@ ~ & ==)
						// doesn't cross the boundary, do a single copy

						bufp@ index@ bufmask@ & + // dest
						buf@ bytecnt@ + // src
						rp@ // sz
						memcpy

						rp@ bufwritten!
					end else
						// crosses the boundary, do two copies

						bufp@ index@ bufmask@ & + // dest
						buf@ bytecnt@ + // src
						bufsize@ index@ bufmask@ & - // sz
						memcpy

						bufp@ // dest
						buf@ bytecnt@ + bufsize@ index@ bufmask@ & - + // src
						endp@ bufmask@ & // sz
						memcpy

						rp@ bufwritten!
					end
				end else
					// the geometry of what this does is 1-dimensional but
					// still too complicated for me to feel like writing a
					// comment explaining it.

					if (header@ CoDuplexBuffer_ReadIndex + @ bufmask@ & index@ bufmask@ & <)
						bufp@ index@ bufmask@ & + // dest
						buf@ bytecnt@ + // src
						bufsize@ index@ bufmask@ & - // maxdest
						mdl@ MmMDLHeader_Length + @ bytecnt@ - // maxsrc
						duplex@ // duplex
						CoDuplexCookedCopyClient rp! bufwritten!

						if (mdl@ MmMDLHeader_Length + @ bytecnt@ - bufwritten@ ~=)
							bufp@ // dest
							buf@ bytecnt@ + bufwritten@ + // src
							header@ CoDuplexBuffer_ReadIndex + @ bufmask@ & // maxdest
							mdl@ MmMDLHeader_Length + @ bytecnt@ - bufwritten@ - // maxsrc
							duplex@ // duplex
							CoDuplexCookedCopyClient rp += bufwritten +=
						end
					end else
						bufp@ index@ bufmask@ & + // dest
						buf@ bytecnt@ + // src
						header@ CoDuplexBuffer_ReadIndex + @ bufmask@ & index@ bufmask@ & - // maxdest
						mdl@ MmMDLHeader_Length + @ bytecnt@ - // maxsrc
						duplex@ // duplex
						CoDuplexCookedCopyClient rp! bufwritten!
					end
				end

				index@ rp@ + header@ CoDuplexBuffer_WriteIndex + !
				rp@ header@ CoDuplexBuffer_RemainingSpace + -=

				bufwritten@ bytecnt +=

				if (bytecnt@ mdl@ MmMDLHeader_Length + @ ==)
					DONE_NORMAL done |=
				end
			end
		end

		if (done@ ~~)
			// enqueue the request.

			bytecnt@ // lengthdone
			buf@ bytecnt@ + // buf
			mdl@ MmMDLHeader_Length + @ bytecnt@ - // length
			REQFLAG_WRITE // flags
			mdl@ // mdl
			duplex@ // duplex
			CoDuplexEnqueueRequest

			STATUS_OTHER_CONDITION ok!
		end
	end

	if (done@)
		bytecnt@ mdl@ MmMDLHeader_Length + !
	end
end

fn (IODispatchReadFunction) CoDuplexRead { timeout flags kflags offset mdl fcb -- ok }
	0 ok!

	auto duplex
	fcb@ IOFileControlBlockGetDeviceObject IODeviceGetExtension duplex!

	if (mdl@ MmMDLHeader_Length + @ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	auto isserver
	fcb@ IOFileControlBlockGetContext isserver!

	if (isserver@)
		if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_SIMPLEX &)
			STATUS_FORBIDDEN_OPERATION ok!
			return
		end
	end

	1 // lockforwrite
	mdl@ // mdl
	MmMDLPin ok!

	if (ok@)
		return
	end

	auto buf
	mdl@ MmMDLMap ok!

	if (ok@)
		return
	end

	mdl@ MmMDLHeader_MappedAddress + @ buf!

	auto ipl
	duplex@ // duplex
	1 // alertable
	CoDuplexLock ok! ipl!

	if (ok@)
		return
	end

	if (isserver@)
		while (duplex@ CoDuplex_InternalFlags + @ DUPLEXFLAG_STOPPED &)
			if (timeout@ ~~)
				0 mdl@ MmMDLHeader_Length + !

				STATUS_RING_EMPTY ok!

				break
			end else
				ipl@ duplex@ CoDuplexUnlock

				mdl@ MmMDLHeader_ModeB + gb // waitmode
				1 // alertable
				timeout@ // timeout
				duplex@ CoDuplex_StoppedEvent + // object
				KeThreadWaitForObject ok!

				if (ok@)
					return
				end

				duplex@ // duplex
				1 // alertable
				CoDuplexLock ok! ipl!

				if (ok@)
					return
				end
			end
		end

		if (ok@ ~~)
			flags@ // flags
			buf@ // buf
			timeout@ // timeout
			mdl@ // mdl
			duplex@ // duplex
			CoDuplexServerRead ok!
		end
	end else
		flags@ // flags
		buf@ // buf
		timeout@ // timeout
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexClientRead ok!
	end

	ipl@ duplex@ CoDuplexUnlock

	if (ok@ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end elseif (ok@ STATUS_OTHER_CONDITION ==)
		// this means the request was enqueued successfully, so report success
		0 ok!
	end elseif (ok@ STATUS_RING_EMPTY ==)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		0 ok!
	end
end

fn (IODispatchWriteFunction) CoDuplexWrite { flags kflags offset mdl fcb -- ok }
	0 ok!

	auto duplex
	fcb@ IOFileControlBlockGetDeviceObject IODeviceGetExtension duplex!

	if (mdl@ MmMDLHeader_Length + @ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	auto isserver
	fcb@ IOFileControlBlockGetContext isserver!

	if (isserver@ ~~)
		if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_SIMPLEX &)
			STATUS_FORBIDDEN_OPERATION ok!
			return
		end
	end

	0 // lockforwrite
	mdl@ // mdl
	MmMDLPin ok!

	if (ok@)
		return
	end

	auto buf
	mdl@ MmMDLMap ok!

	if (ok@)
		return
	end

	mdl@ MmMDLHeader_MappedAddress + @ buf!

	auto ipl
	duplex@ // duplex
	1 // alertable
	CoDuplexLock ok! ipl!

	if (ok@)
		return
	end

	if (isserver@)
		if (duplex@ CoDuplex_Disconnected + @)
			ipl@ duplex@ CoDuplexUnlock

			0 // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete

			0 ok!

			return
		end

		if (duplex@ CoDuplex_ConsoleHeader + CoConsoleHeader_Mode + @ OSCONSOLEMODE_RAW &)
			buf@ // buf
			mdl@ // mdl
			duplex@ // duplex
			CoDuplexServerWriteRaw ok!
		end else
			buf@ // buf
			mdl@ // mdl
			duplex@ // duplex
			CoDuplexServerWriteCooked ok!
		end
	end else
		if (duplex@ CoDuplex_Disconnected + @)
			ipl@ duplex@ CoDuplexUnlock

			STATUS_CONSOLE_HUNG_UP ok!

			return
		end

		buf@ // buf
		mdl@ // mdl
		duplex@ // duplex
		CoDuplexClientWrite ok!
	end

	ipl@ duplex@ CoDuplexUnlock

	if (ok@ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end elseif (ok@ STATUS_OTHER_CONDITION ==)
		// this means the request was enqueued successfully, so report success
		0 ok!
	end elseif (ok@ STATUS_RING_FULL ==)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		0 ok!
	end
end

fn (IODispatchCancelFunction) CoDuplexCancel { mdl -- }
	auto ior
	mdl@ MmMDLHeader_DriverGoWild + ior!

	auto duplex
	ior@ CoDuplexRequest_Duplex + @ duplex!

	auto ipl
	duplex@ // duplex
	0 // alertable
	CoDuplexLock drop ipl!

	if (mdl@ MmMDLHeader_Flags + @ MMMDL_COMPLETE &)
		// already completed, nothing to do
		ipl@ duplex@ CoDuplexUnlock
		return
	end

	auto flags
	ior@ CoDuplexRequest_Flags + @ flags!

	auto header
	0 header!

	auto ls
	auto ns

	ior@ CoDuplexRequest_Prev + @ ls!
	ior@ CoDuplexRequest_Next + @ ns!

	if (flags@ REQFLAG_SERVER &)
		if (flags@ REQFLAG_WRITE &)
			if (ls@)
				ns@ ls@ CoDuplexRequest_Next + !
			end else
				ns@ duplex@ CoDuplex_ServerWriteListHead + !
				duplex@ CoDuplex_ReceiveBuffer + header!
			end

			if (ns@)
				ls@ ns@ CoDuplexRequest_Prev + !
			end else
				ls@ duplex@ CoDuplex_ServerWriteListTail + !
			end
		end else
			if (ls@)
				ns@ ls@ CoDuplexRequest_Next + !
			end else
				ns@ duplex@ CoDuplex_ServerReadListHead + !
				duplex@ CoDuplex_TransmitBuffer + header!
			end

			if (ns@)
				ls@ ns@ CoDuplexRequest_Prev + !
			end else
				ls@ duplex@ CoDuplex_ServerReadListTail + !
			end
		end
	end else
		if (flags@ REQFLAG_WRITE &)
			if (ls@)
				ns@ ls@ CoDuplexRequest_Next + !
			end else
				ns@ duplex@ CoDuplex_ClientWriteListHead + !
				duplex@ CoDuplex_TransmitBuffer + header!
			end

			if (ns@)
				ls@ ns@ CoDuplexRequest_Prev + !
			end else
				ls@ duplex@ CoDuplex_ClientWriteListTail + !
			end
		end else
			if (ls@)
				ns@ ls@ CoDuplexRequest_Next + !
			end else
				ns@ duplex@ CoDuplex_ClientReadListHead + !
				duplex@ CoDuplex_ReceiveBuffer + header!
			end

			if (ns@)
				ls@ ns@ CoDuplexRequest_Prev + !
			end else
				ls@ duplex@ CoDuplex_ClientReadListTail + !
			end
		end
	end

	if (header@ ns@ &&)
		ns@ CoDuplexRequest_Buffer + @ header@ CoDuplexBuffer_UserBuffer + !
		0 header@ CoDuplexBuffer_UserBufferIndex + !
		ns@ CoDuplexRequest_Length + @ header@ CoDuplexBuffer_UserBufferLength + !
	end

	ipl@ duplex@ CoDuplexUnlock

	STATUS_IO_CANCELLED // status
	0 // priboost
	mdl@ // mdl
	MmMDLComplete
end

fn (IODispatchDeleteObjectFunction) CoDuplexDeleteFileObject { object -- ok }
	fnsection "PAGE$text"

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	auto deviceobject
	fcb@ IOFileControlBlockGetDeviceObject deviceobject!

	auto duplex
	deviceobject@ IODeviceGetExtension duplex!

	auto ipl
	auto req
	auto nreq

	if (fcb@ IOFileControlBlockGetContext)
		// server fcb! mark duplex headless and satisfy any pending requests.

		duplex@ // duplex
		0 // alertable
		CoDuplexLock drop ipl!

		1 duplex@ CoDuplex_Disconnected + !

		duplex@ CoDuplex_ClientWriteListHead + @ req!

		while (req@)
			req@ CoDuplexRequest_Next + @ nreq!

			STATUS_CONSOLE_HUNG_UP // status
			0 // priboost
			req@ CoDuplexRequest_MDL + @ // mdl
			MmMDLComplete

			nreq@ req!
		end

		duplex@ CoDuplex_ClientReadListHead + @ req!

		while (req@)
			if (req@ duplex@ CoDuplex_ClientReadListHead + @ ==)
				duplex@ CoDuplex_ReceiveBuffer + CoDuplexBuffer_UserBufferIndex + @
				req@ CoDuplexRequest_LengthDone + @ +
				req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !
			end else
				0 req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !
			end

			req@ CoDuplexRequest_Next + @ nreq!

			0 // status
			0 // priboost
			req@ CoDuplexRequest_MDL + @ // mdl
			MmMDLComplete

			nreq@ req!
		end

		0 duplex@ CoDuplex_ClientReadListHead + !
		0 duplex@ CoDuplex_ClientReadListTail + !

		0 duplex@ CoDuplex_ClientWriteListHead + !
		0 duplex@ CoDuplex_ClientWriteListTail + !

		ipl@ duplex@ CoDuplexUnlock

		if (deviceobject@ IODevice_ConsoleHeader + @)
			OSSIGNAL_HUP // signal
			deviceobject@ IODevice_ConsoleHeader + @ // console
			CoConsoleSignal
		end
	end elseif (deviceobject@ ObObjectReferences 2 ==)
		if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_SIMPLEX &)
			// last client is being closed and this is a pipe, satisfy server
			// write requests.

			duplex@ // duplex
			0 // alertable
			CoDuplexLock drop ipl!

			1 duplex@ CoDuplex_Disconnected + !

			duplex@ CoDuplex_ServerWriteListHead + @ req!

			while (req@)
				if (req@ duplex@ CoDuplex_ServerWriteListHead + @ ==)
					duplex@ CoDuplex_ReceiveBuffer + CoDuplexBuffer_UserBufferIndex + @
					req@ CoDuplexRequest_LengthDone + @ +
					req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !
				end else
					0 req@ CoDuplexRequest_MDL + @ MmMDLHeader_Length + !
				end

				req@ CoDuplexRequest_Next + @ nreq!

				0 // status
				0 // priboost
				req@ CoDuplexRequest_MDL + @ // mdl
				MmMDLComplete

				nreq@ req!
			end

			0 duplex@ CoDuplex_ServerWriteListHead + !
			0 duplex@ CoDuplex_ServerWriteListTail + !

			ipl@ duplex@ CoDuplexUnlock
		end
	end

	// forward to generic function
	object@ IODeviceDeleteFileObject ok!
end

fn (IODispatchDeleteDeviceObjectFunction) CoDuplexDeleteObject { object -- }
	fnsection "PAGE$text"

	auto duplex
	object@ IODeviceGetExtension duplex!

	-1 // writeout
	duplex@ CoDuplex_ServerFCB + @ // fcb
	IOFileControlBlockDelete drop

	duplex@ CoDuplex_Paged + @ // pri
	duplex@ CoDuplex_QuotaBlock + @ // quotablock
	duplex@ CoDuplex_ReceiveBuffer + // header
	CoDuplexBufferUninitialize

	if (duplex@ CoDuplex_Flags + @ OSDUPLEXFLAG_SIMPLEX & ~~)
		duplex@ CoDuplex_Paged + @ // pri
		duplex@ CoDuplex_QuotaBlock + @ // quotablock
		duplex@ CoDuplex_TransmitBuffer + // header
		CoDuplexBufferUninitialize
	end

	duplex@ CoDuplex_QuotaBlock + @ MmQuotaBlockDereference
end