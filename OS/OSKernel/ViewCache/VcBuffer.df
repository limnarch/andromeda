//
// Implements management for view cache buffers.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "<inc>/ViewCache.h"

#include "<ll>/OSDLL/OS.h"

var VcBufferReclaimListHead 0
public VcBufferReclaimListHead

var VcBufferReclaimListTail 0
public VcBufferReclaimListTail

fn VcBufferReclaim { -- bcb vaddr }
	VcBufferReclaimListHead@ bcb!

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"VcBufferReclaim: ipl != IPLDPC \n" KeCrash
		end

		if (bcb@ ~~)
			"VcBufferReclaim: no buffer to reclaim\n" KeCrash
		end

		if (bcb@ VcBuffer_WindowAddress + @ ~~)
			"VcBufferReclaim: BCB is unmapped\n" KeCrash
		end
	end

	// increment the map count to remove it from the reclaim list

	bcb@ VcBufferIncrementMapCount drop

	// disassociate the BCB from the cacheblock and unmap it.
	// if the BCB is non-permanent, return it to the caller so that it can be
	// reused without performing an extra allocation.

	bcb@ VcBuffer_WindowAddress + @ vaddr!

	bcb@ MmBufferUnmap

	bcb@ VcBuffer_Parent + // node
	bcb@ VcBuffer_FileControlBlock + @ IOFileControlBlock_CacheInfoBlock + @ IOCacheInfoBlock_BCBTreeRoot + // rootptr
	ExSplayTreeRemove

	if (bcb@ VcBuffer_Type + @ VCBCBTYPE_PERMANENT ==)
		0 bcb!
	end
end

fn VcBufferFree { bcb -- }
	// disassociate the BCB from the cacheblock and unmap it.
	// if the BCB is non-permanent, free it.

	if (bcb@ VcBuffer_WindowAddress + @)
		if (bcb@ VcBuffer_Type + @ VCBCBTYPE_LARGE ==)
			bcb@ VcBuffer_Length + @ // length
			bcb@ VcBuffer_WindowAddress + @ // vaddr
			PsSystemProcess@ // processobject
			MmUnmapViewProcess drop
		end else
			bcb@ MmBufferUnmap

			auto ipl
			IPLDPC KeIPLRaise ipl!

			bcb@ VcBuffer_Parent + // node
			bcb@ VcBuffer_FileControlBlock + @ IOFileControlBlock_CacheInfoBlock + @ IOCacheInfoBlock_BCBTreeRoot + // rootptr
			ExSplayTreeRemove

			ipl@ KeIPLLower

			bcb@ VcBuffer_WindowAddress + @ VcWindowFree
		end
	end

	if (bcb@ VcBuffer_Type + @ VCBCBTYPE_PERMANENT ==)
		0 bcb@ VcBuffer_FileControlBlock + !
		0 bcb@ VcBuffer_WindowAddress + !
	end else
		bcb@ MmFree
	end
end

fn VcBufferAllocate { cacheblock -- bcb ok }
	// each cacheblock has 1 BCB appended to it.
	// see if this cacheblock's BCB is free and claim it if so.

	0 ok!

	cacheblock@ IOCacheInfoBlock_SIZEOF + bcb!

	auto rs
	HALCPUInterruptDisable rs!

	if (bcb@ VcBuffer_FileControlBlock + @ ~~)
		// take it

		-1 bcb@ VcBuffer_FileControlBlock + !

		rs@ HALCPUInterruptRestore

		return
	end

	rs@ HALCPUInterruptRestore

	// allocate a new BCB from nonpaged pool.

	VcBuffer_SIZEOF // bytes
	'VcBu' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! bcb!

	if (ok@)
		return
	end

	VCBCBTYPE_NORMAL bcb@ VcBuffer_Type + !
	0 bcb@ VcBuffer_WindowAddress + !
	0 bcb@ VcBuffer_FileControlBlock + !
end

fn VcBufferGet { offset fcb -- bcb ok }
	// looks up a BCB mapping the given offset of the file.
	// if none exist, a new one is created and mapped.
	// the MapCount is biased.

	if (DEBUGCHECKS)
		if (offset@ FILEVIEWOFFSETMASK &)
			"VcBufferGet: unaligned offset\n" KeCrash
		end
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"VcBufferGet: no cacheblock\n" KeCrash
		end
	end

	// lock the BCB tree mutex. this guards against two threads attempting to
	// create this BCB at the same time, but does not guard against an
	// existing BCB being reclaimed, so we still need IPL synch for that.

	cacheblock@ IOCacheInfoBlockLockBCB

	auto ipl
	IPLDPC KeIPLRaise ipl!

	offset@ // value
	cacheblock@ IOCacheInfoBlock_BCBTreeRoot + // rootptr
	ExSplayTreeFindNodeByValue bcb! drop

	if (bcb@)
		VcBuffer_Parent bcb -=

		bcb@ VcBufferIncrementMapCount drop

		ipl@ KeIPLLower

		cacheblock@ IOCacheInfoBlockUnlockBCB

		return
	end

	ipl@ KeIPLLower

	auto vaddr
	VcWindowAllocate vaddr! bcb!

	if (bcb@ ~~)
		cacheblock@ VcBufferAllocate ok! bcb!

		if (ok@)
			vaddr@ VcWindowFree

			cacheblock@ IOCacheInfoBlockUnlockBCB

			return
		end
	end

	// initialize the BCB

	fcb@ bcb@ VcBuffer_FileControlBlock + !

	0 bcb@ VcBuffer_ReclaimNext + !
	0 bcb@ VcBuffer_ReclaimPrev + !

	vaddr@ bcb@ VcBuffer_WindowAddress + !
	FILEVIEWGRANULARITY bcb@ VcBuffer_Length + !

	0 bcb@ VcBuffer_Parent + !
	0 bcb@ VcBuffer_LeftChild + !
	0 bcb@ VcBuffer_RightChild + !
	offset@ bcb@ VcBuffer_FileOffset + !

	1 bcb@ VcBuffer_MapCountI + si
	0 bcb@ VcBuffer_PinCountI + si

	// map the buffer

	bcb@ MmBufferMap

	// insert the BCB into the splay tree

	IPLDPC KeIPLRaise ipl!

	0 // insertat
	bcb@ VcBuffer_Parent + // node
	cacheblock@ IOCacheInfoBlock_BCBTreeRoot + // rootptr
	ExSplayTreeInsert

	ipl@ KeIPLLower

	cacheblock@ IOCacheInfoBlockUnlockBCB
end

fn VcBufferIncrementMapCount { bcb -- oldcount }
	// increment the MapCount for the BCB. if it was zero, remove it from the
	// reclaimable list.

	auto rs
	HALCPUInterruptDisable rs!

	bcb@ VcBuffer_MapCountI + gi oldcount!

	oldcount@ 1 + bcb@ VcBuffer_MapCountI + si

	if (oldcount@ ~~)
		// remove from reclaimable list

		auto ls
		bcb@ VcBuffer_ReclaimPrev + @ ls!

		auto ns
		bcb@ VcBuffer_ReclaimNext + @ ns!

		if (ls@)
			ns@ ls@ VcBuffer_ReclaimNext + !
		end else
			ns@ VcBufferReclaimListHead!
		end

		if (ns@)
			ls@ ns@ VcBuffer_ReclaimPrev + !
		end else
			ls@ VcBufferReclaimListTail!
		end
	end

	rs@ HALCPUInterruptRestore
end

fn VcBufferDecrementMapCount { bcb -- oldcount }
	// decrement the MapCount for the BCB. if it became zero, insert it into
	// the reclaimable list.

	auto free
	0 free!

	auto rs
	HALCPUInterruptDisable rs!

	bcb@ VcBuffer_MapCountI + gi oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ ~~)
			"VcBufferDecrementMapCount: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - bcb@ VcBuffer_MapCountI + si

	if (oldcount@ 1 ==)
		if (bcb@ VcBuffer_Type + @ VCBCBTYPE_LARGE ~=)
			// insert into reclaimable list

			auto t
			VcBufferReclaimListTail@ t!

			if (t@ ~~)
				0 bcb@ VcBuffer_ReclaimNext + !
				0 bcb@ VcBuffer_ReclaimPrev + !

				bcb@ VcBufferReclaimListHead!
				bcb@ VcBufferReclaimListTail!
			end else
				0 bcb@ VcBuffer_ReclaimNext + !

				t@ bcb@ VcBuffer_ReclaimPrev + !
				bcb@ t@ VcBuffer_ReclaimNext + !
				bcb@ VcBufferReclaimListTail!
			end
		end else
			1 free!
		end
	end

	rs@ HALCPUInterruptRestore

	if (free@)
		bcb@ VcBufferFree
	end
end