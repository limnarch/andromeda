//
// Implements creation of executive process and thread objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/Console.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/IPC.h"

fn PsProcessInheritConsole { parent process -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (parent@ PsProcess_ConsoleObject + @)
		process@ // process
		parent@ PsProcess_ConsoleObject + @ // console
		CoConsoleInsertProcess drop
	end

	ipl@ KeIPLLower
end

fn PsProcessCreateObject { quotauid sectionobject creationflags parentprocess permissions name -- processobject ok }
	fnsection "PAGE$text"

	auto initial

	if (parentprocess@)
		0 initial!
	end else
		if (KeProcessCurrent KeProcessIdleProcess ~=)
			"PsProcessCreate: no parent process specified but not the idle process\n" KeCrash
		end

		KeProcessIdleProcess parentprocess!

		1 initial!
	end

	if (creationflags@ OSPROCESS_DETACHCONSOLE &)
		SYSTEMPERMISSION_DETACHCONSOLE // permission
		KeProcessCurrent // process
		SeProcessCheckPermission ok!

		if (ok@)
			return
		end
	end

	if (creationflags@ OSPROCESS_NEWSESSION &)
		SYSTEMPERMISSION_NEWSESSION // permission
		KeProcessCurrent // process
		SeProcessCheckPermission ok!

		if (ok@)
			return
		end
	end

	auto paged

	if (initial@)
		name@ // name
		0 // flags
		permissions@ // permissions
		0 // npquotabias
		0 // pquotabias
		PsProcess_SIZEOF PsProcessPaged_SIZEOF + // bodysize
		PsProcessObjectType@ // type
		ObObjectCreate ok! processobject!

		if (ok@)
			return
		end

		// memset the system process because some stuff won't get initialized

		processobject@ // ptr
		PsProcess_SIZEOF PsProcessPaged_SIZEOF + // size
		0 // word
		memset

		processobject@ PsProcess_SIZEOF + paged!
	end else
		name@ // name
		0 // flags
		permissions@ // permissions
		0 // npquotabias
		PsProcessPaged_SIZEOF MmChargeBytesGet // pquotabias
		PsProcess_SIZEOF // bodysize
		PsProcessObjectType@ // type
		ObObjectCreate ok! processobject!

		if (ok@)
			return
		end

		PsProcessPaged_SIZEOF // bytes
		'PrPg' // tag
		PAGED // flags
		MmAllocWithTag ok! paged!
	end

	paged@ processobject@ PsProcess_PagedArea + !

	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_UID + @ paged@ PsProcessPaged_UID + !
	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_GID + @ paged@ PsProcessPaged_GID + !

	0 processobject@ PsProcess_ConsoleObject + !
	0 processobject@ PsProcess_ConsoleListNext + !
	0 processobject@ PsProcess_ConsoleListPrev + !

	// FIXME have logon program grant permissions in all cases; never inherit

	if (creationflags@ OSPROCESS_NEWSESSION & quotauid@ UID_SYSTEM ~= &&)
		0 // inheritfrom
		paged@ PsProcessPaged_Permissions + // permissions
		SePermissionsInitialize
	end else
		parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_Permissions + // inheritfrom
		paged@ PsProcessPaged_Permissions + // permissions
		SePermissionsInitialize
	end

	auto quotablock
	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	if (creationflags@ OSPROCESS_NEWSESSION & quotauid@ -1 ~= &&)
		quotauid@ // uid
		quotablock@ // forkquotablock
		MmQuotaBlockGetByUID ok! quotablock!

		if (ok@)
			paged@ MmFree
		
			processobject@ ObObjectDeallocate

			return
		end
	end else
		// inherit quotablock
		quotablock@ MmQuotaBlockReference
	end

	quotablock@ paged@ PsProcessPaged_QuotaBlock + !

	auto handletable

	if (initial@ ~~)
		processobject@ // context
		quotablock@ // quotablock
		OBHANDLEENTRYSIZELOG // entrysizelog
		ExHandleTableCreate ok! handletable!

		if (ok@)
			quotablock@ MmQuotaBlockDereference

			paged@ MmFree

			processobject@ ObObjectDeallocate

			return
		end
	end else
		// save some heap and reuse the idle process handle table
		parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_HandleTable + @ handletable!
	end

	handletable@ paged@ PsProcessPaged_HandleTable + !

	0 pid!

	if (initial@ ~~)
		// defer creating system process handle until later since the PID
		// table is allocated in paged pool and we can't fault in the idle
		// thread.

		PsProcessTable@ ExHandleTableLockUnalertable

		auto pid
		processobject@ // entryvalue
		PsProcessTable@ // handletable
		1 // locked
		ExHandleCreate ok! drop pid!

		if (ok@)
			PsProcessTable@ ExHandleTableUnlock

			if (initial@ ~~)
				0 handletable@ ExHandleTableDelete

				paged@ MmFree
			end

			quotablock@ MmQuotaBlockDereference

			processobject@ ObObjectDeallocate

			return
		end
	end

	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_PID + @ paged@ PsProcessPaged_ParentPID + !
	pid@ paged@ PsProcessPaged_PID + !

	0 paged@ PsProcessPaged_CleanedUp + !

	"PsProcessCreateDeleteMutex" // name
	KERNELMODE // mode
	processobject@ PsProcess_ThreadCreateDeleteMutex + // mutex
	KeMutexInitialize

	0 // signaled
	OSEVENT_NOTIF // type
	"PsProcessTerminationEvent" // name
	processobject@ PsProcess_TerminationEvent +
	KeEventInitialize

	0 paged@ PsProcessPaged_ActivationBlock + !
	0 paged@ PsProcessPaged_ActivationStatus + !

	name@ // name
	pid@ // asid
	parentprocess@ // parentprocess
	processobject@ // process
	KeProcessInitialize

	if (initial@ ~~)
		if (DEBUGCHECKS)
			if (pid@ ~~)
				"PsProcessCreateObject: pid=0\n" KeCrash
			end
		end

		// create process page directory
		auto pdir
		processobject@ MmPageDirectoryAlloc ok! pdir!

		if (ok@)
			processobject@ KeProcessUninitialize

			pid@ // handle
			PsProcessTable@ // handletable
			1 // locked
			ExHandleDelete drop drop drop

			PsProcessTable@ ExHandleTableUnlock

			0 handletable@ ExHandleTableDelete

			quotablock@ MmQuotaBlockDereference

			paged@ MmFree

			processobject@ ObObjectDeallocate

			return
		end

		pdir@ processobject@ PsProcess_PCB + KeProcess_PageDirectory + !
	end else
		HALPlatformKernelPageDirectory@ processobject@ KeProcess_PageDirectory + !
	end

	sectionobject@ // sectionobject
	processobject@ // process
	MmProcessInitialize ok!

	if (ok@)
		if (initial@ ~~)
			processobject@ MmPageDirectoryDestroy
		end

		processobject@ KeProcessUninitialize

		if (initial@ ~~)
			pid@ // handle
			PsProcessTable@ // handletable
			1 // locked
			ExHandleDelete drop drop drop

			PsProcessTable@ ExHandleTableUnlock
		end

		0 handletable@ ExHandleTableDelete

		quotablock@ MmQuotaBlockDereference

		paged@ MmFree

		processobject@ ObObjectDeallocate

		return
	end

	// put it on the global process list

	PsProcessListLockUnalertable

	0 // trim
	processobject@ // process
	PsProcessInsert

	PsProcessListUnlock

	if (initial@ ~~)
		PsProcessTable@ ExHandleTableUnlock
	end

	if (creationflags@ OSPROCESS_DETACHCONSOLE & ~~)
		// inherit the console group

		parentprocess@ // parent
		processobject@ // process
		PsProcessInheritConsole
	end

	1 PsProcessCreationCount KeInterlockedIncrement drop
end

fn PsProcessCreate { quotauid sectionhandle creationflags permissions name -- processhandle ok }
	fnsection "PAGE$text"

	auto sectionobject
	auto access

	MmSectionObjectType@ // type
	sectionhandle@ // handle
	ObObjectReferenceByHandle ok! sectionobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ ACCESS_WRITE | SeCheckAccess ok!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto processobject

	auto curproc
	KeProcessCurrent curproc!

	quotauid@ // quotauid
	sectionobject@ // sectionobject
	creationflags@ // creationflags
	curproc@ // parentprocess
	permissions@ // permissions
	name@ // name
	PsProcessCreateObject ok! processobject!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	processobject@ // object
	ObObjectOpen ok! processhandle!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	sectionobject@ ObObjectDereferenceByPointer drop
end

fn PsThreadCreateObject { context1 context2 startfunc creationflags permissions name processobject -- threadobject ok }
	fnsection "PAGE$text"

	auto initial
	0 initial!

	if (processobject@ PsSystemProcess@ ==)
		if (PsSystemProcess@ KeProcess_ThreadListHead + @ ~~)
			1 initial!
		end
	end

	auto quotablock
	processobject@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	KETHREADSTACKSIZE // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		return
	end

	KETHREADSTACKSIZE PAGESHIFT >> // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeWS ok!

	if (ok@)
		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	0 // needsthread
	processobject@ // processobject
	PsProcessCreateDeleteAcquireCheck ok!

	if (ok@)
		KETHREADSTACKSIZE PAGESHIFT >> // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeWS

		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	name@ // name
	0 // flags
	permissions@ // permissions
	IPCThreadBlock_SIZEOF MmChargeBytesGet // npquotabias
	0 // pquotabias
	PsThread_SIZEOF // bodysize
	PsThreadObjectType@ // type
	ObObjectCreate ok! threadobject!

	if (ok@)
		processobject@ PsProcessCreateDeleteUnlock

		KETHREADSTACKSIZE PAGESHIFT >> // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeWS

		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	PsProcessTable@ ExHandleTableLockUnalertable

	auto tid
	0 tid!

	if (initial@ ~~)
		threadobject@ // entryvalue
		PsProcessTable@ // handletable
		1 // locked
		ExHandleCreate ok! drop tid!

		if (ok@)
			PsProcessTable@ ExHandleTableUnlock

			processobject@ PsProcessCreateDeleteUnlock

			threadobject@ ObObjectDeallocate

			KETHREADSTACKSIZE PAGESHIFT >> // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargeWS

			KETHREADSTACKSIZE // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargeVM

			return
		end
	end

	tid@ threadobject@ PsThread_TID + !

	auto kstack
	MmKernelStackAlloc ok! kstack!

	if (ok@)
		tid@ // handle
		PsProcessTable@ // handletable
		1 // locked
		ExHandleDelete drop drop drop

		PsProcessTable@ ExHandleTableUnlock

		processobject@ PsProcessCreateDeleteUnlock

		threadobject@ ObObjectDeallocate

		KETHREADSTACKSIZE PAGESHIFT >> // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeWS

		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	processobject@ // process
	kstack@ // kstack
	name@ // name
	threadobject@ // thread
	KeThreadInitialize

	if (startfunc@ pointerof PsThreadUserEntry ==)
		threadobject@ MmThreadInitialize ok!

		if (ok@)
			kstack@ MmKernelStackFree

			threadobject@ KeThreadUninitialize

			tid@ // handle
			PsProcessTable@ // handletable
			1 // locked
			ExHandleDelete drop drop drop

			PsProcessTable@ ExHandleTableUnlock

			processobject@ PsProcessCreateDeleteUnlock

			threadobject@ ObObjectDeallocate

			KETHREADSTACKSIZE PAGESHIFT >> // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargeWS

			KETHREADSTACKSIZE // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargeVM

			return
		end
	end

	0 // signaled
	OSEVENT_NOTIF // type
	"PsThreadTerminationEvent" // name
	threadobject@ PsThread_TerminationEvent +
	KeEventInitialize

	// bias reference count: this gets decremented when the thread is reaped.
	// note that the associated process object is also left referenced.
	// the process is dereferenced when the thread object is deleted.

	processobject@ ObObjectReferenceByPointer drop
	threadobject@ ObObjectReferenceByPointer drop

	if (creationflags@ OSTHREAD_SUSPENDED &)
		1 threadobject@ KeThread_Suspended + !
	end else
		0 threadobject@ KeThread_Suspended + !
	end

	0 threadobject@ PsThread_FileCreationPermissions + !

	PsProcessTable@ ExHandleTableUnlock

	KeThreadCurrent@ KeThread_SignalAcceptMask + @ threadobject@ KeThread_SignalAcceptMask + !

	0 threadobject@ PsThread_IPCBlock + !

	processobject@ PsProcessCreateDeleteUnlock

	QUEUEBACK threadobject@ KeThreadReady
end

fn PsThreadCreate { context1 context2 startfunc creationflags permissions name processhandle -- threadhandle ok }
	fnsection "PAGE$text"

	auto processobject
	auto access

	PsProcessObjectType@ // type
	processhandle@ // handle
	ObObjectReferenceByHandle ok! processobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto threadobject

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	creationflags@ // creationflags
	permissions@ // permissions
	name@ // name
	processobject@ // processobject
	PsThreadCreateObject ok! threadobject!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	threadobject@ // object
	ObObjectOpen ok! threadhandle!

	if (ok@)
		-1 // status
		threadobject@ // threadobject
		PsThreadTerminateObject drop

		threadobject@ ObObjectDereferenceByPointer drop
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	processobject@ ObObjectDereferenceByPointer drop
end

fn PsProcessGetUID { process -- uid }
	process@ PsProcess_PagedArea + @ PsProcessPaged_UID + @ uid!
end

fn PsProcessGetGID { process -- gid }
	process@ PsProcess_PagedArea + @ PsProcessPaged_GID + @ gid!
end

fn PsProcessRemove { trim process -- }
	// assumes process list locked

	auto ls
	auto ns

	if (trim@ ~~)
		1 PsActiveProcessCount -=

		process@ PsProcess_GlobalListPrev + @ ls!
		process@ PsProcess_GlobalListNext + @ ns!

		if (ls@)
			ns@ ls@ PsProcess_GlobalListNext + !
		end else
			ns@ PsProcessListHead!
		end

		if (ns@)
			ls@ ns@ PsProcess_GlobalListPrev + !
		end else
			ls@ PsProcessListTail!
		end
	end

	process@ PsProcess_TrimListPrev + @ ls!
	process@ PsProcess_TrimListNext + @ ns!

	if (ls@)
		ns@ ls@ PsProcess_TrimListNext + !
	end else
		ns@ PsProcessTrimListHead!
	end

	if (ns@)
		ls@ ns@ PsProcess_TrimListPrev + !
	end else
		ls@ PsProcessTrimListTail!
	end
end

fn PsProcessInsert { trim process -- }
	// assumes process list locked

	auto t

	if (trim@ ~~)
		1 PsActiveProcessCount +=

		PsProcessListTail@ t!

		if (t@ ~~)
			0 process@ PsProcess_GlobalListNext + !
			0 process@ PsProcess_GlobalListPrev + !

			process@ PsProcessListHead!
			process@ PsProcessListTail!
		end else
			0 process@ PsProcess_GlobalListNext + !

			t@ process@ PsProcess_GlobalListPrev + !
			process@ t@ PsProcess_GlobalListNext + !
			process@ PsProcessListTail!
		end
	end

	PsProcessTrimListTail@ t!

	if (t@ ~~)
		0 process@ PsProcess_TrimListNext + !
		0 process@ PsProcess_TrimListPrev + !

		process@ PsProcessTrimListHead!
		process@ PsProcessTrimListTail!
	end else
		0 process@ PsProcess_TrimListNext + !

		t@ process@ PsProcess_TrimListPrev + !
		process@ t@ PsProcess_TrimListNext + !
		process@ PsProcessTrimListTail!
	end
end