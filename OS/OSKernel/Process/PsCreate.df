#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALDebug.h"

fn PsProcessCreateObject { sectionobject creationflags parentprocess permissions name -- processobject ok }
	auto initial

	if (parentprocess@)
		0 initial!
	end else
		if (KeProcessCurrent KeProcessIdleProcess ~=)
			"PsProcessCreate: no parent process specified but not the idle process\n" KeCrash
		end

		KeProcessIdleProcess parentprocess!

		1 initial!
	end

	if (creationflags@ OSPROCESS_FORKQUOTA &)
		SYSTEMPERMISSION_FORKQUOTA // permission
		KeProcessCurrent // process
		SeProcessCheckPermission ok!

		if (ok@)
			return
		end
	end

	name@ // name
	0 // flags
	permissions@ // permissions
	0 // quotabias
	PsProcess_SIZEOF // bodysize
	PsProcessObjectType@ // type
	ObObjectCreate ok! processobject!

	if (ok@)
		return
	end

	if (initial@)
		// memset the system process because some stuff won't get initialized

		processobject@ // ptr
		PsProcess_SIZEOF // size
		0 // word
		memset
	end

	parentprocess@ PsProcess_UID + @ processobject@ PsProcess_UID + !
	parentprocess@ PsProcess_GID + @ processobject@ PsProcess_GID + !

	parentprocess@ PsProcess_Permissions + // inheritfrom
	processobject@ PsProcess_Permissions + // permissions
	SePermissionsInitialize

	auto quotablock
	parentprocess@ PsProcess_QuotaBlock + @ quotablock!

	if (creationflags@ OSPROCESS_FORKQUOTA &)
		// fork quotablock
		quotablock@ MmQuotaBlockFork ok! quotablock!

		if (ok@)
			processobject@ ObObjectDeallocate

			return
		end
	end else
		// inherit quotablock
		quotablock@ MmQuotaBlockReference
		quotablock@ processobject@ PsProcess_QuotaBlock + !
	end

	auto handletable

	if (initial@ ~~)
		if (creationflags@ OSPROCESS_NOINHERIT & ~~)
			pointerof ObHandleInheritFunction // func
			parentprocess@ PsProcess_HandleTable + @ // handletablesrc
			processobject@ // chargedprocess
			ExHandleTableDuplicate ok! handletable!

			if (ok@)
				quotablock@ MmQuotaBlockDereference

				processobject@ ObObjectDeallocate

				return
			end
		end else
			processobject@ // chargedprocess
			OBHANDLEENTRYSIZELOG // entrysizelog
			ExHandleTableCreate ok! handletable!

			if (ok@)
				quotablock@ MmQuotaBlockDereference

				processobject@ ObObjectDeallocate

				return
			end
		end
	end else
		// save some heap and reuse the idle process handle table
		parentprocess@ PsProcess_HandleTable + @ handletable!
	end

	handletable@ processobject@ PsProcess_HandleTable + !

	PsProcessTable@ ExHandleTableLockUnalertable

	auto pid
	processobject@ // entryvalue
	PsProcessTable@ // handletable
	1 // locked
	ExHandleCreate ok! drop pid!

	if (ok@)
		PsProcessTable@ ExHandleTableUnlock

		if (initial@ ~~)
			0 handletable@ ExHandleTableDelete
		end

		quotablock@ MmQuotaBlockDereference

		processobject@ ObObjectDeallocate

		return
	end

	parentprocess@ PsProcess_PID + @ processobject@ PsProcess_ParentPID + !
	pid@ processobject@ PsProcess_PID + !

	0 processobject@ PsProcess_CleanedUp + !

	"PsProcessCreateDeleteRwLock"
	processobject@ PsProcess_ThreadCreateDeleteRwLock + // rwlock
	ExRwLockInitialize

	0 // signaled
	OSEVENT_NOTIF // type
	"PsProcessTerminationEvent" // name
	processobject@ PsProcess_TerminationEvent +
	KeEventInitialize

	0 // signaled
	OSEVENT_NOTIF // type
	"PsProcessActivationEvent" // name
	processobject@ PsProcess_ActivationEvent +
	KeEventInitialize

	0 processobject@ PsProcess_ActivationStatus + !

	name@ // name
	pid@ // asid
	processobject@ // process
	KeProcessInitialize

	if (initial@ ~~)
		if (DEBUGCHECKS)
			if (pid@ ~~)
				"PsProcessCreate: pid=0\n" KeCrash
			end
		end

		sectionobject@ // sectionobject
		processobject@ // process
		MmProcessInitialize ok!

		if (ok@)
			processobject@ KeProcessUninitialize

			pid@ // handle
			PsProcessTable@ // handletable
			1 // locked
			ExHandleDelete drop drop drop

			PsProcessTable@ ExHandleTableUnlock

			0 handletable@ ExHandleTableDelete

			quotablock@ MmQuotaBlockDereference

			processobject@ ObObjectDeallocate

			return
		end
	end

	// put it on the global process list

	PsProcessListLock ok!

	if (ok@)
		if (initial@ ~~)
			processobject@ MmProcessUninitialize drop
		end

		processobject@ KeProcessUninitialize

		pid@ // handle
		PsProcessTable@ // handletable
		1 // locked
		ExHandleDelete drop drop drop

		PsProcessTable@ ExHandleTableUnlock

		if (initial@ ~~)
			0 handletable@ ExHandleTableDelete
		end

		quotablock@ MmQuotaBlockDereference

		processobject@ ObObjectDeallocate

		return
	end

	processobject@ PsProcessInsert

	PsProcessListUnlock

	PsProcessTable@ ExHandleTableUnlock
end

fn PsProcessCreate { sectionhandle creationflags permissions name -- processhandle ok }
	auto sectionobject
	auto access

	MmSectionObjectType@ // type
	sectionhandle@ // handle
	ObObjectReferenceByHandle ok! sectionobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ ACCESS_WRITE | SeCheckAccess ok!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto processobject

	auto curproc
	KeProcessCurrent curproc!

	sectionobject@ // sectionobject
	creationflags@ // creationflags
	curproc@ // parentprocess
	permissions@ // permissions
	name@ // name
	PsProcessCreateObject ok! processobject!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	processobject@ // object
	ObObjectOpen ok! processhandle!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	sectionobject@ ObObjectDereferenceByPointer drop
end

fn PsThreadCreateObject { context1 context2 startfunc creationflags permissions name processobject -- threadobject ok }
	0 // needsthread
	processobject@ // processobject
	PsProcessCreateDeleteAcquireCheck ok!

	if (ok@)
		return
	end

	name@ // name
	0 // flags
	permissions@ // permissions
	KETHREADSTACKSIZE // quotabias
	PsThread_SIZEOF // bodysize
	PsThreadObjectType@ // type
	ObObjectCreate ok! threadobject!

	if (ok@)
		processobject@ PsProcessCreateDeleteUnlock

		return
	end

	auto kstack
	MmKernelStackAlloc ok! kstack!

	if (ok@)
		processobject@ PsProcessCreateDeleteUnlock

		threadobject@ ObObjectDeallocate

		return
	end

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	processobject@ // process
	kstack@ // kstack
	name@ // name
	threadobject@ // thread
	KeThreadInitialize

	if (startfunc@ pointerof PsThreadUserEntry ==)
		threadobject@ MmThreadInitialize ok!

		if (ok@)
			kstack@ MmKernelStackFree

			threadobject@ KeThreadUninitialize

			processobject@ PsProcessCreateDeleteUnlock

			threadobject@ ObObjectDeallocate

			return
		end
	end

	0 // signaled
	OSEVENT_NOTIF // type
	"PsThreadTerminationEvent" // name
	threadobject@ PsThread_TerminationEvent +
	KeEventInitialize

	// bias reference count: this gets decremented when the thread is reaped.
	// note that the associated process object is also left referenced.
	// the process is dereferenced when the thread object is deleted.

	processobject@ ObObjectReferenceByPointer drop
	threadobject@ ObObjectReferenceByPointer drop

	if (creationflags@ OSTHREAD_SUSPENDED &)
		1 threadobject@ KeThread_Suspended + !
	end else
		0 threadobject@ KeThread_Suspended + !
		QUEUEBACK threadobject@ KeThreadReady
	end

	processobject@ PsProcessCreateDeleteUnlock
end

fn PsThreadCreate { context1 context2 startfunc creationflags permissions name processhandle -- threadhandle ok }
	auto processobject
	auto access

	PsProcessObjectType@ // type
	processhandle@ // handle
	ObObjectReferenceByHandle ok! processobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto threadobject

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	creationflags@ // creationflags
	permissions@ // permissions
	name@ // name
	processobject@ // processobject
	PsThreadCreateObject ok! threadobject!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	threadobject@ // object
	ObObjectOpen ok! threadhandle!

	if (ok@)
		threadobject@ ObObjectDereferenceByPointer drop
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	processobject@ ObObjectDereferenceByPointer drop
end

fn PsProcessGetUID { process -- uid }
	process@ PsProcess_UID + @ uid!
end

fn PsProcessGetGID { process -- gid }
	process@ PsProcess_GID + @ gid!
end

fn PsProcessRemove { process -- }
	// assumes process list locked

	1 PsActiveProcessCount -=

	auto ls
	process@ PsProcess_GlobalListPrev + @ ls!

	auto ns
	process@ PsProcess_GlobalListNext + @ ns!

	if (ls@)
		ns@ ls@ PsProcess_GlobalListNext + !
	end else
		ns@ PsProcessListHead!
	end

	if (ns@)
		ls@ ns@ PsProcess_GlobalListPrev + !
	end else
		ls@ PsProcessListTail!
	end
end

fn PsProcessInsert { process -- }
	// assumes process list locked

	1 PsActiveProcessCount +=

	auto t

	PsProcessListTail@ t!

	if (t@ ~~)
		0 process@ PsProcess_GlobalListNext + !
		0 process@ PsProcess_GlobalListPrev + !

		process@ PsProcessListHead!
		process@ PsProcessListTail!
	end else
		0 process@ PsProcess_GlobalListNext + !

		t@ process@ PsProcess_GlobalListPrev + !
		process@ t@ PsProcess_GlobalListNext + !
		process@ PsProcessListTail!
	end
end