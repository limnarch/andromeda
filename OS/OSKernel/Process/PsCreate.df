//
// Implements creation of executive process and thread objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/Console.h"

#include "<ll>/OSDLL/OS.h"

fn PsProcessCreateObject { sectionobject creationflags parentprocess permissions name -- processobject ok }
	auto initial

	if (parentprocess@)
		0 initial!
	end else
		if (KeProcessCurrent KeProcessIdleProcess ~=)
			"PsProcessCreate: no parent process specified but not the idle process\n" KeCrash
		end

		KeProcessIdleProcess parentprocess!

		1 initial!
	end

	if (creationflags@ OSPROCESS_FORKQUOTA &)
		SYSTEMPERMISSION_FORKQUOTA // permission
		KeProcessCurrent // process
		SeProcessCheckPermission ok!

		if (ok@)
			return
		end
	end

	if (creationflags@ OSPROCESS_DETACHCONSOLE &)
		SYSTEMPERMISSION_DETACHCONSOLE // permission
		KeProcessCurrent // process
		SeProcessCheckPermission ok!

		if (ok@)
			return
		end
	end

	auto paged

	if (initial@)
		name@ // name
		0 // flags
		permissions@ // permissions
		
		// npquotabias:
		WORKINGSETLISTCOUNT MMWORKINGSETTABLESIZE * // working set list
		// MMWORKINGSETDEFAULTMINIMUM PAGESHIFT << + // minimum working set

		0 // pquotabias
		PsProcess_SIZEOF PsProcessPaged_SIZEOF + // bodysize
		PsProcessObjectType@ // type
		ObObjectCreate ok! processobject!

		if (ok@)
			return
		end

		// memset the system process because some stuff won't get initialized

		processobject@ // ptr
		PsProcess_SIZEOF PsProcessPaged_SIZEOF + // size
		0 // word
		memset

		processobject@ PsProcess_SIZEOF + paged!
	end else
		name@ // name
		0 // flags
		permissions@ // permissions
		
		// npquotabias:
		WORKINGSETLISTCOUNT MMWORKINGSETTABLESIZE * // working set list
		// MMWORKINGSETDEFAULTMINIMUM PAGESHIFT << + // minimum working set

		PsProcessPaged_SIZEOF MmChargeBytesGet // pquotabias
		PsProcess_SIZEOF // bodysize
		PsProcessObjectType@ // type
		ObObjectCreate ok! processobject!

		if (ok@)
			return
		end

		PsProcessPaged_SIZEOF // bytes
		'PrPg' // tag
		PAGED // flags
		MmAllocWithTag ok! paged!
	end

	paged@ processobject@ PsProcess_PagedArea + !

	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_UID + @ paged@ PsProcessPaged_UID + !
	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_GID + @ paged@ PsProcessPaged_GID + !

	0 processobject@ PsProcess_ConsoleObject + !
	0 processobject@ PsProcess_ConsoleListNext + !
	0 processobject@ PsProcess_ConsoleListPrev + !

	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_Permissions + // inheritfrom
	paged@ PsProcessPaged_Permissions + // permissions
	SePermissionsInitialize

	auto quotablock
	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	if (creationflags@ OSPROCESS_FORKQUOTA &)
		// fork quotablock
		quotablock@ MmQuotaBlockFork ok! quotablock!

		if (ok@)
			processobject@ ObObjectDeallocate

			return
		end
	end else
		// inherit quotablock
		quotablock@ MmQuotaBlockReference
	end

	quotablock@ paged@ PsProcessPaged_QuotaBlock + !

	auto handletable

	if (initial@ ~~)
		processobject@ // chargedprocess
		OBHANDLEENTRYSIZELOG // entrysizelog
		ExHandleTableCreate ok! handletable!

		if (ok@)
			quotablock@ MmQuotaBlockDereference

			processobject@ ObObjectDeallocate

			return
		end
	end else
		// save some heap and reuse the idle process handle table
		parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_HandleTable + @ handletable!
	end

	handletable@ paged@ PsProcessPaged_HandleTable + !

	0 pid!

	if (initial@ ~~)
		// defer creating system process handle until later since the PID
		// table is allocated in paged pool and we can't fault in the idle
		// thread.

		PsProcessTable@ ExHandleTableLockUnalertable

		auto pid
		processobject@ // entryvalue
		PsProcessTable@ // handletable
		1 // locked
		ExHandleCreate ok! drop pid!

		if (ok@)
			PsProcessTable@ ExHandleTableUnlock

			if (initial@ ~~)
				0 handletable@ ExHandleTableDelete
			end

			quotablock@ MmQuotaBlockDereference

			processobject@ ObObjectDeallocate

			return
		end
	end

	parentprocess@ PsProcess_PagedArea + @ PsProcessPaged_PID + @ paged@ PsProcessPaged_ParentPID + !
	pid@ paged@ PsProcessPaged_PID + !

	0 paged@ PsProcessPaged_CleanedUp + !

	"PsProcessCreateDeleteMutex" // name
	KERNELMODE // mode
	processobject@ PsProcess_ThreadCreateDeleteMutex + // mutex
	KeMutexInitialize

	0 // signaled
	OSEVENT_NOTIF // type
	"PsProcessTerminationEvent" // name
	processobject@ PsProcess_TerminationEvent +
	KeEventInitialize

	0 paged@ PsProcessPaged_ActivationBlock + !
	0 paged@ PsProcessPaged_ActivationStatus + !

	name@ // name
	pid@ // asid
	parentprocess@ // parentprocess
	processobject@ // process
	KeProcessInitialize

	if (initial@ ~~)
		if (DEBUGCHECKS)
			if (pid@ ~~)
				"PsProcessCreateObject: pid=0\n" KeCrash
			end
		end

		// create process page directory
		auto pdir
		processobject@ MmPageDirectoryAlloc ok! pdir!

		if (ok@)
			processobject@ KeProcessUninitialize

			pid@ // handle
			PsProcessTable@ // handletable
			1 // locked
			ExHandleDelete drop drop drop

			PsProcessTable@ ExHandleTableUnlock

			0 handletable@ ExHandleTableDelete

			quotablock@ MmQuotaBlockDereference

			processobject@ ObObjectDeallocate

			return
		end

		pdir@ processobject@ PsProcess_PCB + KeProcess_PageDirectory + !
	end else
		HALPlatformKernelPageDirectory@ processobject@ KeProcess_PageDirectory + !
	end

	sectionobject@ // sectionobject
	processobject@ // process
	MmProcessInitialize ok!

	if (ok@)
		if (initial@ ~~)
			processobject@ MmPageDirectoryDestroy
		end

		processobject@ KeProcessUninitialize

		if (initial@ ~~)
			pid@ // handle
			PsProcessTable@ // handletable
			1 // locked
			ExHandleDelete drop drop drop

			PsProcessTable@ ExHandleTableUnlock
		end

		0 handletable@ ExHandleTableDelete

		quotablock@ MmQuotaBlockDereference

		processobject@ ObObjectDeallocate

		return
	end

	// put it on the global process list

	PsProcessListLockUnalertable
	processobject@ PsProcessInsert
	PsProcessListUnlock

	if (initial@ ~~)
		PsProcessTable@ ExHandleTableUnlock
	end

	if (creationflags@ OSPROCESS_DETACHCONSOLE & ~~)
		// inherit the console group

		auto ipl
		IPLDPC KeIPLRaise ipl!

		if (parentprocess@ PsProcess_ConsoleObject + @)
			processobject@ // process
			parentprocess@ PsProcess_ConsoleObject + @ // console
			CoConsoleInsertProcess drop
		end

		ipl@ KeIPLLower
	end

	auto rs
	HALCPUInterruptDisable rs!
	1 PsProcessCreationCount +=
	rs@ HALCPUInterruptRestore
end

fn PsProcessCreate { sectionhandle creationflags permissions name -- processhandle ok }
	auto sectionobject
	auto access

	MmSectionObjectType@ // type
	sectionhandle@ // handle
	ObObjectReferenceByHandle ok! sectionobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ ACCESS_WRITE | SeCheckAccess ok!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto processobject

	auto curproc
	KeProcessCurrent curproc!

	sectionobject@ // sectionobject
	creationflags@ // creationflags
	curproc@ // parentprocess
	permissions@ // permissions
	name@ // name
	PsProcessCreateObject ok! processobject!

	if (ok@)
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	processobject@ // object
	ObObjectOpen ok! processhandle!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop
		sectionobject@ ObObjectDereferenceByPointer drop

		return
	end

	sectionobject@ ObObjectDereferenceByPointer drop
end

fn PsThreadCreateObject { context1 context2 startfunc creationflags permissions name processobject -- threadobject ok }
	auto quotablock
	processobject@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	KETHREADSTACKSIZE // charge
	quotablock@ // quotablock
	MmQuotaBlockChargeVM ok!

	if (ok@)
		return
	end

	0 // needsthread
	processobject@ // processobject
	PsProcessCreateDeleteAcquireCheck ok!

	if (ok@)
		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	name@ // name
	0 // flags
	permissions@ // permissions
	KETHREADSTACKSIZE // npquotabias
	0 // pquotabias
	PsThread_SIZEOF // bodysize
	PsThreadObjectType@ // type
	ObObjectCreate ok! threadobject!

	if (ok@)
		processobject@ PsProcessCreateDeleteUnlock

		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	PsProcessTable@ ExHandleTableLockUnalertable

	auto tid
	threadobject@ // entryvalue
	PsProcessTable@ // handletable
	1 // locked
	ExHandleCreate ok! drop tid!

	if (ok@)
		PsProcessTable@ ExHandleTableUnlock

		threadobject@ ObObjectDeallocate

		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	tid@ threadobject@ PsThread_TID + !

	auto kstack
	MmKernelStackAlloc ok! kstack!

	if (ok@)
		tid@ // handle
		PsProcessTable@ // handletable
		1 // locked
		ExHandleDelete drop drop drop

		PsProcessTable@ ExHandleTableUnlock

		processobject@ PsProcessCreateDeleteUnlock

		threadobject@ ObObjectDeallocate

		KETHREADSTACKSIZE // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeVM

		return
	end

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	processobject@ // process
	kstack@ // kstack
	name@ // name
	threadobject@ // thread
	KeThreadInitialize

	if (startfunc@ pointerof PsThreadUserEntry ==)
		threadobject@ MmThreadInitialize ok!

		if (ok@)
			kstack@ MmKernelStackFree

			threadobject@ KeThreadUninitialize

			tid@ // handle
			PsProcessTable@ // handletable
			1 // locked
			ExHandleDelete drop drop drop

			PsProcessTable@ ExHandleTableUnlock

			processobject@ PsProcessCreateDeleteUnlock

			threadobject@ ObObjectDeallocate

			KETHREADSTACKSIZE // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargeVM

			return
		end
	end

	0 // signaled
	OSEVENT_NOTIF // type
	"PsThreadTerminationEvent" // name
	threadobject@ PsThread_TerminationEvent +
	KeEventInitialize

	// bias reference count: this gets decremented when the thread is reaped.
	// note that the associated process object is also left referenced.
	// the process is dereferenced when the thread object is deleted.

	processobject@ ObObjectReferenceByPointer drop
	threadobject@ ObObjectReferenceByPointer drop

	if (creationflags@ OSTHREAD_SUSPENDED &)
		1 threadobject@ KeThread_Suspended + !
	end else
		0 threadobject@ KeThread_Suspended + !
	end

	0 threadobject@ PsThread_FileCreationPermissions + !

	PsProcessTable@ ExHandleTableUnlock

	processobject@ PsProcessCreateDeleteUnlock

	QUEUEBACK threadobject@ KeThreadReady
end

fn PsThreadCreate { context1 context2 startfunc creationflags permissions name processhandle -- threadhandle ok }
	auto processobject
	auto access

	PsProcessObjectType@ // type
	processhandle@ // handle
	ObObjectReferenceByHandle ok! processobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto threadobject

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	creationflags@ // creationflags
	permissions@ // permissions
	name@ // name
	processobject@ // processobject
	PsThreadCreateObject ok! threadobject!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	1 // nocheck
	ACCESS_ALL // permissions
	threadobject@ // object
	ObObjectOpen ok! threadhandle!

	if (ok@)
		-1 // status
		threadobject@ // threadobject
		PsThreadTerminateObject drop

		threadobject@ ObObjectDereferenceByPointer drop
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	processobject@ ObObjectDereferenceByPointer drop
end

fn PsProcessGetUID { process -- uid }
	process@ PsProcess_PagedArea + @ PsProcessPaged_UID + @ uid!
end

fn PsProcessGetGID { process -- gid }
	process@ PsProcess_PagedArea + @ PsProcessPaged_GID + @ gid!
end

fn PsProcessRemove { process -- }
	// assumes process list locked

	1 PsActiveProcessCount -=

	auto ls
	process@ PsProcess_GlobalListPrev + @ ls!

	auto ns
	process@ PsProcess_GlobalListNext + @ ns!

	if (ls@)
		ns@ ls@ PsProcess_GlobalListNext + !
	end else
		ns@ PsProcessListHead!
	end

	if (ns@)
		ls@ ns@ PsProcess_GlobalListPrev + !
	end else
		ls@ PsProcessListTail!
	end
end

fn PsProcessInsert { process -- }
	// assumes process list locked

	1 PsActiveProcessCount +=

	auto t
	PsProcessListTail@ t!

	if (t@ ~~)
		0 process@ PsProcess_GlobalListNext + !
		0 process@ PsProcess_GlobalListPrev + !

		process@ PsProcessListHead!
		process@ PsProcessListTail!
	end else
		0 process@ PsProcess_GlobalListNext + !

		t@ process@ PsProcess_GlobalListPrev + !
		process@ t@ PsProcess_GlobalListNext + !
		process@ PsProcessListTail!
	end
end