//
// Implements usermode entry.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn PsThreadUserEntry { context1 context2 -- }
	// this is the start function for every usermode thread ever.

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// copy TEB to userspace

	auto thread
	KeThreadCurrent@ thread!

	auto kteb
	OSThreadEnvironmentBlock_SIZEOF alloc kteb!

	thread@ PsThread_StackHasGuardPage + @ kteb@ OSThreadEnvironmentBlock_StackHasGuardPage + !
	thread@ PsThread_StackTop + @ kteb@ OSThreadEnvironmentBlock_StackTop + !
	thread@ PsThread_StackBottom + @ kteb@ OSThreadEnvironmentBlock_StackBottom + !
	thread@ PsThread_TID + @ kteb@ OSThreadEnvironmentBlock_ThreadID + !

	thread@ PsThread_UTEB + @ // dest
	kteb@ // src
	OSThreadEnvironmentBlock_SIZEOF // size
	KeSafeCopyOut drop

#ifdef FOX32
	KeThreadCurrent@ PsThread_StackTop + @ 4 - // dest
	PsOSDLLInformation PsOSDLLInfo_ExitFunction + // src
	4 // size
	KeSafeCopyOut drop
#endif

	HALCPUInterruptDisable drop

	0 PsPrepareUsermode

	thread@ PsThread_UTEB + @ // teb
	PsOSDLLInformation PsOSDLLInfo_ExitFunction + @ // exitfunc
	context2@ // context
	KeThreadCurrent@ PsThread_StackTop + @ // ustack
	context1@ // entryfunc
	HALCPUEnterUserMode

	// HALCPUEnterUserMode should not return

	"PsThreadUserEntry\n" KeCrash
end

fn PsPrepareUsermode { trapframe -- }
	// called before the exception handler returns to usermode.
	// handles thread termination and signal dispatch.

	// called with all interrupts disabled.

	auto whatnow

	auto signaled
	0 signaled!

	if (KeIPLCurrentGet IPLDPC >=)
		"PsPrepareUsermode: ipl >= IPLDPC\n" KeCrash
	end

	auto process
	KeProcessCurrent process!

	auto current
	KeThreadCurrent@ current!

	while (1)
		USERMODE // mode
		1 // alertable
		current@ // thread
		KeThreadIsKilled whatnow!

		if (whatnow@ STATUS_KILLED ==)
			// don't return to userland.
			// our journey ends here

			HALCPUInterruptEnable

			PsThreadExit

			// PsThreadExit should not return

			"PsPrepareUsermode\n" KeCrash
		end elseif (current@ KeThread_Suspended + @)
			// suspend!

			HALCPUInterruptEnable

			IPLDPC KeIPLRaise drop

			while (current@ KeThread_Suspended + @)
				auto ok
				IPLLOW // waitipl
				USERMODE // waitmode
				1 // alertable
				THREADSTATUS_SUSPENDED // explicitstatus
				KeThreadWait ok!

				if (ok@ STATUS_KERNEL_APC ==)
					IPLLOW KeIPLLower

					// APC interrupt occurs

					IPLDPC KeIPLRaise drop
				end
			end

			IPLLOW KeIPLLower

			HALCPUInterruptDisable drop

			// continue and recheck signals because things probably
			// changed since we napped.
			continue
		end elseif (whatnow@ STATUS_SIGNALLED ==)
			auto nextsig
			current@ KeThreadNextSignal nextsig!

			if (trapframe@ signaled@ ~~ &&)
				HALCPUInterruptEnable

				nextsig@ // signum
				PsOSDLLInformation PsOSDLLInfo_SignalDispatchFunction + @ // dispatchfunc
				current@ // thread
				trapframe@ // trapframe
				KeCopySignalFrame drop

				HALCPUInterruptDisable drop

				// only allow one signal at a time otherwise things may get hairy
				1 signaled!

				continue
			end else
				break
			end
		end else
			break
		end
	end
end