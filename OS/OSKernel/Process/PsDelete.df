//
// Implements termination and deletion of executive process and thread
// objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/Console.h"

#include "<ll>/OSDLL/OS.h"

fn (ObTypeDeleteFunction) PsProcessObjectDelete { object -- }
	// the last reference to this process object was removed.
	// finally free all resources associated with it.

	// remove from the global process list

	auto ok

	PsProcessListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to lock process list\n" KeCrash
		end
	end

	object@ PsProcessRemove

	PsProcessListUnlock

	// destroy PID

	object@ PsProcess_PID + @ // handle
	PsProcessTable@ // handletable
	0 // locked
	ExHandleDelete ok! drop drop

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to delete PID (%i)\n" KeCrash
		end
	end

	object@ PsProcessCleanup

	// deref quota block

	object@ PsProcess_QuotaBlock + @ MmQuotaBlockDereference

	auto pdir
	object@ PsProcess_PCB + KeProcess_PageDirectory + @ pdir!

	pdir@ MmPageDirectoryDestroy

	object@ KeProcessUninitialize
end

fn (ObTypeDeleteFunction) PsThreadObjectDelete { object -- }
	// the last reference to this thread object was removed.
	// finally free all resources associated with it.

	if (DEBUGCHECKS)
		if (object@ KeThread_Enqueued + @)
			"PsThreadObjectDelete: attempt to delete enqueued thread\n" KeCrash
		end

		if (object@ KeThread_Status + @ THREADSTATUS_TERMINATED ~=)
			"PsThreadObjectDelete: attempt to delete non-terminated thread\n" KeCrash
		end
	end

	object@ KeThread_KernelStackBottom + @ MmKernelStackFree

	KETHREADSTACKSIZE // charge
	object@ KeThread_Process + @ PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUnchargeVM

	object@ KeThread_Process + @ ObObjectDereferenceByPointer drop
end

var PsReaperThreadListHead 0

fn PsReaperWorker { context1 context2 -- }
	PRIORITY_HIGHREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	while (1)
		auto ok
		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		PsReaperEvent // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "PsReaperWorker: failed to wait on reap event (%i)\n" KeCrash
			end
		end

		auto ipl
		IPLDPC KeIPLRaise ipl!

		while (PsReaperThreadListHead@)
			auto thread
			PsReaperThreadListHead@ thread!
			thread@ KeThread_QueueNext + @ PsReaperThreadListHead!

			ipl@ KeIPLLower

			thread@ ObObjectDereferenceByPointer drop

			IPLDPC KeIPLRaise ipl!
		end

		ipl@ KeIPLLower
	end
end

fn PsProcessCleanup { process -- }
	if (process@ PsProcess_CleanedUp + @)
		// process had a last thread that did all this already
		return
	end

	1 process@ PsProcess_CleanedUp + !

	// destroy handle table

	pointerof ObHandleDestroyFunction // enum func
	process@ PsProcess_HandleTable + @ // handle table
	ExHandleTableDelete

	// uninitialize virtual memory structures

	auto ok
	process@ MmProcessUninitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to uninitialize virtual memory (%i)\n" KeCrash
		end
	end

	auto rs
	HALCPUInterruptDisable rs!
	1 PsProcessDeletionCount +=
	rs@ HALCPUInterruptRestore

	process@ CoConsoleRemoveProcess drop
end

fn PsProcessExit { status process -- }
	// this process has reached the end of its life.

	if (process@ PsSystemProcess@ ==)
		"PsProcessExit: system process terminated\n" KeCrash
	end

	if (process@ KeProcess_KilledStatus + @ ~~)
		status@ process@ KeProcess_KilledStatus + !
	end

	process@ PsProcessCleanup

	1 process@ KeProcess_Terminated + !

	0 // priboost
	process@ PsProcess_TerminationEvent + // event
	KeEventSignal
end

fn PsThreadExit { -- }
	// this thread has reached the end of its life. usermode will never regain
	// control.

	auto current
	KeThreadCurrent@ current!

	auto process
	current@ KeThread_Process + @ process!

	// ignore kill so nothing bad happens while we're cleaning up
	current@ KeThreadIgnoreKill drop

	auto ipl
	IPLDPC KeIPLRaise ipl!

	PRIORITY_HIGHREALTIME 1 - // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	ipl@ KeIPLLower

	current@ KeThreadRundown

	current@ MmThreadUninitialize drop

	process@ PsProcessCreateDeleteLock drop

	current@ KeThreadUninitialize

	if (process@ KeProcess_ThreadCount + @ ~~)
		// we were the last thread, process is dead now.
		current@ KeThread_KilledStatus + @ // status
		process@ // status
		PsProcessExit
	end

	process@ PsProcessCreateDeleteUnlock

	0 // priboost
	current@ PsThread_TerminationEvent + // event
	KeEventSignal

	IPLDPC KeIPLRaise drop

	// add ourselves to the reaper thread list and signal its event.

	PsReaperThreadListHead@ current@ KeThread_QueueNext + !
	current@ PsReaperThreadListHead!

	0 // priboost
	PsReaperEvent // event
	KeEventSignal

	THREADSTATUS_TERMINATED KeThreadYield
end

fn PsThreadTerminateObject { status threadobject -- ok }
	0 ok!

	status@ // status
	threadobject@ // thread
	KeThreadTerminate

	threadobject@ KeThreadResume
end

fn PsThreadTerminate { status threadhandle -- ok }
	auto obj
	auto access

	PsThreadObjectType@ // type
	threadhandle@ // handle
	ObObjectReferenceByHandle ok! obj! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		obj@ ObObjectDereferenceByPointer drop

		return
	end

	status@ // status
	obj@ // threadobject
	PsThreadTerminateObject ok!

	obj@ ObObjectDereferenceByPointer drop
end