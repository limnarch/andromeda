#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn (ObTypeDeleteFunction) PsProcessObjectDelete { object -- }
	// the last reference to this process object was removed.
	// finally free all resources associated with it.

	// destroy PID

	auto ok

	object@ PsProcess_PID + @ // handle
	PsProcessTable@ // handletable
	0 // locked
	ExHandleDelete ok! drop drop

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to delete PID (%i)\n" KeCrash
		end
	end

	// destroy handle table

	pointerof ObHandleDestroyFunction // enum func
	object@ PsProcess_HandleTable + @ // handle table
	ExHandleTableDelete

	// remove from the global process list

	PsProcessListLock ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to lock process list\n" KeCrash
		end
	end

	object@ PsProcessRemove

	PsProcessListUnlock

	// deref quota block

	object@ PsProcess_QuotaBlock + @ MmQuotaBlockDereference

	// uninitialize virtual memory structures
	// XXX this should almost DEFINITELY be done in the context of the last
	// thread

	object@ MmProcessUninitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to uninitialize virtual memory (%i)\n" KeCrash
		end
	end

	object@ KeProcessUninitialize
end

fn (ObTypeDeleteFunction) PsThreadObjectDelete { object -- }
	// the last reference to this thread object was removed.
	// finally free all resources associated with it.

	if (DEBUGCHECKS)
		if (object@ KeThread_Enqueued + @)
			"PsThreadObjectDelete: attempt to delete enqueued thread\n" KeCrash
		end

		if (object@ KeThread_Status + @ THREADSTATUS_TERMINATED ~=)
			"PsThreadObjectDelete: attempt to delete non-terminated thread\n" KeCrash
		end
	end

	object@ KeThread_KernelStackBottom + @ MmKernelStackFree

	object@ KeThread_Process + @ ObObjectDereferenceByPointer drop
end

var PsReaperThreadListHead 0

buffer PsReaperEvent KeEvent_SIZEOF

fn PsReaperInit { -- }
	auto ok

	0 // signaled
	OSEVENT_SYNCH // type
	"PsReaperEvent" // event
	PsReaperEvent // event
	KeEventInitialize

	0 // context1
	0 // context2
	pointerof PsReaperWorker // startfunc
	0 // creationflags
	ACCESS_OWNER_ALL // permissions
	"Reaper" // name
	PsSystemProcess@ // processobject
	PsThreadCreateObject ok! drop

	if (ok@)
		"PsReaperInit: failed to create reaper thread\n" KeCrash
	end
end

fn PsReaperWorker { context1 context2 -- }
	PRIORITY_HIGHREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	while (1)
		auto ok
		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		PsReaperEvent // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "PsReaperWorker: failed to wait on reap event (%i)\n" KeCrash
			end
		end

		auto ipl
		IPLDPC KeIPLRaise ipl!

		while (PsReaperThreadListHead@)
			auto thread
			PsReaperThreadListHead@ thread!
			thread@ KeThread_QueueNext + @ PsReaperThreadListHead!

			ipl@ KeIPLLower

			thread@ ObObjectDereferenceByPointer drop

			IPLDPC KeIPLRaise ipl!
		end

		ipl@ KeIPLLower
	end
end

fn PsProcessExit { status process -- }
	// this process has reached the end of its life.

	status@ process@ PsProcess_KilledStatus + !
	1 process@ PsProcess_Terminated + !

	0 // priboost
	process@ PsProcess_TerminationEvent + // event
	KeEventSignal

	if (process@ PsSystemProcess@ ==)
		"PsProcessExit: system process terminated\n" KeCrash
	end
end

fn PsThreadExit { -- }
	// this thread has reached the end of its life. usermode will never regain
	// control.

	auto current
	KeThreadCurrent@ current!

	auto process
	current@ KeThread_Process + @ process!

	// ignore kill so nothing bad happens while we're cleaning up
	current@ KeThreadIgnoreKill drop

	current@ KeThreadRundown

	current@ MmThreadUninitialize drop

	process@ PsProcessCreateDeleteLock drop

	current@ KeThreadUninitialize

	if (process@ KeProcess_ThreadCount + @ ~~)
		// we were the last thread, process is dead now.
		current@ KeThread_KilledStatus + @ // status
		process@ // status
		PsProcessExit
	end

	process@ PsProcessCreateDeleteUnlock

	0 // priboost
	current@ PsThread_TerminationEvent + // event
	KeEventSignal

	auto ipl
	IPLDPC KeIPLRaise drop

	// add ourselves to the reaper thread list and signal its event.

	PsReaperThreadListHead@ current@ KeThread_QueueNext + !
	current@ PsReaperThreadListHead!

	0 // priboost
	PsReaperEvent // event
	KeEventSignal

	THREADSTATUS_TERMINATED KeThreadYield
end

fn PsThreadTerminateObject { status threadobject -- ok }
	0 ok!

	status@ // status
	threadobject@ // thread
	KeThreadTerminate

	threadobject@ PsThreadResumeObject
end

fn PsThreadTerminate { status threadhandle -- ok }
	auto obj
	auto access

	PsThreadObjectType@ // type
	threadhandle@ // handle
	ObObjectReferenceByHandle ok! obj! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		obj@ ObObjectDereferenceByPointer drop

		return
	end

	status@ // status
	obj@ // threadobject
	PsThreadTerminateObject ok!

	obj@ ObObjectDereferenceByPointer drop
end