//
// Implements termination and deletion of executive process and thread
// objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/Console.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/IPC.h"

fn (ObTypeDeleteFunction) PsProcessObjectDelete { object -- }
	fnsection "PAGE$text"

	// the last reference to this process object was removed.
	// finally free all resources associated with it.

	auto pagedarea
	object@ PsProcess_PagedArea + @ pagedarea!

	auto ok

	// remove from the global process list

	PsProcessListLockUnalertable

	0 // trim
	object@ // process
	PsProcessRemove

	PsProcessListUnlock

	// destroy PID

	pagedarea@ PsProcessPaged_PID + @ // handle
	PsProcessTable@ // handletable
	0 // locked
	ExHandleDelete ok! drop drop

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to delete PID (%i)\n" KeCrash
		end
	end

	object@ PsProcessCleanup

	object@ MmPageDirectoryDestroy
	object@ MmProcessHeaderDestroy

	// deref quota block

	pagedarea@ PsProcessPaged_QuotaBlock + @ MmQuotaBlockDereference

	object@ KeProcessUninitialize

	if (DEBUGCHECKS)
		if (pagedarea@ PsProcessPaged_CommittedPageTablesCount + @)
			"PsProcessObjectDelete: failed to decommit page tables\n" KeCrash
		end
	end

	pagedarea@ MmFree
end

fn (ObTypeDeleteFunction) PsThreadObjectDelete { object -- }
	fnsection "PAGE$text"

	// the last reference to this thread object was removed.
	// finally free all resources associated with it.

	if (DEBUGCHECKS)
		if (object@ KeThread_EnqueuedB + gb)
			"PsThreadObjectDelete: attempt to delete enqueued thread\n" KeCrash
		end

		if (object@ KeThread_StatusB + gb THREADSTATUS_TERMINATED ~=)
			"PsThreadObjectDelete: attempt to delete non-terminated thread\n" KeCrash
		end
	end

	// destroy TID

	auto ok
	object@ PsThread_TID + @ // handle
	PsProcessTable@ // handletable
	0 // locked
	ExHandleDelete ok! drop drop

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsThreadObjectDelete: failed to delete TID (%i)\n" KeCrash
		end
	end

	object@ KeThread_KernelStackTop + @ KETHREADSTACKSIZE - MmKernelStackFree

	auto quotablock
	object@ KeThread_Process + @ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	KETHREADSTACKSIZE // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargeVM

	KETHREADSTACKSIZE PAGESHIFT >> // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargeWS

	if (object@ PsThread_IPCBlock + @)
		object@ PsThread_IPCBlock + @ MmFree

		IPCThreadBlock_SIZEOF MmChargeBytesGet // charge
		quotablock@ // quotablock
		MmQuotaBlockUncharge
	end

	object@ KeThread_Process + @ ObObjectDereferenceByPointer drop
end

var PsReaperThreadListHead 0
public PsReaperThreadListHead

fn PsReaperWorker { context1 context2 -- }
	PRIORITY_HIGHREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	// this thread reaps dead threads and dereferences them.
	// it also is a worker thread for reaping dead objects.

	auto object

	while (1)
		auto ok
		USERMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		PsReaperEvent // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "PsReaperWorker: failed to wait on reap event (%i)\n" KeCrash
			end
		end

		auto ipl
		IPLDPC KeIPLRaise ipl!

		while (PsReaperThreadListHead@)
			PsReaperThreadListHead@ object!
			object@ KeThread_QueueNext + @ PsReaperThreadListHead!

			0 object@ KeThread_QueueNext + !

			ipl@ KeIPLLower

			object@ ObObjectDereferenceByPointer drop

			IPLDPC KeIPLRaise ipl!
		end

		while (ObReaperListHead@)
			auto npheader
			ObReaperListHead@ npheader!

			npheader@ ObNonpagedHeader_PointerCount + @ ObReaperListHead!
			npheader@ ObNonpagedHeader_HandleCount + @ object!

			0 npheader@ ObNonpagedHeader_PointerCount + !
			0 npheader@ ObNonpagedHeader_HandleCount + !

			ipl@ KeIPLLower

			object@ ObObjectFree ok!

			if (DEBUGCHECKS)
				if (ok@)
					"PsReaperWorker: failed to free object\n" KeCrash
				end
			end

			IPLDPC KeIPLRaise ipl!
		end

		ipl@ KeIPLLower
	end
end

fn PsProcessCleanup { process -- }
	fnsection "PAGE$text"

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	if (pagedarea@ PsProcessPaged_CleanedUp + @)
		// process had a last thread that did all this already
		return
	end

	1 pagedarea@ PsProcessPaged_CleanedUp + !

	// destroy handle table

	pointerof ObHandleDestroyFunction // enum func
	pagedarea@ PsProcessPaged_HandleTable + @ // handle table
	ExHandleTableDelete

	// uninitialize virtual memory structures

	auto ok
	process@ MmProcessUninitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsProcessObjectDelete: failed to uninitialize virtual memory (%i)\n" KeCrash
		end
	end

	1 PsProcessDeletionCount KeInterlockedIncrement drop

	process@ CoConsoleRemoveProcess drop
end

fn PsProcessExit { status process -- }
	fnsection "PAGE$text"

	// this process has reached the end of its life.

	if (DEBUGCHECKS)
		if (process@ PsSystemProcess@ ==)
			status@ "PsProcessExit: system process terminated (%i)\n" KeCrash
		end
	end

	if (process@ KeProcess_KilledStatus + @ ~~)
		status@ process@ KeProcess_KilledStatus + !
	end

	1 process@ KeProcess_TerminatedB + sb

	process@ PsProcessCleanup

	0 // priboost
	process@ PsProcess_TerminationEvent + // event
	KeEventSignal
end

fn PsThreadExit { -- }
	// this thread has reached the end of its life. usermode will never regain
	// control.

	auto current
	KeThreadCurrent@ current!

	auto process
	current@ KeThread_Process + @ process!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	PRIORITY_HIGHREALTIME 1 - // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	ipl@ KeIPLLower

	// ignore kill so nothing bad happens while we're cleaning up
	current@ KeThreadIgnoreKill drop

	if (current@ PsThread_IOListHead + @)
		// safe to check this in this manner because we are the only one who
		// can enqueue items to this list and we ain't doing that.

		IOThreadRundown
	end

	0 current@ KeThread_KernelStackCanBeSwappedB + sb

	current@ KeThreadRundown

	current@ MmThreadUninitialize drop

	process@ PsProcessCreateDeleteLock drop

	current@ KeThreadUninitialize

	if (process@ KeProcess_ThreadCountI + gi ~~)
		// we were the last thread, process is dead now.
		current@ KeThread_KilledStatus + @ // status
		process@ // process
		PsProcessExit
	end

	process@ PsProcessCreateDeleteUnlock

	IPLDPC KeIPLRaise drop

	if (DEBUGCHECKS)
		if (current@ KeThread_APCListHead + @)
			current@ "PsThreadExit: thread %x had pending APCs\n" KeCrash
		end
	end

	// signal our termination event

	0 // priboost
	current@ PsThread_TerminationEvent + // event
	KeEventSignal

	// add ourselves to the reaper thread list and signal its event.

	PsReaperThreadListHead@ current@ KeThread_QueueNext + !
	current@ PsReaperThreadListHead!

	0 // priboost
	PsReaperEvent // event
	KeEventSignal

	THREADSTATUS_TERMINATED KeThreadYield
end

fn PsThreadTerminateObject { status threadobject -- ok }
	fnsection "PAGE$text"

	0 ok!

	status@ // status
	threadobject@ // thread
	KeThreadTerminate

	threadobject@ KeThreadResume
end

fn PsThreadTerminate { status threadhandle -- ok }
	fnsection "PAGE$text"

	auto obj
	auto access

	PsThreadObjectType@ // type
	threadhandle@ // handle
	ObObjectReferenceByHandle ok! obj! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		obj@ ObObjectDereferenceByPointer drop

		return
	end

	status@ // status
	obj@ // threadobject
	PsThreadTerminateObject ok!

	obj@ ObObjectDereferenceByPointer drop
end