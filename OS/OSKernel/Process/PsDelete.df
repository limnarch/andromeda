//
// Implements termination and deletion of executive process and thread
// objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/Console.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/IPC.h"

#include "PsInternal.h"

fn (ObTypeDeleteFunction) PsiProcessObjectDelete { object -- }
	fnsection "PAGE$text"

	// the last reference to this process object was removed.
	// finally free all resources associated with it.

	auto pagedarea
	object@ PsProcess_PagedArea + @ pagedarea!

	auto ok

	// remove from the global process list

	0 // locked
	object@ // process
	PsProcessRemove

	0 // locked
	object@ // process
	PsProcessRemoveForTrim

	// destroy PID

	pagedarea@ PsProcessPaged_PID + @ // handle
	PsProcessTable@ // handletable
	0 // locked
	ExHandleDelete ok! drop drop

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsiProcessObjectDelete: failed to delete PID (%i)\n" KeCrash
		end
	end

	object@ PsiProcessCleanup

	object@ MmProcessDelete

	// deref quota block

	pagedarea@ PsProcessPaged_QuotaBlock + @ MmQuotaBlockDereference

	object@ KeProcessUninitialize

	if (DEBUGCHECKS)
		if (pagedarea@ PsProcessPaged_CommittedPageTablesCount + @)
			"PsiProcessObjectDelete: failed to decommit page tables\n" KeCrash
		end
	end

	pagedarea@ MmFree
end

fn (ObTypeDeleteFunction) PsiThreadObjectDelete { object -- }
	fnsection "PAGE$text"

	// the last reference to this thread object was removed.
	// finally free all resources associated with it.

	if (DEBUGCHECKS)
		if (object@ KeThread_StatusB + gb THREADSTATUS_TERMINATED ~=)
			object@ KeThread_StatusB + gb
			"PsiThreadObjectDelete: attempt to delete non-terminated thread (%d)\n" KeCrash
		end
	end

	// destroy TID

	auto ok
	object@ PsThread_TID + @ // handle
	PsProcessTable@ // handletable
	0 // locked
	ExHandleDelete ok! drop drop

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsiThreadObjectDelete: failed to delete TID (%i)\n" KeCrash
		end
	end

	object@ KeThread_KernelStackTop + @ KETHREADSTACKSIZE - MmKernelStackFree

	auto quotablock
	object@ KeThread_Process + @ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	KETHREADSTACKSIZE PAGESHIFT >> // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargeWS

	if (object@ PsThread_IPCBlock + @)
		object@ IPCThreadBlockFree
	end

	object@ KeThread_Process + @ ObObjectDereferenceByPointer drop
end

var PsReaperThreadListHead 0
public PsReaperThreadListHead

fn PsiReaperWorker { context1 context2 -- }
	// this thread reaps dead threads and dereferences them.
	// it also is a worker thread for reaping dead objects.

	auto object

	while (1)
		auto ok
		USERMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		PsReaperEvent // object
		KeThreadWaitForObject ok!

		if (DEBUGCHECKS)
			if (ok@)
				ok@ "PsiReaperWorker: failed to wait on reap event (%i)\n" KeCrash
			end
		end

		auto ipl
		IPLDPC KeIPLRaise ipl!

		while (PsReaperThreadListHead@)
			PsReaperThreadListHead@ object!
			object@ KeThread_QueueNext + @ PsReaperThreadListHead!

			0 object@ KeThread_QueueNext + !

			ipl@ KeIPLLower

			object@ ObObjectDereferenceByPointer drop

			IPLDPC KeIPLRaise ipl!
		end

		while (ObReaperListHead@)
			ObReaperPop object!

			ipl@ KeIPLLower

			object@ ObObjectFree ok!

			if (DEBUGCHECKS)
				if (ok@)
					"PsiReaperWorker: failed to free object\n" KeCrash
				end
			end

			IPLDPC KeIPLRaise ipl!
		end

		ipl@ KeIPLLower
	end
end

fn PsiProcessCleanup { process -- }
	fnsection "PAGE$text"

	auto pagedarea
	process@ PsProcess_PagedArea + @ pagedarea!

	if (pagedarea@ PsProcessPaged_CleanedUp + @)
		// process had a last thread that did all this already.
		// this is synchronized via the createdelete lock.

		return
	end

	1 pagedarea@ PsProcessPaged_CleanedUp + !

	// indicate termination to job

	if (pagedarea@ PsProcessPaged_Job + @)
		process@ PsiJobIndicateProcessExit
	end

	// destroy handle table

	pointerof ObHandleDestroyFunction // enum func
	pagedarea@ PsProcessPaged_HandleTable + @ // handle table
	ExHandleTableDelete

	// uninitialize virtual memory structures

	auto ok
	process@ MmProcessUninitialize ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "PsiProcessObjectDelete: failed to uninitialize virtual memory (%i)\n" KeCrash
		end
	end

	// remove from console group

	process@ CoConsoleRemoveProcess drop
end

fn PsiProcessExit { status process -- }
	fnsection "PAGE$text"

	// this process has reached the end of its life.

	if (DEBUGCHECKS)
		if (process@ PsSystemProcess@ ==)
			status@ "PsiProcessExit: system process terminated (%i)\n" KeCrash
		end
	end

	if (process@ KeProcess_KilledStatus + @ ~~)
		status@ process@ KeProcess_KilledStatus + !
	end

	1 process@ KeProcess_TerminatedB + sb

	process@ PsiProcessCleanup

	0 // priboost
	process@ PsProcess_TerminationEvent + // event
	KeEventSignal

	status@ PsProcessSignalActivation drop
end

fn PsiThreadExit { -- }
	// this thread has reached the end of its life. usermode will never regain
	// control.

	auto current
	KeThreadCurrent@ current!

	auto process
	current@ KeThread_Process + @ process!

	PRIORITY_HIGHREALTIME 1 - // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	// ignore kill so nothing bad happens while we're cleaning up

	current@ KeThreadIgnoreKill drop

	if (current@ PsThread_IOListHead + @)
		// safe to check this in this manner because we are the only one who
		// can enqueue items to this list and we ain't doing that right now.

		IOThreadRundown
	end

	0 current@ KeThread_KernelStackCanBeSwappedB + sb

	current@ KeThreadRundown

	current@ MmThreadUninitialize drop

	0 // alertable
	process@ // processobject
	PsProcessCreateDeleteLock drop

	current@ KeThreadUninitialize

	if (process@ KeProcess_ThreadCountI + gi ~~)
		// we were the last thread, process is dead now.
		
		current@ KeThread_KilledStatus + @ // status
		process@ // process
		PsiProcessExit
	end

	process@ PsProcessCreateDeleteUnlock

	IPLDPC KeIPLRaise drop

	if (DEBUGCHECKS)
		if (current@ KeThread_APCListHead + @)
			current@ "PsiThreadExit: thread %x had pending APCs\n" KeCrash
		end
	end

	// signal our termination event

	0 // priboost
	current@ PsThread_TerminationEvent + // event
	KeEventSignal

	// add ourselves to the reaper thread list and signal its event.

	PsReaperThreadListHead@ current@ KeThread_QueueNext + !
	current@ PsReaperThreadListHead!

	0 // priboost
	PsReaperEvent // event
	KeEventSignal

	THREADSTATUS_TERMINATED KeThreadBlock
end

fn PsThreadTerminateObject { status threadobject -- ok }
	fnsection "PAGE$text"

	0 ok!

	status@ // status
	threadobject@ // thread
	KeThreadTerminate

	threadobject@ KeThreadResume
end

fn PsThreadTerminate { status threadhandle -- ok }
	fnsection "PAGE$text"

	auto obj
	auto access

	PsThreadObjectType@ // type
	threadhandle@ // handle
	ObObjectReferenceByHandle ok! obj! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		obj@ ObObjectDereferenceByPointer drop

		return
	end

	status@ // status
	obj@ // threadobject
	PsThreadTerminateObject ok!

	obj@ ObObjectDereferenceByPointer drop
end