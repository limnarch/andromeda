//
// Implements the system calls for the process subsystem.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Object.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn OSProcessCreate { sectionhandle creationflags permissions name -- processhandle ok }
	auto kname
	OBNAMEMAX // max
	name@ // string
	ExCallGetString ok! kname!

	if (ok@)
		return
	end

	sectionhandle@ // sectionhandle
	creationflags@ // creationflags
	permissions@ // permissions
	kname@ // name
	PsProcessCreate ok! processhandle!

	kname@ ExCallFreeString
end

fn OSProcessSignal { signal processhandle -- ok }
	signal@ processhandle@ PsProcessSignal ok!
end

fn OSProcessOpenByPID { access pid -- processhandle ok }
	access@ pid@ PsProcessOpenByPID ok! processhandle!
end

fn OSProcessQuery { processhandle query -- ok }
	auto kquery
	OSProcessInformation_SIZEOF alloc kquery!

	processhandle@ // processhandle
	kquery@ // query
	PsProcessInformationQuery ok!

	if (ok@)
		return
	end

	query@ // dest
	kquery@ // src
	OSProcessInformation_SIZEOF // size
	KeSafeCopyOut ok!
end

fn OSProcessQueryByPID { pid query -- ok }
	auto kquery
	OSProcessInformation_SIZEOF alloc kquery!

	pid@ // pid
	kquery@ // query
	PsProcessInformationQueryByPID ok!

	if (ok@)
		return
	end

	query@ // dest
	kquery@ // src
	OSProcessInformation_SIZEOF // size
	KeSafeCopyOut ok!
end

fn OSProcessReadStatus { processhandle -- status ok }
	processhandle@ PsProcessReadStatus ok! status!
end

fn OSProcessSignalActivation { activationstatus -- ok }
	activationstatus@ PsProcessSignalActivation ok!
end

fn OSProcessWaitForActivation { timeout processhandle -- activationstatus ok }
	timeout@ processhandle@ PsProcessWaitForActivation ok! activationstatus!
end

fn OSProcessExit { status -- }
	auto process
	KeProcessCurrent process!

	status@ process@ KeProcess_KilledStatus + !

	auto ok
	OSSIGNAL_KILL // signal
	process@ // process
	KeProcessSignal ok!

	if (ok@)
		ok@ "OSProcessExit: KeProcessSignal failed (%i)\n" KeCrash
	end
end

fn OSProcessCountQuery { -- count ok }
	0 ok!
	PsActiveProcessCount@ count!
end

fn OSProcessQueryAll { buffer maxquery -- count ok }
	PsActiveProcessCount@ maxquery@ min maxquery!

	maxquery@ OSProcessInformation_SIZEOF * MmQuotaChargeBuffer ok!

	if (ok@)
		return
	end

	auto kbuffer
	maxquery@ OSProcessInformation_SIZEOF * // bytes
	'PsQu' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! kbuffer!

	if (ok@)
		maxquery@ OSProcessInformation_SIZEOF * MmQuotaUnchargeBuffer
		return
	end

	kbuffer@ // buffer
	maxquery@ // maxquery
	PsProcessQueryAll ok! count!

	if (ok@)
		kbuffer@ MmFree
		maxquery@ OSProcessInformation_SIZEOF * MmQuotaUnchargeBuffer
		return
	end

	buffer@ // dest
	kbuffer@ // src
	maxquery@ OSProcessInformation_SIZEOF * // size
	KeSafeCopyOut ok!

	kbuffer@ MmFree
	maxquery@ OSProcessInformation_SIZEOF * MmQuotaUnchargeBuffer
end

fn OSProcessMaskSignal { signal processhandle -- ok }
	signal@ processhandle@ PsProcessMaskSignal ok!
end

fn OSProcessUnmaskSignal { signal processhandle -- ok }
	signal@ processhandle@ PsProcessUnmaskSignal ok!
end

fn OSProcessSetConsoleGroup { filehandle processhandle -- ok }
	filehandle@ processhandle@ PsProcessSetConsoleGroup ok!
end

fn OSProcessClearConsoleGroup { processhandle -- ok }
	processhandle@ PsProcessClearConsoleGroup ok!
end

fn OSSetQuota { quota processhandle -- ok }
	SYSTEMPERMISSION_SETQUOTA // permission
	KeProcessCurrent // process
	SeProcessCheckPermission ok!

	if (ok@)
		return
	end

	auto kquota
	OSQuota_SIZEOF alloc kquota!

	kquota@ // dest
	quota@ // src
	OSQuota_SIZEOF // size
	KeSafeCopyIn ok!

	if (ok@)
		return
	end

	auto processobject
	auto access

	PsProcessObjectType@ // type
	processhandle@ // handle
	ObObjectReferenceByHandle ok! processobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	kquota@ // quota
	processobject@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ // quotablock
	MmSetQuota

	processobject@ ObObjectDereferenceByPointer drop
end

fn OSQuotaQuery { query processhandle -- ok }
	auto processobject
	auto access

	PsProcessObjectType@ // type
	processhandle@ // handle
	ObObjectReferenceByHandle ok! processobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ SeCheckAccess ok!

	if (ok@)
		processobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto kquery
	OSQuotaInformation_SIZEOF alloc kquery!

	kquery@ // ptr
	OSQuotaInformation_SIZEOF // size
	0 // word
	memset

	kquery@ // query
	processobject@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ // quotablock
	MmQuotaQuery

	query@ // dest
	kquery@ // src
	OSMemoryInformation_SIZEOF // size
	KeSafeCopyOut ok!

	processobject@ ObObjectDereferenceByPointer drop
end

fn OSThreadException { signal -- ok }
	signal@ // signal
	KeThreadCurrent@ // thread
	KeThreadException ok!
end

fn OSThreadSetFilePermissions { filepermissions -- ok }
	filepermissions@ KeThreadCurrent@ PsThread_FileCreationPermissions + !
	0 ok!
end

fn OSThreadSleep { ms -- ok }
	ms@ // ms
	USERMODE // waitmode
	1 // alertable
	KeThreadSleep ok!
end

fn OSThreadCreate { context startfunc creationflags permissions name processhandle -- threadhandle ok }
	auto kname
	OBNAMEMAX // max
	name@ // string
	ExCallGetString ok! kname!

	if (ok@)
		return
	end

	startfunc@ // context1
	context@ // context2
	pointerof PsThreadUserEntry // startfunc
	creationflags@ // creationflags
	permissions@ // permissions
	kname@ // name
	processhandle@ // processhandle
	PsThreadCreate ok! threadhandle!

	kname@ ExCallFreeString
end

fn OSThreadTerminate { status threadhandle -- ok }
	status@ threadhandle@ PsThreadTerminate ok!
end

fn OSThreadSuspend { threadhandle -- ok }
	threadhandle@ PsThreadSuspend ok!
end

fn OSThreadResume { threadhandle -- ok }
	threadhandle@ PsThreadResume ok!
end

fn OSThreadReadStatus { threadhandle -- status ok }
	threadhandle@ PsThreadReadStatus ok! status!
end

fn OSThreadQuery { threadhandle query -- ok }
	auto kquery
	OSThreadInformation_SIZEOF alloc kquery!

	threadhandle@ // threadhandle
	kquery@ // query
	PsThreadInformationQuery ok!

	if (ok@)
		return
	end

	query@ // dest
	kquery@ // src
	OSThreadInformation_SIZEOF // size
	KeSafeCopyOut ok!
end