//
// Implements common volume-management routines for filesystem drivers.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Object.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn FSVolumeNameGet { mount -- name }
	fnsection "PAGE$text"

	auto devobj

	mount@ IOMount_RealVolumeFile + @ IOFile_FileControlBlock + @ IOFileControlBlockGetDeviceObject devobj!

	devobj@ ObObjectName name!
end

fn FSVolumeInitialize { blocklog mount -- ok }
	fnsection "PAGE$text"

	// start caching on volume file

	auto volfcb
	mount@ IOMount_DeviceObject + @ IODevice_FileControlBlock + @ volfcb!

	auto realdevice
	mount@ IOMount_RealVolumeFile + @ IOFile_FileControlBlock + @ IOFileControlBlockGetDeviceObject realdevice!

	if (DEBUGCHECKS)
		if (realvolfcb@ IOFileControlBlockGetType OSFILETYPE_CHARDEVICE ==)
			// this is a character device!

			"FSVolumeInitialize: attempted to initialize a character device\n" KeCrash
		end

		if (blocklog@ realdevice@ IODevice_BlockLog + @ <)
			"FSVolumeInitialize: fs block size smaller than underlying device's\n" KeCrash
		end
	end

	blocklog@ mount@ IOMount_DeviceObject + @ IODevice_BlockLog + !

	auto cacheblock
	volfcb@ IOFileControlBlockCacheCheck ok! cacheblock!

	if (ok@ ~~)
		cacheblock@ IOCacheInfoBlockTryIncrementMap ok! drop
	end
end

fn FSVolumeUninitialize { mount -- ok }
	fnsection "PAGE$text"

	0 ok!

	auto volfcb
	mount@ IOMount_DeviceObject + @ IODevice_FileControlBlock + @ volfcb!

	volfcb@ IOFileControlBlock_CacheInfoBlock + @ IOCacheInfoBlockDecrementMap drop
end

fn FSVolumeFlush { mount -- ok }
	fnsection "PAGE$text"

	auto volfcb
	mount@ IOMount_VolumeFile + @ IOFile_FileControlBlock + @ volfcb!

	auto cacheblock
	volfcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	KeThreadCurrent@ KeThreadIgnoreKill drop

	cacheblock@ IOCacheInfoBlockFlush ok!

	KeThreadCurrent@ KeThreadAcceptKill drop
end

fn FSVolumeGetFCBByMount { mount -- volfcb }
	mount@ IOMount_DeviceObject + @ IODevice_FileControlBlock + @ volfcb!
end

fn FSVolumeGetFCB { fcb -- volfcb }
	auto devobj
	fcb@ IOFileControlBlockGetDeviceObject devobj!

	devobj@ IODevice_FileControlBlock + @ volfcb!
end

fn FSCheckAccess { access permbits owninguid owninggid mount -- ok }
	fnsection "PAGE$text"

	if (access@ ACCESS_WRITE &)
		if (mount@ IOMount_Flags + @ OSMOUNT_READONLY &)
			STATUS_READONLY_FILESYSTEM ok!

			return
		end
	end

	if (mount@ IOMount_Flags + @ OSMOUNT_NOUID &)
		0 ok!

		return
	end

	auto process
	KeProcessCurrent process!

	if (mount@ IOMount_Flags + @ OSMOUNT_MATCHUID &)
		auto dev
		mount@ IOMount_RealVolumeFile + @ IOFile_FileControlBlock + @ IOFileControlBlockGetDeviceObject dev!

		dev@ ObObjectUIDGID owninggid! owninguid!

		access@ // access
		permbits@ // permbits
		owninguid@ // owninguid
		owninggid@ // owninggid
		process@ // process
		SeCheckAccessFilesystemX ok!

		return
	end

	access@ // access
	permbits@ // permbits
	owninguid@ // owninguid
	owninggid@ // owninggid 
	process@ // process
	SeCheckAccessFilesystemX ok!
end

fn FSFileObjectSetSecurity { uid gid object mount -- }
	fnsection "PAGE$text"

	auto paged
	KeProcessCurrent PsProcess_PagedArea + @ paged!

	if (mount@ IOMount_Flags + @ OSMOUNT_NOUID &)
		paged@ PsProcessPaged_GID + @ object@ ObObjectSetGID
		paged@ PsProcessPaged_UID + @ object@ ObObjectSetUID

		return
	end

	if (mount@ IOMount_Flags + @ OSMOUNT_MATCHUID &)
		auto dev
		mount@ IOMount_RealVolumeFile + @ IOFile_FileControlBlock + @ IOFileControlBlockGetDeviceObject dev!

		dev@ ObObjectUIDGID gid! uid!
	end

	uid@ object@ ObObjectSetUID
	gid@ object@ ObObjectSetGID
end