//
// General-purpose ringbuffer implementation.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALCPU.h"

#include "<inc>/HALDebug.h"

// this one's actually my own idea for once,
// these are really useful and I'm just adapting the concept from AISIX

fn ExRingBufferCreate { sizelog valuesizelog synchipl quotablock -- ringbuffer ok }
	fnsection "PAGE$text"

	// size parameter is in units of values,
	// NOT in units of bytes

	auto size
	1 sizelog@ << size!

	auto ringbufcharge
	ExRingBuffer_SIZEOF MmChargeBytesGet ringbufcharge!

	auto ringbufdatasize
	size@ valuesizelog@ << ringbufdatasize!

	ringbufdatasize@ MmChargeBytesGet ringbufcharge +=

	if (quotablock@)
		ringbufcharge@ // charge
		quotablock@ // quotablock
		MmQuotaBlockCharge ok!

		if (ok@)
			return
		end

		quotablock@ MmQuotaBlockReference
	end

	ExRingBuffer_SIZEOF // bytes
	'Ring' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! ringbuffer!

	if (ok@)
		if (quotablock@)
			ringbufcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUncharge

			quotablock@ MmQuotaBlockDereference
		end

		return
	end

	auto ringbufdata
	ringbufdatasize@ // bytes
	'RiDa' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! ringbufdata!

	if (ok@)
		ringbuffer@ MmFree

		if (quotablock@)
			ringbufcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUncharge

			quotablock@ MmQuotaBlockDereference
		end

		return
	end

	size@ ringbuffer@ ExRingBuffer_Size + !
	ringbufdata@ ringbuffer@ ExRingBuffer_BufferData + !

	0 ringbuffer@ ExRingBuffer_ReadPointer + !
	0 ringbuffer@ ExRingBuffer_WritePointer + !

	synchipl@ ringbuffer@ ExRingBuffer_SynchIPL + !

	valuesizelog@ ringbuffer@ ExRingBuffer_ValueSizeLog + !

	quotablock@ ringbuffer@ ExRingBuffer_QuotaBlock + !

	0 // signaled
	OSEVENT_SYNCH // type
	"ExRingBufferWriterEvent" // name
	ringbuffer@ ExRingBuffer_WriterEvent + // event
	KeEventInitialize

	0 // signaled
	OSEVENT_SYNCH // type
	"ExRingBufferReaderEvent" // name
	ringbuffer@ ExRingBuffer_ReaderEvent + // event
	KeEventInitialize
end

fn ExRingBufferDelete { ringbuffer -- }
	fnsection "PAGE$text"

	auto quotablock
	ringbuffer@ ExRingBuffer_QuotaBlock + @ quotablock!

	auto charge
	ExRingBuffer_SIZEOF MmChargeBytesGet charge!
	ringbuffer@ ExRingBuffer_BufferData + @ MmBlockChargeGet charge +=

	ringbuffer@ ExRingBuffer_BufferData + @ MmFree
	ringbuffer@ MmFree

	if (quotablock@)
		charge@ // charge
		quotablock@ // quotablock
		MmQuotaBlockUncharge

		quotablock@ MmQuotaBlockDereference
	end
end

fn ExRingBufferWakeReader { priboost ringbuffer -- }
	priboost@ // priboost
	ringbuffer@ ExRingBuffer_ReaderEvent + // event
	KeEventSignal
end

fn ExRingBufferWakeWriter { priboost ringbuffer -- }
	priboost@ // priboost
	ringbuffer@ ExRingBuffer_WriterEvent + // event
	KeEventSignal
end

// waitonfull can be:
// EXRINGDONTWAIT - dont wait on full
// EXRINGWAIT     - wait alertably on full
// EXRINGWITUALRT - wait unalertably on full

fn ExRingBufferWriteValue { value overwrite timeout lastmode waitonfull ringbuffer -- valueptr ok }
	auto ipl
	ringbuffer@ ExRingBuffer_SynchIPL + @ ipl!

	auto valuesizelog
	ringbuffer@ ExRingBuffer_ValueSizeLog + @ valuesizelog!

	auto size
	ringbuffer@ ExRingBuffer_Size + @ size!

	auto offmask
	size@ 1 - offmask!

	auto bufdata
	ringbuffer@ ExRingBuffer_BufferData + @ bufdata!

	auto oldipl

	ipl@ KeIPLRaise oldipl!

	auto rp
	ringbuffer@ ExRingBuffer_ReadPointer + @ rp!

	auto wp
	ringbuffer@ ExRingBuffer_WritePointer + @ wp!

	if (wp@ rp@ - size@ >=)
		if (waitonfull@)
			auto alertable
			waitonfull@ EXRINGWAIT == alertable!

			while (wp@ rp@ - size@ >=)
				// wait while full

				oldipl@ KeIPLLower

				lastmode@ // waitmode
				alertable@ // alertable
				timeout@ // timeout
				ringbuffer@ ExRingBuffer_WriterEvent + // object
				KeThreadWaitForObject ok!

				if (ok@)
					return
				end

				ipl@ KeIPLRaise oldipl!

				// it changed since we slept, so, update these

				ringbuffer@ ExRingBuffer_WritePointer + @ wp!
				ringbuffer@ ExRingBuffer_ReadPointer + @ rp!
			end
		end else
			if (overwrite@)
				1 rp +=

				rp@ ringbuffer@ ExRingBuffer_ReadPointer + !
			end else
				oldipl@ KeIPLLower

				STATUS_RING_FULL ok!

				return
			end
		end
	end

	wp@ offmask@ & valuesizelog@ << bufdata@ + valueptr!

	if (valuesizelog@ 0 ==)
		value@ valueptr@ sb
	end elseif (valuesizelog@ 1 ==)
		value@ valueptr@ si
	end else
		value@ valueptr@ !
	end

	wp@ 1 + ringbuffer@ ExRingBuffer_WritePointer + !

	oldipl@ KeIPLLower

	0 ok!
end

// waitonempty can be:
// EXRINGDONTWAIT - dont wait on empty
// EXRINGWAIT     - wait alertably on empty
// EXRINGWITUALRT - wait unalertably on empty
//
// it can be bitwise OR'd with:
// EXRINGSYNCH    - keep IPL raised when returning

fn ExRingBufferReadValue { timeout lastmode waitonempty ringbuffer -- value valueptr ok }
	auto ipl
	ringbuffer@ ExRingBuffer_SynchIPL + @ ipl!

	auto valuesizelog
	ringbuffer@ ExRingBuffer_ValueSizeLog + @ valuesizelog!

	auto size
	ringbuffer@ ExRingBuffer_Size + @ size!

	auto offmask
	// this always works because the size is defined by a log value
	// (so its always a power of two)
	size@ 1 - offmask!

	auto bufdata
	ringbuffer@ ExRingBuffer_BufferData + @ bufdata!

	auto oldipl

	ipl@ KeIPLRaise oldipl!

	auto rp
	ringbuffer@ ExRingBuffer_ReadPointer + @ rp!

	auto wp
	ringbuffer@ ExRingBuffer_WritePointer + @ wp!

	if (wp@ rp@ ==)
		// buffer is empty. take this opportunity to help prevent these pointers from overflowing...
		0 wp!
		0 rp!
		0 ringbuffer@ ExRingBuffer_WritePointer + !
		0 ringbuffer@ ExRingBuffer_ReadPointer + !

		if (waitonempty@ 0xFF &)
			auto alertable
			waitonempty@ 0xFF & EXRINGWAIT == alertable!

			while (wp@ rp@ ==)
				oldipl@ KeIPLLower

				lastmode@ // waitmode
				alertable@ // alertable
				timeout@ // timeout
				ringbuffer@ ExRingBuffer_ReaderEvent + // object
				KeThreadWaitForObject ok!

				if (ok@)
					return
				end

				ipl@ KeIPLRaise oldipl!

				// it changed since we slept, so, update these

				ringbuffer@ ExRingBuffer_WritePointer + @ wp!
				ringbuffer@ ExRingBuffer_ReadPointer + @ rp!
			end
		end else
			oldipl@ KeIPLLower

			STATUS_RING_EMPTY ok!

			return
		end
	end

	rp@ offmask@ & valuesizelog@ << bufdata@ + valueptr!

	if (valuesizelog@ 0 ==)
		valueptr@ gb value!
	end elseif (valuesizelog@ 1 ==)
		valueptr@ gi value!
	end else
		valueptr@ @ value!
	end

	if (DEBUGCHECKS)
		if (rp@ 0xFFFFFFFF ==)
			"ExRingBufferReadValue: rp overflow\n" KeCrash
		end
	end

	rp@ 1 + ringbuffer@ ExRingBuffer_ReadPointer + !

	if (waitonempty@ EXRINGSYNCH & ~~)
		oldipl@ KeIPLLower
	end

	0 ok!
end

fn ExRingBufferIsFull { ringbuffer -- isfull }
	ringbuffer@ ExRingBuffer_WritePointer + @
	ringbuffer@ ExRingBuffer_ReadPointer + @ -
	ringbuffer@ ExRingBuffer_Size + @ >= isfull!
end

fn ExRingBufferIsEmpty { ringbuffer -- isempty }
	ringbuffer@ ExRingBuffer_WritePointer + @
	ringbuffer@ ExRingBuffer_ReadPointer + @ == isempty!
end

fn ExRingBufferRubout { ringbuffer -- value valueptr ok }
	// un-write the last value and return the value.

	0 ok!

	auto valuesizelog
	ringbuffer@ ExRingBuffer_ValueSizeLog + @ valuesizelog!

	auto size
	ringbuffer@ ExRingBuffer_Size + @ size!

	auto offmask
	size@ 1 - offmask!

	auto bufdata
	ringbuffer@ ExRingBuffer_BufferData + @ bufdata!

	auto rs
	HALCPUInterruptDisable rs!

	auto rp
	ringbuffer@ ExRingBuffer_ReadPointer + @ rp!

	auto wp
	ringbuffer@ ExRingBuffer_WritePointer + @ wp!

	if (wp@ rp@ ==)
		// ringbuffer is empty.

		rs@ HALCPUInterruptRestore

		-1 ok!

		return
	end

	1 wp -=

	wp@ offmask@ & valuesizelog@ << bufdata@ + valueptr!

	if (valuesizelog@ 0 ==)
		valueptr@ gb value!
	end elseif (valuesizelog@ 1 ==)
		valueptr@ gi value!
	end else
		valueptr@ @ value!
	end

	wp@ ringbuffer@ ExRingBuffer_WritePointer + !

	rs@ HALCPUInterruptRestore
end

fn ExRingBufferPutBack { value ringbuffer -- valueptr ok }
	// un-read the last value and replace it with a new one.

	0 ok!

	auto valuesizelog
	ringbuffer@ ExRingBuffer_ValueSizeLog + @ valuesizelog!

	auto size
	ringbuffer@ ExRingBuffer_Size + @ size!

	auto offmask
	size@ 1 - offmask!

	auto bufdata
	ringbuffer@ ExRingBuffer_BufferData + @ bufdata!

	auto rs
	HALCPUInterruptDisable rs!

	auto rp
	ringbuffer@ ExRingBuffer_ReadPointer + @ rp!

	auto wp
	ringbuffer@ ExRingBuffer_WritePointer + @ wp!

	if (wp@ rp@ - size@ >=)
		// ringbuffer is full.

		rs@ HALCPUInterruptRestore

		-1 ok!

		return
	end

	1 rp -=

	rp@ offmask@ & valuesizelog@ << bufdata@ + valueptr!

	if (valuesizelog@ 0 ==)
		value@ valueptr@ sb
	end elseif (valuesizelog@ 1 ==)
		value@ valueptr@ si
	end else
		value@ valueptr@!
	end

	rp@ ringbuffer@ ExRingBuffer_ReadPointer + !

	rs@ HALCPUInterruptRestore
end