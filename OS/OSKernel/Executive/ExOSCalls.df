//
// Implements the system calls for the executive support subsystem.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALConsole.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Object.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn ExCallGetString { max string -- buf ok }
	max@ MmQuotaChargeBuffer ok!

	if (ok@)
		return
	end

	max@ // bytes
	'cStr' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! buf!

	if (ok@)
		max@ MmQuotaUnchargeBuffer
		return
	end

	buf@ // dest
	string@ // src
	max@ 1 - // max
	KeSafeStringCopyIn ok!

	if (ok@)
		buf@ MmFree
		max@ MmQuotaUnchargeBuffer
	end
end

fn ExCallFreeString { buf -- }
	auto charge
	buf@ MmBlockChargeGet charge!

	buf@ MmFree

	charge@ // charge
	KeProcessCurrent PsProcess_QuotaBlock + @ // quotablock
	MmQuotaBlockUncharge
end

externptr ExBootFlags

fn OSGetBootFlags { -- bootflags ok }
	SeAmIAdmin ok!

	if (ok@)
		return
	end

	ExBootFlags@ bootflags!
end

fn OSConsolePutCharacter { c -- ok }
	SeAmIAdmin ok!

	if (ok@)
		// process must be owned by an admin to print to HAL console
		return
	end

	c@ HALPutc
end

fn OSSystemAbort { num1 num2 msg -- ok }
	SeAmIAdmin ok!

	if (ok@)
		// process must be owned by an admin to abort the system
		return
	end

	auto msgbuf
	128 alloc msgbuf!

	// NOTE: no safecopy here because the system is going down anyway

	msgbuf@ // dest
	msg@ // src
	127 // max
	strncpy

	num2@ num1@ msgbuf@ "OSSystemAbort: %s %08x %08x\n" KeCrash
end

fn OSGetSystemConsoleName { namebuf -- ok }
	SYSTEMPERMISSION_SETCONSOLE // permission
	KeProcessCurrent // process
	SeProcessCheckPermission ok!

	if (ok@)
		return
	end

	if (ExSystemConsoleName@)
		namebuf@ // dest
		ExSystemConsoleName@ // src
		OBNAMEMAX 1 - // max
		KeSafeStringCopyOut ok!
	end else
		-1 ok!
	end
end

fn OSContinue { context -- }
	// load an arbitrary context.
	// must not have a return value or the trampoline will mess up the newly-
	// -prepared trapframe.

	auto kcontext
	OSContext_SIZEOF alloc kcontext!

	auto ok
	kcontext@ // dest
	context@ // src
	OSContext_SIZEOF // sz
	KeSafeCopyIn ok!

	if (ok@)
		return
	end

	kcontext@ // context
	KeThreadCurrent@ // thread
	KeThreadContinue
end

fn OSQueryTime { -- sec ms }
	auto time
	KeTime_SIZEOF alloc time!

	time@ HALRTCQuery

	time@ KeTime_SecPart + @ sec!
	time@ KeTime_MsPart + @ ms!
end

fn OSQueryUptime { -- sec ms }
	auto time
	KeTime_SIZEOF alloc time!

	time@ HALUptimeQuery

	time@ KeTime_SecPart + @ sec!
	time@ KeTime_MsPart + @ ms!
end

fn OSShutdownSystem { mode -- ok }
	SeAmIAdmin ok!

	if (ok@)
		return
	end

	mode@ ExShutdownSystem

	STATUS_FORBIDDEN_OPERATION ok!
end

fn OSGetStatistics { statistics -- ok }
	statistics@ // dest
	KeStatistics // src
	OSStatistics_SIZEOF // size
	KeSafeCopyOut ok!
end

externptr ExBuildDate

fn OSVersion { query -- ok }
	query@ OSVersionQuery_OSName + // dest
	"MINTIA" // src
	255 // max
	KeSafeStringCopyOut ok!

	if (ok@)
		return
	end

	query@ OSVersionQuery_NodeName + // dest
	"unk" // src
	255 // max
	KeSafeStringCopyOut ok!

	if (ok@)
		return
	end

	query@ OSVersionQuery_Release + // dest
	"pre-0.1" // src
	255 // max
	KeSafeStringCopyOut ok!

	if (ok@)
		return
	end

	query@ OSVersionQuery_Version + // dest
	ExBuildDate // src
	255 // max
	KeSafeStringCopyOut ok!

	if (ok@)
		return
	end

	query@ OSVersionQuery_Machine + // dest
	HALPlatformModel // src
	255 // max
	KeSafeStringCopyOut ok!

	if (ok@)
		return
	end

	query@ OSVersionQuery_Processor + // dest
	HALCPUModel // src
	255 // max
	KeSafeStringCopyOut ok!

	if (ok@)
		return
	end
end

// ExEvent

fn OSEventCreate { signaled type permissions name -- eventhandle ok }
	auto kname
	0 kname!

	if (name@)
		OBNAMEMAX // max
		name@ // string
		ExCallGetString ok! kname!

		if (ok@)
			return
		end
	end

	signaled@ // signaled
	type@ // type
	permissions@ // permissions
	kname@ // name
	ExEventCreate ok! eventhandle!

	if (name@)
		kname@ ExCallFreeString
	end
end

fn OSEventReset { eventhandle -- signaled ok }
	eventhandle@ ExEventReset ok! signaled!
end

fn OSEventSignal { eventhandle -- ok }
	eventhandle@ ExEventSignal ok!
end

fn OSEventPulse { eventhandle -- ok }
	eventhandle@ ExEventPulse ok!
end

fn OSEventReadState { eventhandle -- signaled ok }
	eventhandle@ ExEventReadState ok! signaled!
end

// ExSemaphore

fn OSSemaphoreCreate { count permissions name -- semaphorehandle ok }
	auto kname
	0 kname!

	if (name@)
		OBNAMEMAX // max
		name@ // string
		ExCallGetString ok! kname!

		if (ok@)
			return
		end
	end

	count@ // count
	permissions@ // permissions
	kname@ // name
	ExSemaphoreCreate ok! semaphorehandle!

	if (name@)
		kname@ ExCallFreeString
	end
end

fn OSSemaphoreRelease { adjustment semaphorehandle -- ok }
	adjustment@ semaphorehandle@ ExSemaphoreRelease ok!
end

fn OSSemaphoreReadState { semaphorehandle -- count ok }
	semaphorehandle@ ExSemaphoreReadState ok! count!
end

// ExMutex

fn OSMutexCreate { permissions name -- mutexhandle ok }
	auto kname
	0 kname!

	if (name@)
		OBNAMEMAX // max
		name@ // string
		ExCallGetString ok! kname!

		if (ok@)
			return
		end
	end

	permissions@ // permissions
	kname@ // name
	ExMutexCreate ok! mutexhandle!

	if (name@)
		kname@ ExCallFreeString
	end
end

fn OSMutexRelease { mutexhandle -- ok }
	mutexhandle@ ExMutexRelease ok!
end

fn OSMutexReadState { mutexhandle -- locked ok }
	mutexhandle@ ExMutexReadState ok! locked!
end

// ExTimer

fn OSTimerCreate { permissions name -- timerhandle ok }
	auto kname
	0 kname!

	if (name@)
		OBNAMEMAX // max
		name@ // string
		ExCallGetString ok! kname!

		if (ok@)
			return
		end
	end

	permissions@ // permissions
	kname@ // name
	ExTimerCreate ok! timerhandle!

	if (name@)
		kname@ ExCallFreeString
	end
end

fn OSTimerReset { timerhandle -- signaled ok }
	timerhandle@ ExTimerReset ok! signaled!
end

fn OSTimerEnqueue { interval timerhandle -- ok }
	interval@ timerhandle@ ExTimerEnqueue ok!
end

fn OSTimerDequeue { timerhandle -- ok }
	timerhandle@ ExTimerDequeue ok!
end

fn OSTimerReadState { timerhandle -- signaled ok }
	timerhandle@ ExTimerReadState ok! signaled!
end