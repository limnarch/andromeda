//
// Implements the executive port object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/IPC.h"

#include "<ll>/OSDLL/OS.h"

fn (ObTypeOpenFunction) IPCPortObjectOpen { access object process -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (process@ object@ IPCPort_OwningProcess + @ ~=)
		STATUS_PERMISSION_DENIED ok!
	end
end

fn (ObTypeDeleteFunction) IPCPortObjectDelete { object -- }
	fnsection "PAGE$text"

	auto ok

	auto clienttable

	IPCGlobalLock drop

	if (object@ IPCPort_Flags + @ IPCPORTFLAG_CLIENT &)
		// it's a client, check if there's a server port still.

		if (object@ IPCPort_ServerPort + @)
			if (object@ IPCPort_Flags + @ IPCPORTFLAG_NO_DISCONNECT_MSG & ~~)
				// TODO send a disconnection message

			end

			// remove client ID from server's table

			object@ IPCPort_ServerPort + @ IPCPort_ClientTableHeader + @ clienttable!

			object@ IPCPort_ClientID + @ // handle
			clienttable@ // handletable
			0 // locked
			ExHandleDelete ok! drop drop

			if (DEBUGCHECKS)
				if (ok@)
					"IPCPortObjectDelete: failed to delete handle (%i)\n" KeCrash
				end
			end
		end
	end else
		object@ IPCPort_ClientTableHeader + @ clienttable!

		pointerof IPCPortHandleDestroyFunction // func
		clienttable@ // handletable
		ExHandleTableDelete

		object@ IPCPort_OwningProcess + @ ObObjectDereferenceByPointer drop
	end

	IPCGlobalUnlock

	// TODO deallocate all pending messages


end

fn (ExHandleEnumFunction) IPCPortHandleDestroyFunction { entryptr handle handletable -- ok }
	fnsection "PAGE$text"

	// TODO send disconnection messages to clients and clean up any pending
	// connections.
end

fn IPCPortCreateObject { serverport owningprocess permissions name -- portobject ok }
	fnsection "PAGE$text"

	name@ // name
	0 // flags
	permissions@ // permissions
	0 // npquotabias
	0 // pquotabias
	IPCPort_SIZEOF // bodysize
	IPCPortObjectType@ // type
	ObObjectCreate ok! portobject!

	if (ok@)
		return
	end

	0 portobject@ IPCPort_MessageListHead + !
	0 portobject@ IPCPort_MessageListTail + !

	0 portobject@ IPCPort_ReceiverListHead + !
	0 portobject@ IPCPort_ReceiverListTail + !

	0 portobject@ IPCPort_Flags + !

	0 portobject@ IPCPort_ServerContextForClient + !

	owningprocess@ portobject@ IPCPort_OwningProcess + !

	auto clienttable

	if (serverport@)
		// this is a client port.

		serverport@ portobject@ IPCPort_ServerPort + !
		0 portobject@ IPCPort_ClientTableHeader + !

		serverport@ IPCPort_ClientTableHeader + @ clienttable!

		auto clientid
		portobject@ // entryvalue
		clienttable@ // handletable
		0 // locked
		ExHandleCreate ok! drop clientid!

		if (ok@)
			portobject@ ObObjectDeallocate

			return
		end

		clientid@ portobject@ IPCPort_ClientID + !

		IPCPORTFLAG_CLIENT portobject@ IPCPort_Flags + |=
	end else
		// this IS a server port.

		0 portobject@ IPCPort_ServerPort + !

		owningprocess@ // chargedprocess
		0 // entrysizelog
		ExHandleTableCreate ok! clienttable!

		if (ok@)
			portobject@ ObObjectDeallocate

			return
		end

		owningprocess@ ObObjectReferenceByPointer drop

		clienttable@ portobject@ IPCPort_ClientTableHeader + !
	end
end