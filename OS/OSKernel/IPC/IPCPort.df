//
// Implements the executive port object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/IPC.h"

fn (ObTypeOpenFunction) IPCPortObjectOpen { access object process -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (process@ object@ IPCPort_OwningProcess + @ ~=)
		STATUS_PERMISSION_DENIED ok!
	end
end

fn (ObTypeDeleteFunction) IPCPortObjectDelete { object -- }
	fnsection "PAGE$text"

	auto ok

	auto clienttable

	IPCGlobalLock drop

	if (object@ IPCPort_Flags + @ IPCPORTFLAG_CLIENT &)
		// it's a client, check if there's a server port still.

		if (object@ IPCPort_ServerPort + @)
			if (object@ IPCPort_Flags + @ IPCPORTFLAG_UNFINISHED_CONNECTION & ~~)
				// TODO send a disconnection message

			end

			// remove client ID from server's table

			object@ IPCPort_ServerPort + @ IPCPort_ClientTableHeader + @ clienttable!

			object@ IPCPort_ClientID + @ // handle
			clienttable@ // handletable
			0 // locked
			ExHandleDelete ok! drop drop

			if (DEBUGCHECKS)
				if (ok@)
					"IPCPortObjectDelete: failed to delete handle (%i)\n" KeCrash
				end
			end
		end
	end else
		object@ IPCPort_ClientTableHeader + @ clienttable!

		pointerof IPCPortHandleDestroyFunction // func
		clienttable@ // handletable
		ExHandleTableDelete

		object@ IPCPort_OwningProcess + @ ObObjectDereferenceByPointer drop
	end

	IPCGlobalUnlock

	// TODO unlink all of my messages still out there in a queue

	// TODO orphan all of the pending messages in my queue

	// destroy my zone

	object@ IPCPort_ZoneHeader + MmZoneEmpty

	// uncharge quota for zone extensions

	if (object@ IPCPort_ZoneExtensionCharge + @)
		object@ IPCPort_ZoneExtensionCharge + @ // charge
		object@ ObObjectNonpagedHeader ObNonpagedHeader_QuotaBlock + @ // quotablock
		MmQuotaBlockUncharge
	end
end

fn (ExHandleEnumFunction) IPCPortHandleDestroyFunction { entryptr handle handletable -- ok }
	fnsection "PAGE$text"

	// TODO send disconnection messages to clients and clean up any pending
	// connections.
end

fn IPCPortCreateObject { maxlen serverport owningprocess permissions name -- portobject ok }
	fnsection "PAGE$text"

	if (maxlen@ 3 &)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	auto msgzonesize

	if (serverport@)
		serverport@ IPCPort_MaximumMessageBody + @ maxlen!

		IPCKernelMessage_SIZEOF maxlen@ +
		IPCINITIALMESSAGES_CLIENT *
		MMZONEOVERHEAD + msgzonesize!
	end else
		IPCKernelMessage_SIZEOF maxlen@ +
		IPCINITIALMESSAGES_SERVER *
		MMZONEOVERHEAD + msgzonesize!
	end

	name@ // name
	0 // flags
	permissions@ // permissions
	msgzonesize@ MmChargeBytesGet // npquotabias
	0 // pquotabias
	IPCPort_SIZEOF // bodysize
	IPCPortObjectType@ // type
	ObObjectCreate ok! portobject!

	if (ok@)
		return
	end

	0 portobject@ IPCPort_MessageListHead + !
	0 portobject@ IPCPort_MessageListTail + !

	0 portobject@ IPCPort_SentListHead + !
	0 portobject@ IPCPort_SentListTail + !

	0 portobject@ IPCPort_WaiterListHead + !
	0 portobject@ IPCPort_WaiterListTail + !

	0 portobject@ IPCPort_Flags + !

	0 portobject@ IPCPort_ServerContextForClient + !

	OSPORT_CONID_FIRSTDYNAMIC portobject@ IPCPort_NextConversationID + !

	owningprocess@ portobject@ IPCPort_OwningProcess + !

	0 portobject@ IPCPort_ZoneExtensionCharge + !

	auto chunk
	msgzonesize@ // bytes
	'PoZn' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! chunk!

	if (ok@)
		portobject@ ObObjectDeallocate

		return
	end

	msgzonesize@ // bytes
	chunk@ // chunk
	IPCKernelMessage_SIZEOF maxlen@ + // blocksize
	portobject@ IPCPort_ZoneHeader + // zoneheader
	MmZoneInitialize

	auto clienttable

	if (serverport@)
		// this is a client port.

		serverport@ portobject@ IPCPort_ServerPort + !
		0 portobject@ IPCPort_ClientTableHeader + !

		serverport@ IPCPort_ClientTableHeader + @ clienttable!

		auto clientid
		portobject@ // entryvalue
		clienttable@ // handletable
		0 // locked
		ExHandleCreate ok! drop clientid!

		if (ok@)
			chunk@ MmFree

			portobject@ ObObjectDeallocate

			return
		end

		clientid@ portobject@ IPCPort_ClientID + !

		IPCPORTFLAG_CLIENT portobject@ IPCPort_Flags + |=
		IPCPORTFLAG_UNFINISHED_CONNECTION portobject@ IPCPort_Flags + |=
	end else
		// this IS a server port.

		0 portobject@ IPCPort_ServerPort + !

		portobject@ // context
		owningprocess@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ // quotablock
		0 // entrysizelog
		ExHandleTableCreate ok! clienttable!

		if (ok@)
			chunk@ MmFree

			portobject@ ObObjectDeallocate

			return
		end

		owningprocess@ ObObjectReferenceByPointer drop

		clienttable@ portobject@ IPCPort_ClientTableHeader + !
	end

	maxlen@ portobject@ IPCPort_MaximumMessageBody + !
end

fn IPCPortWakeWaiter { rxmsg waiter portobject -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IPCPortWakeWaiter: ipl != IPLDPC\n" KeCrash
		end
	end

	// store message pointer

	rxmsg@ waiter@ IPCThreadBlock_RXMessage + !

	// dequeue waiter

	auto ls
	auto ns

	waiter@ IPCThreadBlock_WaiterPrev + @ ls!
	waiter@ IPCThreadBlock_WaiterNext + @ ns!

	if (ls@)
		ns@ ls@ IPCThreadBlock_WaiterNext + !
	end else
		ns@ portobject@ IPCPort_WaiterListHead + !
	end

	if (ns@)
		ls@ ns@ IPCThreadBlock_WaiterPrev + !
	end else
		ls@ portobject@ IPCPort_WaiterListTail + !
	end

	// signal event

	IPCBOOST // priboost
	waiter@ IPCThreadBlock_Event + // event
	KeEventSignal
end

fn IPCPortEnqueueMessage { msg portobject -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IPCPortEnqueueMessage: ipl != IPLDPC\n" KeCrash
		end
	end

	// add the message to the queue for the port object.
	// if there are any waiters with a matching conversation ID, wake them.
	// if the message type is OSPORT_MESSAGE_REPLY, the message can only go to
	// someone waiting on that specific conversation ID. if it is any other,
	// the message can only go to someone waiting on any message.
	//
	// caller should have verified that the destination port is connected to
	// the source port. client source does this by grabbing ServerPort
	// atomically with enqueuing the message. server source does this by
	// carefully checking the client port's pointer count in a similar manner
	// to how referencing a process by PID works. this must be atomic with
	// calling this function i.e. IPL is raised to IPLDPC for the duration of
	// the check and the operation of this function. IPL sync is used instead
	// of a mutex because it is anticipated that DPCs will need to enqueue IPC
	// messages; additionally IPL sync comes with a shorter codepath.

	// wake up waiter

	auto conid
	msg@ IPCKernelMessage_Header + OSMessageHeader_ConversationID + @ conid!

	auto msgtype
	msg@ IPCKernelMessage_Header + OSMessageHeader_TypeB + gb msgtype!

	auto waiter
	portobject@ IPCPort_WaiterListHead + @ waiter!

	while (waiter@)
		auto wake
		0 wake!

		if (msgtype@ OSPORT_MESSAGE_REPLY ==)
			if (waiter@ IPCThreadBlock_WaitingConversationID + @ conid@ ==)
				1 wake!
			end
		end else
			if (waiter@ IPCThreadBlock_WaitingConversationID + @ OSPORT_CONID_ANY ==)
				1 wake!
			end
		end

		if (wake@)
			msg@ // rxmsg
			waiter@ // waiter
			portobject@ // portobject
			IPCPortWakeWaiter

			return
		end

		waiter@ IPCThreadBlock_WaiterNext + @ waiter!
	end

	// no waiters right now, add message to message queue

	auto t
	portobject@ IPCPort_MessageListTail + @ t!

	t@ msg@ IPCKernelMessage_QueuePrev + !

	if (t@ ~~)
		msg@ portobject@ IPCPort_MessageListHead + !
	end else
		msg@ t@ IPCKernelMessage_QueueNext + !
	end

	msg@ portobject@ IPCPort_MessageListTail + !

	// add message to port rundown queue

	auto msgport
	msg@ IPCKernelMessage_OriginatingPort + @ msgport!

	msgport@ IPCPort_SentListTail + @ t!

	t@ msg@ IPCKernelMessage_PortPrev + !

	if (t@ ~~)
		msg@ msgport@ IPCPort_SentListHead + !
	end else
		msg@ t@ IPCKernelMessage_PortNext + !
	end

	msg@ msgport@ IPCPort_SentListTail + !
end