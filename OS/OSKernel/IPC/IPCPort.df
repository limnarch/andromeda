//
// Implements the executive port object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/IPC.h"

fn (ObTypeOpenFunction) IPCPortObjectOpen { access object process -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (process@ object@ IPCPort_OwningProcess + @ ~=)
		STATUS_PERMISSION_DENIED ok!
	end
end

fn (ObTypeDeleteFunction) IPCPortObjectDelete { object -- }
	fnsection "PAGE$text"

	auto ok

	auto clienttable

	IPCGlobalLock drop

	if (object@ IPCPort_Flags + @ IPCPORTFLAG_CLIENT &)
		// it's a client, check if there's a server port still.

		if (object@ IPCPort_ServerPort + @)
			if (object@ IPCPort_Flags + @ IPCPORTFLAG_UNFINISHED_CONNECTION & ~~)
				// TODO send a disconnection message

			end

			// remove client ID from server's table

			object@ IPCPort_ServerPort + @ IPCPort_ClientTableHeader + @ clienttable!

			object@ IPCPort_ClientID + @ // handle
			clienttable@ // handletable
			0 // locked
			ExHandleDelete ok! drop drop

			if (DEBUGCHECKS)
				if (ok@)
					"IPCPortObjectDelete: failed to delete handle (%i)\n" KeCrash
				end
			end
		end
	end else
		object@ IPCPort_ClientTableHeader + @ clienttable!

		pointerof IPCPortHandleDestroyFunction // func
		clienttable@ // handletable
		ExHandleTableDelete

		object@ IPCPort_OwningProcess + @ ObObjectDereferenceByPointer drop
	end

	IPCGlobalUnlock

	// TODO unlink all of my messages still out there in a queue

	// TODO orphan all of the pending messages in my queue

	// destroy my zone

	object@ IPCPort_ZoneHeader + MmZoneEmpty

	// uncharge quota for zone extensions

	if (object@ IPCPort_ZoneExtensionCharge + @)
		object@ IPCPort_ZoneExtensionCharge + @ // charge
		object@ ObObjectNonpagedHeader ObNonpagedHeader_QuotaBlock + @ // quotablock
		MmQuotaBlockUncharge
	end
end

fn (ExHandleEnumFunction) IPCPortHandleDestroyFunction { entryptr handle handletable -- ok }
	fnsection "PAGE$text"

	// TODO send disconnection messages to clients and clean up any pending
	// connections.
end

fn IPCPortCreateObject { maxlen serverport owningprocess permissions name -- portobject ok }
	fnsection "PAGE$text"

	if (maxlen@ 3 &)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	auto msgzonesize

	if (serverport@)
		serverport@ IPCPort_MaximumMessageBody + @ maxlen!

		IPCKernelMessage_SIZEOF maxlen@ +
		IPCINITIALMESSAGES_CLIENT *
		MMZONEOVERHEAD + msgzonesize!
	end else
		IPCKernelMessage_SIZEOF maxlen@ +
		IPCINITIALMESSAGES_SERVER *
		MMZONEOVERHEAD + msgzonesize!
	end

	name@ // name
	0 // flags
	permissions@ // permissions
	msgzonesize@ MmChargeBytesGet // npquotabias
	0 // pquotabias
	IPCPort_SIZEOF // bodysize
	IPCPortObjectType@ // type
	ObObjectCreate ok! portobject!

	if (ok@)
		return
	end

	0 portobject@ IPCPort_MessageListHead + !
	0 portobject@ IPCPort_MessageListTail + !

	0 portobject@ IPCPort_SentListHead + !
	0 portobject@ IPCPort_SentListTail + !

	0 portobject@ IPCPort_WaiterListHead + !
	0 portobject@ IPCPort_WaiterListTail + !

	0 portobject@ IPCPort_Flags + !

	0 portobject@ IPCPort_ServerContextForClient + !

	OSPORT_CONID_FIRSTDYNAMIC portobject@ IPCPort_NextConversationID + !

	owningprocess@ portobject@ IPCPort_OwningProcess + !

	0 portobject@ IPCPort_ZoneExtensionCharge + !

	auto chunk
	msgzonesize@ // bytes
	'PoZn' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! chunk!

	if (ok@)
		portobject@ ObObjectDeallocate

		return
	end

	msgzonesize@ // bytes
	chunk@ // chunk
	IPCKernelMessage_SIZEOF maxlen@ + // blocksize
	portobject@ IPCPort_ZoneHeader + // zoneheader
	MmZoneInitialize

	auto clienttable

	if (serverport@)
		// this is a client port.

		serverport@ portobject@ IPCPort_ServerPort + !
		0 portobject@ IPCPort_ClientTableHeader + !

		serverport@ IPCPort_ClientTableHeader + @ clienttable!

		auto clientid
		portobject@ // entryvalue
		clienttable@ // handletable
		0 // locked
		ExHandleCreate ok! drop clientid!

		if (ok@)
			chunk@ MmFree

			portobject@ ObObjectDeallocate

			return
		end

		clientid@ portobject@ IPCPort_ClientID + !

		IPCPORTFLAG_CLIENT portobject@ IPCPort_Flags + |=
		IPCPORTFLAG_UNFINISHED_CONNECTION portobject@ IPCPort_Flags + |=
	end else
		// this IS a server port.

		0 portobject@ IPCPort_ServerPort + !

		portobject@ // context
		owningprocess@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ // quotablock
		0 // entrysizelog
		ExHandleTableCreate ok! clienttable!

		if (ok@)
			chunk@ MmFree

			portobject@ ObObjectDeallocate

			return
		end

		owningprocess@ ObObjectReferenceByPointer drop

		clienttable@ portobject@ IPCPort_ClientTableHeader + !
	end

	maxlen@ portobject@ IPCPort_MaximumMessageBody + !
end

fn IPCPortWakeWaiter { rxmsg waiter portobject -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IPCPortWakeWaiter: ipl != IPLDPC\n" KeCrash
		end
	end

	// store message pointer

	rxmsg@ waiter@ IPCThreadBlock_RXMessage + !
	waiter@ IPCThreadBlock_RXMessage + rxmsg@ IPCKernelMessage_RundownPointer + !

	// dequeue waiter

	waiter@ // waiter
	portobject@ // portobject
	IPCPortWaiterDequeue

	// signal event

	IPCBOOST // priboost
	waiter@ IPCThreadBlock_Event + // event
	KeEventSignal
end

fn IPCPortSendMessage { msg portobject -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IPCPortEnqueueMessage: ipl != IPLDPC\n" KeCrash
		end
	end

	// add the message to the queue for the port object.
	// if there are any waiters with a matching conversation ID, wake them.
	// if the message type is OSPORT_MESSAGE_REPLY, the message can only go to
	// someone waiting on that specific conversation ID. if it is any other,
	// the message can only go to someone waiting on any message.
	//
	// caller should have verified that the destination port is connected to
	// the source port. client source does this by grabbing ServerPort
	// atomically with enqueuing the message. server source does this by
	// carefully checking the client port's pointer count in a similar manner
	// to how referencing a process by PID works. this must be atomic with
	// calling this function i.e. IPL is raised to IPLDPC for the duration of
	// the check and the operation of this function. IPL sync is used instead
	// of a mutex because it is anticipated that DPCs will need to enqueue IPC
	// messages; additionally IPL sync comes with a shorter codepath.

	msg@ IPCMessageEnqueueRundown

	// wake up waiter

	auto conid
	msg@ IPCKernelMessage_Header + OSMessageHeader_ConversationID + @ conid!

	auto msgtype
	msg@ IPCKernelMessage_Header + OSMessageHeader_TypeB + gb msgtype!

	auto waiter
	portobject@ IPCPort_WaiterListHead + @ waiter!

	while (waiter@)
		auto wake
		0 wake!

		if (msgtype@ OSPORT_MESSAGE_REPLY ==)
			if (waiter@ IPCThreadBlock_WaitingConversationID + @ conid@ ==)
				1 wake!
			end
		end else
			if (waiter@ IPCThreadBlock_WaitingConversationID + @ OSPORT_CONID_ANY ==)
				1 wake!
			end
		end

		if (wake@)
			msg@ // rxmsg
			waiter@ // waiter
			portobject@ // portobject
			IPCPortWakeWaiter

			return
		end

		waiter@ IPCThreadBlock_WaiterNext + @ waiter!
	end

	msg@ // msg
	portobject@ // portobject
	IPCMessageEnqueue
end

fn IPCPortReceiveMessage { umsg mode conid timeout portobject -- ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IPCPortReceiveMessage: ipl != IPLDPC\n" KeCrash
		end
	end

	// entered at IPLDPC, leaves at IPLLOW

	auto msg
	portobject@ IPCPort_MessageListHead + @ msg!

	while (msg@)
		auto found
		0 found!

		if (conid@ OSPORT_CONID_ANY ==)
			if (msg@ IPCKernelMessage_Header + OSMessageHeader_TypeB + gb OSPORT_MESSAGE_REPLY ~=)
				1 found!
			end
		end elseif (msg@ IPCKernelMessage_Header + OSMessageHeader_TypeB + gb OSPORT_MESSAGE_REPLY ==)
			if (msg@ IPCKernelMessage_Header + OSMessageHeader_ConversationID + @ conid@ ==)
				1 found!
			end
		end

		if (found@)
			// dequeue message

			msg@ // msg
			portobject@ // portobject
			IPCMessageDequeue

			break
		end

		msg@ IPCKernelMessage_QueueNext + @ msg!
	end

	if (msg@ ~~)
		// no matching message

		if (timeout@ ~~)
			// nonblocking

			IPLLOW KeIPLLower

			STATUS_NO_MESSAGE ok!

			return
		end

		// build & enqueue a waiter block

		auto waiter
		KeThreadCurrent@ PsThread_IPCBlock + @ waiter!

		if (DEBUGCHECKS)
			if (waiter@ ~~)
				"IPCPortReceiveMessage: no ipcblock\n" KeCrash
			end
		end

		conid@ waiter@ IPCThreadBlock_WaitingConversationID + !
		0 waiter@ IPCThreadBlock_RXMessage + !

		0 waiter@ IPCThreadBlock_WaiterNext + !

		waiter@ // waiter
		portobject@ // portobject
		IPCPortWaiterEnqueue

		// NOTE: event should already be initialized and cleared

		IPLLOW KeIPLLower

		mode@ // waitmode
		1 // alertable
		timeout@ // timeout
		waiter@ IPCThreadBlock_Event + // object
		KeThreadWaitForObject ok!

		IPLDPC KeIPLRaise drop

		waiter@ IPCThreadBlock_RXMessage + @ msg!

		if (msg@ ~~)
			// we were awoken before the message could be received.
			// our waiter block is still enqueued so remove it.

			waiter@ // waiter
			portobject@ // portobject
			IPCPortWaiterDequeue

			IPLLOW KeIPLLower

			return
		end elseif (msg@ -1 ==)
			// the other port disconnected. our waiter block is not enqueued,
			// do not remove it.

			IPLLOW KeIPLLower

			STATUS_PORT_DISCONNECTED ok!

			return
		end

		// the message was received successfully.
		// ignore any status code we got from waiting on the event.

		0 ok!
	end

	// process the message at IPLDPC

	auto msgport
	msg@ IPCKernelMessage_OriginatingPort + @ msgport!

	if (msgport@ ObObjectNonpagedHeader ObNonpagedHeader_PointerCount + @ ~~)
		// port is being deleted but hadn't gotten to this message yet.

		0 msg@ IPCKernelMessage_RundownPointer + !

		IPLLOW KeIPLLower

		STATUS_PORT_DISCONNECTED ok!

		return
	end

	// remove this message from rundown list since its in our custody now

	msg@ IPCMessageDequeueRundown

	// reference port object to stop it from dropping out from under us now

	msgport@ ObObjectReferenceByPointer drop

	// reference any passed object

	auto object
	msg@ IPCKernelMessage_Object + @ object!

	if (object@)
		object@ ObObjectReferenceByPointer drop
		0 object@ IPCKernelMessage_Object + !
	end

	IPLLOW KeIPLLower

	if (object@)
		// open object in our handle table and save the handle in the message

		1 // nocheck
		msg@ IPCKernelMessage_Header + OSMessageHeader_Access + @ // access
		object@ // object
		KeProcessCurrent // process
		ObObjectOpenProcess ok! object!

		object@ msg@ IPCKernelMessage_Header + OSMessageHeader_Handle + !

		if (ok@)
			// failed to open the object
			object@ ObObjectDereferenceByPointer drop
		end
	end

	if (ok@ ~~)
		// opening the object worked, copy contents

		if (mode@ USERMODE ==)
			umsg@ // dest
			msg@ IPCKernelMessage_Header + // src
			msg@ IPCKernelMessage_Header + OSMessageHeader_LengthI + gi OSMessageHeader_SIZEOF + // sz
			KeSafeCopyOut ok!
		end else
			umsg@ // dest
			msg@ IPCKernelMessage_Header + // src
			msg@ IPCKernelMessage_Header + OSMessageHeader_LengthI + gi OSMessageHeader_SIZEOF + // sz
			memcpy
		end
	end

	if (object@ ~~)
		// free to message zone. don't free if there's a passed object because
		// the synchronous IPC call will free the message instead.

		msg@ IPCMessageFree
	end

	// dereference message port

	msgport@ ObObjectDereferenceByPointer drop
end

fn IPCPortWaiterEnqueue { waiter portobject -- }
	auto t
	portobject@ IPCPort_WaiterListTail + @ t!

	t@ waiter@ IPCThreadBlock_WaiterPrev + !

	if (t@ ~~)
		waiter@ portobject@ IPCPort_WaiterListHead + !
	end else
		waiter@ t@ IPCThreadBlock_WaiterNext + !
	end

	waiter@ portobject@ IPCPort_WaiterListTail + !
end

fn IPCPortWaiterDequeue { waiter portobject -- }
	auto ls
	auto ns

	waiter@ IPCThreadBlock_WaiterPrev + @ ls!
	waiter@ IPCThreadBlock_WaiterNext + @ ns!

	if (ls@)
		ns@ ls@ IPCThreadBlock_WaiterNext + !
	end else
		ns@ portobject@ IPCPort_WaiterListHead + !
	end

	if (ns@)
		ls@ ns@ IPCThreadBlock_WaiterPrev + !
	end else
		ls@ portobject@ IPCPort_WaiterListTail + !
	end
end