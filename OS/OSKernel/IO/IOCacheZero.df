//
// Implements efficient zeroing of newly allocated file space.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

const IOCACHEZEROMAX (512 1024 * PAGESHIFT >>)

fn IOCacheZeroData { size offset flags fcb -- ok }
	fnsection "PAGE$text"

	// zeroes the specified range in the FCB. intended for use in efficiently
	// zeroing new file allocations.
	//
	// if there are plentiful pages, it is done directly in the page cache by
	// allocating zeroed pages for the range and marking them as modified.
	// if the range is too large, or the file is uncached, the zeroes are
	// written by direct (uncached) I/O to the driver.
	//
	// expects the FCB to be locked.

	auto pagestozero
	offset@ PAGEOFFSETMASK & size@ + PAGEOFFSETMASK + PAGESHIFT >> pagestozero!

	if (flags@ OSFILEFLAG_NOCACHE & ~~)
		if (fcb@ IOFileControlBlock_CacheInfoBlock + @)
			if (pagestozero@ IOCACHEZEROMAX <=)
				if (MmPageFreeCount@ MmEvictablePageCount@ + pagestozero@ + MmPageFreeCountSufficient@ >=)
					// sufficient resources to zero in the cache

					size@ // size
					offset@ // offset
					fcb@ // fcb
					IOCacheZeroInCache ok!

					if (ok@ ~~)
						return
					end
				end
			end
		end
	end

	size@ // size
	offset@ // offset
	fcb@ // fcb
	IOCacheZeroDirectIO ok!
end

fn IOCacheZeroDirectIO { size offset fcb -- ok }
	fnsection "PAGE$text"

	// use direct IO with our funky constant zero page to obliterate the
	// specified range.

	KeThreadCurrent@ KeThreadIgnoreKill drop

	auto mdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	// initialize all the MDL page frames to point to the zero page.

	auto event
	KeEvent_SIZEOF alloc event!

	auto pagecount
	IOTRANSFERMAX PAGESHIFT >> pagecount!

	while (pagecount@)
		MmConstantZeroPage@ mdlpos@!

		4 mdlpos +=
		1 pagecount -=
	end

	-1 mdlpos@!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	while (size@ IOTRANSFERMAX >=)
		KeThreadCurrent@ KeThreadAcceptKill drop

		KERNELMODE // mode
		1 // alertable
		KeThreadCurrent@ // thread
		KeThreadIsKilled ok!

		KeThreadCurrent@ KeThreadIgnoreKill drop

		if (ok@)
			0 size!
			break
		end

		0 // signaled
		OSEVENT_NOTIF // type
		"IOCacheZeroEvent" // name
		event@ // event
		KeEventInitialize

		KERNELMODE // mode
		IOTRANSFERMAX // length
		offset@ PAGEOFFSETMASK & // vaddr
		mdl@ // mdl
		MmMDLInitialize

		MMMDL_DONTUNPIN MMMDL_PINNED | mdl@ MmMDLHeader_Flags + |=
		event@ mdl@ MmMDLHeader_Event + !

		0 // flags
		IOKFLAG_URGENT // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		writefunc@ IODispatchWriteFunction ok!

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@)
			0 size!
			break
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			0 size!
			break
		end

		IOTRANSFERMAX offset +=
		IOTRANSFERMAX size -=
	end

	if (size@)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOCacheZeroEvent" // name
		event@ // event
		KeEventInitialize

		KERNELMODE // mode
		size@ // length
		offset@ PAGEOFFSETMASK & // vaddr
		mdl@ // mdl
		MmMDLInitialize

		MMMDL_DONTUNPIN MMMDL_PINNED | mdl@ MmMDLHeader_Flags + |=
		event@ mdl@ MmMDLHeader_Event + !

		0 // flags
		IOKFLAG_URGENT // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		writefunc@ IODispatchWriteFunction ok!

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@ ~~)
			mdl@ MmMDLHeader_Status + @ ok!
		end
	end

	KeThreadCurrent@ KeThreadAcceptKill drop
end

fn IOCacheZeroInCache { size offset fcb -- ok }
	fnsection "PAGE$text"

	0 ok!

	KeThreadCurrent@ KeThreadIgnoreKill drop

	auto pagestozero
	offset@ PAGEOFFSETMASK & size@ + PAGEOFFSETMASK + PAGESHIFT >> pagestozero!

	while (pagestozero@)
		MmThrottle

		auto pfdbe
		0 // localpteaddr
		0 // iointent
		IOKFLAG_ZEROES IOKFLAG_URGENT | // kflags
		offset@ PAGENUMBERMASK & // offset
		fcb@ // fcb
		IOCachePageGet ok! pfdbe! drop

		if (ok@)
			KeThreadCurrent@ KeThreadAcceptKill drop
			return
		end

		pfdbe@ // pfdbe
		KeProcessCurrent // process
		MmEvictablePageModify

		pfdbe@ MmEvictablePageDereference drop

		1 pagestozero -=
		PAGESIZE offset +=
	end

	KeThreadCurrent@ KeThreadAcceptKill drop
end