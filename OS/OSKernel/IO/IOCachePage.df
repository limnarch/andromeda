//
// Implements management routines and eviction for filestream pages.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Transfer.h"

#include "<ll>/OSDLL/OS.h"

var IOCachePagesUsed 0
public IOCachePagesUsed

fn IOCachePageGet { process iointent kflags offset fcb -- pageframe pfdbe ok }
	// if localpteaddr is set, we must enter and leave at IPLDPC.

	if (DEBUGCHECKS)
		if (offset@ PAGEOFFSETMASK &)
			"IOCachePageGet: offset wasn't page-aligned\n" KeCrash
		end
	end

	0 ok!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto filesize
	fcb@ IOFileControlBlock_SizeInBytes + @ filesize!

	if (DEBUGCHECKS)
		if (offset@ filesize@ >=)
			"IOCachePageGet: offset was beyond end of file\n" KeCrash
		end
	end

	auto pri
	CANBLOCK pri!

	kflags@ MmKflagToPriority pri |=

	auto ipl

	if (process@ ~~)
		IPLDPC KeIPLRaise ipl!

		0 // process
		pri@ // priority
		MmPageWait ok! drop

		if (ok@)
			ipl@ KeIPLLower

			return
		end
	end

	auto lastnode
	offset@ // value
	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + // rootptr
	ExSplayTreeFindNodeByValue pfdbe! lastnode!

	if (pfdbe@)
		IOPageFrameEntryCache_Parent pfdbe -=

		// found the page, it was in the cache already!

		// ref it so it doesn't get evicted while caller is using it

		pfdbe@ MmEvictablePageReference drop

		pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!

		while (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb
			MMEVICTFLAG_VALID MMEVICTFLAG_IOINPROGRESS | & MMEVICTFLAG_IOINPROGRESS ==)
			// this page is in transition. wait for the I/O to complete.

			// XXX there was a race condition here where when a page read
			// failed and left the page invalid but satisfied, the wait here
			// would be satisfied but then it wouldn't set the IOINPROGRESS
			// flag because it was written as an if elseif. these kinds of
			// subtle bugs are extremely important to be vigilant for...

			process@ // process
			pri@ // pri
			pfdbe@ // pfdbe
			MmEvictablePageWait ok!

			if (ok@)
				pfdbe@ MmEvictablePageDereference drop
				break
			end elseif (process@)
				pfdbe@ MmEvictablePageDereference drop
				STATUS_REFAULT ok!
				return
			end
		end

		if (ok@ ~~)
			if (iointent@)
				if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID & ~~)
					pfdbe@ MmEvictablePageStartIO
				end
			end
		end

		if (process@ ~~)
			ipl@ KeIPLLower
		end

		return
	end

	// not in the cache -- allocate a page for it.

	if (MmPageFreeListHead@ ~~)
		if (MmPageZeroListHead@ ~~)
			// can't use this hint since it might get reclaimed.
			
			// XXX this won't be synchronized properly in SMP unless we hold a
			// big PFDB spinlock this entire time.

			0 lastnode!
		end
	end

	auto zeroes
	filesize@ offset@ - PAGESIZE <
	kflags@ IOKFLAG_ZEROES & || zeroes!

	if (zeroes@)
		ZEROMUST pri |=
	end else
		FREEFIRST pri |=
	end

	MMEVICTFLAG_WORKINGSET // flags
	MMEVICTTYPE_FILE // evictablefuncs
	pri@ // priority
	MmEvictablePageGet ok! drop pfdbe!

	if (iointent@)
		pfdbe@ MmEvictablePageStartIO
	end

	if (ok@)
		if (process@ ~~)
			ipl@ KeIPLLower
		end

		if (pri@ TRYFOREVER &)
			// we needed this page for a swapout, system detonates.
			// this flag is also used for certain other situations
			// where an IO operation must succeed.
			"IOCachePageGet: failed to allocate page needed for swapout!\n" KeCrash
		end

		return
	end

	offset@ pfdbe@ IOPageFrameEntryCache_OffsetInFile + !
	fcb@ pfdbe@ IOPageFrameEntryCache_FCB + !

	1 IOCachePagesUsed +=

	lastnode@ // insertat
	pfdbe@ IOPageFrameEntryCache_Parent + // node
	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + // rootptr
	ExSplayTreeInsert

	if (process@ ~~)
		ipl@ KeIPLLower
	end

	// no need to ref the page -- it gets ref'd on allocation by MmEvictablePageAlloc

	pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!
end

fn (MmEvictionFunction) IOCachePageEvictionFunction { pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageEvictionFunction: no cacheblock\n" KeCrash
		end
	end

	// remove from splay tree
	
	pfdbe@ IOPageFrameEntryCache_Parent + // node
	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + // rootptr
	ExSplayTreeRemove

	1 IOCachePagesUsed -=
end

fn IOCachePageWrite { transfer kflags pfdbe -- ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IOCachePageWrite: ipl != IPLDPC\n" KeCrash
		end
	end

	// assumes caller referenced the page.
	// will cluster pages that it finds are in order.

	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto mdl

	if (transfer@ ~~)
		MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!
	end else
		transfer@ mdl!
	end

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto pagecount
	0 pagecount!

	while (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
		0 // process
		kflags@ MmKflagToPriority // pri
		pfdbe@ // pfdbe
		MmEvictablePageWait ok!

		if (ok@)
			if (transfer@)
				transfer@ IOTransferComplete
			end

			return
		end
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		if (transfer@)
			transfer@ IOTransferComplete
		end
	
		return
	end

	auto off
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

	// search backward for more modified pages
	while (pagecount@ IOTRANSFERMAX PAGESHIFT >> 1 - <)
		if (off@ ~~)
			break
		end

		auto spfdbe
		pfdbe@ IOPageFrameEntryCache_Parent + // node
		ExSplayTreeNodePrevious spfdbe!

		if (spfdbe@ ~~)
			break
		end

		IOPageFrameEntryCache_Parent spfdbe -=

		if (spfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
			break
		end

		if (spfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
			break
		end

		if (spfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off@ PAGESIZE - ~=)
			break
		end

		spfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!
		spfdbe@ pfdbe!

		1 pagecount +=
	end

	0 pagecount!

	auto startoffset
	off@ startoffset!
	-1 off!

	// now go forward to build the MDL
	while (pagecount@ IOTRANSFERMAX PAGESHIFT >> <)
		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
			break
		end

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
			break
		end

		if (off@ -1 ~=)
			if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off@ PAGESIZE + ~=)
				break
			end
		end

		pfdbe@ MmEvictablePageReference drop

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ & MMEVICTFLAG_IOINPROGRESS |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		0 pfdbe@ IOPageFrameEntryCache_Event + !

		pfdbe@ mdlpos@!

		pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

		4 mdlpos +=
		1 pagecount +=

		pfdbe@ IOPageFrameEntryCache_Parent + // node
		ExSplayTreeNodeNext pfdbe!

		if (pfdbe@ ~~)
			break
		end

		IOPageFrameEntryCache_Parent pfdbe -=
	end

	if (pagecount@ ~~)
		// no pages to write...

		if (transfer@)
			transfer@ IOTransferComplete
		end

		0 ok!
		return
	end

	IPLLOW KeIPLLower

	-1 mdlpos@!

	0 // fileobject
	KERNELMODE // mode
	pagecount@ PAGESHIFT << // length
	0 // vaddr
	mdl@ // mdl
	MmMDLInitialize

	if (transfer@ ~~)
		auto event
		KeEvent_SIZEOF alloc event!

		0 // signaled
		OSEVENT_NOTIF // type
		"IOCachePageWriteEvent" // name
		event@ // event
		KeEventInitialize

		event@ mdl@ MmMDLHeader_Event + !
	end else
		pointerof IOCachePageMDLComplete mdl@ MmMDLHeader_CompleteRoutine + !
	end

	MMMDL_DONTUNPIN MMMDL_PINNED | mdl@ MmMDLHeader_Flags + |=

	transfer@ mdl@ MmMDLHeader_Context1 + !

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	KeThreadCurrent@ KeThreadIgnoreKill drop

	0 // flags
	kflags@ // kflags
	startoffset@ // offset
	mdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok!

	if (ok@)
		// complete the MDL so we can wait for any fragments to finish

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end

	if (transfer@ ~~)
		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@ ~~)
			mdl@ MmMDLHeader_Status + @ ok!
		end
	end

	KeThreadCurrent@ KeThreadAcceptKill drop

	IPLDPC KeIPLRaise drop

	if (transfer@ ~~)
		mdl@ IOCachePageMDLComplete
	end
end

fn (MmMDLCompleteRoutine) IOCachePageMDLComplete { mdl -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto status
	mdl@ MmMDLHeader_Status + @ status!

	if (status@)
		// TODO pop-up window or something
		status@ "IO error while writing unsaved data (%i)\n" Printf
	end

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto pagecount
	mdl@ MmMDLHeader_Pages + @ pagecount!

	while (pagecount@)
		auto pfdbe
		mdlpos@@ pfdbe!

		if (status@)
			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED |
			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
		end

		pfdbe@ MmEvictablePageSatisfy
		pfdbe@ MmEvictablePageDereference drop

		1 pagecount -=
		4 mdlpos +=
	end

	if (mdl@ MmMDLHeader_Context1 + @)
		mdl@ MmMDLHeader_Context1 + @ IOTransferComplete
	end

	ipl@ KeIPLLower
end

fn IOCachePageRead { localpteaddr flags kflags offset fcb -- pageframe pfdbe ok }
	// if localpteaddr is set, we must enter and leave at IPLDPC.

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageRead: attempt to perform cached page read from noncached file\n" KeCrash
		end
	end

	auto process

	if (localpteaddr@ ~~)
		0 process!
	end elseif (kflags@ IOKFLAG_SWAPIN &)
		PsSystemProcess@ process!
	end else
		KeProcessCurrent process!
	end

	process@ // process
	1 // iointent
	kflags@ // kflags
	offset@ // offset
	fcb@ // fcb
	IOCachePageGet ok! pfdbe! pageframe!

	if (ok@)
		return
	end

	auto rs

	auto ipl

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID & ~~)
		// this cache page is invalid and needs to be read in

		auto readfunc
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

		if (DEBUGCHECKS)
			if (readfunc@ ~~)
				"IOCachePageRead: no read function\n" KeCrash
			end
		end

		HALCPUInterruptDisable rs!

		if (kflags@ IOKFLAG_PAGEAC &)
			1 MmHardPageFaultCount +=
		end

		1 MmPageInCount +=

		rs@ HALCPUInterruptRestore

		auto capturedpte
		auto transitionpte

		if (localpteaddr@)
			localpteaddr@@ capturedpte!

			if (kflags@ IOKFLAG_SWAPIN &)
				// this is a kernel mapping
				pageframe@ IDENTITYSPACEMASK & PTE_TRANSITION | PTE_TLBHACK | transitionpte!
			end else
				pageframe@ IDENTITYSPACEMASK & PTE_TRANSITION | transitionpte!
			end

			transitionpte@ localpteaddr@!

			IPLLOW KeIPLLower

			process@ MmVADListUnlock
		end

		// perform the read operation

		auto event
		KeEvent_SIZEOF alloc event!

		0 // signaled
		OSEVENT_NOTIF // type
		"IOCachePageReadEvent" // name
		event@ // event
		KeEventInitialize

		auto mdl
		MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

		0 // fileobject
		KERNELMODE // mode
		PAGESIZE // length
		pageframe@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		kflags@ IOKFLAG_PAGEIN | // kflags
		offset@ PAGENUMBERMASK & // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok!

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@ ~~)
			mdl@ MmMDLHeader_Status + @ ok!
		end

		if (process@)
			process@ MmVADListLock drop
		end

		IPLDPC KeIPLRaise ipl!

		pfdbe@ MmEvictablePageSatisfy

		if (ok@ ~~)
			// read succeeded, page is now valid

			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID |
			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

			if (localpteaddr@)
				if (localpteaddr@@ transitionpte@ ~=)
					// PTE was deleted.
					STATUS_REFAULT ok!
				end
			end
		end

		if (ok@)
			if (localpteaddr@)
				if (localpteaddr@@ transitionpte@ ==)
					capturedpte@ localpteaddr@!
				end
			end

			pfdbe@ MmEvictablePageDereference drop
		end

		if (localpteaddr@ ~~)
			ipl@ KeIPLLower
		end
	end elseif (kflags@ IOKFLAG_PAGEAC &)
		HALCPUInterruptDisable rs!
		1 MmSoftPageFaultCount +=
		rs@ HALCPUInterruptRestore
	end
end

fn IOCachePageModified { pfdbe -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_DELETED &)
		ipl@ KeIPLLower

		return
	end

	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto oldcount
	cacheblock@ IOCacheInfoBlock_ModifiedPageCount + @ oldcount!

	oldcount@ 1 + cacheblock@ IOCacheInfoBlock_ModifiedPageCount + !

	if (oldcount@ ~~)
		// add the cacheblock to the dirty list and enqueue the writebehind
		// timer.

		cacheblock@ IOCacheInfoBlockReference drop

		1 IOCacheInfoBlockDirtyCount +=

		auto t
		IOCacheInfoBlockDirtyListTail@ t!

		if (t@)
			cacheblock@ t@ IOCacheInfoBlock_Next + !
		end else
			cacheblock@ IOCacheInfoBlockDirtyListHead!
		end

		0 cacheblock@ IOCacheInfoBlock_Next + !
		t@ cacheblock@ IOCacheInfoBlock_Prev + !

		cacheblock@ IOCacheInfoBlockDirtyListTail!

		IOScheduleWritebehind
	end

	ipl@ KeIPLLower
end