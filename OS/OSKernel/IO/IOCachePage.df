//
// Implements management routines and eviction for filestream pages.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Transfer.h"

#include "<ll>/OSDLL/OS.h"

var IOCachePagesUsed 0
public IOCachePagesUsed

struct IOCachePageEvent
	KeEvent_SIZEOF Event
	4 References
endstruct

fn IOCachePageWait { pri pfdbe -- ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IOCachePageWait: ipl != IPLDPC\n" KeCrash
		end
	end

	// wait for IO to complete on a cache page.

	// entered at IPLDPC

	0 ok!

	auto eventblock
	pfdbe@ IOPageFrameEntryCache_Event + @ eventblock!

	if (eventblock@ ~~)
		// allocate an event block.
		// some odd but harmless interactions can happen here.

		IPLLOW KeIPLLower

		IOCachePageEvent_SIZEOF // bytes
		'IOCE' // tag
		pri@ // flags
		MmAllocWithTag ok! eventblock!

		IPLDPC KeIPLRaise drop

		if (ok@)
			return
		end

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS & ~~)
			// IO completed while doing that allocation, free our eventblock
			// and go home.

			eventblock@ MmFree
			return
		end

		if (pfdbe@ IOPageFrameEntryCache_Event + @)
			// awkward, someone allocated one while we were trying to.
			// free ours and use theirs.

			eventblock@ MmFree
			pfdbe@ IOPageFrameEntryCache_Event + @ eventblock!
		end else
			eventblock@ pfdbe@ IOPageFrameEntryCache_Event + !

			0 // signaled
			OSEVENT_NOTIF // type
			"IOCachePageWaitEvent" // name
			eventblock@ IOCachePageEvent_Event + // event
			KeEventInitialize

			0 eventblock@ IOCachePageEvent_References + !
		end
	end

	1 eventblock@ IOCachePageEvent_References + +=

	IPLLOW KeIPLLower

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	eventblock@ IOCachePageEvent_Event + // object
	KeThreadWaitForObject drop

	IPLDPC KeIPLRaise drop

	1 eventblock@ IOCachePageEvent_References + -=

	if (eventblock@ IOCachePageEvent_References + @ ~~)
		eventblock@ MmFree
	end
end

fn IOCachePageSatisfy { pfdbe -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IOCachePageSatisfy: ipl != IPLDPC \n" KeCrash
		end
	end

	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS ~ &
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

	auto eventblock
	pfdbe@ IOPageFrameEntryCache_Event + @ eventblock!

	if (eventblock@)
		0 // priboost
		eventblock@ IOCachePageEvent_Event + // event
		KeEventSignal
	end
end

fn IOCachePageGet { iointent kflags offset fcb -- pageframe pfdbe ok }
	if (DEBUGCHECKS)
		if (offset@ PAGEOFFSETMASK &)
			"IOCachePageGet: offset wasn't page-aligned\n" KeCrash
		end
	end

	0 ok!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto filesize
	fcb@ IOFileControlBlock_SizeInBytes + @ filesize!

	if (DEBUGCHECKS)
		if (offset@ filesize@ >=)
			"IOCachePageGet: offset was beyond end of file\n" KeCrash
		end
	end

	auto pri
	CANBLOCK pri!

	kflags@ MmKflagToPriority pri |=

	auto ipl
	IPLDPC KeIPLRaise ipl!

	pri@ MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower

		return
	end

	auto lastnode
	offset@ // value
	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + // rootptr
	ExSplayTreeFindNodeByValue pfdbe! lastnode!

	if (pfdbe@)
		IOPageFrameEntryCache_Parent pfdbe -=

		// found the page, it was in the cache already!

		// ref it so it doesn't get evicted while caller is using it

		pfdbe@ MmEvictablePageReference drop

		pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!

		while (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb
			MMEVICTFLAG_VALID MMEVICTFLAG_IOINPROGRESS | & MMEVICTFLAG_IOINPROGRESS ==)
			// XXX there was a race condition here where when a page read
			// failed and left the page invalid but satisfied, the wait here
			// would be satisfied but then it wouldn't set the IOINPROGRESS
			// flag because it was written as an if elseif. these kinds of
			// subtle bugs are extremely important to be vigilant for...

			pri@ pfdbe@ IOCachePageWait ok!

			if (ok@)
				pfdbe@ MmEvictablePageDereference drop
				break
			end
		end

		if (ok@ ~~)
			if (iointent@)
				if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID & ~~)
					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS |
					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

					0 pfdbe@ IOPageFrameEntryCache_Event + !
				end
			end
		end

		ipl@ KeIPLLower

		return
	end

	// not in the cache -- allocate a page for it.

	if (MmPageFreeListHead@ ~~)
		if (MmPageZeroListHead@ ~~)
			// can't use this hint since it might get reclaimed.
			
			// XXX this won't be synchronized properly in SMP unless we hold a
			// big PFDB spinlock this entire time.

			0 lastnode!
		end
	end

	auto zeroes
	filesize@ offset@ - PAGESIZE <
	kflags@ IOKFLAG_ZEROES & || zeroes!

	if (zeroes@)
		ZEROMUST pri |=
	end else
		FREEFIRST pri |=
	end

	MMEVICTFLAG_WORKINGSET // flags
	MMEVICTTYPE_FILE // evictablefuncs
	pri@ // priority
	MmEvictablePageGet ok! drop pfdbe!

	if (iointent@)
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		0 pfdbe@ IOPageFrameEntryCache_Event + !
	end

	if (ok@)
		ipl@ KeIPLLower

		if (pri@ TRYFOREVER &)
			// we needed this page for a swapout, system detonates.
			// this flag is also used for certain other situations
			// where an IO operation must succeed.
			"IOCachePageGet: failed to allocate page needed for swapout!\n" KeCrash
		end

		return
	end

	offset@ pfdbe@ IOPageFrameEntryCache_OffsetInFile + !
	fcb@ pfdbe@ IOPageFrameEntryCache_FCB + !

	1 IOCachePagesUsed +=

	lastnode@ // insertat
	pfdbe@ IOPageFrameEntryCache_Parent + // node
	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + // rootptr
	ExSplayTreeInsert

	ipl@ KeIPLLower

	// no need to ref the page -- it gets ref'd on allocation by MmEvictablePageAlloc

	pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!
end

fn (MmEvictionFunction) IOCachePageEvictionFunction { pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageEvictionFunction: no cacheblock\n" KeCrash
		end
	end

	// remove from splay tree
	
	pfdbe@ IOPageFrameEntryCache_Parent + // node
	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + // rootptr
	ExSplayTreeRemove

	1 IOCachePagesUsed -=
end

fn IOCachePageWrite { transfer kflags pfdbe -- ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IOCachePageWrite: ipl != IPLDPC\n" KeCrash
		end
	end

	// assumes caller referenced the page.
	// will cluster pages that it finds are in order.

	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto mdl

	if (transfer@ ~~)
		MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!
	end else
		transfer@ mdl!
	end

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto pagecount
	0 pagecount!

	while (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
		kflags@ MmKflagToPriority // pri
		pfdbe@ // pfdbe
		IOCachePageWait ok!

		if (ok@)
			if (transfer@)
				transfer@ IOTransferComplete
			end

			return
		end
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		if (transfer@)
			transfer@ IOTransferComplete
		end
	
		return
	end

	auto off
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

	// search backward for more modified pages
	while (pagecount@ IOTRANSFERMAX PAGESHIFT >> 1 - <)
		if (off@ ~~)
			break
		end

		auto spfdbe
		pfdbe@ IOPageFrameEntryCache_Parent + // node
		ExSplayTreeNodePrevious spfdbe!

		if (spfdbe@ ~~)
			break
		end

		IOPageFrameEntryCache_Parent spfdbe -=

		if (spfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
			break
		end

		if (spfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
			break
		end

		if (spfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off@ PAGESIZE - ~=)
			break
		end

		spfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!
		spfdbe@ pfdbe!

		1 pagecount +=
	end

	0 pagecount!

	auto startoffset
	off@ startoffset!
	-1 off!

	// now go forward to build the MDL
	while (pagecount@ IOTRANSFERMAX PAGESHIFT >> <)
		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
			break
		end

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
			break
		end

		if (off@ -1 ~=)
			if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off@ PAGESIZE + ~=)
				break
			end
		end

		pfdbe@ MmEvictablePageReference drop

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ & MMEVICTFLAG_IOINPROGRESS |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		0 pfdbe@ IOPageFrameEntryCache_Event + !

		pfdbe@ mdlpos@!

		pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

		4 mdlpos +=
		1 pagecount +=

		pfdbe@ IOPageFrameEntryCache_Parent + // node
		ExSplayTreeNodeNext pfdbe!

		if (pfdbe@ ~~)
			break
		end

		IOPageFrameEntryCache_Parent pfdbe -=
	end

	if (pagecount@ ~~)
		// no pages to write...

		if (transfer@)
			transfer@ IOTransferComplete
		end

		0 ok!
		return
	end

	IPLLOW KeIPLLower

	-1 mdlpos@!

	KERNELMODE // mode
	pagecount@ PAGESHIFT << // length
	0 // vaddr
	mdl@ // mdl
	MmMDLInitialize

	if (transfer@ ~~)
		auto event
		KeEvent_SIZEOF alloc event!

		0 // signaled
		OSEVENT_NOTIF // type
		"IOCachePageWriteEvent" // name
		event@ // event
		KeEventInitialize

		event@ mdl@ MmMDLHeader_Event + !
	end else
		pointerof IOCachePageMDLComplete mdl@ MmMDLHeader_CompleteRoutine + !
	end

	2 mdl@ MmMDLHeader_PinCount + !
	transfer@ mdl@ MmMDLHeader_Context1 + !

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	KeThreadCurrent@ KeThreadIgnoreKill drop

	0 // flags
	kflags@ // kflags
	startoffset@ // offset
	mdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok! drop

	if (ok@)
		// complete the MDL so we can wait for any fragments to finish

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end

	if (transfer@ ~~)
		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@ ~~)
			mdl@ MmMDLHeader_Status + @ ok!
		end
	end

	KeThreadCurrent@ KeThreadAcceptKill drop

	IPLDPC KeIPLRaise drop

	if (transfer@ ~~)
		mdl@ IOCachePageMDLComplete
	end
end

fn (MmMDLCompleteRoutine) IOCachePageMDLComplete { mdl -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto status
	mdl@ MmMDLHeader_Status + @ status!

	if (status@)
		// TODO pop-up window or something
		status@ "IO error while writing unsaved data (%i)\n" Printf
	end

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto pagecount
	mdl@ MmMDLHeader_Pages + @ pagecount!

	while (pagecount@)
		auto pfdbe
		mdlpos@@ pfdbe!

		if (status@)
			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED |
			pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
		end

		pfdbe@ IOCachePageSatisfy
		pfdbe@ MmEvictablePageDereference drop

		1 pagecount -=
		4 mdlpos +=
	end

	if (mdl@ MmMDLHeader_Context1 + @)
		mdl@ MmMDLHeader_Context1 + @ IOTransferComplete
	end

	ipl@ KeIPLLower
end

fn IOCachePageRead { flags kflags offset fcb -- pageframe pfdbe ok }
	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageRead: attempt to perform cached page read from noncached file\n" KeCrash
		end
	end

	1 // iointent
	kflags@ // kflags
	offset@ // offset
	fcb@ // fcb
	IOCachePageGet ok! pfdbe! pageframe!

	if (ok@)
		return
	end

	auto ipl

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID & ~~)
		// this cache page is invalid and needs to be read in

		auto readfunc
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

		if (DEBUGCHECKS)
			if (readfunc@ ~~)
				"IOCachePageRead: no read function\n" KeCrash
			end
		end

		// perform the read operation

		auto event
		KeEvent_SIZEOF alloc event!

		0 // signaled
		OSEVENT_NOTIF // type
		"IOCachePageReadEvent" // name
		event@ // event
		KeEventInitialize

		auto mdl
		MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

		KERNELMODE // mode
		PAGESIZE // length
		pageframe@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		kflags@ IOKFLAG_PAGEIN | // kflags
		offset@ PAGENUMBERMASK & // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok! drop

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@)
			// read failed

			IPLDPC KeIPLRaise ipl!
			pfdbe@ IOCachePageSatisfy
			ipl@ KeIPLLower

			pfdbe@ MmEvictablePageDereference drop

			return
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			// read failed

			IPLDPC KeIPLRaise ipl!
			pfdbe@ IOCachePageSatisfy
			ipl@ KeIPLLower

			pfdbe@ MmEvictablePageDereference drop

			return
		end

		// read succeeded, page is now valid

		IPLDPC KeIPLRaise ipl!

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		pfdbe@ IOCachePageSatisfy

		ipl@ KeIPLLower
	end
end