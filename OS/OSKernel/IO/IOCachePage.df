//
// Implements management routines and eviction for filestream pages.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

table IOCacheEvictableFunctions
	pointerof IOCachePageEvictionFunction // EvictionFunc
	pointerof IOCachePageReferenceFunction // ReferenceFunc
	pointerof IOCachePageDereferenceFunction // DereferenceFunc
	0 // DirtyFunc
	0 // Reserved2
	0 // Reserved3
	0 // Reserved4
	0 // Reserved5
endtable
public IOCacheEvictableFunctions

var IOCacheDirtyPageListHead 0
public IOCacheDirtyPageListHead

var IOCacheDirtyPageListTail 0
public IOCacheDirtyPageListTail

var IOCachePagesUsed 0
public IOCachePagesUsed

var IOCachePagesDirtyMaximum 0
public IOCachePagesDirtyMaximum

var IOCachePagesDirtyCount 0
public IOCachePagesDirtyCount

fn IOCachePageRemoveDirty { pfdbe -- }
	auto rs
	HALCPUInterruptDisable rs!

	// remove from dirty list
	auto n
	pfdbe@ MmPageFrameEntryEvictable_Next + @ n!

	if (n@)
		pfdbe@ MmPageFrameEntryEvictable_Prev + @ n@ MmPageFrameEntryEvictable_Prev + !
	end else // no next means we were the tail
		pfdbe@ MmPageFrameEntryEvictable_Prev + @ IOCacheDirtyPageListTail!
	end

	auto p
	pfdbe@ MmPageFrameEntryEvictable_Prev + @ p!

	if (p@)
		pfdbe@ MmPageFrameEntryEvictable_Next + @ p@ MmPageFrameEntryEvictable_Next + !
	end else // no prev means we were the head
		pfdbe@ MmPageFrameEntryEvictable_Next + @ IOCacheDirtyPageListHead!
	end

	rs@ HALCPUInterruptRestore
end

fn IOCachePageInsertDirty { pfdbe -- }
	auto rs
	HALCPUInterruptDisable rs!

	// use the evict LRU links to insert the page on the back of the dirty list

	auto t
	IOCacheDirtyPageListTail@ t!

	if (t@ ~~)
		0 pfdbe@ MmPageFrameEntryEvictable_Next + !
		0 pfdbe@ MmPageFrameEntryEvictable_Prev + !

		pfdbe@ IOCacheDirtyPageListHead!
		pfdbe@ IOCacheDirtyPageListTail!
	end else
		0 pfdbe@ MmPageFrameEntryEvictable_Next + !

		t@ pfdbe@ MmPageFrameEntryEvictable_Prev + !
		pfdbe@ t@ MmPageFrameEntryEvictable_Next + !
		pfdbe@ IOCacheDirtyPageListTail!
	end

	rs@ HALCPUInterruptRestore
end

fn IOCachePageDirtyCleanup { pfdbe -- }
	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (DEBUGCHECKS)
		if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY & ~~)
			pfdbe@ "IOCachePageDirtyCleanup: page wasn't dirty (0x%08x)\n" KeCrash
		end
	end

	// clear dirty flag
	IOCACHEPAGEFLAG_DIRTY ~ pfdbe@ IOPageFrameEntryCache_Flags + &=

	// decrement dirty page count

	if (DEBUGCHECKS)
		if (cacheblock@ IOCacheInfoBlock_DirtyPages + @ 0 ==)
			"IOCachePageDirtyCleanup: underflow\n" KeCrash
		end
	end

	1 cacheblock@ IOCacheInfoBlock_DirtyPages + -=
	1 IOCachePagesDirtyCount -=

	// remove from dirty list
	pfdbe@ IOCachePageRemoveDirty

	// if there's a dirty PTE somewhere, clear the writable bit so that
	// the next time the process writes to it, this page gets properly
	// marked as dirty again

	if (pfdbe@ IOPageFrameEntryCache_DirtyPTE + @)
		pfdbe@ IOPageFrameEntryCache_DirtyPTE + @ MmPTEUndirty
		0 pfdbe@ IOPageFrameEntryCache_DirtyPTE + !
	end

	auto quotablock
	pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + @ quotablock!

	if (quotablock@)
		// someone was charged quota for this dirty page

		1 // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargeDirtyPages

		quotablock@ MmQuotaBlockDereference

		0 pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + !
	end

	ipl@ KeIPLLower
end

fn IOCachePageWriteDirty { dontderef pfdbe -- ok }
	// XXX call with care: data loss could occur if thread can receive signals
	// during this operation

	if (DEBUGCHECKS)
		if (KeThreadCurrent@ KeThread_IgnoreKill + @ ~~)
			"IOCachePageWriteDirty: could be killed\n" KeCrash
		end
	end

	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	pfdbe@ IOCachePageDirtyCleanup

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	auto off
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

	// perform the write operation

	0 // flags
	0 // kflags
	PAGESIZE // length
	off@ // offset
	pfdbe@ IOPageFrameEntryCache_PFN + @ PAGESHIFT << IDENTITYSPACE | // buffer
	fcb@ // fcb
	KERNELMODE // lastmode
	writefunc@ IODispatchWriteFunction ok! drop

	if (dontderef@ ~~)
		// no longer dirty, unbias the refcount
		pfdbe@ MmEvictablePageDereference drop
	end
end

fn IOCachePageGet { kflags locked offset fcb -- pageframe pfdbe ok }
	if (DEBUGCHECKS)
		if (offset@ PAGEOFFSETMASK &)
			"IOCachePageGet: offset wasn't page-aligned\n" KeCrash
		end
	end

	0 ok!

	auto cacheblock

	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto filesize
	fcb@ IOFileControlBlock_SizeInBytes + @ filesize!

	if (DEBUGCHECKS)
		if (offset@ filesize@ >=)
			"IOCachePageGet: offset was beyond end of file\n" KeCrash
		end
	end

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	if (locked@ ~~)
		cacheblock@ // cacheblock
		IOCacheInfoBlockLockShared ok!

		if (ok@)
			return
		end

		bucket@ // bucket
		cacheblock@ // cacheblock
		IOCacheInfoBlockLockBucket ok!

		if (ok@)
			cacheblock@ IOCacheInfoBlockUnlock

			return
		end
	end

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	auto buckettail
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + 4 + buckettail!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	buckethead@@ pfdbe!

	while (pfdbe@)
		if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset@ ==)
			// found the page, it was in the cache already!

			// ref it so it doesn't get evicted while caller is using it

			pfdbe@ MmEvictablePageReference drop

			// remove from hash list so that it can be reinserted on the recently-used end

			if (pfdbe@ buckethead@@ ~=)
				pfdbe@ // pfdbe
				buckethead@ // buckethead
				IOCachePageRemove

				pfdbe@ // pfdbe
				buckethead@ // buckethead
				IOCachePageInsert
			end

			ipl@ KeIPLLower

			if (locked@ ~~)
				bucket@ // bucket
				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlockBucket

				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlock
			end

			pfdbe@ IOPageFrameEntryCache_PFN + @ PAGESHIFT << IDENTITYSPACE | pageframe!

			return
		end

		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
	end

	ipl@ KeIPLLower

	// not in the cache -- allocate a page for it.

	if (filesize@ offset@ - PAGESIZE <)
		// not a full page -- get zeroes because this might leak data

		MMEVICTFLAG_WORKINGSET // flags
		IOCacheEvictableFunctions // evictablefuncs
		ZEROMUST CACHEALLOC | // priority
		MmEvictablePageAlloc ok! drop pfdbe!
	end else
		// full page, get any random page that may or may not be zeroed

		MMEVICTFLAG_WORKINGSET // flags
		IOCacheEvictableFunctions // evictablefuncs
		FREEFIRST CACHEALLOC | // priority
		MmEvictablePageAlloc ok! drop pfdbe!
	end

	auto rs

	if (ok@)
		if (DEBUGCHECKS)
			if (ok@ STATUS_NO_MEMORY ~=)
				ok@ "IOCachePageGet: weird return value from MmEvictablePageAlloc (%i)\n" KeCrash
			end
		end

		// weren't able to find a reusable page. try to allocate again,
		// but this time we can block.

		if (kflags@ IOKFLAG_SWAPOUT &)
			// this IOCachePageGet is needed for a swap-out operation
			// (i.e., the filesystem driver is using it to cache disk
			// structures and needs whatever is going to be read into
			// this page to know where to swap the page out to).

			MUSTSUCCEED CANBLOCK | kflags!
		end elseif (kflags@ IOKFLAG_URGENT &)
			MUSTSUCCEEDL2 CANBLOCK | kflags!
		end else
			CANBLOCK kflags!
		end

		if (filesize@ offset@ - PAGESIZE <)
			// not a full page -- get zeroes because this might leak data otherwise

			MMEVICTFLAG_WORKINGSET // flags
			IOCacheEvictableFunctions // evictablefuncs
			ZEROMUST kflags@ | // priority
			MmEvictablePageAlloc ok! drop pfdbe!
		end else
			// full page, get any random page that may or may not be zeroed

			MMEVICTFLAG_WORKINGSET // flags
			IOCacheEvictableFunctions // evictablefuncs
			FREEFIRST kflags@ | // priority
			MmEvictablePageAlloc ok! drop pfdbe!
		end

		if (ok@)
			if (kflags@ MUSTSUCCEED ==)
				// we needed this page for a swapout, system detonates.
				// this flag is also used for certain other situations
				// where an IO operation must succeed.
				"IOCachePageGet: failed to allocate page needed for swapout!\n" KeCrash
			end

			if (locked@ ~~)
				bucket@ // bucket
				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlockBucket

				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlock
			end

			return
		end else
			HALCPUInterruptDisable rs!
			1 IOCachePagesUsed +=
			rs@ HALCPUInterruptRestore
		end
	end else
		HALCPUInterruptDisable rs!
		1 IOCachePagesUsed +=
		rs@ HALCPUInterruptRestore
	end

	0 pfdbe@ IOPageFrameEntryCache_Flags + !
	offset@ pfdbe@ IOPageFrameEntryCache_OffsetInFile + !
	fcb@ pfdbe@ IOPageFrameEntryCache_FCB + !
	0 pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + !
	0 pfdbe@ IOPageFrameEntryCache_DirtyPTE + !
	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	0 pfdbe@ IOPageFrameEntryCache_NextCachePage + !

	IPLDPC KeIPLRaise ipl!

	pfdbe@ // pfdbe
	buckethead@ // buckethead
	IOCachePageInsert

	ipl@ KeIPLLower

	// account for this new reference

	0 // oldcount
	pfdbe@ // pfdbe
	IOCachePageReferenceFunction

	// no need to ref the page -- it gets ref'd on allocation by MmEvictablePageAlloc

	if (locked@ ~~)
		bucket@ // bucket
		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlockBucket

		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlock
	end

	pfdbe@ IOPageFrameEntryCache_PFN + @ PAGESHIFT << IDENTITYSPACE | pageframe!
end

fn IOCacheDumpInfo { cacheblock -- }
	auto i
	0 i!

	while (i@ IOCACHEPAGEBUCKETS <)
		auto buckethead
		cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + buckethead!

		auto pfdbe
		buckethead@@ pfdbe!

		buckethead@ 4 + @ buckethead@@ i@ "%d h=%x t=%x: " Printf

		while (pfdbe@)
			pfdbe@ IOPageFrameEntryCache_References + @ "%d " Printf

			pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
		end

		"\n" Printf

		1 i +=
	end
end

fn IOCachePageRemove { pfdbe buckethead -- }
	// remove from hash list.
	// assumes IPLDPC or equivalent.

	auto n
	pfdbe@ IOPageFrameEntryCache_NextCachePage + @ n!

	if (n@)
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no next means we were the tail
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ buckethead@ 4 + !
	end

	auto p
	pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ p!

	if (p@)
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ p@ IOPageFrameEntryCache_NextCachePage + !
	end else // no prev means we were the head
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ buckethead@!
	end

	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	0 pfdbe@ IOPageFrameEntryCache_NextCachePage + !
end

fn IOCachePageInsert { pfdbe buckethead -- }
	// insert into hash list on the recently-used end.
	// assumes IPLDPC or equivalent.

	auto n
	buckethead@@ n!

	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	n@ pfdbe@ IOPageFrameEntryCache_NextCachePage + !

	if (n@)
		pfdbe@ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no head, set tail
		pfdbe@ buckethead@ 4 + !
	end

	pfdbe@ buckethead@!
end

fn (MmReferenceFunction) IOCachePageReferenceFunction { oldcount pfdbe -- }
	// keep track of a global refcount for the cache block.
	// this is done so that there's a fast way to tell whether
	// a file can be truncated.

	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	cacheblock@ // cacheblock
	IOCacheInfoBlockReference drop
end

fn (MmDereferenceFunction) IOCachePageDereferenceFunction { oldcount pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	cacheblock@ // cacheblock
	IOCacheInfoBlockDereference drop
end

fn (MmEvictionFunction) IOCachePageEvictionFunction { pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto offset
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset!

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	if (DEBUGCHECKS)
		if (pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + @)
			"IOCachePageEvictionFunction: cache page had dirty quota block\n" KeCrash
		end
	end

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	// remove from hash list

	pfdbe@ // pfdbe
	buckethead@ // buckethead
	IOCachePageRemove

	1 IOCachePagesUsed -=
end

fn IOCachePageDirtyQuotaCharge { quotablock pfdbe -- charged }
	// attempts to charge dirty page quota for the pfdbe.
	// not 100% foolproof but "good enough".

	// keep in mind that once called, if you become aware that the page may
	// not be marked dirty after all, ensure that you call
	// IOCachePageDirtyQuotaUncharge on it BEFORE dereferencing it.

	// disable interrupts instead of raising IPL since raising IPL would
	// probably actually be slower.

	// XXX should this time out?

	auto ok

	auto rs
	HALCPUInterruptDisable rs!

	while (1)
		0 charged!

		if (pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + @)
			// page already accounted for.
			rs@ HALCPUInterruptRestore
			return
		end

		// page is not accounted for, try to charge quota.

		1 charged!

		if (IOCachePagesDirtyCount@ IOCachePagesDirtyMaximum@ >=)
			STATUS_VM_QUOTA_EXCEEDED ok!
		end else
			1 // charge
			quotablock@ // quotablock
			MmQuotaBlockChargeDirtyPages ok!
		end

		if (ok@)
			// failed to charge quota. throttle for 35ms and try again.
			rs@ HALCPUInterruptRestore

			35 // ms
			KERNELMODE // waitmode
			0 // alertable
			KeThreadSleep drop

			HALCPUInterruptDisable rs!
		end else
			// charged successfully.
			quotablock@ MmQuotaBlockReference
			quotablock@ pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + !
			rs@ HALCPUInterruptRestore
			return
		end
	end
end

fn IOCachePageDirtyQuotaUncharge { pfdbe -- }
	auto quotablock
	pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + @ quotablock!

	if (DEBUGCHECKS)
		if (quotablock@ ~~)
			"IOCachePageDirtyQuotaUncharge: no quotablock\n" KeCrash
		end
	end

	0 pfdbe@ IOPageFrameEntryCache_DirtyQuotaBlock + !

	1 // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargeDirtyPages

	quotablock@ MmQuotaBlockDereference
end

fn IOCachePageDirtyFunction { pfdbe -- ok }
	// mark a page dirty and insert it on the dirty page list if
	// necessary.

	0 ok!

	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageDirty: no cacheblock on FCB\n" KeCrash
		end
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
		ipl@ KeIPLLower

		return
	end

	// bias the refcount so that it doesn't get evicted while dirty.
	// this gets undone when it is written out.

	pfdbe@ MmEvictablePageReference drop

	pfdbe@ IOCachePageInsertDirty

	IOCACHEPAGEFLAG_DIRTY pfdbe@ IOPageFrameEntryCache_Flags + |=

	// mark valid: the page must either already be valid, and only be
	// partially dirty, or be invalid and fully overwritten (in which case,
	// it is now valid). caller guarantees this.
	IOCACHEPAGEFLAG_VALID pfdbe@ IOPageFrameEntryCache_Flags + |=

	// will be decremented when written out
	1 cacheblock@ IOCacheInfoBlock_DirtyPages + +=
	1 IOCachePagesDirtyCount +=

	if (IOCachePagesDirtyCount@ IOCachePagesDirtyMaximum@ >=)
		0 // priboost
		IODirtyPageEvent // event
		KeEventSignal
	end

	ipl@ KeIPLLower
end

fn IOCachePageRead { flags kflags offset fcb -- pageframe pfdbe ok }
	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageRead: attempt to perform cached page read from noncached file\n" KeCrash
		end
	end

	cacheblock@ IOCacheInfoBlockLockShared ok!

	if (ok@)
		return
	end

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	bucket@ // bucket
	cacheblock@ // cacheblock
	IOCacheInfoBlockLockBucket ok!

	if (ok@)
		cacheblock@ IOCacheInfoBlockUnlock

		return
	end

	kflags@ // kflags
	1 // locked
	offset@ // offset
	fcb@ // fcb
	IOCachePageGet ok! pfdbe! pageframe!

	if (ok@)
		bucket@ // bucket
		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlockBucket

		cacheblock@ IOCacheInfoBlockUnlock

		return
	end

	if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_VALID & ~~)
		// this cache page is invalid and needs to be read in

		auto readfunc
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

		if (DEBUGCHECKS)
			if (readfunc@ ~~)
				"IOCachePageRead: no read function\n" KeCrash
			end
		end

		// perform the read operation

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		kflags@ // kflags
		PAGESIZE // length
		offset@ PAGENUMBERMASK & // offset
		pageframe@ // buffer
		fcb@ // fcb
		KERNELMODE // lastmode
		readfunc@ IODispatchReadFunction ok! drop

		if (ok@)
			// read failed

			pfdbe@ MmEvictablePageDereference drop

			bucket@ // bucket
			cacheblock@ // cacheblock
			IOCacheInfoBlockUnlockBucket

			cacheblock@ IOCacheInfoBlockUnlock

			return
		end

		// read succeeded, page is now valid

		IOCACHEPAGEFLAG_VALID pfdbe@ IOPageFrameEntryCache_Flags + |=
	end

	bucket@ // bucket
	cacheblock@ // cacheblock
	IOCacheInfoBlockUnlockBucket

	cacheblock@ IOCacheInfoBlockUnlock
end