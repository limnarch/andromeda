//
// Implements management routines and eviction for filestream pages.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

var IOCachePagesUsed 0
public IOCachePagesUsed

struct IOCachePageEvent
	KeEvent_SIZEOF Event
	4 References
endstruct

fn IOCachePageWait { pri pfdbe -- ok }
	// wait for IO to complete on a cache page.

	// entered at IPLDPC

	0 ok!

	auto eventblock
	pfdbe@ IOPageFrameEntryCache_Event + @ eventblock!

	if (eventblock@ ~~)
		// allocate an event block

		IPLLOW KeIPLLower

		IOCachePageEvent_SIZEOF // bytes
		'IOCE' // tag
		pri@ // flags
		MmAllocWithTag ok! eventblock!

		IPLDPC KeIPLRaise drop

		if (ok@)
			return
		end

		if (pfdbe@ IOPageFrameEntryCache_Event + @)
			// awkward, someone allocated one while we were trying to.
			// free ours and use theirs.

			eventblock@ MmFree
			pfdbe@ IOPageFrameEntryCache_Event + @ eventblock!
		end else
			eventblock@ pfdbe@ IOPageFrameEntryCache_Event + !

			0 // signaled
			OSEVENT_NOTIF // type
			"IOCachePageWaitEvent" // name
			eventblock@ IOCachePageEvent_Event + // event
			KeEventInitialize

			0 eventblock@ IOCachePageEvent_References + !
		end
	end

	1 eventblock@ IOCachePageEvent_References + +=

	IPLLOW KeIPLLower

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	eventblock@ IOCachePageEvent_Event + // object
	KeThreadWaitForObject drop

	IPLDPC KeIPLRaise drop

	1 eventblock@ IOCachePageEvent_References + -=

	if (eventblock@ IOCachePageEvent_References + @ ~~)
		eventblock@ MmFree
	end
end

fn IOCachePageSatisfy { pfdbe -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS ~ &
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

	auto eventblock
	pfdbe@ IOPageFrameEntryCache_Event + @ eventblock!

	if (eventblock@)
		0 // priboost
		eventblock@ IOCachePageEvent_Event + // event
		KeEventSignal
	end

	ipl@ KeIPLLower
end

fn IOCachePageGet { iointent kflags locked offset fcb -- pageframe pfdbe ok }
	if (DEBUGCHECKS)
		if (offset@ PAGEOFFSETMASK &)
			"IOCachePageGet: offset wasn't page-aligned\n" KeCrash
		end
	end

	0 ok!

	auto cacheblock

	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto filesize
	fcb@ IOFileControlBlock_SizeInBytes + @ filesize!

	if (DEBUGCHECKS)
		if (offset@ filesize@ >=)
			"IOCachePageGet: offset was beyond end of file\n" KeCrash
		end
	end

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEHASHSHIFT >> IOCACHEPAGEMASK & bucket!

	if (locked@ ~~)
		cacheblock@ // cacheblock
		IOCacheInfoBlockLockShared ok!

		if (ok@)
			return
		end
	end

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	auto buckettail
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + 4 + buckettail!

	auto pri

	if (kflags@ IOKFLAG_SWAPOUT &)
		// this IOCachePageGet is needed for a swap-out operation
		// (i.e., the filesystem driver is using it to cache disk
		// structures and needs whatever is going to be read into
		// this page to know where to swap the page out to).

		MUSTSUCCEED CANBLOCK | pri!
	end elseif (kflags@ IOKFLAG_URGENT &)
		MUSTSUCCEEDL2 CANBLOCK | pri!
	end elseif (kflags@ IOKFLAG_SWAPIN &)
		CANBLOCK TRYFOREVER | pri!
	end else
		CANBLOCK pri!
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	pri@ MmPageWait ok! drop

	if (ok@)
		ipl@ KeIPLLower

		if (locked@ ~~)
			cacheblock@ // cacheblock
			IOCacheInfoBlockUnlock
		end

		return
	end

	buckethead@@ pfdbe!

	while (pfdbe@)
		if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset@ ==)
			// found the page, it was in the cache already!

			// ref it so it doesn't get evicted while caller is using it

			pfdbe@ MmEvictablePageReference drop

			// remove from hash list so that it can be reinserted on the recently-used end

			if (pfdbe@ buckethead@@ ~=)
				pfdbe@ // pfdbe
				buckethead@ // buckethead
				IOCachePageRemove

				pfdbe@ // pfdbe
				buckethead@ // buckethead
				IOCachePageInsert
			end

			ipl@ KeIPLLower

			if (locked@ ~~)
				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlock
			end

			pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!

			IPLDPC KeIPLRaise ipl!

			if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS &)
				pri@ pfdbe@ IOCachePageWait ok!

				if (ok@)
					pfdbe@ MmEvictablePageDereference drop
				end
			end

			ipl@ KeIPLLower

			return
		end

		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
	end

	// not in the cache -- allocate a page for it.

	auto zeroes
	filesize@ offset@ - PAGESIZE <
	kflags@ IOKFLAG_ZEROES & || zeroes!

	if (zeroes@)
		ZEROMUST pri |=
	end else
		FREEFIRST pri |=
	end

	MMEVICTFLAG_WORKINGSET // flags
	MMEVICTTYPE_FILE // evictablefuncs
	pri@ // priority
	MmEvictablePageGet ok! drop pfdbe!

	if (iointent@)
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_IOINPROGRESS |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		0 pfdbe@ IOPageFrameEntryCache_Event + !
	end

	ipl@ KeIPLLower

	if (ok@)
		if (pri@ TRYFOREVER &)
			// we needed this page for a swapout, system detonates.
			// this flag is also used for certain other situations
			// where an IO operation must succeed.
			"IOCachePageGet: failed to allocate page needed for swapout!\n" KeCrash
		end

		if (locked@ ~~)
			cacheblock@ // cacheblock
			IOCacheInfoBlockUnlock
		end

		return
	end

	offset@ pfdbe@ IOPageFrameEntryCache_OffsetInFile + !
	fcb@ pfdbe@ IOPageFrameEntryCache_FCB + !
	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	0 pfdbe@ IOPageFrameEntryCache_NextCachePage + !

	IPLDPC KeIPLRaise ipl!

	1 IOCachePagesUsed +=

	pfdbe@ // pfdbe
	buckethead@ // buckethead
	IOCachePageInsert

	ipl@ KeIPLLower

	// no need to ref the page -- it gets ref'd on allocation by MmEvictablePageAlloc

	if (locked@ ~~)
		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlock
	end

	pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!
end

fn IOCacheDumpInfo { cacheblock -- }
	auto i
	0 i!

	while (i@ IOCACHEPAGEBUCKETS <)
		auto buckethead
		cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + buckethead!

		auto pfdbe
		buckethead@@ pfdbe!

		buckethead@ 4 + @ buckethead@@ i@ "%d h=%x t=%x: " Printf

		while (pfdbe@)
			pfdbe@ IOPageFrameEntryCache_ReferencesI + gi "%d " Printf

			pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
		end

		"\n" Printf

		1 i +=
	end
end

fn IOCachePageRemove { pfdbe buckethead -- }
	// remove from hash list.
	// assumes IPLDPC or equivalent.

	auto n
	pfdbe@ IOPageFrameEntryCache_NextCachePage + @ n!

	if (n@)
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no next means we were the tail
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ buckethead@ 4 + !
	end

	auto p
	pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ p!

	if (p@)
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ p@ IOPageFrameEntryCache_NextCachePage + !
	end else // no prev means we were the head
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ buckethead@!
	end

	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	0 pfdbe@ IOPageFrameEntryCache_NextCachePage + !
end

fn IOCachePageInsert { pfdbe buckethead -- }
	// insert into hash list on the recently-used end.
	// assumes IPLDPC or equivalent.

	auto n
	buckethead@@ n!

	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	n@ pfdbe@ IOPageFrameEntryCache_NextCachePage + !

	if (n@)
		pfdbe@ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no head, set tail
		pfdbe@ buckethead@ 4 + !
	end

	pfdbe@ buckethead@!
end

fn (MmEvictionFunction) IOCachePageEvictionFunction { pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageEvictionFunction: no cacheblock\n" KeCrash
		end
	end

	auto offset
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset!

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEHASHSHIFT >> IOCACHEPAGEMASK & bucket!

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	// remove from hash list

	pfdbe@ // pfdbe
	buckethead@ // buckethead
	IOCachePageRemove

	1 IOCachePagesUsed -=
end

fn IOCachePageWrite { kflags pfdbe -- ok }
	// assumes caller referenced the page.
	// will cluster pages that it finds are in order.

	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto mdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto pagecount
	0 pagecount!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto off
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

	// search "backward" in the bucket for more modified pages
	while (pagecount@ IOCACHEPAGECLUSTERMAX 1 - <)
		auto spfdbe
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ spfdbe!

		if (spfdbe@ ~~)
			break
		end

		if (spfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
			break
		end

		if (spfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off@ PAGESIZE - ~=)
			break
		end

		spfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!
		spfdbe@ pfdbe!

		1 pagecount +=
	end

	0 pagecount!

	auto startoffset
	off@ startoffset!
	-1 off!

	// now go "forward" to build the MDL
	while (pagecount@ IOCACHEPAGECLUSTERMAX <)
		if (pagecount@ IOTRANSFERMAX PAGESHIFT >> >=)
			break
		end

		if (pfdbe@ ~~)
			break
		end

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
			break
		end

		if (off@ -1 ~=)
			if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off@ PAGESIZE + ~=)
				break
			end
		end

		pfdbe@ MmEvictablePageReference drop

		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

		pfdbe@ mdlpos@!

		pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ pfdbe!

		4 mdlpos +=
		1 pagecount +=
	end

	ipl@ KeIPLLower

	if (pagecount@ ~~)
		// no pages to write...
		0 ok!
		return
	end

	KERNELMODE // mode
	pagecount@ PAGESHIFT << // length
	0 // vaddr
	mdl@ // mdl
	MmMDLInitialize

	1 mdl@ MmMDLHeader_PinCount + !

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	KeThreadCurrent@ KeThreadIgnoreKill drop

	0 // flags
	kflags@ // kflags
	startoffset@ // offset
	mdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok! drop

	KeThreadCurrent@ KeThreadAcceptKill drop

	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	IPLDPC KeIPLRaise ipl!

	while (pagecount@)
		mdlpos@@ MmEvictablePageDereference drop

		1 pagecount -=
		4 mdlpos +=
	end

	ipl@ KeIPLLower
end

fn IOCachePageRead { flags kflags offset fcb -- pageframe pfdbe ok }
	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageRead: attempt to perform cached page read from noncached file\n" KeCrash
		end
	end

	cacheblock@ IOCacheInfoBlockLockShared ok!

	if (ok@)
		return
	end

	1 // iointent
	kflags@ // kflags
	1 // locked
	offset@ // offset
	fcb@ // fcb
	IOCachePageGet ok! pfdbe! pageframe!

	if (ok@)
		cacheblock@ IOCacheInfoBlockUnlock

		return
	end

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID & ~~)
		// this cache page is invalid and needs to be read in

		auto readfunc
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

		if (DEBUGCHECKS)
			if (readfunc@ ~~)
				"IOCachePageRead: no read function\n" KeCrash
			end
		end

		// perform the read operation

		auto mdl
		MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

		KERNELMODE // mode
		PAGESIZE // length
		pageframe@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		kflags@ IOKFLAG_PAGEIN | // kflags
		offset@ PAGENUMBERMASK & // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok! drop

		if (ok@)
			// read failed

			pfdbe@ IOCachePageSatisfy

			pfdbe@ MmEvictablePageDereference drop

			cacheblock@ IOCacheInfoBlockUnlock

			return
		end

		// read succeeded, page is now valid

		auto rs
		HALCPUInterruptDisable rs!
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID |
		pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
		rs@ HALCPUInterruptRestore

		pfdbe@ IOCachePageSatisfy
	end

	cacheblock@ IOCacheInfoBlockUnlock
end