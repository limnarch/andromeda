//
// Implements management routines and eviction for filestream pages.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

var IOCachePagesUsed 0
public IOCachePagesUsed

fn IOCachePageGet { kflags locked offset fcb -- pageframe pfdbe ok }
	if (DEBUGCHECKS)
		if (offset@ PAGEOFFSETMASK &)
			"IOCachePageGet: offset wasn't page-aligned\n" KeCrash
		end
	end

	0 ok!

	auto cacheblock

	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto filesize
	fcb@ IOFileControlBlock_SizeInBytes + @ filesize!

	if (DEBUGCHECKS)
		if (offset@ filesize@ >=)
			"IOCachePageGet: offset was beyond end of file\n" KeCrash
		end
	end

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	if (locked@ ~~)
		cacheblock@ // cacheblock
		IOCacheInfoBlockLockShared ok!

		if (ok@)
			return
		end

		bucket@ // bucket
		cacheblock@ // cacheblock
		IOCacheInfoBlockLockBucket ok!

		if (ok@)
			cacheblock@ IOCacheInfoBlockUnlock

			return
		end
	end

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	auto buckettail
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + 4 + buckettail!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	buckethead@@ pfdbe!

	while (pfdbe@)
		if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset@ ==)
			// found the page, it was in the cache already!

			// ref it so it doesn't get evicted while caller is using it

			pfdbe@ MmEvictablePageReference drop

			// remove from hash list so that it can be reinserted on the recently-used end

			if (pfdbe@ buckethead@@ ~=)
				pfdbe@ // pfdbe
				buckethead@ // buckethead
				IOCachePageRemove

				pfdbe@ // pfdbe
				buckethead@ // buckethead
				IOCachePageInsert
			end

			ipl@ KeIPLLower

			if (locked@ ~~)
				bucket@ // bucket
				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlockBucket

				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlock
			end

			pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!

			return
		end

		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
	end

	ipl@ KeIPLLower

	// not in the cache -- allocate a page for it.

	if (filesize@ offset@ - PAGESIZE <)
		// not a full page -- get zeroes because this might leak data

		MMEVICTFLAG_WORKINGSET // flags
		MMEVICTTYPE_FILE // evictablefuncs
		ZEROMUST CACHEALLOC | // priority
		MmEvictablePageAlloc ok! drop pfdbe!
	end else
		// full page, get any random page that may or may not be zeroed

		MMEVICTFLAG_WORKINGSET // flags
		MMEVICTTYPE_FILE // evictablefuncs
		FREEFIRST CACHEALLOC | // priority
		MmEvictablePageAlloc ok! drop pfdbe!
	end

	auto rs

	if (ok@)
		if (DEBUGCHECKS)
			if (ok@ STATUS_NO_MEMORY ~=)
				ok@ "IOCachePageGet: weird return value from MmEvictablePageAlloc (%i)\n" KeCrash
			end
		end

		// weren't able to find a reusable page. try to allocate again,
		// but this time we can block.

		if (kflags@ IOKFLAG_SWAPOUT &)
			// this IOCachePageGet is needed for a swap-out operation
			// (i.e., the filesystem driver is using it to cache disk
			// structures and needs whatever is going to be read into
			// this page to know where to swap the page out to).

			MUSTSUCCEED CANBLOCK | kflags!
		end elseif (kflags@ IOKFLAG_URGENT &)
			MUSTSUCCEEDL2 CANBLOCK | kflags!
		end else
			CANBLOCK kflags!
		end

		if (filesize@ offset@ - PAGESIZE <)
			MMEVICTFLAG_WORKINGSET // flags
			MMEVICTTYPE_FILE // evictablefuncs
			ZEROMUST kflags@ | // priority
			MmEvictablePageAlloc ok! drop pfdbe!
		end else
			MMEVICTFLAG_WORKINGSET // flags
			MMEVICTTYPE_FILE // evictablefuncs
			FREEFIRST kflags@ | // priority
			MmEvictablePageAlloc ok! drop pfdbe!
		end

		if (ok@)
			if (kflags@ MUSTSUCCEED ==)
				// we needed this page for a swapout, system detonates.
				// this flag is also used for certain other situations
				// where an IO operation must succeed.
				"IOCachePageGet: failed to allocate page needed for swapout!\n" KeCrash
			end

			if (locked@ ~~)
				bucket@ // bucket
				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlockBucket

				cacheblock@ // cacheblock
				IOCacheInfoBlockUnlock
			end

			return
		end else
			HALCPUInterruptDisable rs!
			1 IOCachePagesUsed +=
			rs@ HALCPUInterruptRestore
		end
	end else
		HALCPUInterruptDisable rs!
		1 IOCachePagesUsed +=
		rs@ HALCPUInterruptRestore
	end

	0 pfdbe@ IOPageFrameEntryCache_Flags + !
	offset@ pfdbe@ IOPageFrameEntryCache_OffsetInFile + !
	fcb@ pfdbe@ IOPageFrameEntryCache_FCB + !
	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	0 pfdbe@ IOPageFrameEntryCache_NextCachePage + !

	IPLDPC KeIPLRaise ipl!

	pfdbe@ // pfdbe
	buckethead@ // buckethead
	IOCachePageInsert

	ipl@ KeIPLLower

	// account for this new reference

	0 // oldcount
	pfdbe@ // pfdbe
	IOCachePageReferenceFunction

	// no need to ref the page -- it gets ref'd on allocation by MmEvictablePageAlloc

	if (locked@ ~~)
		bucket@ // bucket
		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlockBucket

		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlock
	end

	pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!
end

fn IOCacheDumpInfo { cacheblock -- }
	auto i
	0 i!

	while (i@ IOCACHEPAGEBUCKETS <)
		auto buckethead
		cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + buckethead!

		auto pfdbe
		buckethead@@ pfdbe!

		buckethead@ 4 + @ buckethead@@ i@ "%d h=%x t=%x: " Printf

		while (pfdbe@)
			pfdbe@ IOPageFrameEntryCache_ReferencesI + gi "%d " Printf

			pfdbe@ IOPageFrameEntryCache_NextCachePage + @ pfdbe!
		end

		"\n" Printf

		1 i +=
	end
end

fn IOCachePageRemove { pfdbe buckethead -- }
	// remove from hash list.
	// assumes IPLDPC or equivalent.

	auto n
	pfdbe@ IOPageFrameEntryCache_NextCachePage + @ n!

	if (n@)
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no next means we were the tail
		pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ buckethead@ 4 + !
	end

	auto p
	pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ p!

	if (p@)
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ p@ IOPageFrameEntryCache_NextCachePage + !
	end else // no prev means we were the head
		pfdbe@ IOPageFrameEntryCache_NextCachePage + @ buckethead@!
	end

	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	0 pfdbe@ IOPageFrameEntryCache_NextCachePage + !
end

fn IOCachePageInsert { pfdbe buckethead -- }
	// insert into hash list on the recently-used end.
	// assumes IPLDPC or equivalent.

	auto n
	buckethead@@ n!

	0 pfdbe@ IOPageFrameEntryCache_PrevCachePage + !
	n@ pfdbe@ IOPageFrameEntryCache_NextCachePage + !

	if (n@)
		pfdbe@ n@ IOPageFrameEntryCache_PrevCachePage + !
	end else // no head, set tail
		pfdbe@ buckethead@ 4 + !
	end

	pfdbe@ buckethead@!
end

fn (MmReferenceFunction) IOCachePageReferenceFunction { oldcount pfdbe -- }
	// keep track of a global refcount for the cache block.
	// this is done so that there's a fast way to tell whether
	// a file can be truncated.

	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	cacheblock@ // cacheblock
	IOCacheInfoBlockReference drop
end

fn (MmDereferenceFunction) IOCachePageDereferenceFunction { oldcount pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	cacheblock@ // cacheblock
	IOCacheInfoBlockDereference drop
end

fn (MmEvictionFunction) IOCachePageEvictionFunction { pfdbe -- }
	auto cacheblock
	pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto offset
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ offset!

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	auto buckethead
	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + bucket@ 3 << + buckethead!

	// remove from hash list

	pfdbe@ // pfdbe
	buckethead@ // buckethead
	IOCachePageRemove

	1 IOCachePagesUsed -=
end

fn IOCachePageWrite { kflags pfdbe -- ok }
	// assumes caller referenced the page

	auto rs
	HALCPUInterruptDisable rs!

	if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED & ~~)
		// page is already clean, nothing to do but report success.

		rs@ HALCPUInterruptRestore

		0 ok!

		return
	end

	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED ~ &
	pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb

	rs@ HALCPUInterruptRestore

	KeThreadCurrent@ KeThreadIgnoreKill drop

	auto fcb
	pfdbe@ IOPageFrameEntryCache_FCB + @ fcb!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	auto off
	pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ off!

	// perform the write operation

	auto mdl
	MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

	KERNELMODE // mode
	PAGESIZE // length
	pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | // vaddr
	mdl@ // mdl
	MmMDLInitialize

	0 // flags
	kflags@ // kflags
	off@ // offset
	mdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok! drop

	KeThreadCurrent@ KeThreadAcceptKill drop
end

fn IOCachePageRead { flags kflags offset fcb -- pageframe pfdbe ok }
	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (DEBUGCHECKS)
		if (cacheblock@ ~~)
			"IOCachePageRead: attempt to perform cached page read from noncached file\n" KeCrash
		end
	end

	cacheblock@ IOCacheInfoBlockLockShared ok!

	if (ok@)
		return
	end

	auto bucket
	offset@ PAGESHIFT >> IOCACHEPAGEMASK & bucket!

	bucket@ // bucket
	cacheblock@ // cacheblock
	IOCacheInfoBlockLockBucket ok!

	if (ok@)
		cacheblock@ IOCacheInfoBlockUnlock

		return
	end

	kflags@ // kflags
	1 // locked
	offset@ // offset
	fcb@ // fcb
	IOCachePageGet ok! pfdbe! pageframe!

	if (ok@)
		bucket@ // bucket
		cacheblock@ // cacheblock
		IOCacheInfoBlockUnlockBucket

		cacheblock@ IOCacheInfoBlockUnlock

		return
	end

	if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_VALID & ~~)
		// this cache page is invalid and needs to be read in

		auto readfunc
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

		if (DEBUGCHECKS)
			if (readfunc@ ~~)
				"IOCachePageRead: no read function\n" KeCrash
			end
		end

		// perform the read operation

		auto mdl
		MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

		KERNELMODE // mode
		PAGESIZE // length
		pageframe@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		kflags@ // kflags
		offset@ PAGENUMBERMASK & // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok! drop

		if (ok@)
			// read failed

			pfdbe@ MmEvictablePageDereference drop

			bucket@ // bucket
			cacheblock@ // cacheblock
			IOCacheInfoBlockUnlockBucket

			cacheblock@ IOCacheInfoBlockUnlock

			return
		end

		// read succeeded, page is now valid

		IOCACHEPAGEFLAG_VALID pfdbe@ IOPageFrameEntryCache_Flags + |=
	end

	bucket@ // bucket
	cacheblock@ // cacheblock
	IOCacheInfoBlockUnlockBucket

	cacheblock@ IOCacheInfoBlockUnlock
end