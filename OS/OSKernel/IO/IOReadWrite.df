//
// Implements the file IO entrypoints.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOFileTruncate { newsize growing handle -- oldsize ok }
	auto fileobject
	auto access

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	newsize@ // newsize
	growing@ // growing
	0 // keeplocked
	1 // zero
	fileobject@ IOFile_FileControlBlock + @ // fcb
	IOFileControlBlockTruncate ok! oldsize!

	if (ok@ ~~)
		auto pokefunc
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Poke + @ pokefunc!

		if (pokefunc@)
			// notify driver that the FCB was truncated so it can update
			// timestamps etc.

			IOPOKE_WRITE // poketype
			fileobject@ IOFile_FileControlBlock + @ // fcb
			pokefunc@ IODispatchPoke
		end
	end

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileSeek { offset handle mode -- newoffset ok }
	if (mode@ 0 ==)
		STATUS_INVALID_ARGUMENT ok!
		return
	end elseif (mode@ OSSEEK_END >)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	auto fileobject

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! drop

	if (ok@)
		return
	end

	offset@ // offset
	fileobject@ // fileobject
	mode@ // mode
	IOFileSeekObject ok! newoffset!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileSeekObject { offset fileobject mode -- newoffset ok }
	0 ok!

	fileobject@ IOFile_Offset + @ newoffset!

	if (mode@ OSSEEK_CUR ==)
		offset@ newoffset +=
	end elseif (mode@ OSSEEK_END ==)
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_SizeInBytes + @ offset@ + newoffset!
	end elseif (mode@ OSSEEK_SET ==)
		offset@ newoffset!
	end else
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	newoffset@ fileobject@ IOFile_Offset + !
end

fn IOFileRead { timeout flags length buffer filehandle -- bytesread ok }
	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	timeout@ // timeout
	flags@ // flags
	length@ // length
	buffer@ // buffer
	fileobject@ // fileobject
	KeProcessCurrent // process
	IOFileReadObject ok! bytesread!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileReadObject { timeout flags length buffer fileobject process -- bytesread ok }
	if (process@ PsSystemProcess@ ==)
		0 process!
	end

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IOFileReadProcess: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IOFileReadProcess: file object had no dispatch table\n" KeCrash
		end
	end

	auto readfunc
	dispatchtable@ IODispatchTable_Read + @ readfunc!

	if (readfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto fileflags
	fileobject@ IOFile_Flags + @ fileflags!

	0 bytesread!

	auto lastmode

	if (process@ ~~)
		// no process provided to read into. therefore, we must be reading directly into
		// system space.

		if (buffer@ MMLOWESTSYSTEMADDRESS <)
			"IOFileReadProcess: buffer was not in system space\n" KeCrash
		end

		KERNELMODE lastmode!
	end else
		// do these checks first to make sure no overflow
		if (buffer@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end elseif (length@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		if (buffer@ length@ + MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		USERMODE lastmode!
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
		// always bypass cache for character devices -- call directly into driver.

		if (DEBUGCHECKS)
			if (cacheblock@)
				"IOFileReadProcess: file was character device, but is cached?\n" KeCrash
			end
		end

		timeout@ // timeout
		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		readfunc@ IODispatchReadFunction ok! bytesread!

		HALCPUInterruptDisable rs!
		bytesread@ fileobject@ IOFile_Offset + +=
		rs@ HALCPUInterruptRestore

		return
	end

	auto rs

	if (fileflags@ OSFILEFLAG_NOCACHE &)
		HALCPUInterruptDisable rs!

		fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

		if (cacheblock@ ~~)
			1 fcb@ IOFileControlBlock_UncachedIOCount + +=

			rs@ HALCPUInterruptRestore
		end else
			rs@ HALCPUInterruptRestore

			0 // wantcaching
			fcb@ // fcb
			IOFileControlBlockCacheCheck ok! cacheblock!

			if (ok@)
				return
			end
		end
	end elseif (cacheblock@ ~~)
		1 // wantcaching
		fcb@ // fcb
		IOFileControlBlockCacheCheck ok! cacheblock!

		if (ok@)
			return
		end
	end

	fcb@ // fcb
	IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	if (cacheblock@ ~~)
		// no caching -- call directly into driver.

		timeout@ // timeout
		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		readfunc@ IODispatchReadFunction ok! bytesread!

		HALCPUInterruptDisable rs!
		1 fcb@ IOFileControlBlock_UncachedIOCount + -=
		rs@ HALCPUInterruptRestore
	end else
		// caching -- call into cache read function.

		flags@ // flags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		IOCacheFileRead ok! bytesread!
	end

	fcb@ IOFileControlBlockUnlock

	HALCPUInterruptDisable rs!
	bytesread@ fileobject@ IOFile_Offset + +=
	rs@ HALCPUInterruptRestore

	auto pokefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Poke + @ pokefunc!

	if (pokefunc@)
		// notify driver that the FCB was read so it can update timestamps
		// etc.

		IOPOKE_READ // poketype
		fcb@ // fcb
		pokefunc@ IODispatchPoke
	end
end

fn IOFileWrite { flags length buffer filehandle -- byteswritten ok }
	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	flags@ // flags
	length@ // length
	buffer@ // buffer
	fileobject@ // fileobject
	KeProcessCurrent // process
	IOFileWriteObject ok! byteswritten!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileWriteObject { flags length buffer fileobject process -- byteswritten ok }
	if (process@ PsSystemProcess@ ==)
		0 process!
	end

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IOFileWriteProcess: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IOFileWriteProcess: file object had no dispatch table\n" KeCrash
		end
	end

	auto writefunc
	dispatchtable@ IODispatchTable_Write + @ writefunc!

	if (writefunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto fileflags
	fileobject@ IOFile_Flags + @ fileflags!

	0 byteswritten!

	auto lastmode

	if (process@ ~~)
		// no process provided to read into. therefore, we must be reading directly into
		// system space.

		if (buffer@ MMLOWESTSYSTEMADDRESS <)
			"IOFileWriteProcess: buffer was not in system space\n" KeCrash
		end

		KERNELMODE lastmode!
	end else
		// do these checks first to make sure no overflow
		if (buffer@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end elseif (length@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		if (buffer@ length@ + MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		USERMODE lastmode!
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
		// always bypass cache for character devices -- call directly into driver.

		if (DEBUGCHECKS)
			if (cacheblock@)
				"IOFileWriteProcess: file was character device, but is cached?\n" KeCrash
			end
		end

		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		writefunc@ IODispatchWriteFunction ok! byteswritten!

		HALCPUInterruptDisable rs!
		byteswritten@ fileobject@ IOFile_Offset + +=
		rs@ HALCPUInterruptRestore

		return
	end

	auto rs

	if (fileflags@ OSFILEFLAG_NOCACHE &)
		HALCPUInterruptDisable rs!

		fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

		if (cacheblock@ ~~)
			1 fcb@ IOFileControlBlock_UncachedIOCount + +=

			rs@ HALCPUInterruptRestore
		end else
			rs@ HALCPUInterruptRestore

			0 // wantcaching
			fcb@ // fcb
			IOFileControlBlockCacheCheck ok! cacheblock!

			if (ok@)
				return
			end
		end
	end elseif (cacheblock@ ~~)
		1 // wantcaching
		fcb@ // fcb
		IOFileControlBlockCacheCheck ok! cacheblock!

		if (ok@)
			return
		end
	end

	fcb@ // fcb
	IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	if (cacheblock@ ~~)
		// no caching -- call directly into driver.

		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		writefunc@ IODispatchWriteFunction ok! byteswritten!

		HALCPUInterruptDisable rs!
		1 fcb@ IOFileControlBlock_UncachedIOCount + -=
		rs@ HALCPUInterruptRestore

		fcb@ IOFileControlBlockUnlock
	end else
		// caching -- call into cache write function.

		flags@ // flags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		IOCacheFileWrite ok! byteswritten!

		// IOCacheFileWrite is responsible for unlocking the FCB now.
		// fcb@ IOFileControlBlockUnlock
	end

	HALCPUInterruptDisable rs!
	byteswritten@ fileobject@ IOFile_Offset + +=
	rs@ HALCPUInterruptRestore

	auto pokefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Poke + @ pokefunc!

	if (pokefunc@)
		// notify driver that the FCB was modified so it can update timestamps
		// etc.

		IOPOKE_WRITE // poketype
		fcb@ // fcb
		pokefunc@ IODispatchPoke
	end
end

fn IODirectoryRename { srcname srcfilehandle destname destfilehandle -- ok }
	auto access
	auto srcfileobject

	IOFileTypeObject@ // type
	srcfilehandle@ // handle
	ObObjectReferenceByHandle ok! srcfileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE ACCESS_EXEC | SeCheckAccess ok!

	if (ok@)
		srcfileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto destfileobject

	if (srcfilehandle@ destfilehandle@ ==)
		// small optimization, don't ref a second time if they're the same.
		srcfileobject@ destfileobject!
	end else
		IOFileTypeObject@ // type
		destfilehandle@ // handle
		ObObjectReferenceByHandle ok! destfileobject! access!

		if (ok@)
			srcfileobject@ ObObjectDereferenceByPointer drop

			return
		end

		access@ ACCESS_WRITE ACCESS_EXEC | SeCheckAccess ok!

		if (ok@)
			destfileobject@ ObObjectDereferenceByPointer drop
			srcfileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end

	srcname@ // srcname
	srcfileobject@ // srcfileobject
	destname@ // destname
	destfileobject@ // destfileobject
	IODirectoryRenameObject ok!

	if (srcfilehandle@ destfilehandle@ ~=)
		destfileobject@ ObObjectDereferenceByPointer drop
	end

	srcfileobject@ ObObjectDereferenceByPointer drop
end

fn IODirectoryRenameObject { srcname srcfileobject destname destfileobject -- ok }
	auto srcfcb
	auto destfcb
	auto dispatchtable

	destfileobject@ IOFile_FileControlBlock + @ destfcb!

	srcfileobject@ IOFile_FileControlBlock + @ srcfcb!

	srcfcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (destfcb@ IOFileControlBlock_DispatchTable + @ dispatchtable@ ~=)
		STATUS_CROSS_VOLUME ok!

		return
	end

	auto renamefunc
	dispatchtable@ IODispatchTable_Rename + @ renamefunc!

	if (renamefunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	// some sanity checks for silly situations that the FS driver shouldn't
	// have to worry about

	if (srcfcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (destfcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (srcfcb@ destfcb@ ==)
		if (srcname@ destname@ strcmp)
			0 ok!
			return
		end
	end

	// make sure the directory fcbs have cacheblocks

	if (srcfcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		1 // wantcaching
		srcfcb@ // fcb
		IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	if (destfcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		1 // wantcaching
		destfcb@ // fcb
		IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	srcfcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	if (srcfcb@ destfcb@ ~=)
		destfcb@ IOFileControlBlockLock ok!

		if (ok@)
			srcfcb@ IOFileControlBlockUnlock

			return
		end
	end

	srcname@ // srcname
	srcfcb@ // srcfcb
	destname@ // destname
	destfcb@ // destfcb
	renamefunc@ IODispatchRenameFunction ok!

	if (srcfcb@ destfcb@ ~=)
		destfcb@ IOFileControlBlockUnlock
	end

	srcfcb@ IOFileControlBlockUnlock

	if (ok@ ~~)
		auto pokefunc
		dispatchtable@ IODispatchTable_Poke + @ pokefunc!

		if (pokefunc@)
			// notify driver that the FCBs were messed with so it can update
			// timestamps etc.

			IOPOKE_WRITE // poketype
			srcfcb@ // fcb
			pokefunc@ IODispatchPoke

			IOPOKE_WRITE // poketype
			destfcb@ // fcb
			pokefunc@ IODispatchPoke
		end
	end
end

fn IODirectoryUnlink { name filehandle -- ok }
	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE ACCESS_EXEC | SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	name@ // name
	fileobject@ // fileobject
	IODirectoryUnlinkObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IODirectoryUnlinkObject { name fileobject -- ok }
	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IODirectoryUnlinkObject: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IODirectoryUnlinkObject: file object had no dispatch table\n" KeCrash
		end
	end

	auto unlinkfunc
	dispatchtable@ IODispatchTable_Unlink + @ unlinkfunc!

	if (unlinkfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		// make sure the directory fcb has a cacheblock

		1 // wantcaching
		fcb@ // fcb
		IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	name@ // name
	fcb@ // dirfcb
	unlinkfunc@ IODispatchUnlinkFunction ok!

	fcb@ IOFileControlBlockUnlock

	if (ok@ ~~)
		auto pokefunc
		dispatchtable@ IODispatchTable_Poke + @ pokefunc!

		if (pokefunc@)
			// notify driver that the FCBs were messed with so it can update
			// timestamps etc.

			IOPOKE_WRITE // poketype
			fcb@ // fcb
			pokefunc@ IODispatchPoke
		end
	end
end

fn IODirectoryRead { dirent filehandle -- ok }
	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	dirent@ // dirent
	fileobject@ // fileobject
	IODirectoryReadObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IODirectoryReadObject { dirent fileobject -- ok }
	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IODirectoryReadObject: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IODirectoryReadObject: file object had no dispatch table\n" KeCrash
		end
	end

	auto readfunc
	dispatchtable@ IODispatchTable_ReadDirectory + @ readfunc!

	if (readfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		1 // wantcaching
		fcb@ // fcb
		IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	fcb@ IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	fileobject@ IOFile_Offset + @ // seek
	dirent@ // dirent
	fcb@ // fcb
	readfunc@ IODispatchReadDirectoryFunction ok! fileobject@ IOFile_Offset + !

	fcb@ IOFileControlBlockUnlock

	if (ok@ ~~)
		auto pokefunc
		dispatchtable@ IODispatchTable_Poke + @ pokefunc!

		if (pokefunc@)
			// notify driver that the FCBs were messed with so it can update
			// timestamps etc.

			IOPOKE_READ // poketype
			fcb@ // fcb
			pokefunc@ IODispatchPoke
		end
	end
end