//
// Implements the file IO entrypoints.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOFileFlush { purge filehandle -- ok }
	fnsection "PAGE$text"

	auto fileobject
	auto access

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	if (access@ ACCESS_WRITE ACCESS_READ | & ~~)
		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_PERMISSION_DENIED ok!

		return
	end

	purge@ fileobject@ IOFileFlushObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileFlushObject { purge fileobject -- ok }
	fnsection "PAGE$text"

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (cacheblock@ ~~)
		// no cacheblock, nothing to do

		fcb@ IOFileControlBlockUnlock

		return
	end

	if (purge@)
		0 // newsize
		1 // writeout
		cacheblock@ // cacheblock
		IOCacheInfoBlockTruncate ok!
	end else
		cacheblock@ IOCacheInfoBlockFlush ok!
	end

	fcb@ IOFileControlBlockUnlock
end

fn IOFileTruncate { newsize growing handle -- oldsize ok }
	fnsection "PAGE$text"

	auto fileobject
	auto access

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_SYSTEMFILE &)
		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_FORBIDDEN_OPERATION ok!

		return
	end

	if (fileobject@ IOFile_Flags + @ OSFILEFLAG_NOCACHE & ~~)
		if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ~=)
			// try to initiate caching to make truncation more efficient

			fcb@ IOFileControlBlockCacheCheck drop drop
		end
	end

	newsize@ // newsize
	growing@ // growing
	0 // keeplocked
	1 // zero
	fileobject@ IOFile_Flags + @ // flags
	fcb@ // fcb
	IOFileControlBlockTruncate ok! oldsize!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileSeek { offset handle mode -- newoffset ok }
	fnsection "PAGE$text"

	if (mode@ 0 ==)
		STATUS_INVALID_ARGUMENT ok!
		return
	end elseif (mode@ OSSEEK_END >)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	auto fileobject

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! drop

	if (ok@)
		return
	end

	offset@ // offset
	fileobject@ // fileobject
	mode@ // mode
	IOFileSeekObject ok! newoffset!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileSeekObject { offset fileobject mode -- newoffset ok }
	fnsection "PAGE$text"

	0 ok!

	fileobject@ IOFile_Offset + @ newoffset!

	if (mode@ OSSEEK_CUR ==)
		offset@ newoffset +=
	end elseif (mode@ OSSEEK_END ==)
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_SizeInBytes + @ offset@ + newoffset!
	end elseif (mode@ OSSEEK_SET ==)
		offset@ newoffset!
	end else
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	newoffset@ fileobject@ IOFile_Offset + !
end

fn IOFileRead { timeout flags length buffer filehandle -- bytesread ok }
	fnsection "PAGE$text"

	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	timeout@ // timeout
	flags@ // flags
	length@ // length
	buffer@ // buffer
	fileobject@ // fileobject
	KeProcessCurrent // process
	IOFileReadObject ok! bytesread!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileReadObject { timeout flags length buffer fileobject process -- bytesread ok }
	fnsection "PAGE$text"

	if (process@ PsSystemProcess@ ==)
		0 process!
	end

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IOFileReadProcess: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IOFileReadProcess: file object had no dispatch table\n" KeCrash
		end
	end

	auto readfunc
	dispatchtable@ IODispatchTable_Read + @ readfunc!

	if (readfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	auto fileflags
	fileobject@ IOFile_Flags + @ fileflags!

	if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_SYSTEMFILE &)
		if (fileflags@ OSFILEFLAG_NOCACHE & ~~)
			STATUS_FORBIDDEN_OPERATION ok!

			return
		end
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	0 bytesread!

	auto lastmode

	if (process@ ~~)
		// no process provided to read into. therefore, we must be reading
		// directly into system space.

		if (buffer@ MMLOWESTSYSTEMADDRESS <)
			"IOFileReadProcess: buffer was not in system space\n" KeCrash
		end

		KERNELMODE lastmode!
	end else
		// do these checks first to make sure no overflow
		if (buffer@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end elseif (length@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		if (buffer@ length@ + MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		USERMODE lastmode!
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
		// always bypass cache for character devices -- call directly into driver.

		if (DEBUGCHECKS)
			if (cacheblock@)
				"IOFileReadProcess: file was character device, but is cached?\n" KeCrash
			end
		end

		timeout@ // timeout
		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		0 // write
		IOReadWrite ok! bytesread!

		bytesread@ fileobject@ IOFile_Offset + KeInterlockedIncrement drop

		return
	end

	auto rs

	if (fileflags@ OSFILEFLAG_NOCACHE & ~~)
		if (cacheblock@ ~~)
			fcb@ IOFileControlBlockCacheCheck ok! cacheblock!

			if (ok@)
				return
			end
		end
	end else
		0 cacheblock!
	end

	fcb@ // fcb
	IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	if (cacheblock@ ~~)
		// no caching -- call directly into driver.

		timeout@ // timeout
		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		0 // write
		IOReadWrite ok! bytesread!
	end else
		// caching -- call into cache read function.

		flags@ // flags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		IOCacheFileRead ok! bytesread!
	end

	fcb@ IOFileControlBlockUnlock

	bytesread@ fileobject@ IOFile_Offset + KeInterlockedIncrement drop

	auto pokefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Poke + @ pokefunc!

	if (pokefunc@)
		// notify driver that the FCB was read so it can update timestamps
		// etc.

		IOPOKE_READ // poketype
		fileobject@ // object
		pokefunc@ IODispatchPokeFunction
	end
end

fn IOFileWrite { flags length buffer filehandle -- byteswritten ok }
	fnsection "PAGE$text"

	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	flags@ // flags
	length@ // length
	buffer@ // buffer
	fileobject@ // fileobject
	KeProcessCurrent // process
	IOFileWriteObject ok! byteswritten!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOFileWriteObject { flags length buffer fileobject process -- byteswritten ok }
	fnsection "PAGE$text"

	if (process@ PsSystemProcess@ ==)
		0 process!
	end

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IOFileWriteProcess: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IOFileWriteProcess: file object had no dispatch table\n" KeCrash
		end
	end

	auto writefunc
	dispatchtable@ IODispatchTable_Write + @ writefunc!

	if (writefunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_SYSTEMFILE &)
		STATUS_FORBIDDEN_OPERATION ok!

		return
	end

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	auto fileflags
	fileobject@ IOFile_Flags + @ fileflags!

	0 byteswritten!

	auto lastmode

	if (process@ ~~)
		// no process provided to read into. therefore, we must be writing
		// directly from system space.

		if (buffer@ MMLOWESTSYSTEMADDRESS <)
			"IOFileWriteProcess: buffer was not in system space\n" KeCrash
		end

		KERNELMODE lastmode!
	end else
		// do these checks first to make sure no overflow
		if (buffer@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end elseif (length@ MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		if (buffer@ length@ + MMHIGHESTUSERADDRESS >)
			STATUS_FAULT ok!

			return
		end

		USERMODE lastmode!
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_CHARDEVICE ==)
		// always bypass cache for character devices -- call directly into driver.

		if (DEBUGCHECKS)
			if (cacheblock@)
				"IOFileWriteProcess: file was character device, but is cached?\n" KeCrash
			end
		end

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		1 // write
		IOReadWrite ok! byteswritten!

		byteswritten@ fileobject@ IOFile_Offset + KeInterlockedIncrement drop

		return
	end

	auto rs

	if (fileflags@ OSFILEFLAG_NOCACHE & ~~)
		if (cacheblock@ ~~)
			fcb@ IOFileControlBlockCacheCheck ok! cacheblock!

			if (ok@)
				return
			end
		end
	end else
		0 cacheblock!
	end

	fcb@ // fcb
	IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	if (cacheblock@ ~~)
		// no caching -- call directly into driver.

		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		0 // kflags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		1 // write
		IOReadWrite ok! byteswritten!

		fcb@ IOFileControlBlockUnlock
	end else
		// caching -- call into cache write function.

		flags@ // flags
		length@ // length
		fileobject@ IOFile_Offset + @ // offset
		buffer@ // buffer
		fcb@ // fcb
		lastmode@ // lastmode
		IOCacheFileWrite ok! byteswritten!

		// IOCacheFileWrite is responsible for unlocking the FCB now.
		// fcb@ IOFileControlBlockUnlock
	end

	byteswritten@ fileobject@ IOFile_Offset + KeInterlockedIncrement drop

	auto pokefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Poke + @ pokefunc!

	if (pokefunc@)
		// notify driver that the FCB was modified so it can update timestamps
		// etc.

		IOPOKE_WRITE // poketype
		fileobject@ // object
		pokefunc@ IODispatchPokeFunction
	end
end

fn IODirectoryRename { srcname srcfilehandle destname destfilehandle -- ok }
	fnsection "PAGE$text"

	auto access
	auto srcfileobject

	IOFileTypeObject@ // type
	srcfilehandle@ // handle
	ObObjectReferenceByHandle ok! srcfileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE ACCESS_EXEC | SeCheckAccess ok!

	if (ok@)
		srcfileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto destfileobject

	if (srcfilehandle@ destfilehandle@ ==)
		// small optimization, don't ref a second time if they're the same.
		srcfileobject@ destfileobject!
	end else
		IOFileTypeObject@ // type
		destfilehandle@ // handle
		ObObjectReferenceByHandle ok! destfileobject! access!

		if (ok@)
			srcfileobject@ ObObjectDereferenceByPointer drop

			return
		end

		access@ ACCESS_WRITE ACCESS_EXEC | SeCheckAccess ok!

		if (ok@)
			destfileobject@ ObObjectDereferenceByPointer drop
			srcfileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end

	srcname@ // srcname
	srcfileobject@ // srcfileobject
	destname@ // destname
	destfileobject@ // destfileobject
	IODirectoryRenameObject ok!

	if (srcfilehandle@ destfilehandle@ ~=)
		destfileobject@ ObObjectDereferenceByPointer drop
	end

	srcfileobject@ ObObjectDereferenceByPointer drop
end

fn IODirectoryRenameObject { srcname srcfileobject destname destfileobject -- ok }
	fnsection "PAGE$text"

	auto srcfcb
	auto destfcb
	auto dispatchtable

	destfileobject@ IOFile_FileControlBlock + @ destfcb!

	srcfileobject@ IOFile_FileControlBlock + @ srcfcb!

	srcfcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (destfcb@ IOFileControlBlock_DispatchTable + @ dispatchtable@ ~=)
		// filter out renames across different filesystem drivers.
		// if the filesystem forbids renames across volumes, it needs to take
		// care of that.

		STATUS_CROSS_VOLUME ok!

		return
	end

	auto renamefunc
	dispatchtable@ IODispatchTable_Rename + @ renamefunc!

	if (renamefunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	// some sanity checks for silly situations that the FS driver shouldn't
	// have to worry about

	if (srcfcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (destfcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	// make sure the directory fcbs have cacheblocks

	if (srcfcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		srcfcb@ IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	if (destfcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		destfcb@ IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	srcfcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	if (srcfcb@ destfcb@ ~=)
		destfcb@ IOFileControlBlockLock ok!

		if (ok@)
			srcfcb@ IOFileControlBlockUnlock

			return
		end
	end

	srcname@ // srcname
	srcfcb@ // srcfcb
	destname@ // destname
	destfcb@ // destfcb
	renamefunc@ IODispatchRenameFunction ok!

	if (srcfcb@ destfcb@ ~=)
		destfcb@ IOFileControlBlockUnlock
	end

	srcfcb@ IOFileControlBlockUnlock
end

fn IODirectoryUnlink { name filehandle -- ok }
	fnsection "PAGE$text"

	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE ACCESS_EXEC | SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	name@ // name
	fileobject@ // fileobject
	IODirectoryUnlinkObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IODirectoryUnlinkObject { name fileobject -- ok }
	fnsection "PAGE$text"

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IODirectoryUnlinkObject: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IODirectoryUnlinkObject: file object had no dispatch table\n" KeCrash
		end
	end

	auto unlinkfunc
	dispatchtable@ IODispatchTable_Unlink + @ unlinkfunc!

	if (unlinkfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		// make sure the directory fcb has a cacheblock

		fcb@ IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	name@ // name
	fcb@ // dirfcb
	unlinkfunc@ IODispatchUnlinkFunction ok!

	fcb@ IOFileControlBlockUnlock
end

fn IODirectoryRead { dirent filehandle -- ok }
	fnsection "PAGE$text"

	auto access
	auto fileobject

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_READ SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	dirent@ // dirent
	fileobject@ // fileobject
	IODirectoryReadObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IODirectoryReadObject { dirent fileobject -- ok }
	fnsection "PAGE$text"

	auto fcb
	auto dispatchtable

	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ 0 ==)
			"IODirectoryReadObject: file object had no FCB\n" KeCrash
		end
	end

	fcb@ IOFileControlBlock_DispatchTable + @ dispatchtable!

	if (DEBUGCHECKS)
		if (dispatchtable@ 0 ==)
			"IODirectoryReadObject: file object had no dispatch table\n" KeCrash
		end
	end

	auto readfunc
	dispatchtable@ IODispatchTable_ReadDirectory + @ readfunc!

	if (readfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		fcb@ IOFileControlBlockCacheCheck ok! drop

		if (ok@)
			return
		end
	end

	fcb@ IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	fileobject@ IOFile_Offset + @ // seek
	dirent@ // dirent
	fcb@ // fcb
	readfunc@ IODispatchReadDirectoryFunction ok! fileobject@ IOFile_Offset + !

	fcb@ IOFileControlBlockUnlock
end