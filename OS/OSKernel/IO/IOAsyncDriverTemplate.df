//
// Implements a template for asynchronous character devices.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

// must be <=32 bytes to fit in the MDL DriverGoWild area
struct IOAsyncCharacterRequest
	4 Next
	4 Prev

	4 Flags
	4 MDL
	4 Buffer
	4 Length
	4 Header
	4 LengthDone
endstruct

const REQFLAG_WRITE 1

fn IOAsyncDeviceInitialize { context txfunc rxfunc rxsizelog pri header -- ok }
	rxsizelog@ // sizelog
	0 // quotablock
	pri@ // pri
	header@ IOAsyncDeviceHeader_ReceiveBuffer + // header
	IOTypeaheadBufferInitialize ok!

	if (ok@)
		return
	end

	txfunc@ header@ IOAsyncDeviceHeader_TXFunc + !
	rxfunc@ header@ IOAsyncDeviceHeader_RXFunc + !
	context@ header@ IOAsyncDeviceHeader_Context + !

	0 header@ IOAsyncDeviceHeader_RequestListHead + !
	0 header@ IOAsyncDeviceHeader_RequestListTail + !
end

fn (DPCFunction) IOAsyncDPCFunction { context1 context2 -- }
	auto currentreq
	context1@ IOAsyncDeviceHeader_RequestListHead + @ currentreq!

	auto completed
	0 completed!

	auto ok

	while (1)
		auto c
		context1@ // header
		context1@ IOAsyncDeviceHeader_RXFunc + @ IOAsyncRXFunc ok! bytes! c!

		if (ok@)
			break
		end

		bytes@ // bytestocopy
		c@ // buf
		context1@ IOAsyncDeviceHeader_ReceiveBuffer + // header
		IOTypeaheadBufferCopyIn ok! drop

		if (currentreq@)
			if (currentreq@ IOAsyncCharacterRequest_Flags + @ REQFLAG_WRITE & ~~)
				bytes@ currentreq@ IOAsyncCharacterRequest_LengthDone + +=
			end
		end

		if (ok@ STATUS_OTHER_CONDITION ==)
			if (DEBUGCHECKS)
				if (currentreq@ ~~)
					"IOAsyncDPCFunction: no read request\n" KeCrash
				end

				if (currentreq@ IOAsyncCharacterRequest_Flags + @ REQFLAG_WRITE &)
					"IOAsyncDPCFunction: not a read request\n" KeCrash
				end
			end

			currentreq@ IOAsyncCharacterRequest_LengthDone + @ currentreq@ IOAsyncCharacterRequest_MDL + @ MmMDLHeader_Length + !

			1 completed!
		end
	end

	auto bytes

	auto len
	auto buf

	if (currentreq@)
		if (currentreq@ IOAsyncCharacterRequest_Flags + @ REQFLAG_WRITE &)
			currentreq@ IOAsyncCharacterRequest_Length + @ len!
			currentreq@ IOAsyncCharacterRequest_Buffer + @ buf!

			while (len@)
				buf@ // buf
				context1@ // header
				context1@ IOAsyncDeviceHeader_TXFunc + @ IOAsyncTXFunc ok! bytes!

				if (ok@)
					break
				end

				bytes@ buf +=
				bytes@ len -=
			end

			if (len@ ~~)
				1 completed!
			end

			buf@ currentreq@ IOAsyncCharacterRequest_Buffer + !
			len@ currentreq@ IOAsyncCharacterRequest_Length + !
		end
	end

	while (completed@)
		0 completed!

		0 // status
		IOBOOSTCONSOLE // priboost
		currentreq@ IOAsyncCharacterRequest_MDL + @ // mdl
		MmMDLComplete

		currentreq@ IOAsyncCharacterRequest_Next + @ currentreq!

		currentreq@ context1@ IOAsyncDeviceHeader_RequestListHead + !

		if (currentreq@ ~~)
			0 context1@ IOAsyncDeviceHeader_RequestListTail + !
			return
		end

		0 currentreq@ IOAsyncCharacterRequest_Prev + !

		// start next request

		if (currentreq@ IOAsyncCharacterRequest_Flags + @ REQFLAG_WRITE &)
			currentreq@ IOAsyncCharacterRequest_Length + @ len!
			currentreq@ IOAsyncCharacterRequest_Buffer + @ buf!

			while (len@)
				buf@ // buf
				context1@ // header
				context1@ IOAsyncDeviceHeader_TXFunc + @ IOAsyncTXFunc ok! bytes!

				if (ok@)
					break
				end

				bytes@ buf +=
				bytes@ len -=
			end

			if (len@ ~~)
				// managed to write everything.

				1 completed!

				continue
			end

			len@ currentreq@ IOAsyncCharacterRequest_Length + !
			buf@ currentreq@ IOAsyncCharacterRequest_Buffer + !
		end else
			currentreq@ IOAsyncCharacterRequest_Length + @ len!
			currentreq@ IOAsyncCharacterRequest_Buffer + @ buf!

			auto read
			len@ // bytestocopy
			buf@ // buf
			1 // switch
			context1@ IOAsyncDeviceHeader_ReceiveBuffer + // header
			IOTypeaheadBufferCopyOut ok! read!

			read@ len -=

			if (ok@ ~~)
				read@ currentreq@ IOAsyncCharacterRequest_MDL + @ MmMDLHeader_Length + !

				1 completed!

				continue
			end

			if (DEBUGCHECKS)
				if (ok@ STATUS_OTHER_CONDITION ~=)
					ok@ "IOAsyncDPCFunction: odd %i\n" KeCrash
				end
			end

			len@ currentreq@ IOAsyncCharacterRequest_Length + !
			buf@ read@ + currentreq@ IOAsyncCharacterRequest_Buffer + !
		end
	end
end

fn IOAsyncDeviceRead { timeout flags kflags offset mdl header -- ok }
	0 // lockforwrite
	mdl@ // mdl
	MmMDLPin ok!

	if (ok@)
		return
	end

	auto buf

	if (mdl@ MmMDLHeader_Pages + @ 1 >)
		mdl@ MmMDLMap ok!

		if (ok@)
			mdl@ MmMDLUnpin

			return
		end

		mdl@ MmMDLHeader_MappedAddress + @ buf!
	end else
		// only one page, copy thru identityspace as a time saver
		mdl@ MmMDLHeader_SIZEOF + @ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE |
		mdl@ MmMDLHeader_VirtualAddress + @ PAGEOFFSETMASK & + buf!
	end

	auto len
	mdl@ MmMDLHeader_Length + @ len!

	auto ior
	mdl@ MmMDLHeader_DriverGoWild + ior!

	0       ior@ IOAsyncCharacterRequest_Next + !
	0       ior@ IOAsyncCharacterRequest_Prev + !
	mdl@    ior@ IOAsyncCharacterRequest_MDL + !
	0       ior@ IOAsyncCharacterRequest_Flags + !
	buf@    ior@ IOAsyncCharacterRequest_Buffer + !
	len@    ior@ IOAsyncCharacterRequest_Length + !
	header@ ior@ IOAsyncCharacterRequest_Header + !
	0       ior@ IOAsyncCharacterRequest_LengthDone + !

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto t
	header@ IOAsyncDeviceHeader_RequestListTail + @ t!

	if (t@ ~~)
		// no requests, enqueue our request and then read as many characters
		// as possible.

		auto read
		len@ // bytestocopy
		buf@ // buf
		timeout@ 0 ~= // switch
		header@ IOAsyncDeviceHeader_ReceiveBuffer + // header
		IOTypeaheadBufferCopyOut ok! read!

		read@ len -=

		if (ok@ STATUS_OTHER_CONDITION ~=)
			ipl@ KeIPLLower

			if (ok@ STATUS_RING_EMPTY ==)
				if (read@)
					0 ok!
				end
			end

			read@ mdl@ MmMDLHeader_Length + !

			if (ok@ ~~)
				0 // status
				IOBOOSTCONSOLE // priboost
				mdl@ // mdl
				MmMDLComplete
			end

			return
		end

		read@ ior@ IOAsyncCharacterRequest_LengthDone + !
		len@ ior@ IOAsyncCharacterRequest_Length + !
		buf@ read@ + ior@ IOAsyncCharacterRequest_Buffer + !

		ior@ header@ IOAsyncDeviceHeader_RequestListTail + !
		ior@ header@ IOAsyncDeviceHeader_RequestListHead + !

		0 ok!
	end elseif (timeout@)
		// add our request to the tail of the queue.

		t@ ior@ IOAsyncCharacterRequest_Prev + !
		ior@ t@ IOAsyncCharacterRequest_Next + !
		ior@ header@ IOAsyncDeviceHeader_RequestListTail + !
	end else
		STATUS_RING_EMPTY ok!
	end

	ipl@ KeIPLLower
end

fn IOAsyncDeviceWrite { flags kflags offset mdl header -- ok }
	0 // lockforwrite
	mdl@ // mdl
	MmMDLPin ok!

	if (ok@)
		return
	end

	auto buf

	if (mdl@ MmMDLHeader_Pages + @ 1 >)
		mdl@ MmMDLMap ok!

		if (ok@)
			mdl@ MmMDLUnpin

			return
		end

		mdl@ MmMDLHeader_MappedAddress + @ buf!
	end else
		// only one page, copy thru identityspace as a time saver
		mdl@ MmMDLHeader_SIZEOF + @ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE |
		mdl@ MmMDLHeader_VirtualAddress + @ PAGEOFFSETMASK & + buf!
	end

	auto len
	mdl@ MmMDLHeader_Length + @ len!

	auto ior
	mdl@ MmMDLHeader_DriverGoWild + ior!

	0             ior@ IOAsyncCharacterRequest_Next + !
	0             ior@ IOAsyncCharacterRequest_Prev + !
	mdl@          ior@ IOAsyncCharacterRequest_MDL + !
	REQFLAG_WRITE ior@ IOAsyncCharacterRequest_Flags + !
	buf@          ior@ IOAsyncCharacterRequest_Buffer + !
	len@          ior@ IOAsyncCharacterRequest_Length + !
	header@       ior@ IOAsyncCharacterRequest_Header + !
	0             ior@ IOAsyncCharacterRequest_LengthDone + !

	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto t
	header@ IOAsyncDeviceHeader_RequestListTail + @ t!

	if (t@ ~~)
		// no requests, enqueue our request and then write as many characters
		// as possible.

		while (len@)
			auto bytes
			buf@ // buf
			header@ // header
			header@ IOAsyncDeviceHeader_TXFunc + @ IOAsyncTXFunc ok! bytes!

			if (ok@)
				0 ok!
				break
			end

			bytes@ buf +=
			bytes@ len -=
		end

		if (len@ ~~)
			// managed to write everything.

			ipl@ KeIPLLower

			0 // status
			IOBOOSTCONSOLE // priboost
			mdl@ // mdl
			MmMDLComplete

			return
		end

		buf@ ior@ IOAsyncCharacterRequest_Buffer + !
		len@ ior@ IOAsyncCharacterRequest_Length + !

		ior@ header@ IOAsyncDeviceHeader_RequestListTail + !
		ior@ header@ IOAsyncDeviceHeader_RequestListHead + !
	end else
		// add our request to the tail of the queue.

		t@ ior@ IOAsyncCharacterRequest_Prev + !
		ior@ t@ IOAsyncCharacterRequest_Next + !
		ior@ header@ IOAsyncDeviceHeader_RequestListTail + !
	end

	ipl@ KeIPLLower
end

fn (IODispatchCancelFunction) IOAsyncDriverCancel { mdl -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto ior
	mdl@ MmMDLHeader_DriverGoWild + ior!

	if (mdl@ MmMDLHeader_Flags + @ MMMDL_COMPLETE &)
		// already completed, nothing to do
		ipl@ KeIPLLower
		return
	end

	auto header
	ior@ IOAsyncCharacterRequest_Header + @ header!

	if (ior@ IOAsyncCharacterRequest_Flags + @ REQFLAG_WRITE & ~~)
		header@ IOAsyncDeviceHeader_ReceiveBuffer + IOTypeaheadBufferComplete drop
	end

	auto ls
	ior@ IOAsyncCharacterRequest_Prev + @ ls!

	auto ns
	ior@ IOAsyncCharacterRequest_Next + @ ns!

	if (ls@)
		ns@ ls@ IOAsyncCharacterRequest_Next + !
	end else
		ns@ header@ IOAsyncDeviceHeader_RequestListHead + !
	end

	if (ns@)
		ls@ ns@ IOAsyncCharacterRequest_Prev + !
	end else
		ls@ header@ IOAsyncDeviceHeader_RequestListTail + !
	end

	ipl@ KeIPLLower

	STATUS_IO_CANCELLED // status
	0 // priboost
	mdl@ // mdl
	MmMDLComplete
end