//
// Implements pagefile management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Transfer.h"

#include "<ll>/OSDLL/OS.h"

#include "IOInternal.h"

#include "../../Common/Common.h"

extern MmMPWAssessTransfers { transfersize transfer1 -- }

var IOSwapPagesUsed 0
public IOSwapPagesUsed

var IOSwapPagesCount 0
public IOSwapPagesCount

var IOSwapPagesUsedPeak 0
public IOSwapPagesUsedPeak

var IOSwapPagesWritten 0
public IOSwapPagesWritten

var IOSwapPagesRead 0
public IOSwapPagesRead

struct IOiPageFile
	4 MinimumSize
	4 MaximumSize
	4 FileObject
	4 CapturedFCB
	ComBitmapHeader_SIZEOF BitmapHeader
	4 Hint
	4 CurrentSize
	4 UsedCount
	4 Priority
	4 Number
	4 Next
	4 TransferSize
endstruct

buffer IOiPageFileCreationMutex KeMutex_SIZEOF

buffer IOPageFileExtendEvent KeEvent_SIZEOF
public IOPageFileExtendEvent

table IOPageFiles[IOPAGEFILEMAX]

var IOiPageFileExtensionIndex 0

var IOPageFileCount 0
public IOPageFileCount

fn IOiPageFileInsert { pri fcb pagefile -- }
	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	// set system file flag
	auto rs
	HALCPUInterruptDisable rs!

	IOFCBFLAG_SYSTEMFILE fcbp@ IOFileControlBlockPaged_Flags + |=

	pagefile@ [IOPageFileCount@]IOPageFiles!
	pagefile@ IOiPageFile_MinimumSize + @ IOSwapPagesCount +=

	2 MmAnonTransfersAvailable +=

	rs@ HALCPUInterruptRestore

	if (IOPageFileCount@ 0 ==)
		// this is the first pagefile created.
		// set the commit limit to its size and signal the creation event.

		pagefile@ IOiPageFile_MinimumSize + @ MmCommitLimit!
		pagefile@ IOiPageFile_MaximumSize + @ MmTheoreticalCommitLimit!
	end else
		HALCPUInterruptDisable rs!
		pagefile@ IOiPageFile_MinimumSize + @ MmCommitLimit +=
		pagefile@ IOiPageFile_MaximumSize + @ MmTheoreticalCommitLimit +=
		rs@ HALCPUInterruptRestore
	end

	1 IOPageFileCount +=
end

fn IOPageFileGetPriority { pagefile -- pri }
	pagefile@ IOiPageFile_Priority + @ pri!
end

fn IOPageFileGetFree { pagefile -- free }
	pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_UsedCount + @ - free!
end

fn IOPageFileGetNumber { pagefile -- number }
	pagefile@ IOiPageFile_Number + @ number!
end

fn IOiPageFileInit { -- }
	fnsection "INIT$text"

	"IOiPageFileCreationMutex" // name
	KERNELMODE // mode
	IOiPageFileCreationMutex // mutex
	KeMutexInitialize
end

fn IOiPageFileCreateLock { -- }
	fnsection "PAGE$text"

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	IOiPageFileCreationMutex // object
	KeThreadWaitForObject drop
end

fn IOiPageFileCreateUnlock { -- }
	fnsection "PAGE$text"

	0 // abandon
	IOiPageFileCreationMutex // mutex
	KeMutexRelease drop
end

fn IOPageFileCreate { minpages maxpages pri path -- ok }
	fnsection "PAGE$text"

	SeAmIAdmin ok!

	if (ok@)
		STATUS_PERMISSION_DENIED ok!

		return
	end

	if (pri@ IOPAGEFILEMAXPRI >=)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (maxpages@ minpages@ <)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	IOiPageFileCreateLock

	if (IOPageFileCount@ IOPAGEFILEMAX >=)
		IOiPageFileCreateUnlock

		STATUS_TOO_MANY_PAGEFILES ok!

		return
	end

	416 KeThreadCurrent@ PsThread_FileCreationPermissions + !

	auto handle
	OSFILEFLAG_CREATE OSFILEFLAG_PAGEFILE | // flags
	ACCESS_READ ACCESS_WRITE | // access
	OSNONE // initialobjecthandle
	path@ // path
	ObObjectOpenByPath ok! handle!

	if (ok@)
		IOiPageFileCreateUnlock

		return
	end

	auto fileobject
	auto access
	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	handle@ ObObjectClose drop

	if (ok@)
		IOiPageFileCreateUnlock

		return
	end

	access@ ACCESS_WRITE ACCESS_READ | SeCheckAccess ok!

	if (ok@)
		IOiPageFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	if (fcbp@ IOFileControlBlockPaged_Flags + @ IOFCBFLAG_SYSTEMFILE &)
		IOiPageFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_DEVICE_BUSY ok!

		return
	end

	if (fcbp@ IOFileControlBlockPaged_FileType + @ OSFILETYPE_BLOCKDEVICE ==)
		// disk or otherwise, can't resize.

		fcb@ IOFileControlBlock_SizeInBytes + @ PAGESHIFT >> dup minpages! maxpages!
	end elseif (fcbp@ IOFileControlBlockPaged_FileType + @ OSFILETYPE_FILE ==)
		// file, truncate to minpages.

		minpages@ PAGESHIFT << // newsize
		0 // growing
		0 // keeplocked
		0 // zero
		OSFILEFLAG_NOCACHE // flags
		fcb@ // fcb
		IOFileControlBlockTruncate ok! drop

		if (ok@)
			IOiPageFileCreateUnlock

			fileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end else
		// bad

		IOiPageFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (minpages@ 128 <)
		// needs to be at least 128 pages (512KB with 4KB pages)

		IOiPageFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_SWAP_TOO_SMALL ok!

		return
	end

	auto stacksize
	fcb@ IOFileControlBlock_StackDepth + @ stacksize!

	auto transfersize
	IOTransfer_SIZEOF IOPacketHeaderPagingIO_SIZEOF + stacksize@ IOPacketLocation_SIZEOF * + transfersize!

	// do an inline allocation of the pagefile, two transfer structures, and
	// the bitmap.

	auto pagefile
	IOiPageFile_SIZEOF
	transfersize@ 2 * +
	maxpages@ 7 + 3 >> + // bytes
	'SwFi' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! pagefile!

	if (ok@)
		IOiPageFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	transfersize@ pagefile@ IOiPageFile_TransferSize + !

	auto transfer1
	pagefile@ IOiPageFile_SIZEOF + transfer1!

	pagefile@ // pagefile
	transfer1@ // transfer
	MmMPWAnonTransferInitialize

	auto transfer2
	transfer1@ transfersize@ + transfer2!

	pagefile@ // pagefile
	transfer2@ // transfer
	MmMPWAnonTransferInitialize

	auto bitmap
	transfer2@ transfersize@ + bitmap!

	// initialize the bitmap
	maxpages@ // sizeinbits
	bitmap@ // data
	pagefile@ IOiPageFile_BitmapHeader + // header
	ComBitmapInitialize

	// clear the minimum size
	minpages@ // runlength
	0 // index
	pagefile@ IOiPageFile_BitmapHeader + // header
	ComBitmapClearBits

	// set beyond the minimum size
	maxpages@ minpages@ - // runlength
	minpages@ // index
	pagefile@ IOiPageFile_BitmapHeader + // header
	ComBitmapSetBits

	// initialize pagefile structures
	minpages@ pagefile@ IOiPageFile_MinimumSize + !
	maxpages@ pagefile@ IOiPageFile_MaximumSize + !
	fileobject@ pagefile@ IOiPageFile_FileObject + !
	fileobject@ IOFile_FileControlBlock + @ pagefile@ IOiPageFile_CapturedFCB + !
	0 pagefile@ IOiPageFile_Hint + !
	minpages@ pagefile@ IOiPageFile_CurrentSize + !
	0 pagefile@ IOiPageFile_UsedCount + !
	pri@ pagefile@ IOiPageFile_Priority + !
	IOPageFileCount@ pagefile@ IOiPageFile_Number + !

	pri@ // pri
	fcb@ // fcb
	pagefile@ // pagefile
	IOiPageFileInsert

	transfer1@ IOTransferComplete
	transfer2@ IOTransferComplete

	IOiPageFileCreateUnlock

	// leave fileobject refcount biased

	0 ok!
end

fn IOPageFileQuery { query id -- ok }
	fnsection "PAGE$text"

	if (id@ IOPageFileCount@ >=)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	0 ok!

	auto pagefile
	[id@]IOPageFiles@ pagefile!

	if (pagefile@ IOiPageFile_FileObject + @ IOFile_OpenedPath + @)
		query@ OSPageFileInformation_Name + // dest
		pagefile@ IOiPageFile_FileObject + @ IOFile_OpenedPath + @ // src
		strcpy
	end else
		query@ OSPageFileInformation_Name + // dest
		"unknown" // src
		strcpy
	end

	pagefile@ IOiPageFile_MinimumSize + @ query@ OSPageFileInformation_MinimumSize + !
	pagefile@ IOiPageFile_MaximumSize + @ query@ OSPageFileInformation_MaximumSize + !
	pagefile@ IOiPageFile_CurrentSize + @ query@ OSPageFileInformation_CurrentSize + !
	pagefile@ IOiPageFile_UsedCount + @ query@ OSPageFileInformation_UsedCount + !
	pagefile@ IOiPageFile_Priority + @ query@ OSPageFileInformation_Priority + !
end

fn IOPageFileReserve { pagesneeded pagefile -- offset ok }
	auto bmpheader
	pagefile@ IOiPageFile_BitmapHeader + bmpheader!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_UsedCount + @ - pagesneeded@ <)
		ipl@ KeIPLLower

		STATUS_NO_SWAP ok!

		return
	end

	pagefile@ IOiPageFile_Hint + @ // hint
	pagesneeded@ // runlength
	bmpheader@ // header
	ComBitmapFindRun ok! offset!

	if (ok@)
		ipl@ KeIPLLower

		STATUS_NO_SWAP ok!

		return
	end

	pagesneeded@ IOSwapPagesUsed +=

	if (IOSwapPagesUsed@ IOSwapPagesUsedPeak@ >)
		IOSwapPagesUsed@ IOSwapPagesUsedPeak!
	end

	pagesneeded@ pagefile@ IOiPageFile_UsedCount + +=

	pagesneeded@ // runlength
	offset@ // index
	bmpheader@ // header
	ComBitmapSetBits

	ipl@ KeIPLLower

	offset@ pagefile@ IOiPageFile_Hint + !
end

fn IOPageFileRelease { pages offset pagefile -- }
	if (pages@ ~~)
		return
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	pages@ IOSwapPagesUsed -=
	pages@ pagefile@ IOiPageFile_UsedCount + -=

	pages@ // runlength
	offset@ // index
	pagefile@ IOiPageFile_BitmapHeader + // header
	ComBitmapClearBits

	if (MmAnonTransfersAvailable@ ~~
		pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_UsedCount + @ - IOPAGEFILEFREELOW >= ||)
		pagefile@ IOiPageFile_TransferSize + @ // transfersize
		pagefile@ IOiPageFile_SIZEOF + // transfer1
		MmMPWAssessTransfers
	end

	ipl@ KeIPLLower
end

fn IOSwapPageFree { pno pagefile -- }
	// frees a page in swap

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 // runlength
	pno@ // index
	pagefile@ IOiPageFile_BitmapHeader + // header
	ComBitmapClearBits

	1 IOSwapPagesUsed -=
	1 pagefile@ IOiPageFile_UsedCount + -=

	if (DEBUGCHECKS)
		if (IOSwapPagesUsed@ z<)
			"IOSwapPageFree: underflow\n" KeCrash
		end
	end

	if (MmAnonTransfersAvailable@ ~~
		pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_UsedCount + @ - IOPAGEFILEFREELOW >= ||)
		pagefile@ IOiPageFile_TransferSize + @ // transfersize
		pagefile@ IOiPageFile_SIZEOF + // transfer1
		MmMPWAssessTransfers
	end

	ipl@ KeIPLLower
end

fn IOSwapPageFreePTE { pte -- }
	if (DEBUGCHECKS)
		if (pte@ PTE_INSWAP & ~~)
			"IOSwapPageFreePTE: not an INSWAP pte\n" KeCrash
		end
	end

	pte@ PAGESHIFT >> // pno
	[pte@ PTE_PAGEFILE_SHIFT >> PTE_PAGEFILE_MASK &]IOPageFiles@ // pagefile
	IOSwapPageFree
end

fn IOSwapPageReadPTE { kflags pfdbe pte -- ok }
	// reads swap page at pno into pageframe

	if (DEBUGCHECKS)
		if (pte@ PTE_INSWAP & ~~)
			"IOSwapPageReadPTE: not an INSWAP pte\n" KeCrash
		end
	end

	auto pagefile
	[pte@ PTE_PAGEFILE_SHIFT >> PTE_PAGEFILE_MASK &]IOPageFiles@ pagefile!

	auto fcb
	pagefile@ IOiPageFile_CapturedFCB + @ fcb!

	// perform the read operation

	auto mdl
	MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

	pfdbe@ mdl@ MmMDLHeader_SIZEOF + !
	-1 mdl@ MmMDLHeader_SIZEOF + 4 + !

	PAGESIZE // length
	0 // vaddr
	kflags@ // kflags
	mdl@ // mdl
	MmMDLInitialize

	MMMDL_PINNED MMMDL_DONTUNPIN | mdl@ MmMDLHeader_Flags + !

	0 // iop
	0 // completionroutine
	IODISPATCH_READ // functioncode
	0 // flags
	kflags@ // kflags
	mdl@ // mdl
	pte@ PAGENUMBERMASK & // offset
	fcb@ // fcb
	IOMDLTransfer ok! drop

	if (ok@)
		return
	end

	auto rs
	HALCPUInterruptDisable rs!
	1 IOSwapPagesRead +=
	1 MmPageInCount +=
	rs@ HALCPUInterruptRestore
end

fn IOPageFileWriteMDL { pagecount offset mdl -- ok }
	pagecount@ PAGESHIFT << // length
	0 // vaddr
	IOKFLAG_SWAPOUT // kflags
	mdl@ // mdl
	MmMDLInitialize

	MMMDL_DONTUNPIN MMMDL_PINNED | mdl@ MmMDLHeader_Flags + |=

	offset@ mdl@ IOTransfer_Prev + !

	auto pagefile
	mdl@ IOTransfer_PageFile + @ pagefile!

	auto fcb
	pagefile@ IOiPageFile_CapturedFCB + @ fcb!

	mdl@ IOTransfer_SIZEOF + // iop
	pointerof MmAnonPageWriterAPCRoutine // completionroutine
	IODISPATCH_WRITE // functioncode
	0 // flags
	IOKFLAG_SWAPOUT // kflags
	mdl@ // mdl
	offset@ PAGESHIFT << // offset
	fcb@ // fcb
	IOMDLTransfer ok! drop

	if (ok@)
		return
	end

	pagecount@ IOSwapPagesWritten +=
end

var IOiPageFileExtensionListHead 0
var IOiPageFileExtensionListTail 0

struct IOPageFileExtension
	4 Next
	4 Pages
	KeEvent_SIZEOF Event
	4 Success
endstruct

fn IOPageFileRequestExpansion { pages -- ok }
	// entered and left at IPLDPC.

	// quick check to make sure this can feasibly work before we go to the
	// trouble of queuing a request and waking the worker thread.

	auto i
	0 i!

	auto avail
	0 avail!

	while (i@ IOPageFileCount@ <)
		auto pagefile
		[i@]IOPageFiles@ pagefile!

		pagefile@ IOiPageFile_MaximumSize + @ pagefile@ IOiPageFile_CurrentSize + @ - avail +=

		if (avail@ pages@ >=)
			break
		end

		1 i +=
	end

	if (avail@ pages@ MmCommitUsage@ + MmCommitLimit@ - <)
		// not enough potential expansion left to satisfy this.
		STATUS_COMMIT_EXCEEDED ok!
		return
	end

	IPLLOW KeIPLLower

	auto extension
	IOPageFileExtension_SIZEOF alloc extension!

	0 extension@ IOPageFileExtension_Next + !
	pages@ extension@ IOPageFileExtension_Pages + !
	-1 extension@ IOPageFileExtension_Success + !

	0 // signaled
	OSEVENT_SYNCH // type
	"IOPageFileRequestExpansionEvent" // name
	extension@ IOPageFileExtension_Event + // event
	KeEventInitialize

	auto rs
	HALCPUInterruptDisable rs!

	auto t
	IOiPageFileExtensionListTail@ t!

	if (t@ ~~)
		extension@ IOiPageFileExtensionListHead!
	end else
		extension@ t@ IOPageFileExtension_Next + !
	end

	extension@ IOiPageFileExtensionListTail!

	rs@ HALCPUInterruptRestore

	0 // priboost
	IOPageFileExtendEvent // event
	KeEventSignal

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	extension@ IOPageFileExtension_Event + // object
	KeThreadWaitForObject drop

	extension@ IOPageFileExtension_Success + @ ok!

	IPLDPC KeIPLRaise drop
end

fn IOiPageFileExtend { -- }
	// called by worker thread.
	// pops extension requests off the listhead and tries to satisfy them.
	// satisfying a request is done by extending the pagefile & signaling the
	// event to wake up the waiting thread.

	while (IOiPageFileExtensionListHead@)
		auto extension

		auto rs
		HALCPUInterruptDisable rs!

		IOiPageFileExtensionListHead@ extension!
		extension@ IOPageFileExtension_Next + @ IOiPageFileExtensionListHead!

		if (IOiPageFileExtensionListHead@ ~~)
			0 IOiPageFileExtensionListTail!
		end

		rs@ HALCPUInterruptRestore

		extension@ IOiPageFileSatisfyExtension
	end
end

fn IOiPageFileSatisfyExtension { extension -- }
	auto i
	0 i!

	auto avail
	0 avail!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (extension@ IOPageFileExtension_Pages + @ MmCommitUsage@ + MmCommitLimit@ <=)
		// immediately succeed
		ipl@ KeIPLLower

		0 extension@ IOPageFileExtension_Success + !

		0 // priboost
		extension@ IOPageFileExtension_Event + // event
		KeEventSignal

		return
	end

	while (i@ IOPageFileCount@ <)
		auto pagefile
		[i@]IOPageFiles@ pagefile!

		pagefile@ IOiPageFile_MaximumSize + @ pagefile@ IOiPageFile_CurrentSize + @ - avail +=

		if (avail@ extension@ IOPageFileExtension_Pages + @ >=)
			break
		end

		1 i +=
	end

	auto requiredextension
	extension@ IOPageFileExtension_Pages + @ MmCommitUsage@ + MmCommitLimit@ - requiredextension!

	if (avail@ requiredextension@ <)
		// immediately fail
		ipl@ KeIPLLower

		STATUS_COMMIT_EXCEEDED extension@ IOPageFileExtension_Success + !

		0 // priboost
		extension@ IOPageFileExtension_Event + // event
		KeEventSignal

		return
	end

	ipl@ KeIPLLower

	requiredextension@ IOiPageFileTryExtendAll extension@ IOPageFileExtension_Success + !

	0 // priboost
	extension@ IOPageFileExtension_Event + // event
	KeEventSignal
end

fn IOiPageFileTryExtendAll { extension -- ok }
	fnsection "PAGE$text"

	if (IOiPageFileExtensionIndex@ IOPageFileCount@ >=)
		0 IOiPageFileExtensionIndex!
	end

	0 ok!

	auto i
	0 i!

	while (i@ 2 <)
		auto max
		auto j

		if (i@ 0 ==)
			IOPageFileCount@ max!
			IOiPageFileExtensionIndex@ j!
		end else
			IOiPageFileExtensionIndex@ max!
			0 j!
		end

		while (j@ max@ <)
			auto realextension
			extension@ // extension
			[j@]IOPageFiles@ // pagefile
			IOiPageFileTryExtend realextension!

			if (realextension@ extension@ >)
				0 extension!
			end else
				realextension@ extension -=
			end

			if (extension@ ~~)
				break
			end

			1 j +=
		end

		if (extension@ ~~)
			j@ 1 + IOiPageFileExtensionIndex!
			break
		end

		1 i +=
	end

	if (extension@)
		STATUS_COMMIT_EXCEEDED ok!
	end
end

const IOPAGEFILEMINIMUMEXTENSION 128

fn IOiPageFileTryExtend { extension pagefile -- realextension }
	auto maxextend
	pagefile@ IOiPageFile_MaximumSize + @ pagefile@ IOiPageFile_CurrentSize + @ - maxextend!

	auto i
	0 i!

	auto tryextension
	extension@ tryextension!

	if (tryextension@ IOPAGEFILEMINIMUMEXTENSION <)
		IOPAGEFILEMINIMUMEXTENSION tryextension!
	end

	if (maxextend@ tryextension@ <)
		maxextend@ tryextension!
	end

	if (extension@ tryextension@ ==)
		1 i!
	end

	while (i@ 2 <)
		auto ok
		pagefile@ IOiPageFile_CurrentSize + @ tryextension@ + PAGESHIFT << // newsize
		1 // growing
		0 // keeplocked
		0 // zero
		OSFILEFLAG_NOCACHE // flags
		pagefile@ IOiPageFile_CapturedFCB + @ // fcb
		IOFileControlBlockTruncate ok! drop

		if (ok@ ~~)
			break
		end else
			if (ok@ STATUS_END_OF_DISK ~=)
				0 realextension!
				return
			end

			if (i@ 1 ==)
				0 realextension!
				return
			end

			extension@ tryextension!
		end

		1 i +=
	end

	tryextension@ realextension!

	// growing the pagefile succeeded. update the structures.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	realextension@ // runlength
	pagefile@ IOiPageFile_CurrentSize + @ // index
	pagefile@ IOiPageFile_BitmapHeader + // header
	ComBitmapClearBits

	realextension@ pagefile@ IOiPageFile_CurrentSize + +=
	realextension@ IOSwapPagesCount +=
	realextension@ MmCommitLimit +=

	0 pagefile@ IOiPageFile_Hint + !

	pagefile@ IOiPageFile_TransferSize + @ // transfersize
	pagefile@ IOiPageFile_SIZEOF + // transfer1
	MmMPWAssessTransfers

	ipl@ KeIPLLower
end

fn IOiPageFileContract { -- }
	fnsection "PAGE$text"

	// called by the worker thread every 5 seconds to scan the pagefiles and
	// determine if any of them should be shrunk.

	if (MmPageFreeCount@ MmEvictablePageCount@ + MmPageFreeCountSufficient@ <)
		// don't shrink pagefiles while pages are being dumped to disk

		return
	end

	auto potentialcontraction
	MmCommitLimit@ MmCommitUsage@ - potentialcontraction!

	if (potentialcontraction@ IOPAGEFILEMINIMUMEXTENSION <)
		// if commit usage is within 512KB of the commit limit then it
		// probably isn't worth it to bother scanning the pagefiles.

		return
	end

	auto i
	0 i!

	0 potentialcontraction!

	while (i@ IOPageFileCount@ <)
		auto pagefile
		[i@]IOPageFiles@ pagefile!

		auto free
		pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_UsedCount + @ - free!

		auto excess
		pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_MinimumSize + @ - excess!

		if (excess@ IOPAGEFILEMINIMUMEXTENSION >=)
			if (free@ IOPAGEFILEMINIMUMEXTENSION >=)
				excess@ free@ min potentialcontraction +=
			end
		end

		1 i +=
	end

	if (potentialcontraction@ IOPAGEFILEMINIMUMEXTENSION <)
		return
	end

	potentialcontraction@ IOiPageFileTryContractAll
end

fn IOiPageFileTryContractAll { contraction -- }
	fnsection "PAGE$text"

	if (IOiPageFileExtensionIndex@ IOPageFileCount@ >=)
		0 IOiPageFileExtensionIndex!
	end

	auto i
	0 i!

	while (i@ 2 <)
		auto max
		auto j

		if (i@ 0 ==)
			IOPageFileCount@ max!
			IOiPageFileExtensionIndex@ j!
		end else
			IOiPageFileExtensionIndex@ max!
			0 j!
		end

		while (j@ max@ <)
			auto contractedby
			contraction@ // contraction
			[j@]IOPageFiles@ // pagefile
			IOiPageFileTryContract contractedby!

			if (contractedby@ contraction@ >=)
				0 contraction!
				break
			end

			contractedby@ contraction -=

			1 j +=
		end

		if (contraction@ ~~)
			j@ 1 + IOiPageFileExtensionIndex!
			break
		end

		1 i +=
	end
end

fn IOiPageFileTryContract { contraction pagefile -- contractedby }
	0 contractedby!

	if (contraction@ IOPAGEFILEMINIMUMEXTENSION <)
		IOPAGEFILEMINIMUMEXTENSION contraction!
	end

	if (contraction@ pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_MinimumSize + @ - >)
		pagefile@ IOiPageFile_CurrentSize + @ pagefile@ IOiPageFile_MinimumSize + @ - contraction!
	end

	if (contraction@ IOPAGEFILEMINIMUMEXTENSION <)
		return
	end

	if (contraction@ MmCommitLimit@ >)
		// this check is fine since the currently executing thread is the only
		// one that is allowed to shrink the commit limit. others can grow it,
		// but it can only be shrunk by this one worker thread.

		return
	end

	while (contraction@ IOPAGEFILEMINIMUMEXTENSION >=)
		auto ipl
		IPLDPC KeIPLRaise ipl!

		// only contract if the new commit limit would leave a margin of >=64
		// pages from the current commit usage. this attempts to avoid
		// excessive expansion and contraction cycles.

		if (MmCommitLimit@ contraction@ - MmCommitUsage@ 64 + >=)
			auto clear
			contraction@ // runlength
			pagefile@ IOiPageFile_CurrentSize + @ contraction@ - // index
			pagefile@ IOiPageFile_BitmapHeader + // header
			ComBitmapCheckClearBits clear!

			if (clear@)
				// chop!

				contraction@ // runlength
				pagefile@ IOiPageFile_CurrentSize + @ contraction@ - // index
				pagefile@ IOiPageFile_BitmapHeader + // header
				ComBitmapSetBits

				contraction@ pagefile@ IOiPageFile_CurrentSize + -=
				contraction@ IOSwapPagesCount -=
				contraction@ MmCommitLimit -=

				0 pagefile@ IOiPageFile_Hint + !

				ipl@ KeIPLLower

				pagefile@ IOiPageFile_CurrentSize + @ PAGESHIFT << // newsize
				0 // growing
				0 // keeplocked
				0 // zero
				OSFILEFLAG_NOCACHE // flags
				pagefile@ IOiPageFile_CapturedFCB + @ // fcb
				IOFileControlBlockTruncate drop drop

				return
			end
		end

		ipl@ KeIPLLower

		1 contraction >>=
	end
end