//
// Implements swapfile management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Transfer.h"

#include "<ll>/OSDLL/OS.h"

#include "../../Common/Common.h"

var IOSwapPagesUsed 0
public IOSwapPagesUsed

var IOSwapPagesCount 0
public IOSwapPagesCount

var IOSwapPagesUsedPeak 0
public IOSwapPagesUsedPeak

var IOSwapPagesWritten 0
public IOSwapPagesWritten

var IOSwapPagesRead 0
public IOSwapPagesRead

buffer IOSwapFileCreationMutex KeMutex_SIZEOF

buffer IOSwapFileExtendEvent KeEvent_SIZEOF
public IOSwapFileExtendEvent

buffer IOSwapFileCreationEvent KeEvent_SIZEOF
public IOSwapFileCreationEvent

struct IOSwapFile
	4 MinimumSize
	4 MaximumSize
	4 FileObject
	4 CapturedFCB
	ComBitmapHeader_SIZEOF BitmapHeader
	4 Hint
	4 CurrentSize
	4 UsedCount
	4 Priority
	4 Number
	4 Next
endstruct

const IOSWAPFILEMAX 16
const IOSWAPFILEMAXPRI 8

table IOSwapFiles[IOSWAPFILEMAX]

table IOSwapFilePriorityListHeads[IOSWAPFILEMAXPRI]
table IOSwapFilePriorityListTails[IOSWAPFILEMAXPRI]

var IOSwapFileExtensionIndex 0

var IOSwapFileCount 0
public IOSwapFileCount

fn IOSwapFileInsert { pri fcb swapfile -- }
	// set system file flag
	auto rs
	HALCPUInterruptDisable rs!
	IOFCBFLAG_SYSTEMFILE fcb@ IOFileControlBlock_Flags + |=

	swapfile@ [IOSwapFileCount@]IOSwapFiles!
	swapfile@ IOSwapFile_MinimumSize + @ IOSwapPagesCount +=

	auto h
	[pri@]IOSwapFilePriorityListHeads@ h!

	h@ swapfile@ IOSwapFile_Next + !
	swapfile@ [pri@]IOSwapFilePriorityListHeads!

	if (h@ ~~)
		swapfile@ [pri@]IOSwapFilePriorityListTails!
	end

	rs@ HALCPUInterruptRestore

	if (IOSwapFileCount@ 0 ==)
		// this is the first swapfile created.
		// set the commit limit to its size and signal the creation event.

		swapfile@ IOSwapFile_MinimumSize + @ MmCommitLimit!
		swapfile@ IOSwapFile_MaximumSize + @ MmTheoreticalCommitLimit!

		0 // priboost
		IOSwapFileCreationEvent // event
		KeEventSignal
	end else
		HALCPUInterruptDisable rs!
		swapfile@ IOSwapFile_MinimumSize + @ MmCommitLimit +=
		swapfile@ IOSwapFile_MaximumSize + @ MmTheoreticalCommitLimit +=
		rs@ HALCPUInterruptRestore
	end

	1 IOSwapFileCount +=
end

fn IOSwapFileInit { -- }
	fnsection "INIT$text"

	"IOSwapFileCreationMutex" // name
	KERNELMODE // mode
	IOSwapFileCreationMutex // mutex
	KeMutexInitialize
end

fn IOSwapFileCreateLock { -- }
	fnsection "PAGE$text"

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	IOSwapFileCreationMutex // object
	KeThreadWaitForObject drop
end

fn IOSwapFileCreateUnlock { -- }
	fnsection "PAGE$text"

	0 // abandon
	IOSwapFileCreationMutex // mutex
	KeMutexRelease drop
end

fn IOSwapFileCreate { minpages maxpages pri path -- ok }
	fnsection "PAGE$text"

	SeAmIAdmin ok!

	if (ok@)
		STATUS_PERMISSION_DENIED ok!

		return
	end

	if (pri@ IOSWAPFILEMAXPRI >=)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (maxpages@ minpages@ <)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	IOSwapFileCreateLock

	if (IOSwapFileCount@ IOSWAPFILEMAX >=)
		IOSwapFileCreateUnlock

		STATUS_TOO_MANY_SWAPFILES ok!

		return
	end

	416 KeThreadCurrent@ PsThread_FileCreationPermissions + !

	auto handle
	OSFILEFLAG_CREATE // flags
	ACCESS_READ ACCESS_WRITE | // access
	OSNONE // initialobjecthandle
	path@ // path
	ObObjectOpenByPath ok! handle!

	if (ok@)
		IOSwapFileCreateUnlock

		return
	end

	auto fileobject
	auto access
	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	handle@ ObObjectClose drop

	if (ok@)
		IOSwapFileCreateUnlock

		return
	end

	access@ ACCESS_WRITE ACCESS_READ | SeCheckAccess ok!

	if (ok@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_SYSTEMFILE &)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_DEVICE_BUSY ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_BLOCKDEVICE ==)
		// disk or otherwise, can't resize.

		fcb@ IOFileControlBlock_SizeInBytes + @ PAGESHIFT >> dup minpages! maxpages!
	end elseif (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_FILE ==)
		// file, truncate to minpages.

		minpages@ PAGESHIFT << // newsize
		0 // growing
		0 // keeplocked
		0 // zero
		OSFILEFLAG_NOCACHE // flags
		fcb@ // fcb
		IOFileControlBlockTruncate ok! drop

		if (ok@)
			IOSwapFileCreateUnlock

			fileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end else
		// bad

		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (minpages@ 128 <)
		// needs to be at least 128 pages (512KB with 4KB pages)

		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_SWAP_TOO_SMALL ok!

		return
	end

	auto qcharge
	maxpages@ 7 + 3 >> IOSwapFile_SIZEOF + MmChargeBytesGet qcharge!

	qcharge@ // charge
	MmQuotaSystem // quotablock
	MmQuotaBlockCharge ok!

	if (ok@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto bitmap
	maxpages@ 7 + 3 >> // bytes
	'SwBm' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! bitmap!

	if (ok@)
		IOSwapFileCreateUnlock

		qcharge@ // charge
		MmQuotaSystem // quotablock
		MmQuotaBlockUncharge

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto swapfile
	IOSwapFile_SIZEOF // bytes
	'SwFi' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! swapfile!

	if (ok@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		bitmap@ MmFree

		qcharge@ // charge
		MmQuotaSystem // quotablock
		MmQuotaBlockUncharge

		return
	end

	// initialize the bitmap
	maxpages@ // sizeinbits
	bitmap@ // data
	swapfile@ IOSwapFile_BitmapHeader + // header
	ComBitmapInitialize

	// clear the minimum size
	minpages@ // runlength
	0 // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ComBitmapClearBits

	// set beyond the minimum size
	maxpages@ minpages@ - // runlength
	minpages@ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ComBitmapSetBits

	// initialize swapfile structures
	minpages@ swapfile@ IOSwapFile_MinimumSize + !
	maxpages@ swapfile@ IOSwapFile_MaximumSize + !
	fileobject@ swapfile@ IOSwapFile_FileObject + !
	fileobject@ IOFile_FileControlBlock + @ swapfile@ IOSwapFile_CapturedFCB + !
	0 swapfile@ IOSwapFile_Hint + !
	minpages@ swapfile@ IOSwapFile_CurrentSize + !
	0 swapfile@ IOSwapFile_UsedCount + !
	pri@ swapfile@ IOSwapFile_Priority + !
	IOSwapFileCount@ swapfile@ IOSwapFile_Number + !

	pri@ // pri
	fcb@ // fcb
	swapfile@ // swapfile
	IOSwapFileInsert

	IOSwapFileCreateUnlock

	// leave fileobject refcount biased

	0 ok!
end

fn IOSwapFileQuery { query id -- ok }
	fnsection "PAGE$text"

	if (id@ IOSwapFileCount@ >=)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	0 ok!

	auto swapfile
	[id@]IOSwapFiles@ swapfile!

	if (swapfile@ IOSwapFile_FileObject + @ IOFile_OpenedPath + @)
		query@ OSSwapFileInformation_Name + // dest
		swapfile@ IOSwapFile_FileObject + @ IOFile_OpenedPath + @ // src
		strcpy
	end else
		query@ OSSwapFileInformation_Name + // dest
		"unknown" // src
		strcpy
	end

	swapfile@ IOSwapFile_MinimumSize + @ query@ OSSwapFileInformation_MinimumSize + !
	swapfile@ IOSwapFile_MaximumSize + @ query@ OSSwapFileInformation_MaximumSize + !
	swapfile@ IOSwapFile_CurrentSize + @ query@ OSSwapFileInformation_CurrentSize + !
	swapfile@ IOSwapFile_UsedCount + @ query@ OSSwapFileInformation_UsedCount + !
	swapfile@ IOSwapFile_Priority + @ query@ OSSwapFileInformation_Priority + !
end

fn IOSwapFileReserve { pagesneeded swapfile -- offset ok }
	auto bmpheader
	swapfile@ IOSwapFile_BitmapHeader + bmpheader!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (swapfile@ IOSwapFile_CurrentSize + @ swapfile@ IOSwapFile_UsedCount + @ - pagesneeded@ <)
		ipl@ KeIPLLower

		STATUS_NO_SWAP ok!

		return
	end

	swapfile@ IOSwapFile_Hint + @ // hint
	pagesneeded@ // runlength
	bmpheader@ // header
	ComBitmapFindRun ok! offset!

	if (ok@)
		ipl@ KeIPLLower

		STATUS_NO_SWAP ok!

		return
	end

	pagesneeded@ IOSwapPagesUsed +=

	if (IOSwapPagesUsed@ IOSwapPagesUsedPeak@ >)
		IOSwapPagesUsed@ IOSwapPagesUsedPeak!
	end

	pagesneeded@ swapfile@ IOSwapFile_UsedCount + +=

	pagesneeded@ // runlength
	offset@ // index
	bmpheader@ // header
	ComBitmapSetBits

	ipl@ KeIPLLower

	offset@ swapfile@ IOSwapFile_Hint + !
end

fn IOSwapFileRelease { pages offset swapfile -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	pages@ IOSwapPagesUsed -=
	pages@ swapfile@ IOSwapFile_UsedCount + -=

	pages@ // runlength
	offset@ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ComBitmapClearBits

	ipl@ KeIPLLower
end

fn IOSwapPageFree { pno swapfile -- }
	// frees a page in swap

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 // runlength
	pno@ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ComBitmapClearBits

	1 IOSwapPagesUsed -=
	1 swapfile@ IOSwapFile_UsedCount + -=

	if (DEBUGCHECKS)
		if (IOSwapPagesUsed@ z<)
			"IOSwapPageFree: underflow\n" KeCrash
		end
	end

	ipl@ KeIPLLower
end

fn IOSwapPageFreePTE { pte -- }
	if (DEBUGCHECKS)
		if (pte@ PTE_INSWAP & ~~)
			"IOSwapPageFreePTE: not an INSWAP pte\n" KeCrash
		end
	end

	pte@ PAGESHIFT >> // pno
	[pte@ PTE_SWAPFILE_SHIFT >> PTE_SWAPFILE_MASK &]IOSwapFiles@ // swapfile
	IOSwapPageFree
end

fn IOSwapPageReadPTE { kflags pageframe pte -- ok }
	// reads swap page at pno into pageframe

	if (DEBUGCHECKS)
		if (pageframe@ PAGEOFFSETMASK &)
			"IOSwapPageRead: pageframe wasn't page-aligned\n" KeCrash
		end

		if (pte@ PTE_INSWAP & ~~)
			"IOSwapPageReadPTE: not an INSWAP pte\n" KeCrash
		end
	end

	auto swapfile
	[pte@ PTE_SWAPFILE_SHIFT >> PTE_SWAPFILE_MASK &]IOSwapFiles@ swapfile!

	auto fcb
	swapfile@ IOSwapFile_CapturedFCB + @ fcb!

	auto readfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

	// perform the read operation

	auto event
	KeEvent_SIZEOF alloc event!

	0 // signaled
	OSEVENT_NOTIF // type
	"IOSwapPageReadEvent" // name
	event@ // event
	KeEventInitialize

	auto mdl
	MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

	KERNELMODE // mode
	PAGESIZE // length
	pageframe@ // vaddr
	mdl@ // mdl
	MmMDLInitialize

	event@ mdl@ MmMDLHeader_Event + !

	OSWAIT_TIMEOUTINFINITE // timeout
	0 // flags
	kflags@ // kflags
	pte@ PAGENUMBERMASK & // offset
	mdl@ // mdl
	fcb@ // fcb
	readfunc@ IODispatchReadFunction ok!

	if (ok@)
		// complete the MDL so we can wait for any fragments to finish

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end

	if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		event@ // object
		KeThreadWaitForObject drop
	end

	if (ok@)
		return
	end

	mdl@ MmMDLHeader_Status + @ ok!

	if (ok@)
		return
	end

	auto rs
	HALCPUInterruptDisable rs!
	1 IOSwapPagesRead +=
	1 MmPageInCount +=
	rs@ HALCPUInterruptRestore
end

fn IOSwapFileWriteMDL { pagecount mdl -- ok }
	0 ok!

	KERNELMODE // mode
	pagecount@ PAGESHIFT << // length
	0 // vaddr
	mdl@ // mdl
	MmMDLInitialize

	MMMDL_DONTUNPIN MMMDL_PINNED | mdl@ MmMDLHeader_Flags + |=
	pointerof IOSwapPageWriteMDLComplete mdl@ MmMDLHeader_CompleteRoutine + !
	0 mdl@ MmMDLHeader_Context1 + !

	auto pri
	0 pri!

	auto offset
	0 offset!

	auto fragged
	0 fragged!

	while (pri@ IOSWAPFILEMAXPRI <)
		auto swapfile
		[pri@]IOSwapFilePriorityListHeads@ swapfile!

		if (swapfile@)
			auto writtencount
			pagecount@ // pagecount
			offset@ // offset
			mdl@ // mdl
			pri@ // pri
			IOSwapFileWritePriorityLevel ok! writtencount! fragged |=

			if (ok@ ~~)
				writtencount@ offset +=
				writtencount@ pagecount -=

				if (pagecount@ ~~)
					if (fragged@)
						0 // status
						0 // priboost
						mdl@ // mdl
						MmMDLComplete
					end

					return
				end
			end else
				break
			end
		end

		1 pri +=
	end

	if (pagecount@)
		if (ok@ ~~)
			STATUS_NO_SWAP ok!
		end

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end
end

fn IOSwapFileWritePriorityLevel { pagecount offset mdl pri -- fragged writtenpagecount ok }
	// write as many pages as possible at this swapfile priority level.

	0 writtenpagecount!
	0 ok!
	0 fragged!

	auto pagestowrite
	pagecount@ pagestowrite!

	while (pagestowrite@)
		auto swapfile
		[pri@]IOSwapFilePriorityListHeads@ swapfile!

		while (swapfile@)
			while (1)
				// try to write clusters of this size until we either run out of
				// pages to write or we discover that this swapfile no longer has
				// room for them.

				pagestowrite@ // pagecount
				offset@ // mdloffset
				mdl@ // mdl
				swapfile@ // swapfile
				IOSwapFileWritePages ok!

				if (ok@ ~~)
					if (mdl@ MmMDLHeader_Pages + @ pagestowrite@ ~=)
						1 fragged!
					end

					pagestowrite@ pagecount -=
					pagestowrite@ writtenpagecount +=
					pagestowrite@ offset +=

					if (pagecount@ pagestowrite@ <)
						if (pagecount@ ~~)
							break
						end

						pagecount@ pagestowrite!
					end
				end else
					if (ok@ STATUS_NO_SWAP ~=)
						break
					end

					0 ok!

					break
				end
			end

			if (ok@)
				break
			end

			if (pagecount@ pagestowrite@ <)
				if (pagecount@ ~~)
					break
				end

				pagecount@ pagestowrite!
			end

			swapfile@ IOSwapFile_Next + @ swapfile!
		end

		if (ok@)
			break
		end

		if (pagecount@ ~~)
			break
		end

		1 pagestowrite >>=
	end

	auto rs
	HALCPUInterruptDisable rs!

	auto h
	[pri@]IOSwapFilePriorityListHeads@ h!

	auto t
	[pri@]IOSwapFilePriorityListTails@ t!

	if (h@ t@ ~=)
		// move the first swapfile to the end of the priority queue so we
		// fill them in a round-robin fashion to help avoid fragmentation.

		h@ IOSwapFile_Next + @ [pri@]IOSwapFilePriorityListHeads!
		0 h@ IOSwapFile_Next + !
		h@ t@ IOSwapFile_Next + !
		h@ [pri@]IOSwapFilePriorityListTails!
	end

	rs@ HALCPUInterruptRestore
end

fn IOSwapFileWritePages { pagecount mdloffset mdl swapfile -- ok }
	// try to write this many pages as a single clustered operation to the
	// swapfile.

	auto offset
	pagecount@ // pagecount
	swapfile@ // swapfile
	IOSwapFileReserve ok! offset!

	if (ok@)
		return
	end

	auto fragged
	0 fragged!

	auto writemdl

	if (mdl@ MmMDLHeader_Pages + @ pagecount@ ~=)
		// have to split the mdl

		0 // extraspace
		KERNELMODE // mode
		pagecount@ PAGESHIFT << // length
		mdloffset@ PAGESHIFT << // vaddr
		IOKFLAG_SWAPOUT // kflags
		MmMDLAllocate ok! writemdl! drop

		if (ok@)
			pagecount@ // pages
			offset@ // offset
			swapfile@ // swapfile
			IOSwapFileRelease

			return
		end

		mdloffset@ PAGESHIFT << // vaddr
		pagecount@ PAGESHIFT << // length
		mdl@ // srcmdl
		writemdl@ // destmdl
		MmMDLSplit

		1 fragged!
	end else
		if (DEBUGCHECKS)
			if (mdloffset@)
				"IOSwapFileWritePages: mdloffset\n" KeCrash
			end
		end

		// can use the MDL as-is
		mdl@ writemdl!
	end

	// perform the write operation

	mdl@ writemdl@ MmMDLHeader_Context1 + !
	offset@ writemdl@ MmMDLHeader_Context2 + !
	swapfile@ writemdl@ MmMDLHeader_Context3 + !

	pointerof IOSwapPageWriteMDLComplete writemdl@ MmMDLHeader_CompleteRoutine + !

	auto fcb
	swapfile@ IOSwapFile_CapturedFCB + @ fcb!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	0 // flags
	IOKFLAG_SWAPOUT // kflags
	offset@ PAGESHIFT << // offset
	writemdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok!

	if (ok@)
		if (fragged@)
			ok@ // status
			0 // priboost
			writemdl@ // mdl
			MmMDLComplete
		end

		return
	end

	pagecount@ IOSwapPagesWritten +=
end

fn (MmMDLCompleteRoutine) IOSwapPageWriteMDLComplete { mdl -- }
	// runs as an APC in the context of the modified page writer.

	auto transfer
	mdl@ MmMDLHeader_Context1 + @ transfer!

	auto status
	mdl@ MmMDLHeader_Status + @ status!

	auto pagecount
	mdl@ MmMDLHeader_Pages + @ pagecount!

	auto swapfile
	mdl@ MmMDLHeader_Context3 + @ swapfile!

	auto offset
	mdl@ MmMDLHeader_Context2 + @ offset!

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto number

	if (transfer@)
		swapfile@ IOSwapFile_Number + @ number!
	end

	// this loop will either run once if the root MDL was never fragmented,
	// or it will run (number of fragments)+1 times. When any fragments are
	// completed, they come through here and either complete their journey by
	// recording swap PTEs in anon pfdbes, or they see that the operation
	// failed and they free those swap PTEs. When the root MDL comes through,
	// it dereferences all the anon pages. This is done in one step if the
	// root MDL was never fragmented.

	while (pagecount@)
		auto pfdbe
		mdlpos@@ pfdbe!

		if (transfer@)
			if (status@)
				// IO error, don't save the swap page

				offset@ swapfile@ IOSwapPageFree
			end else
				if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb
					MMEVICTFLAG_MODIFIED MMEVICTFLAG_DELETED | &)
					// modified or deleted, free the swap page :(

					offset@ swapfile@ IOSwapPageFree
				end else
					auto swappte
					pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ swappte!

					offset@ PAGESHIFT << number@ PTE_SWAPFILE_SHIFT << | PTE_INSWAP |
					swappte@ PTE_TLBHACK & |
#ifdef DEBUGCHECKS
					swappte@ PTE_KERNELSTACK & |
#endif
					pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !
				end
			end
		end

		if (mdl@ MmMDLHeader_ParentMDL + @ ~~)
			if (status@)
				if (pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + @ PTE_INSWAP & ~~)
					// no need to mark the page modified again if it was
					// written to swap successfully.

					auto rs
					HALCPUInterruptDisable rs!
					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED |
					pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + sb
					rs@ HALCPUInterruptRestore
				end
			end

			pfdbe@ MmEvictablePageDereference drop
		end

		1 offset +=
		1 pagecount -=
		4 mdlpos +=
	end

	if (mdl@ MmMDLHeader_ParentMDL + @ ~~)
		if (status@)
			// TODO pop-up window or something
			status@ "IO error while writing data to swap (%i)\n" Printf
		end

		// root MDL, complete transfer.
		// this requires no synchronization as the transfer structures are
		// only accessed by the modified page writer, which is currently
		// executing this routine.

		mdl@ IOTransferComplete
	end
end

var IOSwapFileExtensionListHead 0
var IOSwapFileExtensionListTail 0

struct IOSwapFileExtension
	4 Next
	4 Pages
	KeEvent_SIZEOF Event
	4 Success
endstruct

fn IOSwapFileRequestExpansion { pages -- ok }
	// entered and left at IPLDPC.

	// quick check to make sure this can feasibly work before we go to the
	// trouble of queuing a request and waking the worker thread.

	auto i
	0 i!

	auto avail
	0 avail!

	while (i@ IOSwapFileCount@ <)
		auto swapfile
		[i@]IOSwapFiles@ swapfile!

		swapfile@ IOSwapFile_MaximumSize + @ swapfile@ IOSwapFile_CurrentSize + @ - avail +=

		if (avail@ pages@ >=)
			break
		end

		1 i +=
	end

	if (avail@ pages@ MmCommitUsage@ + MmCommitLimit@ - <)
		// not enough potential expansion left to satisfy this.
		STATUS_COMMIT_EXCEEDED ok!
		return
	end

	IPLLOW KeIPLLower

	auto extension
	IOSwapFileExtension_SIZEOF alloc extension!

	0 extension@ IOSwapFileExtension_Next + !
	pages@ extension@ IOSwapFileExtension_Pages + !
	-1 extension@ IOSwapFileExtension_Success + !

	0 // signaled
	OSEVENT_SYNCH // type
	"IOSwapFileRequestExpansionEvent" // name
	extension@ IOSwapFileExtension_Event + // event
	KeEventInitialize

	auto rs
	HALCPUInterruptDisable rs!

	auto t
	IOSwapFileExtensionListTail@ t!

	if (t@ ~~)
		extension@ IOSwapFileExtensionListHead!
	end else
		extension@ t@ IOSwapFileExtension_Next + !
	end

	extension@ IOSwapFileExtensionListTail!

	rs@ HALCPUInterruptRestore

	0 // priboost
	IOSwapFileExtendEvent // event
	KeEventSignal

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	extension@ IOSwapFileExtension_Event + // object
	KeThreadWaitForObject drop

	extension@ IOSwapFileExtension_Success + @ ok!

	IPLDPC KeIPLRaise drop
end

fn IOSwapFileExtend { -- }
	// called by worker thread.
	// pops extension requests off the listhead and tries to satisfy them.
	// satisfying a request is done by extending the pagefile & signaling the
	// event to wake up the waiting thread.

	while (IOSwapFileExtensionListHead@)
		auto extension

		auto rs
		HALCPUInterruptDisable rs!

		IOSwapFileExtensionListHead@ extension!
		extension@ IOSwapFileExtension_Next + @ IOSwapFileExtensionListHead!

		if (IOSwapFileExtensionListHead@ ~~)
			0 IOSwapFileExtensionListTail!
		end

		rs@ HALCPUInterruptRestore

		extension@ IOSwapFileSatisfyExtension
	end
end

fn IOSwapFileSatisfyExtension { extension -- }
	auto i
	0 i!

	auto avail
	0 avail!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (extension@ IOSwapFileExtension_Pages + @ MmCommitUsage@ + MmCommitLimit@ <=)
		// immediately succeed
		ipl@ KeIPLLower

		0 extension@ IOSwapFileExtension_Success + !

		0 // priboost
		extension@ IOSwapFileExtension_Event + // event
		KeEventSignal

		return
	end

	while (i@ IOSwapFileCount@ <)
		auto swapfile
		[i@]IOSwapFiles@ swapfile!

		swapfile@ IOSwapFile_MaximumSize + @ swapfile@ IOSwapFile_CurrentSize + @ - avail +=

		if (avail@ extension@ IOSwapFileExtension_Pages + @ >=)
			break
		end

		1 i +=
	end

	auto requiredextension
	extension@ IOSwapFileExtension_Pages + @ MmCommitUsage@ + MmCommitLimit@ - requiredextension!

	if (avail@ requiredextension@ <)
		// immediately fail
		ipl@ KeIPLLower

		STATUS_COMMIT_EXCEEDED extension@ IOSwapFileExtension_Success + !

		0 // priboost
		extension@ IOSwapFileExtension_Event + // event
		KeEventSignal

		return
	end

	ipl@ KeIPLLower

	requiredextension@ IOSwapFileTryExtendAll extension@ IOSwapFileExtension_Success + !

	0 // priboost
	extension@ IOSwapFileExtension_Event + // event
	KeEventSignal
end

fn IOSwapFileTryExtendAll { extension -- ok }
	fnsection "PAGE$text"

	if (IOSwapFileExtensionIndex@ IOSwapFileCount@ >=)
		0 IOSwapFileExtensionIndex!
	end

	0 ok!

	auto i
	0 i!

	while (i@ 2 <)
		auto max
		auto j

		if (i@ 0 ==)
			IOSwapFileCount@ max!
			IOSwapFileExtensionIndex@ j!
		end else
			IOSwapFileExtensionIndex@ max!
			0 j!
		end

		while (j@ max@ <)
			auto realextension
			extension@ // extension
			[j@]IOSwapFiles@ // swapfile
			IOSwapFileTryExtend realextension!

			if (realextension@ extension@ >)
				0 extension!
			end else
				realextension@ extension -=
			end

			if (extension@ ~~)
				break
			end

			1 j +=
		end

		if (extension@ ~~)
			j@ 1 + IOSwapFileExtensionIndex!
			break
		end

		1 i +=
	end

	if (extension@)
		STATUS_COMMIT_EXCEEDED ok!
	end
end

const IOSWAPFILEMINIMUMEXTENSION 128

fn IOSwapFileTryExtend { extension swapfile -- realextension }
	auto maxextend
	swapfile@ IOSwapFile_MaximumSize + @ swapfile@ IOSwapFile_CurrentSize + @ - maxextend!

	auto i
	0 i!

	auto tryextension
	extension@ tryextension!

	if (tryextension@ IOSWAPFILEMINIMUMEXTENSION <)
		IOSWAPFILEMINIMUMEXTENSION tryextension!
	end

	if (maxextend@ tryextension@ <)
		maxextend@ tryextension!
	end

	if (extension@ tryextension@ ==)
		1 i!
	end

	while (i@ 2 <)
		auto ok
		swapfile@ IOSwapFile_CurrentSize + @ tryextension@ + PAGESHIFT << // newsize
		1 // growing
		0 // keeplocked
		0 // zero
		OSFILEFLAG_NOCACHE // flags
		swapfile@ IOSwapFile_CapturedFCB + @ // fcb
		IOFileControlBlockTruncate ok! drop

		if (ok@ ~~)
			break
		end else
			if (ok@ STATUS_END_OF_DISK ~=)
				0 realextension!
				return
			end

			if (i@ 1 ==)
				0 realextension!
				return
			end

			extension@ tryextension!
		end

		1 i +=
	end

	tryextension@ realextension!

	// growing the swapfile succeeded. update the structures.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	realextension@ // runlength
	swapfile@ IOSwapFile_CurrentSize + @ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ComBitmapClearBits

	realextension@ swapfile@ IOSwapFile_CurrentSize + +=
	realextension@ IOSwapPagesCount +=
	realextension@ MmCommitLimit +=

	0 swapfile@ IOSwapFile_Hint + !

	ipl@ KeIPLLower
end

fn IOSwapFileContract { -- }
	fnsection "PAGE$text"

	// called by the worker thread every 5 seconds to scan the swapfiles and
	// determine if any of them should be shrunk.

	if (MmEventLowMemory KeDispatchIsSignaled)
		// don't shrink swapfiles while pages are being dumped to disk
		return
	end

	auto potentialcontraction
	MmCommitLimit@ MmCommitUsage@ - potentialcontraction!

	if (potentialcontraction@ IOSWAPFILEMINIMUMEXTENSION 2 * <)
		// if commit usage is within 2 megabytes of the commit limit then it
		// probably isn't worth it to bother scanning the swapfiles.

		return
	end

	auto i
	0 i!

	0 potentialcontraction!

	while (i@ IOSwapFileCount@ <)
		auto swapfile
		[i@]IOSwapFiles@ swapfile!

		auto free
		swapfile@ IOSwapFile_CurrentSize + @ swapfile@ IOSwapFile_UsedCount + @ - free!

		auto excess
		swapfile@ IOSwapFile_CurrentSize + @ swapfile@ IOSwapFile_MinimumSize + @ - excess!

		if (excess@ IOSWAPFILEMINIMUMEXTENSION >=)
			if (free@ IOSWAPFILEMINIMUMEXTENSION >=)
				excess@ free@ min potentialcontraction +=
			end
		end

		1 i +=
	end

	if (potentialcontraction@ IOSWAPFILEMINIMUMEXTENSION 2 * <)
		return
	end

	potentialcontraction@ IOSwapFileTryContractAll
end

fn IOSwapFileTryContractAll { contraction -- }
	fnsection "PAGE$text"

	if (IOSwapFileExtensionIndex@ IOSwapFileCount@ >=)
		0 IOSwapFileExtensionIndex!
	end

	auto i
	0 i!

	while (i@ 2 <)
		auto max
		auto j

		if (i@ 0 ==)
			IOSwapFileCount@ max!
			IOSwapFileExtensionIndex@ j!
		end else
			IOSwapFileExtensionIndex@ max!
			0 j!
		end

		while (j@ max@ <)
			auto contractedby
			contraction@ // contraction
			[j@]IOSwapFiles@ // swapfile
			IOSwapFileTryContract contractedby!

			if (contractedby@ contraction@ >=)
				0 contraction!
				break
			end

			contractedby@ contraction -=

			1 j +=
		end

		if (contraction@ ~~)
			j@ 1 + IOSwapFileExtensionIndex!
			break
		end

		1 i +=
	end
end

fn IOSwapFileTryContract { contraction swapfile -- contractedby }
	0 contractedby!

	if (contraction@ IOSWAPFILEMINIMUMEXTENSION <)
		IOSWAPFILEMINIMUMEXTENSION contraction!
	end

	if (contraction@ swapfile@ IOSwapFile_CurrentSize + @ swapfile@ IOSwapFile_MinimumSize + @ - >)
		swapfile@ IOSwapFile_CurrentSize + @ swapfile@ IOSwapFile_MinimumSize + @ - contraction!
	end

	if (contraction@ IOSWAPFILEMINIMUMEXTENSION <)
		return
	end

	while (contraction@ IOSWAPFILEMINIMUMEXTENSION >=)
		auto ipl
		IPLDPC KeIPLRaise ipl!

		if (contraction@ MmCommitLimit@ >)
			ipl@ KeIPLLower

			break
		end

		if (MmCommitLimit@ contraction@ - MmCommitUsage@ IOSWAPFILEMINIMUMEXTENSION 2 * + <)
			ipl@ KeIPLLower

			break
		end

		auto clear
		contraction@ // runlength
		swapfile@ IOSwapFile_CurrentSize + @ contraction@ - // index
		swapfile@ IOSwapFile_BitmapHeader + // header
		ComBitmapCheckClearBits clear!

		if (clear@)
			// chop!

			contraction@ // runlength
			swapfile@ IOSwapFile_CurrentSize + @ contraction@ - // index
			swapfile@ IOSwapFile_BitmapHeader + // header
			ComBitmapSetBits

			contraction@ swapfile@ IOSwapFile_CurrentSize + -=
			contraction@ IOSwapPagesCount -=
			contraction@ MmCommitLimit -=

			0 swapfile@ IOSwapFile_Hint + !

			ipl@ KeIPLLower

			swapfile@ IOSwapFile_CurrentSize + @ PAGESHIFT << // newsize
			0 // growing
			0 // keeplocked
			0 // zero
			OSFILEFLAG_NOCACHE // flags
			swapfile@ IOSwapFile_CapturedFCB + @ // fcb
			IOFileControlBlockTruncate drop drop

			return
		end

		ipl@ KeIPLLower

		1 contraction >>=
	end
end