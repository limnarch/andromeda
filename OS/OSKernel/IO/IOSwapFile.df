//
// Implements swapfile management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/Transfer.h"

#include "<ll>/OSDLL/OS.h"

var IOSwapPagesUsed 0
public IOSwapPagesUsed

var IOSwapPagesCount 0
public IOSwapPagesCount

var IOSwapPagesUsedPeak 0
public IOSwapPagesUsedPeak

var IOSwapPagesWritten 0
public IOSwapPagesWritten

var IOSwapPagesRead 0
public IOSwapPagesRead

buffer IOSwapFileCreationMutex KeMutex_SIZEOF

buffer IOSwapFileCreationEvent KeEvent_SIZEOF
public IOSwapFileCreationEvent

buffer IOSwapFileExtendEvent KeEvent_SIZEOF
public IOSwapFileExtendEvent

struct IOSwapFile
	4 MinimumSize
	4 MaximumSize
	4 FileObject
	ExBitmapHeader_SIZEOF BitmapHeader
	4 Hint
	4 CurrentSize
	4 UsedCount
	4 Priority
	4 Number
	4 Next
endstruct

const IOSWAPFILEMAX 16
const IOSWAPFILEMAXPRI 8

table IOSwapFiles[IOSWAPFILEMAX]

table IOSwapFilePriorityListHeads[IOSWAPFILEMAXPRI]
table IOSwapFilePriorityListTails[IOSWAPFILEMAXPRI]

var IOSwapFileExtensionIndex 0

var IOSwapFileCount 0

fn IOSwapFileInit { -- }
	"IOSwapFileCreationMutex" // name
	KERNELMODE // mode
	IOSwapFileCreationMutex // mutex
	KeMutexInitialize
end

fn IOSwapFileAwaitCreation { -- }
	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	IOSwapFileCreationEvent // object
	KeThreadWaitForObject drop
end

fn IOSwapFileCreateLock { -- }
	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	IOSwapFileCreationMutex // object
	KeThreadWaitForObject drop
end

fn IOSwapFileCreateUnlock { -- }
	0 // abandon
	IOSwapFileCreationMutex // mutex
	KeMutexRelease drop
end

fn IOSwapFileCreate { minpages maxpages pri path -- ok }
	SeAmIAdmin ok!

	if (ok@)
		STATUS_PERMISSION_DENIED ok!

		return
	end

	if (pri@ IOSWAPFILEMAXPRI >=)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (maxpages@ minpages@ <)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	IOSwapFileCreateLock

	if (IOSwapFileCount@ IOSWAPFILEMAX >=)
		IOSwapFileCreateUnlock

		STATUS_TOO_MANY_SWAPFILES ok!

		return
	end

	416 KeThreadCurrent@ PsThread_FileCreationPermissions + !

	auto handle
	OSFILEFLAG_CREATE // flags
	ACCESS_READ ACCESS_WRITE | // access
	OSNONE // initialobjecthandle
	path@ // path
	ObObjectOpenByPath ok! handle!

	if (ok@)
		IOSwapFileCreateUnlock

		return
	end

	auto fileobject
	auto access
	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	handle@ ObObjectClose drop

	if (ok@)
		IOSwapFileCreateUnlock

		return
	end

	access@ ACCESS_WRITE ACCESS_READ | SeCheckAccess ok!

	if (ok@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_SYSTEMFILE &)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_DEVICE_BUSY ok!

		return
	end

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_BLOCKDEVICE ==)
		// disk or otherwise, can't resize.

		fcb@ IOFileControlBlock_SizeInBytes + @ PAGESHIFT >> dup minpages! maxpages!
	end elseif (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_FILE ==)
		// file, truncate to minpages.

		minpages@ PAGESHIFT << // newsize
		0 // growing
		0 // keeplocked
		0 // zero
		fcb@ // fcb
		IOFileControlBlockTruncate ok! drop

		if (ok@)
			IOSwapFileCreateUnlock

			fileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end else
		// bad

		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_INVALID_ARGUMENT ok!

		return
	end

	if (minpages@ 128 <)
		// needs to be at least 128 pages (512KB with 4KB pages)

		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		STATUS_SWAP_TOO_SMALL ok!

		return
	end

	auto qcharge
	maxpages@ 7 + 3 >> IOSwapFile_SIZEOF + MmChargeBytesGet qcharge!

	qcharge@ // charge
	MmQuotaSystem // quotablock
	MmQuotaBlockCharge ok!

	if (ok@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto bitmap
	maxpages@ 7 + 3 >> // bytes
	'SwBm' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! bitmap!

	if (ok@)
		IOSwapFileCreateUnlock

		qcharge@ // charge
		MmQuotaSystem // quotablock
		MmQuotaBlockUncharge

		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	auto swapfile
	IOSwapFile_SIZEOF // bytes
	'SwFi' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! swapfile!

	if (ok@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		bitmap@ MmFree

		qcharge@ // charge
		MmQuotaSystem // quotablock
		MmQuotaBlockUncharge

		return
	end

	auto cacheblock
	0 // wantcaching
	fcb@ // fcb
	IOFileControlBlockCacheCheck ok! cacheblock!

	// the swapfile will be left with UncachedIOCount biased to prevent page
	// cache accesses to it.

	if (ok@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		bitmap@ MmFree
		swapfile@ MmFree

		qcharge@ // charge
		MmQuotaSystem // quotablock
		MmQuotaBlockUncharge

		return
	end

	if (cacheblock@)
		IOSwapFileCreateUnlock

		fileobject@ ObObjectDereferenceByPointer drop

		bitmap@ MmFree
		swapfile@ MmFree

		qcharge@ // charge
		MmQuotaSystem // quotablock
		MmQuotaBlockUncharge

		STATUS_TRY_AGAIN_LATER ok!

		return
	end

	// initialize the bitmap
	maxpages@ // sizeinbits
	bitmap@ // data
	swapfile@ IOSwapFile_BitmapHeader + // header
	ExBitmapInitialize

	// clear the minimum size
	minpages@ // runlength
	0 // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ExBitmapClearBits

	// set beyond the minimum size
	maxpages@ minpages@ - // runlength
	minpages@ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ExBitmapSetBits

	// set system file flag
	auto rs
	HALCPUInterruptDisable rs!
	IOFCBFLAG_SYSTEMFILE fcb@ IOFileControlBlock_Flags + |=
	rs@ HALCPUInterruptRestore

	// initialize swapfile structures
	minpages@ swapfile@ IOSwapFile_MinimumSize + !
	maxpages@ swapfile@ IOSwapFile_MaximumSize + !
	fileobject@ swapfile@ IOSwapFile_FileObject + !
	0 swapfile@ IOSwapFile_Hint + !
	minpages@ swapfile@ IOSwapFile_CurrentSize + !
	0 swapfile@ IOSwapFile_UsedCount + !
	pri@ swapfile@ IOSwapFile_Priority + !
	IOSwapFileCount@ swapfile@ IOSwapFile_Number + !

	HALCPUInterruptDisable rs!

	swapfile@ [IOSwapFileCount@]IOSwapFiles!
	minpages@ IOSwapPagesCount +=

	auto h
	[pri@]IOSwapFilePriorityListHeads@ h!

	h@ swapfile@ IOSwapFile_Next + !
	swapfile@ [pri@]IOSwapFilePriorityListHeads!

	if (h@ ~~)
		swapfile@ [pri@]IOSwapFilePriorityListTails!
	end

	rs@ HALCPUInterruptRestore

	1 IOSwapFileCount +=

	if (IOSwapFileCount@ 1 ==)
		// this is the first swapfile created.
		// set the commit limit to its size and signal the creation event.

		minpages@ MmCommitLimit!
		maxpages@ MmTheoreticalCommitLimit!

		0 // priboost
		IOSwapFileCreationEvent // event
		KeEventSignal
	end else
		HALCPUInterruptDisable rs!
		minpages@ MmCommitLimit +=
		maxpages@ MmTheoreticalCommitLimit +=
		rs@ HALCPUInterruptRestore
	end

	IOSwapFileCreateUnlock

	// leave fileobject refcount biased

	0 ok!
end

fn IOSwapFileQuery { query id -- ok }
	if (id@ IOSwapFileCount@ >=)
		STATUS_INVALID_ARGUMENT ok!

		return
	end

	0 ok!

	auto swapfile
	[id@]IOSwapFiles@ swapfile!

	if (swapfile@ IOSwapFile_FileObject + @ IOFile_OpenedPath + @)
		query@ OSSwapFileInformation_Name + // dest
		swapfile@ IOSwapFile_FileObject + @ IOFile_OpenedPath + @ // src
		strcpy
	end else
		query@ OSSwapFileInformation_Name + // dest
		"unknown" // src
		strcpy
	end

	swapfile@ IOSwapFile_MinimumSize + @ query@ OSSwapFileInformation_MinimumSize + !
	swapfile@ IOSwapFile_MaximumSize + @ query@ OSSwapFileInformation_MaximumSize + !
	swapfile@ IOSwapFile_CurrentSize + @ query@ OSSwapFileInformation_CurrentSize + !
	swapfile@ IOSwapFile_UsedCount + @ query@ OSSwapFileInformation_UsedCount + !
	swapfile@ IOSwapFile_Priority + @ query@ OSSwapFileInformation_Priority + !
end

fn IOSwapFileReserve { pagesneeded swapfile -- offset ok }
	auto bmpheader
	swapfile@ IOSwapFile_BitmapHeader + bmpheader!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (swapfile@ IOSwapFile_CurrentSize + @ swapfile@ IOSwapFile_UsedCount + @ - pagesneeded@ <)
		ipl@ KeIPLLower

		STATUS_NO_SWAP ok!

		return
	end

	swapfile@ IOSwapFile_Hint + @ // hint
	pagesneeded@ // runlength
	bmpheader@ // header
	ExBitmapFindRun ok! offset!

	if (ok@)
		ipl@ KeIPLLower

		STATUS_NO_SWAP ok!

		return
	end

	pagesneeded@ IOSwapPagesUsed +=

	if (IOSwapPagesUsed@ IOSwapPagesUsedPeak@ >)
		IOSwapPagesUsed@ IOSwapPagesUsedPeak!
	end

	pagesneeded@ swapfile@ IOSwapFile_UsedCount + +=

	pagesneeded@ // runlength
	offset@ // index
	bmpheader@ // header
	ExBitmapSetBits

	ipl@ KeIPLLower

	offset@ swapfile@ IOSwapFile_Hint + !
end

fn IOSwapFileRelease { pages offset swapfile -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	pages@ IOSwapPagesUsed -=
	pages@ swapfile@ IOSwapFile_UsedCount + -=

	pages@ // runlength
	offset@ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ExBitmapClearBits

	ipl@ KeIPLLower
end

fn IOSwapPageFree { pno swapfile -- }
	// frees a page in swap

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 // runlength
	pno@ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ExBitmapClearBits

	1 IOSwapPagesUsed -=
	1 swapfile@ IOSwapFile_UsedCount + -=

	if (DEBUGCHECKS)
		if (IOSwapPagesUsed@ 0 s<)
			"IOSwapPageFree: underflow\n" KeCrash
		end
	end

	ipl@ KeIPLLower
end

fn IOSwapPageFreePTE { pte -- }
	if (DEBUGCHECKS)
		if (pte@ PTE_INSWAP & ~~)
			"IOSwapPageFreePTE: not an INSWAP pte\n" KeCrash
		end
	end

	pte@ PAGESHIFT >> // pno
	[pte@ PTE_SWAPFILE_SHIFT >> PTE_SWAPFILE_MASK &]IOSwapFiles@ // swapfile
	IOSwapPageFree
end

fn IOSwapPageReadPTE { kflags pageframe pte -- ok }
	// reads swap page at pno into pageframe

	if (DEBUGCHECKS)
		if (pageframe@ PAGEOFFSETMASK &)
			"IOSwapPageRead: pageframe wasn't page-aligned\n" KeCrash
		end

		if (pte@ PTE_INSWAP & ~~)
			"IOSwapPageReadPTE: not an INSWAP pte\n" KeCrash
		end
	end

	auto swapfile
	[pte@ PTE_SWAPFILE_SHIFT >> PTE_SWAPFILE_MASK &]IOSwapFiles@ swapfile!

	auto fcb
	swapfile@ IOSwapFile_FileObject + @ IOFile_FileControlBlock + @ fcb!

	auto readfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

	// perform the read operation

	auto event
	KeEvent_SIZEOF alloc event!

	0 // signaled
	OSEVENT_NOTIF // type
	"IOSwapPageReadEvent" // name
	event@ // event
	KeEventInitialize

	auto mdl
	MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

	KERNELMODE // mode
	PAGESIZE // length
	pageframe@ // vaddr
	mdl@ // mdl
	MmMDLInitialize

	event@ mdl@ MmMDLHeader_Event + !

	OSWAIT_TIMEOUTINFINITE // timeout
	0 // flags
	kflags@ // kflags
	pte@ PAGENUMBERMASK & // offset
	mdl@ // mdl
	fcb@ // fcb
	readfunc@ IODispatchReadFunction ok! drop

	if (ok@)
		// complete the MDL so we can wait for any fragments to finish

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end

	if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		event@ // object
		KeThreadWaitForObject drop
	end

	if (ok@)
		return
	end

	mdl@ MmMDLHeader_Status + @ ok!

	if (ok@)
		return
	end

	auto rs
	HALCPUInterruptDisable rs!
	1 IOSwapPagesRead +=
	rs@ HALCPUInterruptRestore
end

fn IOSwapFileWriteMDL { pagecount mdl -- ok }
	0 ok!

	KERNELMODE // mode
	pagecount@ PAGESHIFT << // length
	0 // vaddr
	mdl@ // mdl
	MmMDLInitialize

	2 mdl@ MmMDLHeader_PinCount + !
	pointerof IOSwapPageWriteMDLComplete mdl@ MmMDLHeader_CompleteRoutine + !
	0 mdl@ MmMDLHeader_Context1 + !

	auto pri
	0 pri!

	auto offset
	0 offset!

	auto fragged
	0 fragged!

	while (pri@ IOSWAPFILEMAXPRI <)
		auto swapfile
		[pri@]IOSwapFilePriorityListHeads@ swapfile!

		if (swapfile@)
			auto writtencount
			pagecount@ // pagecount
			offset@ // offset
			mdl@ // mdl
			pri@ // pri
			IOSwapFileWritePriorityLevel ok! writtencount! fragged |=

			if (ok@ ~~)
				writtencount@ offset +=
				writtencount@ pagecount -=

				if (pagecount@ ~~)
					if (fragged@)
						0 // status
						0 // priboost
						mdl@ // mdl
						MmMDLComplete
					end

					return
				end
			end

			0 ok!
		end

		1 pri +=
	end

	if (pagecount@)
		STATUS_NO_SWAP ok!

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end
end

fn IOSwapFileWritePriorityLevel { pagecount offset mdl pri -- fragged writtenpagecount ok }
	// write as many pages as possible at this swapfile priority level.

	0 writtenpagecount!
	0 ok!
	0 fragged!

	auto pagestowrite
	pagecount@ pagestowrite!

	while (pagestowrite@)
		auto swapfile
		[pri@]IOSwapFilePriorityListHeads@ swapfile!

		while (swapfile@)
			0 ok!

			while (ok@ ~~)
				// try to write clusters of this size until we either run out of
				// pages to write or we discover that this swapfile no longer has
				// room for them.

				pagestowrite@ // pagecount
				offset@ // mdloffset
				mdl@ // mdl
				swapfile@ // swapfile
				IOSwapFileWritePages ok! fragged |=

				if (ok@ ~~)
					pagestowrite@ pagecount -=
					pagestowrite@ writtenpagecount +=
					pagestowrite@ offset +=

					if (pagecount@ pagestowrite@ <)
						if (pagecount@ ~~)
							break
						end

						pagecount@ pagestowrite!
					end
				end else
					if (ok@ STATUS_NO_SWAP ~=)
						return
					end

					0 ok!

					break
				end
			end

			if (pagecount@ pagestowrite@ <)
				if (pagecount@ ~~)
					break
				end

				pagecount@ pagestowrite!
			end

			swapfile@ IOSwapFile_Next + @ swapfile!
		end

		if (pagecount@ ~~)
			break
		end

		1 pagestowrite >>=
	end

	if (writtenpagecount@)
		auto rs
		HALCPUInterruptDisable rs!

		auto h
		[pri@]IOSwapFilePriorityListHeads@ h!

		auto t
		[pri@]IOSwapFilePriorityListTails@ t!

		if (h@ t@ ~=)
			// move the first swapfile to the end of the priority queue so we
			// fill them in a round-robin fashion to help avoid fragmentation.

			h@ IOSwapFile_Next + @ [pri@]IOSwapFilePriorityListHeads!
			0 h@ IOSwapFile_Next + !
			h@ t@ IOSwapFile_Next + !
			h@ [pri@]IOSwapFilePriorityListTails!
		end

		rs@ HALCPUInterruptRestore
	end
end

fn IOSwapFileWritePages { pagecount mdloffset mdl swapfile -- fragged ok }
	// try to write this many pages as a single clustered operation to the
	// swapfile.

	auto offset
	pagecount@ // pagecount
	swapfile@ // swapfile
	IOSwapFileReserve ok! offset!

	if (ok@)
		return
	end

	auto writemdl

	if (mdl@ MmMDLHeader_Pages + @ pagecount@ ~=)
		// have to split the mdl

		KERNELMODE // mode
		pagecount@ PAGESHIFT << // length
		mdloffset@ PAGESHIFT << // vaddr
		IOKFLAG_SWAPOUT // kflags
		MmMDLAllocate ok! writemdl!

		if (ok@)
			pagecount@ // pages
			offset@ // offset
			swapfile@ // swapfile
			IOSwapFileRelease

			return
		end

		mdloffset@ PAGESHIFT << // vaddr
		pagecount@ PAGESHIFT << // length
		mdl@ // srcmdl
		writemdl@ // destmdl
		MmMDLSplit

		1 fragged!
	end else
		if (DEBUGCHECKS)
			if (mdloffset@)
				"IOSwapFileWritePages: mdloffset\n" KeCrash
			end
		end

		// can use the MDL as-is
		mdl@ writemdl!

		0 fragged!
	end

	// perform the write operation

	mdl@ writemdl@ MmMDLHeader_Context1 + !
	offset@ writemdl@ MmMDLHeader_Context2 + !
	swapfile@ writemdl@ MmMDLHeader_Context3 + !

	pointerof IOSwapPageWriteMDLComplete writemdl@ MmMDLHeader_CompleteRoutine + !

	auto fcb
	swapfile@ IOSwapFile_FileObject + @ IOFile_FileControlBlock + @ fcb!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	0 // flags
	IOKFLAG_SWAPOUT // kflags
	offset@ PAGESHIFT << // offset
	writemdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok! drop

	if (ok@)
		pagecount@ // pages
		offset@ // offset
		swapfile@ // swapfile
		IOSwapFileRelease

		return
	end

	pagecount@ IOSwapPagesWritten +=
end

fn (MmMDLCompleteRoutine) IOSwapPageWriteMDLComplete { mdl -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto transfer
	mdl@ MmMDLHeader_Context1 + @ transfer!

	if (transfer@)
		auto pagecount
		mdl@ MmMDLHeader_Pages + @ pagecount!

		auto swapfile
		mdl@ MmMDLHeader_Context3 + @ swapfile!

		auto offset
		mdl@ MmMDLHeader_Context2 + @ offset!

		auto mdlpos
		mdl@ MmMDLHeader_SIZEOF + mdlpos!

		auto number
		swapfile@ IOSwapFile_Number + @ number!

		while (pagecount@)
			auto pfdbe
			mdlpos@@ pfdbe!

			if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb
				MMEVICTFLAG_MODIFIED MMEVICTFLAG_DELETED | &)
				// modified or deleted, free the swap page :(

				offset@ swapfile@ IOSwapPageFree
			end else
				offset@ PAGESHIFT << number@ PTE_SWAPFILE_SHIFT << | PTE_INSWAP | pfdbe@ MmPageFrameEntryAnonymous_SwapPTE + !
			end

			pfdbe@ MmEvictablePageDereference drop

			1 offset +=
			1 pagecount -=
			4 mdlpos +=
		end
	end

	if (mdl@ MmMDLHeader_ParentMDL + @ ~~)
		// root MDL, complete transfer
		mdl@ IOTransferComplete
	end

	ipl@ KeIPLLower
end

var IOSwapFileExtensionListHead 0
var IOSwapFileExtensionListTail 0

struct IOSwapFileExtension
	4 Next
	4 Pages
	KeEvent_SIZEOF Event
	4 Success
endstruct

fn IOSwapFileRequestExpansion { pages -- ok }
	// entered and left at IPLDPC.

	IPLLOW KeIPLLower

	// quick check to make sure this can feasibly work before we go to the
	// trouble of queuing a request and waking the worker thread.

	auto i
	0 i!

	auto avail
	0 avail!

	while (i@ IOSwapFileCount@ <)
		auto swapfile
		[i@]IOSwapFiles@ swapfile!

		swapfile@ IOSwapFile_MaximumSize + @ swapfile@ IOSwapFile_CurrentSize + @ - avail +=

		if (avail@ pages@ >=)
			break
		end

		1 i +=
	end

	if (avail@ pages@ <)
		// not enough potential expansion left to satisfy this.
		STATUS_COMMIT_EXCEEDED ok!
		return
	end

	auto extension
	IOSwapFileExtension_SIZEOF alloc extension!

	0 extension@ IOSwapFileExtension_Next + !
	pages@ extension@ IOSwapFileExtension_Pages + !
	-1 extension@ IOSwapFileExtension_Success + !

	0 // signaled
	OSEVENT_SYNCH // type
	"IOSwapFileRequestExpansionEvent" // name
	extension@ IOSwapFileExtension_Event + // event
	KeEventInitialize

	auto rs
	HALCPUInterruptDisable rs!

	auto t
	IOSwapFileExtensionListTail@ t!

	if (t@ ~~)
		extension@ IOSwapFileExtensionListHead!
	end else
		extension@ t@ IOSwapFileExtension_Next + !
	end

	extension@ IOSwapFileExtensionListTail!

	rs@ HALCPUInterruptRestore

	0 // priboost
	IOSwapFileExtendEvent // event
	KeEventSignal

	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	extension@ IOSwapFileExtension_Event + // object
	KeThreadWaitForObject drop

	extension@ IOSwapFileExtension_Success + @ ok!

	IPLDPC KeIPLRaise drop
end

fn IOSwapFileExtend { -- }
	// called by worker thread.
	// pops extension requests off the listhead and tries to satisfy them.
	// satisfying a request is done by extending the pagefile, signaling the
	// event to wake up the waiting thread, and atomically granting the
	// requested commitment to the process. commitment may already be
	// plentiful to grant it without extending the swapfile, in that case,
	// just do that.

	while (IOSwapFileExtensionListHead@)
		auto extension

		auto rs
		HALCPUInterruptDisable rs!

		IOSwapFileExtensionListHead@ extension!
		extension@ IOSwapFileExtension_Next + @ IOSwapFileExtensionListHead!

		if (IOSwapFileExtensionListHead@ ~~)
			0 IOSwapFileExtensionListTail!
		end

		rs@ HALCPUInterruptRestore

		extension@ IOSwapFileSatisfyExtension
	end
end

fn IOSwapFileSatisfyExtension { extension -- }
	auto i
	0 i!

	auto avail
	0 avail!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (extension@ IOSwapFileExtension_Pages + @ MmCommitUsage@ + MmCommitLimit@ <=)
		// immediately succeed
		ipl@ KeIPLLower

		0 extension@ IOSwapFileExtension_Success + !

		0 // priboost
		extension@ IOSwapFileExtension_Event + // event
		KeEventSignal

		return
	end

	while (i@ IOSwapFileCount@ <)
		auto swapfile
		[i@]IOSwapFiles@ swapfile!

		swapfile@ IOSwapFile_MaximumSize + @ swapfile@ IOSwapFile_CurrentSize + @ - avail +=

		if (avail@ extension@ IOSwapFileExtension_Pages + @ >=)
			break
		end

		1 i +=
	end

	if (avail@ extension@ IOSwapFileExtension_Pages + @ <)
		// immediately fail
		ipl@ KeIPLLower

		STATUS_COMMIT_EXCEEDED extension@ IOSwapFileExtension_Success + !

		0 // priboost
		extension@ IOSwapFileExtension_Event + // event
		KeEventSignal

		return
	end

	auto requiredextension
	extension@ IOSwapFileExtension_Pages + @ MmCommitUsage@ + MmCommitLimit@ - requiredextension!

	ipl@ KeIPLLower

	requiredextension@ IOSwapFileTryExtendAll extension@ IOSwapFileExtension_Success + !

	0 // priboost
	extension@ IOSwapFileExtension_Event + // event
	KeEventSignal
end

fn IOSwapFileTryExtendAll { extension -- ok }
	if (IOSwapFileExtensionIndex@ IOSwapFileCount@ >=)
		0 IOSwapFileExtensionIndex!
	end

	0 ok!

	auto i
	0 i!

	while (i@ 2 <)
		auto max
		auto j

		if (i@ 0 ==)
			IOSwapFileCount@ max!
			IOSwapFileExtensionIndex@ j!
		end else
			IOSwapFileExtensionIndex@ max!
			0 j!
		end

		while (j@ max@ <)
			auto realextension
			extension@ // extension
			[j@]IOSwapFiles@ // swapfile
			IOSwapFileTryExtend realextension!

			if (realextension@ extension@ >)
				0 extension!
			end else
				realextension@ extension -=
			end

			if (extension@ ~~)
				break
			end

			1 j +=
		end

		if (extension@ ~~)
			j@ 1 + IOSwapFileExtensionIndex!
			break
		end

		1 i +=
	end

	if (extension@)
		STATUS_COMMIT_EXCEEDED ok!
	end
end

const IOSWAPFILEMINIMUMEXTENSION 128

fn IOSwapFileTryExtend { extension swapfile -- realextension }
	auto maxextend
	swapfile@ IOSwapFile_MaximumSize + @ swapfile@ IOSwapFile_CurrentSize + @ - maxextend!

	auto i
	0 i!

	auto tryextension
	extension@ tryextension!

	if (tryextension@ IOSWAPFILEMINIMUMEXTENSION <)
		IOSWAPFILEMINIMUMEXTENSION tryextension!
	end

	if (maxextend@ tryextension@ <)
		maxextend@ tryextension!
	end

	if (extension@ tryextension@ ==)
		1 i!
	end

	while (i@ 2 <)
		auto ok
		swapfile@ IOSwapFile_CurrentSize + @ tryextension@ + PAGESHIFT << // newsize
		1 // growing
		0 // keeplocked
		0 // zero
		swapfile@ IOSwapFile_FileObject + @ IOFile_FileControlBlock + @ // fcb
		IOFileControlBlockTruncate ok! drop

		if (ok@ ~~)
			break
		end else
			if (ok@ STATUS_END_OF_DISK ~=)
				0 realextension!
				return
			end

			if (i@ 1 ==)
				0 realextension!
				return
			end

			extension@ tryextension!
		end

		1 i +=
	end

	tryextension@ realextension!

	// growing the swapfile succeeded. update the structures.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	realextension@ // runlength
	swapfile@ IOSwapFile_CurrentSize + @ // index
	swapfile@ IOSwapFile_BitmapHeader + // header
	ExBitmapClearBits

	realextension@ swapfile@ IOSwapFile_CurrentSize + +=
	realextension@ IOSwapPagesCount +=
	realextension@ MmCommitLimit +=

	ipl@ KeIPLLower
end