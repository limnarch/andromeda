//
// Implements swapfile management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALArgs.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

var IOSwapPagesUsed 0
public IOSwapPagesUsed

var IOSwapPagesCount 0
public IOSwapPagesCount

var IOSwapPagesUsedPeak 0
public IOSwapPagesUsedPeak

var IOSwapPagesWritten 0
public IOSwapPagesWritten

var IOSwapPagesRead 0
public IOSwapPagesRead

var IOSwapPageHint 0

var IOSwapFileObject 0

buffer IOSwapBitmap ExBitmapHeader_SIZEOF

buffer IOSwapFileCreationMutex KeMutex_SIZEOF

buffer IOSwapFileCreationEvent KeEvent_SIZEOF
public IOSwapFileCreationEvent

fn IOSwapFileInit { -- }
	"IOSwapFileCreationMutex" // name
	KERNELMODE // mode
	IOSwapFileCreationMutex // mutex
	KeMutexInitialize
end

fn IOSwapFileAwaitCreation { -- }
	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	IOSwapFileCreationEvent // object
	KeThreadWaitForObject drop
end

fn IOSwapFileCreateLock { -- }
	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	IOSwapFileCreationMutex // object
	KeThreadWaitForObject drop
end

fn IOSwapFileCreateUnlock { -- }
	0 // abandon
	IOSwapFileCreationMutex // mutex
	KeMutexRelease drop
end

fn IOSwapFileCreateObject { fileobject -- sizeinpages ok }
	SeAmIAdmin ok!

	if (ok@)
		STATUS_PERMISSION_DENIED ok!

		return
	end

	IOSwapFileCreateLock

	if (IOSwapFileObject@)
		IOSwapFileCreateUnlock

		STATUS_FORBIDDEN_OPERATION ok!

		return
	end

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_BLOCKDEVICE ==)
		// disk or otherwise
	end elseif (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_FILE ==)
		// file
	end else
		// bad

		IOSwapFileCreateUnlock

		STATUS_INVALID_ARGUMENT ok!

		return
	end

	fcb@ IOFileControlBlock_SizeInBytes + @ PAGESHIFT >> sizeinpages!

	if (sizeinpages@ 128 <)
		// needs to be at least 128 pages (512KB with 4KB pages)

		IOSwapFileCreateUnlock

		STATUS_SWAP_TOO_SMALL ok!

		return
	end

	auto bitmap

	sizeinpages@ 7 + 3 >> // bytes
	'SwBm' // tag
	0 // flags
	MmAllocWithTag ok! bitmap!

	if (ok@)
		IOSwapFileCreateUnlock

		return
	end

	auto cacheblock

	0 // wantcaching
	fcb@ // fcb
	IOFileControlBlockCacheCheck ok! cacheblock!

	// the swapfile will be left with UncachedIOCount biased to prevent page
	// cache accesses to it.

	if (ok@)
		IOSwapFileCreateUnlock

		bitmap@ MmFree

		return
	end

	if (cacheblock@)
		IOSwapFileCreateUnlock

		bitmap@ MmFree

		STATUS_TRY_AGAIN_LATER ok!

		return
	end

	sizeinpages@ // sizeinbits
	bitmap@ // data
	IOSwapBitmap // header
	ExBitmapInitialize

	IOSwapBitmap // header
	ExBitmapClear

	// bias refcount
	fileobject@ ObObjectReferenceByPointer drop

	// set system file flag
	auto rs
	HALCPUInterruptDisable rs!
	IOFCBFLAG_SYSTEMFILE fcb@ IOFileControlBlock_Flags + |=
	rs@ HALCPUInterruptRestore

	// set as swapfile
	fileobject@ IOSwapFileObject!

	sizeinpages@ IOSwapPagesCount!
	sizeinpages@ MmCommitLimit!

	0 // priboost
	IOSwapFileCreationEvent // event
	KeEventSignal

	IOSwapFileCreateUnlock

	0 ok!
end

fn IOSwapFileCreate { filehandle -- sizeinpages ok }
	auto fileobject
	auto access

	IOFileTypeObject@ // type
	filehandle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ ACCESS_WRITE ACCESS_READ | SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	fileobject@ // fileobject
	IOSwapFileCreateObject ok! sizeinpages!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOSwapFileReserve { pagesneeded -- offset ok }
	auto bmpheader
	IOSwapBitmap bmpheader!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	IOSwapPageHint@ // hint
	pagesneeded@ // runlength
	bmpheader@ // header
	ExBitmapFindRun ok! offset!

	if (ok@)
		ipl@ KeIPLLower

		STATUS_NO_SWAP ok!

		return
	end

	pagesneeded@ IOSwapPagesUsed +=

	if (IOSwapPagesUsed@ IOSwapPagesUsedPeak@ >)
		IOSwapPagesUsed@ IOSwapPagesUsedPeak!
	end

	offset@ IOSwapPageHint!

	pagesneeded@ // runlength
	offset@ // index
	bmpheader@ // header
	ExBitmapSetBits

	ipl@ KeIPLLower
end

fn IOSwapFileRelease { pages offset -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	pages@ IOSwapPagesUsed -=

	pages@ // runlength
	offset@ // index
	IOSwapBitmap // header
	ExBitmapClearBits

	ipl@ KeIPLLower
end

fn IOSwapPageFree { pno -- }
	// frees a page in swap

	if (DEBUGCHECKS)
		if (IOSwapFileObject@ ~~)
			"IOSwapPageFree: no swapfile\n" KeCrash
		end
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 // runlength
	pno@ // index
	IOSwapBitmap // header
	ExBitmapClearBits

	1 IOSwapPagesUsed -=

	if (DEBUGCHECKS)
		if (IOSwapPagesUsed@ 0 s<)
			"IOSwapPageFree: underflow\n" KeCrash
		end
	end

	ipl@ KeIPLLower
end

fn IOSwapPageRead { kflags pageframe pno -- ok }
	// reads swap page at pno into pageframe and frees it in swap

	if (DEBUGCHECKS)
		if (pageframe@ PAGEOFFSETMASK &)
			"IOSwapPageRead: pageframe wasn't page-aligned\n" KeCrash
		end

		if (IOSwapFileObject@ ~~)
			"IOSwapPageRead: no swapfile\n" KeCrash
		end
	end

	auto fcb
	IOSwapFileObject@ IOFile_FileControlBlock + @ fcb!

	auto readfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

	// perform the read operation

	auto mdl
	MmMDLHeader_SIZEOF 4 2 * + alloc mdl!

	KERNELMODE // mode
	PAGESIZE // length
	pageframe@ // vaddr
	mdl@ // mdl
	MmMDLInitialize

	OSWAIT_TIMEOUTINFINITE // timeout
	0 // flags
	kflags@ // kflags
	pno@ PAGESHIFT << // offset
	mdl@ // mdl
	fcb@ // fcb
	readfunc@ IODispatchReadFunction ok! drop

	if (ok@)
		return
	end

	auto rs
	HALCPUInterruptDisable rs!
	1 IOSwapPagesRead +=
	rs@ HALCPUInterruptRestore
end

fn IOSwapFileWriteMDL { pagecount mdl -- ok }
	if (DEBUGCHECKS)
		if (IOSwapFileObject@ ~~)
			"IOSwapFileWriteMDL: no swapfile\n" KeCrash
		end
	end

	KERNELMODE // mode
	pagecount@ PAGESHIFT << // length
	0 // vaddr
	mdl@ // mdl
	MmMDLInitialize

	1 mdl@ MmMDLHeader_PinCount + !

	auto offset
	pagecount@ IOSwapFileReserve ok! offset!

	if (ok@)
		// failed to reserve space for the entire MDL, try half-size chunks.

		pagecount@ // pagecount
		mdl@ // mdl
		IOSwapFileWriteHalfMDL ok!

		return
	end

	auto fcb
	IOSwapFileObject@ IOFile_FileControlBlock + @ fcb!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	// perform the write operation

	0 // flags
	IOKFLAG_SWAPOUT // kflags
	offset@ PAGESHIFT << // offset
	mdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok! drop

	if (ok@)
		pagecount@ // pages
		offset@ // offset
		IOSwapFileRelease

		return
	end

	pagecount@ // pagecount
	offset@ // offset
	mdl@ // mdl
	IOSwapPageWriteMDLComplete

	1 IOSwapPagesWritten += // misnomer: counts transfers, not pages
end

fn IOSwapFileWriteHalfMDL { pagecount mdl -- ok }
	auto halfcount
	pagecount@ 1 >> halfcount!

	auto otherhalfcount
	pagecount@ halfcount@ - otherhalfcount!

	auto offset
	halfcount@ IOSwapFileReserve ok! offset!

	if (ok@)
		// swapfile is too fragmented to even write half, fall back to page
		// writes.

		pagecount@ // pagecount
		mdl@ // mdl
		IOSwapFileWritePagesMDL ok!

		return
	end

	auto halfmdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT 1 + >> 1 + 4 * + alloc halfmdl!

	0 // vaddr
	halfcount@ PAGESHIFT << // length
	mdl@ // srcmdl
	halfmdl@ // destmdl
	MmMDLSplit

	auto fcb
	IOSwapFileObject@ IOFile_FileControlBlock + @ fcb!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	// perform the write operation

	0 // flags
	IOKFLAG_SWAPOUT // kflags
	offset@ PAGESHIFT << // offset
	halfmdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok! drop

	if (ok@)
		halfcount@ // pages
		offset@ // offset
		IOSwapFileRelease

		return
	end

	halfcount@ // pagecount
	offset@ // offset
	halfmdl@ // mdl
	IOSwapPageWriteMDLComplete

	// do the other half now

	if (otherhalfcount@ ~~)
		return
	end

	halfcount@ PAGESHIFT << // vaddr
	otherhalfcount@ PAGESHIFT << // length
	mdl@ // srcmdl
	halfmdl@ // destmdl
	MmMDLSplit

	otherhalfcount@ IOSwapFileReserve ok! offset!

	if (ok@)
		// swapfile is too fragmented to write other half, fall back to page
		// writes.

		otherhalfcount@ // pagecount
		halfmdl@ // mdl
		IOSwapFileWritePagesMDL ok!

		return
	end

	0 // flags
	IOKFLAG_SWAPOUT // kflags
	offset@ PAGESHIFT << // offset
	halfmdl@ // mdl
	fcb@ // fcb
	writefunc@ IODispatchWriteFunction ok! drop

	if (ok@)
		otherhalfcount@ // pages
		offset@ // offset
		IOSwapFileRelease

		return
	end

	otherhalfcount@ // pagecount
	offset@ // offset
	halfmdl@ // mdl
	IOSwapPageWriteMDLComplete
end

fn IOSwapFileWritePagesMDL { pagecount mdl -- ok }
	// write the pages in the MDL one at a time.
	// this isn't preferred but must be resorted to sometimes.

	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto writemdl
	MmMDLHeader_SIZEOF 8 + alloc writemdl!

	KERNELMODE // mode
	PAGESIZE // length
	0 // vaddr
	writemdl@ // mdl
	MmMDLInitialize

	1 writemdl@ MmMDLHeader_PinCount + !

	-1 writemdl@ MmMDLHeader_SIZEOF + 4 + !

	auto fcb
	IOSwapFileObject@ IOFile_FileControlBlock + @ fcb!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	while (pagecount@)
		auto pfdbe
		mdlpos@@ pfdbe!

		pfdbe@ writemdl@ MmMDLHeader_SIZEOF + !

		auto offset
		1 IOSwapFileReserve ok! offset!

		if (ok@)
			return
		end

		// perform the write operation

		0 // flags
		IOKFLAG_SWAPOUT // kflags
		offset@ PAGESHIFT << // offset
		writemdl@ // mdl
		fcb@ // fcb
		writefunc@ IODispatchWriteFunction ok! drop

		if (ok@)
			offset@ IOSwapPageFree
			return
		end

		auto ipl
		IPLDPC KeIPLRaise ipl!

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb
			MMEVICTFLAG_MODIFIED MMEVICTFLAG_DELETED | &)
			// modified or deleted, free the swap page :(

			offset@ IOSwapPageFree
		end else
			offset@ pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + !
		end

		pfdbe@ MmEvictablePageDereference drop

		ipl@ KeIPLLower

		1 pagecount -=
		4 mdlpos +=
	end
end

fn IOSwapPageWriteMDLComplete { pagecount offset mdl -- }
	auto mdlpos
	mdl@ MmMDLHeader_SIZEOF + mdlpos!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	while (pagecount@)
		auto pfdbe
		mdlpos@@ pfdbe!

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb
			MMEVICTFLAG_MODIFIED MMEVICTFLAG_DELETED | &)
			// modified or deleted, free the swap page :(

			offset@ IOSwapPageFree
		end else
			offset@ pfdbe@ MmPageFrameEntryAnonymous_SwapPageNumber + !
		end

		pfdbe@ MmEvictablePageDereference drop

		1 offset +=
		1 pagecount -=
		4 mdlpos +=
	end

	ipl@ KeIPLLower
end