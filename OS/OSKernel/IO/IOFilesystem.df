//
// Implements filesystem volume management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "IOInternal.h"

var IOFilesystemListHead 0
public IOFilesystemListHead

var IOMountListHead 0
public IOMountListHead

var IOMountCount 0
public IOMountCount

fn IOiLockMountList { alertable -- ok }
	fnsection "PAGE$text"

	alertable@ // alertable
	0 // nowait
	IOiMountListRwLock // rwlock
	ExRwLockAcquireExclusive ok!
end

fn IOiLockMountListShared { alertable -- ok }
	fnsection "PAGE$text"

	alertable@ // alertable
	0 // nowait
	0 // canstarve
	IOiMountListRwLock // rwlock
	ExRwLockAcquireShared ok!
end

fn IOiUnlockMountList { -- }
	fnsection "PAGE$text"

	IOiMountListRwLock ExRwLockRelease
end

fn IOFilesystemRegister { filesystem -- ok }
	fnsection "INIT$text"

	// assumes being run single-threaded (i.e. in a DriverInit routine)...

	0 ok!

	IOFilesystemListHead@ filesystem@ IOFilesystem_Next + !
	filesystem@ IOFilesystemListHead!
end

fn IOFilesystemMount { flags handle fsname -- mount ok }
	fnsection "PAGE$text"

	auto fileobject

	auto access

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ // access
	ACCESS_READ // permission
	SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	if (flags@ OSMOUNT_READONLY & ~~)
		access@ // access
		ACCESS_WRITE // permission
		SeCheckAccess ok!

		if (ok@)
			fileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end

	flags@ // flags
	fileobject@ // fileobject
	fsname@ // fsname
	IOMountObject ok! mount!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOMountObject { flags fileobject fsname -- mount ok }
	fnsection "PAGE$text"

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto filetype
	fcbp@ IOFileControlBlockPaged_FileType + @ filetype!

	if (filetype@ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	if (filetype@ OSFILETYPE_BLOCKDEVICE ~=)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	auto filesystem
	0 filesystem!

	if (fsname@)
		IOFilesystemListHead@ filesystem!

		while (filesystem@)
			if (filesystem@ IOFilesystem_Name + @ fsname@ strcmp)
				break
			end

			filesystem@ IOFilesystem_Next + @ filesystem!
		end

		if (filesystem@ ~~)
			STATUS_NO_SUCH_FILESYSTEM ok!

			return
		end
	end

	1 IOiLockMountList ok!

	if (ok@)
		return
	end

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		IOiUnlockMountList

		return
	end

	if (fcbp@ IOFileControlBlockPaged_Mount + @)
		fcb@ IOFileControlBlockUnlock
		IOiUnlockMountList

		STATUS_DEVICE_BUSY ok!

		return
	end

	IOMount_SIZEOF // bytes
	'IOMt' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! mount!

	if (ok@)
		fcb@ IOFileControlBlockUnlock
		IOiUnlockMountList

		return
	end

	0 mount@ IOMount_Next + !
	0 mount@ IOMount_Prev + !

	0 mount@ IOMount_FSContext + !
	fileobject@ mount@ IOMount_VolumeFile + !
	0 mount@ IOMount_RootFCB + !
	flags@ mount@ IOMount_Flags + !
	0 mount@ IOMount_RealVolumeFile + !
	0 mount@ IOMount_VolumeCapturedFCB + !
	0 mount@ IOMount_RealVolumeCapturedFCB + !
	0 mount@ IOMount_ReclaimedFrom + !

	STATUS_BAD_FILESYSTEM ok!

	auto mountfunc

	if (filesystem@ ~~)
		// no filesystem was explicitly given.
		// try any

		IOFilesystemListHead@ filesystem!

		while (filesystem@)
			filesystem@ mount@ IOMount_Filesystem + !
			
			if (filesystem@ IOFilesystem_Flags + @ IOFSFLAG_NOAUTO & ~~)
				filesystem@ IOFilesystem_MountFunction + @ mountfunc!

				if (DEBUGCHECKS)
					if (mountfunc@ ~~)
						"IOMountObject: filesystem had no mount function 1\n" KeCrash
					end
				end

				mount@ // mount
				mountfunc@ IOFilesystemMountFunction ok!

				if (ok@ 0 ==)
					// successfully mounted as this filesystem

					break
				end
			end

			filesystem@ IOFilesystem_Next + @ filesystem!
		end
	end else
		filesystem@ mount@ IOMount_Filesystem + !

		filesystem@ IOFilesystem_MountFunction + @ mountfunc!

		if (DEBUGCHECKS)
			if (mountfunc@ ~~)
				"IOMountObject: filesystem had no mount function 2\n" KeCrash
			end
		end

		mount@ // mount
		mountfunc@ IOFilesystemMountFunction ok!
	end

	if (ok@)
		fcb@ IOFileControlBlockUnlock
		IOiUnlockMountList

		// did not successfully mount

		mount@ MmFree

		return
	end

	mount@ fcbp@ IOFileControlBlockPaged_Mount + !

	// bias the reference count of the volume file object
	fileobject@ ObObjectReferenceByPointer drop

	// add to head of mount list

	auto h
	IOMountListHead@ h!

	if (h@)
		mount@ h@ IOMount_Prev + !
	end

	h@ mount@ IOMount_Next + !
	mount@ IOMountListHead!

	1 IOMountCount +=

	fcb@ IOFileControlBlockUnlock
	IOiUnlockMountList
end

fn IOFilesystemUnmount { handle -- ok }
	fnsection "PAGE$text"

	auto fileobject

	auto access

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ // access
	ACCESS_READ // permission
	SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	fileobject@ // fileobject
	IOUnmountObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOUnmountObject { fileobject -- ok }
	fnsection "PAGE$text"

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto filetype
	fcbp@ IOFileControlBlockPaged_FileType + @ filetype!

	if (filetype@ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	if (filetype@ OSFILETYPE_BLOCKDEVICE ~=)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	1 IOiLockMountList ok!

	if (ok@)
		return
	end

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		IOiUnlockMountList

		return
	end

	auto mount
	fcbp@ IOFileControlBlockPaged_Mount + @ mount!

	if (mount@ ~~)
		fcb@ IOFileControlBlockUnlock
		IOiUnlockMountList

		STATUS_NOT_MOUNTED ok!

		return
	end

	auto filesystem
	mount@ IOMount_Filesystem + @ filesystem!

	auto unmountfunc
	filesystem@ IOFilesystem_UnmountFunction + @ unmountfunc!

	if (DEBUGCHECKS)
		if (unmountfunc@ ~~)
			"IOUnmountObject: filesystem had no unmount function\n" KeCrash
		end
	end

	mount@ // mount
	unmountfunc@ IOFilesystemUnmountFunction ok!

	if (ok@)
		// failed to unmount

		fcb@ IOFileControlBlockUnlock
		IOiUnlockMountList

		return
	end

	// remove from mount list
	auto n
	mount@ IOMount_Next + @ n!

	if (n@)
		mount@ IOMount_Prev + @ n@ IOMount_Prev + !
	end

	auto p
	mount@ IOMount_Prev + @ p!

	if (p@)
		mount@ IOMount_Next + @ p@ IOMount_Next + !
	end else // no prev means we were the head
		mount@ IOMount_Next + @ IOMountListHead!
	end

	1 IOMountCount -=

	auto volfile
	mount@ IOMount_VolumeFile + @ volfile!

	mount@ MmFree

	// unmounted successfully

	0 fcbp@ IOFileControlBlockPaged_Mount + !

	// unbias reference count of volume file object

	volfile@ ObObjectDereferenceByPointer drop

	fcb@ IOFileControlBlockUnlock
	IOiUnlockMountList
end

fn IOMountUpdateFlags { newflags handle -- ok }
	fnsection "PAGE$text"

	auto fileobject

	auto access

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ // access
	ACCESS_READ // permission
	SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	if (newflags@ OSMOUNT_READONLY & ~~)
		access@ // access
		ACCESS_WRITE // permission
		SeCheckAccess ok!

		if (ok@)
			fileobject@ ObObjectDereferenceByPointer drop

			return
		end
	end

	newflags@ // newflags
	fileobject@ // fileobject
	IOMountUpdateFlagsObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOMountUpdateFlagsObject { newflags fileobject -- ok }
	fnsection "PAGE$text"

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto filetype
	fcbp@ IOFileControlBlockPaged_FileType + @ filetype!

	if (filetype@ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	if (filetype@ OSFILETYPE_BLOCKDEVICE ~=)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	auto mount
	fcbp@ IOFileControlBlockPaged_Mount + @ mount!

	if (mount@ ~~)
		fcb@ IOFileControlBlockUnlock

		STATUS_NOT_MOUNTED ok!

		return
	end

	auto oldflags
	mount@ IOMount_Flags + @ oldflags!

	if (oldflags@ newflags@ ==)
		fcb@ IOFileControlBlockUnlock

		return
	end

	auto filesystem
	mount@ IOMount_Filesystem + @ filesystem!

	auto updatefunc
	filesystem@ IOFilesystem_UpdateFlagsFunction + @ updatefunc!

	if (DEBUGCHECKS)
		if (updatefunc@ ~~)
			"IOMountUpdateFlagsObject: filesystem had no update flags function\n" KeCrash
		end
	end

	newflags@ // newflags
	oldflags@ // oldflags
	mount@ // mount
	updatefunc@ IOFilesystemUpdateFlagsFunction ok!

	if (ok@ ~~)
		newflags@ mount@ IOMount_Flags + !
	end

	fcb@ IOFileControlBlockUnlock
end

fn IOMountGetFilesystemName { buffer handle -- ok }
	fnsection "PAGE$text"

	auto fileobject

	auto access

	IOFileTypeObject@ // type
	handle@ // handle
	ObObjectReferenceByHandle ok! fileobject! access!

	if (ok@)
		return
	end

	access@ // access
	ACCESS_READ // permission
	SeCheckAccess ok!

	if (ok@)
		fileobject@ ObObjectDereferenceByPointer drop

		return
	end

	buffer@ // buffer
	fileobject@ // fileobject
	IOMountGetFilesystemNameObject ok!

	fileobject@ ObObjectDereferenceByPointer drop
end

fn IOMountGetFilesystemNameObject { buffer fileobject -- ok }
	fnsection "PAGE$text"

	auto fcb
	fileobject@ IOFile_FileControlBlock + @ fcb!

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto filetype
	fcbp@ IOFileControlBlockPaged_FileType + @ filetype!

	if (filetype@ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!

		return
	end

	if (filetype@ OSFILETYPE_BLOCKDEVICE ~=)
		STATUS_NOT_SUPPORTED ok!

		return
	end

	buffer@ // ptr
	OBNAMEMAX // size
	0 // word
	memset

	fcb@ IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	auto mount
	fcbp@ IOFileControlBlockPaged_Mount + @ mount!

	if (mount@ ~~)
		fcb@ IOFileControlBlockUnlock

		STATUS_NOT_MOUNTED ok!

		return
	end

	buffer@ // dest
	mount@ IOMount_Filesystem + @ IOFilesystem_Name + @ // src
	OBNAMEMAX 1 -
	strncpy

	fcb@ IOFileControlBlockUnlock
end

fn IOMountQueryAll { buffer maxquery -- count ok }
	fnsection "PAGE$text"

	buffer@ // ptr
	maxquery@ OSMountInformation_SIZEOF * // size
	0 // word
	memset

	1 IOiLockMountListShared ok!

	if (ok@)
		return
	end

	auto mount
	IOMountListHead@ mount!

	0 count!

	while (mount@)
		if (maxquery@ ~~)
			break
		end

		auto name
		mount@ IOMount_VolumeFile + @ IOFile_OpenedPath + @ name!

		if (name@)
			buffer@ OSMountInformation_VolumeName + // dest
			name@ // src
			OBNAMEMAX 1 - // max
			strncpy
		end else
			0 buffer@ OSMountInformation_VolumeName + sb
		end

		mount@ IOMount_Flags + @ buffer@ OSMountInformation_Flags + !

		buffer@ OSMountInformation_FilesystemName + // dest
		mount@ IOMount_Filesystem + @ IOFilesystem_Name + @ // src
		OBNAMEMAX 1 -
		strncpy

		if (mount@ IOMount_Filesystem + @ IOFilesystem_VolumeQueryFunction + @)
			buffer@ // query
			mount@ // mount
			mount@ IOMount_Filesystem + @ IOFilesystem_VolumeQueryFunction + @ IOFilesystemVolumeQueryFunction drop
		end

		1 count +=
		1 maxquery -=
		OSMountInformation_SIZEOF buffer +=
		mount@ IOMount_Next + @ mount!
	end

	IOiUnlockMountList
end

fn IOMountGetFlags { mount -- flags }
	mount@ IOMount_Flags + @ flags!
end

fn IOMountSetFlags { flags mount -- }
	flags@ mount@ IOMount_Flags + !
end

fn IOMountSetContext { context mount -- }
	context@ mount@ IOMount_FSContext + !
end

fn IOMountGetContext { mount -- context }
	mount@ IOMount_FSContext + @ context!
end

fn IOMountSetRootFCB { fcb mount -- }
	fcb@ mount@ IOMount_RootFCB + !
end

fn IOMountGetRootFCB { mount -- fcb }
	mount@ IOMount_RootFCB + @ fcb!
end

fn IOiFilesystemSyncAll { shutdown -- ok }
	fnsection "PAGE$text"

	1 IOiLockMountListShared ok!

	if (ok@)
		return
	end

	auto mount
	IOMountListHead@ mount!

	while (mount@)
		auto filesystem
		mount@ IOMount_Filesystem + @ filesystem!

		auto flushfunc
		filesystem@ IOFilesystem_FlushFunction + @ flushfunc!

		if (flushfunc@)
			shutdown@ // shutdown
			mount@ // mount
			flushfunc@ IOFilesystemFlushFunction drop
		end

		mount@ IOMount_Next + @ mount!
	end

	IOiUnlockMountList
end

fn IOiFilesystemReclaimFCB { -- }
	fnsection "PAGE$text"

	// iterate all of the mounted filesystems to find an FCB to reclaim.
	// if the mount has been reclaimed from recently, skip it.

	// NOTE: THIS MAY RECURSIVELY LOCK THE MOUNT LIST AND
	// FILESYSTEM-SPECIFIC STRUCTURES.

	auto count
	IOFileControlBlockCount@ IOFileControlBlockPreferred@ - count!

	if (count@ z<)
		return
	end

	if (count@ ~~)
		return
	end

	auto filesystem
	auto reclaimfunc

	auto trimmed

	auto actual
	0 actual!

	auto skipped
	0 skipped!

	auto ok
	0 IOiLockMountListShared ok!

	if (ok@)
		return
	end

	auto mount
	IOMountListHead@ mount!

	while (mount@)
		if (mount@ IOMount_ReclaimedFrom + @ ~~)
			mount@ IOMount_Filesystem + @ filesystem!

			filesystem@ IOFilesystem_ReclaimFunction + @ reclaimfunc!

			if (reclaimfunc@)
				count@ actual@ - // preferredcount
				mount@ // mount
				reclaimfunc@ IOFilesystemReclaimFunction trimmed!

				if (trimmed@)
					1 mount@ IOMount_ReclaimedFrom + !
				end

				trimmed@ actual +=

				if (actual@ count@ >=)
					break
				end
			end
		end else
			1 skipped +=
		end

		mount@ IOMount_Next + @ mount!
	end

	if (actual@ count@ >=)
		IOiUnlockMountList

		return
	end

	// we failed to reclaim enough.

	if (skipped@ ~~)
		// we didn't skip any mounts, so that can't be why.

		IOiUnlockMountList

		return
	end

	// iterate all the mounts again, this time we don't care if the mount has
	// already been reclaimed from. we continue to iterate even after finding
	// an FCB so that we can reset all of their ReclaimedFrom fields.

	IOMountListHead@ mount!

	while (mount@)
		0 mount@ IOMount_ReclaimedFrom + !

		if (actual@ count@ <)
			mount@ IOMount_Filesystem + @ filesystem!

			filesystem@ IOFilesystem_ReclaimFunction + @ reclaimfunc!

			if (reclaimfunc@)
				count@ actual@ - // preferredcount
				mount@ // mount
				reclaimfunc@ IOFilesystemReclaimFunction trimmed!

				trimmed@ actual +=
			end
		end

		mount@ IOMount_Next + @ mount!
	end

	IOiUnlockMountList
end