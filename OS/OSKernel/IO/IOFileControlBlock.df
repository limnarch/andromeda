//
// Implements the file control block (FCB) management routines and cache.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "IOInternal.h"

fn IOiFileControlBlockInitialize { devobj filetype flags fcb -- }
	fnsection "PAGE$text"

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	devobj@ fcbp@ IOFileControlBlockPaged_DeviceObject + !
	filetype@ fcbp@ IOFileControlBlockPaged_FileType + !

	flags@ fcbp@ IOFileControlBlockPaged_Flags + !
	0 fcb@ IOFileControlBlock_CacheInfoBlock + !
	0 fcb@ IOFileControlBlock_SizeInBytes + !

	devobj@ IODevice_Driver + @ IODriver_DispatchTable + @ fcb@ IOFileControlBlock_DispatchTable + !
	devobj@ IODevice_StackDepth + @ fcb@ IOFileControlBlock_StackDepth + !

	0 fcbp@ IOFileControlBlockPaged_FSContext + !

	fcbp@ IOFileControlBlockPaged_AccessTime + // ptr
	KeTime_SIZEOF // size
	0 // word
	memset

	fcbp@ IOFileControlBlockPaged_ModifyTime + // ptr
	KeTime_SIZEOF // size
	0 // word
	memset

	fcbp@ IOFileControlBlockPaged_ChangeTime + // ptr
	KeTime_SIZEOF // size
	0 // word
	memset

	0 fcb@ IOFileControlBlock_AsyncIOCount + !

	1 // signaled
	OSEVENT_NOTIF // type
	"FCBAsyncEvent" // name
	fcb@ IOFileControlBlock_AsyncIOEvent + // event
	KeEventInitialize

	"FCBRwLock" // name
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockInitialize
end

fn IOFileControlBlockIncrementReclaimable { -- }
	1 IOFileControlBlockCount KeInterlockedIncrement drop

	if (IOFileControlBlockCount@ IOFileControlBlockMaximum@ >=)
		0 // priboost
		IOiFileControlBlockCacheTrimEvent // event
		KeEventSignal
	end
end

fn IOFileControlBlockDecrementReclaimable { -- }
	-1 IOFileControlBlockCount KeInterlockedIncrement drop
end

fn IOFileControlBlockThrottle { -- }
	fnsection "PAGE$text"

	if (IOFileControlBlockCount@ IOiFileControlBlockThrottleCount@ >=)
		0 // priboost
		IOiFileControlBlockCacheTrimEvent // event
		KeEventSignal

		100 // ms
		KERNELMODE // waitmode
		0 // alertable
		KeThreadSleep drop
	end
end

fn IOFileControlBlockCreate { devobj filetype flags -- fcb ok }
	fnsection "PAGE$text"

	IOFileControlBlock_SIZEOF // bytes
	'IOFC' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! fcb!

	if (ok@)
		return
	end

	auto fcbp

	if (flags@ IOFCBFLAG_PAGED &)
		IOFileControlBlockPaged_SIZEOF // bytes
		'IOFp' // tag
		PAGED // flags
		MmAllocWithTag ok! fcbp!
	end else
		IOFileControlBlockPaged_SIZEOF // bytes
		'IOFn' // tag
		CANBLOCK // flags
		MmAllocWithTag ok! fcbp!
	end

	if (ok@)
		fcb@ MmFree

		return
	end

	fcbp@ fcb@ IOFileControlBlock_Paged + !

	devobj@ // devobj
	filetype@ // filetype
	flags@ // flags
	fcb@ // fcb
	IOiFileControlBlockInitialize
end

fn IOFileControlBlockFlush { fcb -- ok }
	fnsection "PAGE$text"

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	0 ok!

	if (cacheblock@)
		cacheblock@ IOCacheInfoBlockFlush ok!
	end
end

fn IOFileControlBlockDestroyCache { writeout fcb -- }
	fnsection "PAGE$text"

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (cacheblock@)
		writeout@ // writeout
		cacheblock@ // cacheblock
		IOiCacheInfoBlockDestroy drop

		0 fcb@ IOFileControlBlock_CacheInfoBlock + !
	end
end

fn IOFileControlBlockDelete { writeout fcb -- ok }
	fnsection "PAGE$text"

	// caller should be 100% sure this FCB won't be used again.
	// it also should have removed it from the reusable list by now.

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (cacheblock@)
		if (DEBUGCHECKS)
			if (writeout@ -1 ==)
				"IOFileControlBlockDelete: didn't expect a cacheblock\n" KeCrash
			end
		end

		writeout@ // writeout
		cacheblock@ // cacheblock
		IOiCacheInfoBlockDestroy ok!

		if (ok@)
			return
		end
	end

	fcb@ IOFileControlBlock_RwLock + ExRwLockUninitialize

	fcb@ IOFileControlBlock_Paged + @ MmFree
	fcb@ MmFree
end

fn IOFileControlBlockLock { fcb -- ok }
	fnsection "PAGE$text"

	1 // alertable
	0 // nowait
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockAcquireExclusive ok!
end

fn IOFileControlBlockDemoteToShared { fcb -- ok }
	fnsection "PAGE$text"

	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockDemoteToShared ok!
end

fn IOFileControlBlockLockShared { fcb -- ok }
	fnsection "PAGE$text"

	1 // alertable
	0 // nowait
	0 // canstarve
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockAcquireShared ok!
end

fn IOFileControlBlockUnlock { fcb -- }
	fcb@ IOFileControlBlock_RwLock + ExRwLockRelease
end

fn IOFileControlBlockCacheCheck { fcb -- cacheblock ok }
	fnsection "PAGE$text"

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (cacheblock@ ~~)
		// still no cache block, plus we want there to be one.
		// therefore, initiate caching

		fcb@ // fcb
		IOiCacheInitialize ok! cacheblock!

		if (ok@)
			fcb@ IOFileControlBlockUnlock

			return
		end
	end

	fcb@ IOFileControlBlockUnlock
end

fn IOFileControlBlockTruncate { newsize growing keeplocked zero flags fcb -- oldsize ok }
	fnsection "PAGE$text"

	if (fcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!
		return
	end

	auto truncfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Truncate + @ truncfunc!

	if (truncfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!
		return
	end

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	if (fcb@ IOFileControlBlock_AsyncIOCount + @)
		// wait for async IO to complete. no more can be enqueued after this
		// value reaches zero because we are holding the rwlock exclusive.

		KERNELMODE // waitmode
		0 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		fcb@ IOFileControlBlock_AsyncIOEvent + // object
		KeThreadWaitForObject drop
	end

	while (1)
		fcb@ IOFileControlBlock_SizeInBytes + @ oldsize!

		if (growing@ 2 ==)
			oldsize@ newsize@ + newsize!
		end

		if (newsize@ oldsize@ <)
			// shrinking
			if (growing@)
				// don't shrink
				break
			end

			if (fcb@ IOFileControlBlock_CacheInfoBlock + @)
				newsize@ // newsize
				0 // writeout
				fcb@ IOFileControlBlock_CacheInfoBlock + @ // cacheblock
				IOCacheInfoBlockTruncate ok!

				if (ok@)
					fcb@ IOFileControlBlockUnlock
					return
				end
			end
		end

		newsize@ // newsize
		zero@ // zero
		flags@ // flags
		fcb@ // fcb
		truncfunc@ IODispatchTruncateFunction ok!

		if (ok@)
			fcb@ IOFileControlBlockUnlock
			return
		end

		if (DEBUGCHECKS)
			if (fcb@ IOFileControlBlock_SizeInBytes + @ newsize@ ~=)
				"IOFileControlBlockTruncate: fs driver reported success but didn't modify size\n" KeCrash
			end
		end

		break
	end

	if (keeplocked@)
		fcb@ IOFileControlBlockDemoteToShared ok!

		if (ok@)
			fcb@ IOFileControlBlockUnlock
			return
		end
	end else
		fcb@ IOFileControlBlockUnlock
	end
end

// millions of getters and setters so we don't break every driver whenever we
// change the struct

fn IOFileControlBlockGetContext { fcb -- context }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ context!
end

fn IOFileControlBlockSetContext { context fcb -- }
	context@ fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + !
end

fn IOFileControlBlockGetMount { fcb -- mount }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_DeviceObject + @ IODevice_RelevantMount + @ mount!
end

fn IOFileControlBlockGetDeviceObject { fcb -- devobj }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_DeviceObject + @ devobj!
end

fn IOFileControlBlockGetType { fcb -- filetype }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FileType + @ filetype!
end

fn IOFileControlBlockGetSize { fcb -- size }
	fcb@ IOFileControlBlock_SizeInBytes + @ size!
end

fn IOFileControlBlockGetFlags { fcb -- flags }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_Flags + @ flags!
end

fn IOFileControlBlockSetSize { size fcb -- }
	size@ fcb@ IOFileControlBlock_SizeInBytes + !
end

fn IOFileControlBlockGetCacheInfoBlock { fcb -- cacheblock }
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!
end

fn IOFileControlBlockSetAccessTime { time fcb -- }
	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	time@ KeTime_SecPart + @ fcbp@ IOFileControlBlockPaged_AccessTime + KeTime_SecPart + !
	time@ KeTime_MsPart + @ fcbp@ IOFileControlBlockPaged_AccessTime + KeTime_MsPart + !
end

fn IOFileControlBlockSetModifyTime { time fcb -- }
	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	time@ KeTime_SecPart + @ fcbp@ IOFileControlBlockPaged_ModifyTime + KeTime_SecPart + !
	time@ KeTime_MsPart + @ fcbp@ IOFileControlBlockPaged_ModifyTime + KeTime_MsPart + !
end

fn IOFileControlBlockSetChangeTime { time fcb -- }
	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	time@ KeTime_SecPart + @ fcbp@ IOFileControlBlockPaged_ChangeTime + KeTime_SecPart + !
	time@ KeTime_MsPart + @ fcbp@ IOFileControlBlockPaged_ChangeTime + KeTime_MsPart + !
end

fn IOFileControlBlockGetAccessTime { fcb -- time }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_AccessTime + time!
end

fn IOFileControlBlockGetModifyTime { fcb -- time }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_ModifyTime + time!
end

fn IOFileControlBlockGetChangeTime { fcb -- time }
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_ChangeTime + time!
end

fn IOFileControlBlockGetSizeof { -- sizeof }
	IOFileControlBlock_SIZEOF sizeof!
end