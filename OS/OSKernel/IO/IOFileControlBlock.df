//
// Implements the file control block (FCB) management routines and cache.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

var IOFileControlBlockReusableListHead 0
var IOFileControlBlockReusableListTail 0

var IOFileControlBlockMaximum 0
public IOFileControlBlockMaximum

var IOFileControlBlockCount 0

fn IOFileControlBlockInitialize { dispatchtable devobj filetype flags fcb -- }
	fnsection "PAGE$text"

	devobj@ fcb@ IOFileControlBlock_DeviceObject + !
	filetype@ fcb@ IOFileControlBlock_FileType + !

	flags@ fcb@ IOFileControlBlock_Flags + !
	0 fcb@ IOFileControlBlock_CacheInfoBlock + !
	0 fcb@ IOFileControlBlock_References + !
	0 fcb@ IOFileControlBlock_SizeInBytes + !
	dispatchtable@ fcb@ IOFileControlBlock_DispatchTable + !
	0 fcb@ IOFileControlBlock_FSContext + !
	0 fcb@ IOFileControlBlock_Mount + !
	0 fcb@ IOFileControlBlock_ParseCount + !

	0 fcb@ IOFileControlBlock_ReusableListNext + !
	0 fcb@ IOFileControlBlock_ReusableListPrev + !

	"FCBRwLock" // name
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockInitialize

	fcb@ IOFileControlBlock_AccessTime + // ptr
	KeTime_SIZEOF // size
	0 // word
	memset

	fcb@ IOFileControlBlock_ModifyTime + // ptr
	KeTime_SIZEOF // size
	0 // word
	memset

	fcb@ IOFileControlBlock_ChangeTime + // ptr
	KeTime_SIZEOF // size
	0 // word
	memset
end

fn IOFileControlBlockAllocate { dispatchtable devobj filetype flags -- fcb ok }
	// like IOFileControlBlockCreate but will steal from the pool of reusable
	// FCBs if the count is above the maximum.

	0 fcb!
	0 ok!

	if (IOFileControlBlockCount@ 1 + IOFileControlBlockMaximum@ >=)
		// above the maximum, try to reclaim one.

		auto ipl
		IPLDPC KeIPLRaise ipl!

		IOFileControlBlockReusableListHead@ fcb!

		while (fcb@)
			auto reclaimfunc
			fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_ReclaimFCB + @ reclaimfunc!

			if (DEBUGCHECKS)
				if (reclaimfunc@ ~~)
					"IOFileControlBlockAllocate: no reclaimfunc\n" KeCrash
				end
			end

			KeThreadCurrent@ KeThreadIgnoreKill drop

			auto reclaimed
			fcb@ // fcb
			fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_ReclaimFCB + @
			IODispatchReclaimFCBFunction reclaimed!

			KeThreadCurrent@ KeThreadAcceptKill drop

			if (reclaimed@)
				fcb@ IOFileControlBlockRemove

				ipl@ KeIPLLower

				// don't write out because it is the fs driver's
				// responsibility to flush.

				0 // writeout
				fcb@ // fcb
				IOFileControlBlockReclaim drop

				break
			end

			fcb@ IOFileControlBlock_ReusableListNext + @ fcb!
		end

		ipl@ KeIPLLower
	end

	if (fcb@ ~~)
		// didn't get an FCB by now, create it.

		dispatchtable@ // dispatchtable
		devobj@ // devobj
		filetype@ // filetype
		flags@ // flags
		IOFileControlBlockCreate ok! fcb!

		if (ok@)
			return
		end
	end else
		dispatchtable@ // dispatchtable
		devobj@ // devobj
		filetype@ // filetype
		flags@ // flags
		fcb@ // fcb
		IOFileControlBlockInitialize
	end
end

fn IOFileControlBlockCreate { dispatchtable devobj filetype flags -- fcb ok }
	IOFileControlBlock_SIZEOF // bytes
	'IOFC' // tag
	CANBLOCK POOLALLOC | // flags
	MmAllocWithTag ok! fcb!

	if (ok@)
		return
	end

	dispatchtable@ // dispatchtable
	devobj@ // devobj
	filetype@ // filetype
	flags@ // flags
	fcb@ // fcb
	IOFileControlBlockInitialize

	if (fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_ReclaimFCB + @)
		// only count it if its reclaimable.
		auto rs
		HALCPUInterruptDisable rs!
		1 IOFileControlBlockCount +=
		rs@ HALCPUInterruptRestore
	end
end

fn IOFileControlBlockFlush { fcb -- ok }
	fnsection "PAGE$text"

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	0 ok!

	if (cacheblock@)
		cacheblock@ IOCacheInfoBlockFlush ok!
	end
end

fn IOFileControlBlockReclaim { writeout fcb -- ok }
	fnsection "PAGE$text"

	auto cacheblock
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (cacheblock@)
		if (writeout@ -1 ==)
			"IOFileControlBlockReclaim: didn't expect a cacheblock\n" KeCrash
		end

		writeout@ // writeout
		cacheblock@ // cacheblock
		IOCacheInfoBlockDestroy ok!

		if (ok@)
			return
		end
	end

	fcb@ IOFileControlBlock_RwLock + ExRwLockUninitialize
end

fn IOFileControlBlockDelete { writeout fcb -- ok }
	// caller should be 100% sure this FCB won't be used again.
	// it also should have removed it from the reusable list by now.

	if (DEBUGCHECKS)
		if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_REUSABLEINSERTED &)
			"IOFileControlBlockDelete: FCB was reusable\n" KeCrash
		end
	end

	writeout@ // writeout
	fcb@ // fcb
	IOFileControlBlockReclaim ok!

	if (ok@)
		return
	end

	if (fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_ReclaimFCB + @)
		auto rs
		HALCPUInterruptDisable rs!
		1 IOFileControlBlockCount -=
		rs@ HALCPUInterruptRestore
	end

	fcb@ MmFree
end

fn IOFileControlBlockLock { fcb -- ok }
	fnsection "PAGE$text"

	1 // alertable
	0 // nowait
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockAcquireExclusive ok!
end

fn IOFileControlBlockDemoteToShared { fcb -- ok }
	fnsection "PAGE$text"

	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockDemoteToShared ok!
end

fn IOFileControlBlockLockShared { fcb -- ok }
	fnsection "PAGE$text"

	1 // alertable
	0 // nowait
	0 // canstarve
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockAcquireShared ok!
end

fn IOFileControlBlockTryLock { fcb -- ok }
	0 // alertable
	1 // nowait
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockAcquireExclusive ok!

	if (ok@ z<)
		0 ok!
	end
end

fn IOFileControlBlockTryLockShared { fcb -- ok }
	0 // alertable
	1 // nowait
	0 // canstarve
	fcb@ IOFileControlBlock_RwLock + // rwlock
	ExRwLockAcquireShared ok!

	if (ok@ z<)
		0 ok!
	end
end

fn IOFileControlBlockUnlock { fcb -- }
	fcb@ IOFileControlBlock_RwLock + ExRwLockRelease
end

fn IOFileControlBlockIsPinned { fcb -- pinned }
	fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_LOCKEDMETADATA & pinned!
end

fn IOFileControlBlockDeleteLastReference { fcb -- }
	auto rs
	HALCPUInterruptDisable rs!
	IOFCBFLAG_DELETELASTREFERENCE fcb@ IOFileControlBlock_Flags + |=
	rs@ HALCPUInterruptRestore
end

fn IOFileControlBlockRescue { fcb -- }
	auto rs
	HALCPUInterruptDisable rs!
	IOFCBFLAG_DELETELASTREFERENCE ~ fcb@ IOFileControlBlock_Flags + &=
	rs@ HALCPUInterruptRestore
end

fn IOFileControlBlockReference { fcb -- oldcount }
	// should be called by filesystem driver in its parse method.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	fcb@ IOFileControlBlock_References + @ oldcount!

	oldcount@ 1 + fcb@ IOFileControlBlock_References + !

	if (oldcount@ ~~)
		if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_REUSABLEINSERTED &)
			IOFCBFLAG_REUSABLEINSERTED ~ fcb@ IOFileControlBlock_Flags + &=
			fcb@ IOFileControlBlockRemove
		end
	end

	ipl@ KeIPLLower
end

fn IOFileControlBlockDereference { fcb -- oldcount }
	// should be called by filesystem driver in its delete method.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	fcb@ IOFileControlBlock_References + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"IOFileControlBlockDereference: refcount underflow\n" KeCrash
		end
	end

	oldcount@ 1 - fcb@ IOFileControlBlock_References + !

	if (oldcount@ 1 ==)
		if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_DELETELASTREFERENCE &)
			ipl@ KeIPLLower

			KeThreadCurrent@ KeThreadIgnoreKill drop

			auto cacheblock
			fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

			if (cacheblock@)
				0 // writeout
				cacheblock@ // cacheblock
				IOCacheInfoBlockDestroy drop

				0 fcb@ IOFileControlBlock_CacheInfoBlock + !
			end

			fcb@ // fcb
			fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Delete + @
			IODispatchDeleteFunction

			KeThreadCurrent@ KeThreadAcceptKill drop

			0 // writeout
			fcb@ // fcb
			IOFileControlBlockDelete drop

			return
		end elseif (fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_ReclaimFCB + @)
			if (IOFileControlBlockCount@ IOFileControlBlockMaximum@ >=)
				// above the maximum! attempt to free this FCB immediately.

				KeThreadCurrent@ KeThreadIgnoreKill drop

				auto reclaimed
				fcb@ // fcb
				fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_ReclaimFCB + @
				IODispatchReclaimFCBFunction reclaimed!

				KeThreadCurrent@ KeThreadAcceptKill drop

				if (reclaimed@)
					ipl@ KeIPLLower

					// don't write out because it is the fs driver's
					// responsibility to flush.

					0 // writeout
					fcb@ // fcb
					IOFileControlBlockDelete drop

					return
				end
			end

			IOFCBFLAG_REUSABLEINSERTED fcb@ IOFileControlBlock_Flags + |=
			fcb@ IOFileControlBlockInsert
		end
	end

	ipl@ KeIPLLower
end

fn IOFileControlBlockPinMetadata { fcb -- ok }
	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	if (fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_LOCKEDMETADATA &)
		// already pinned.

		fcb@ IOFileControlBlockUnlock

		return
	end

	fcb@ // fcb
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_PinMetadata + @ IODispatchPinMetadataFunction ok!

	if (ok@ ~~)
		auto rs
		HALCPUInterruptDisable rs!
		IOFCBFLAG_LOCKEDMETADATA fcb@ IOFileControlBlock_Flags + |=
		rs@ HALCPUInterruptRestore
	end

	fcb@ IOFileControlBlockUnlock
end

fn IOFileControlBlockRemove { fcb -- }
	// assumes IPLDPC or equivalent

	auto ls
	fcb@ IOFileControlBlock_ReusableListPrev + @ ls!

	auto ns
	fcb@ IOFileControlBlock_ReusableListNext + @ ns!

	if (ls@)
		ns@ ls@ IOFileControlBlock_ReusableListNext + !
	end else
		ns@ IOFileControlBlockReusableListHead!
	end

	if (ns@)
		ls@ ns@ IOFileControlBlock_ReusableListPrev + !
	end else
		ls@ IOFileControlBlockReusableListTail!
	end
end

fn IOFileControlBlockInsert { fcb -- }
	// assumes IPLDPC or equivalent

	auto t

	IOFileControlBlockReusableListTail@ t!

	if (t@ ~~)
		0 fcb@ IOFileControlBlock_ReusableListNext + !
		0 fcb@ IOFileControlBlock_ReusableListPrev + !

		fcb@ IOFileControlBlockReusableListHead!
		fcb@ IOFileControlBlockReusableListTail!
	end else
		0 fcb@ IOFileControlBlock_ReusableListNext + !

		t@ fcb@ IOFileControlBlock_ReusableListPrev + !
		fcb@ t@ IOFileControlBlock_ReusableListNext + !
		fcb@ IOFileControlBlockReusableListTail!
	end
end

fn IOFileControlBlockCacheCheck { fcb -- cacheblock ok }
	fnsection "PAGE$text"

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

	if (cacheblock@ ~~)
		// still no cache block, plus we want there to be one.
		// therefore, initiate caching

		fcb@ // fcb
		IOCacheInitialize ok! cacheblock!

		if (ok@)
			fcb@ IOFileControlBlockUnlock

			return
		end
	end

	fcb@ IOFileControlBlockUnlock
end

fn IOFileControlBlockTruncate { newsize growing keeplocked zero flags fcb -- oldsize ok }
	fnsection "PAGE$text"

	if (fcb@ IOFileControlBlock_FileType + @ OSFILETYPE_DIRECTORY ==)
		STATUS_IS_A_DIRECTORY ok!
		return
	end

	auto truncfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Truncate + @ truncfunc!

	if (truncfunc@ ~~)
		STATUS_NOT_SUPPORTED ok!
		return
	end

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	while (1)
		fcb@ IOFileControlBlock_SizeInBytes + @ oldsize!

		if (newsize@ oldsize@ <)
			// shrinking
			if (growing@)
				// don't shrink
				break
			end

			if (fcb@ IOFileControlBlock_CacheInfoBlock + @)
				newsize@ // newsize
				0 // writeout
				fcb@ IOFileControlBlock_CacheInfoBlock + @ // cacheblock
				IOCacheInfoBlockTruncate ok!

				if (ok@)
					fcb@ IOFileControlBlockUnlock
					return
				end
			end
		end

		newsize@ // newsize
		zero@ // zero
		flags@ // flags
		fcb@ // fcb
		truncfunc@ IODispatchTruncateFunction ok!

		if (ok@)
			fcb@ IOFileControlBlockUnlock
			return
		end

		if (DEBUGCHECKS)
			if (fcb@ IOFileControlBlock_SizeInBytes + @ newsize@ ~=)
				"IOFileControlBlockTruncate: fs driver reported success but didn't modify size\n" KeCrash
			end
		end

		break
	end

	if (keeplocked@)
		fcb@ IOFileControlBlockDemoteToShared ok!

		if (ok@)
			fcb@ IOFileControlBlockUnlock
			return
		end
	end else
		fcb@ IOFileControlBlockUnlock
	end
end

// millions of getters and setters so we don't break every driver whenever we
// change the struct

fn IOFileControlBlockGetReferences { fcb -- references }
	fcb@ IOFileControlBlock_References + @ references!
end

fn IOFileControlBlockGetContext { fcb -- context }
	fcb@ IOFileControlBlock_FSContext + @ context!
end

fn IOFileControlBlockSetContext { context fcb -- }
	context@ fcb@ IOFileControlBlock_FSContext + !
end

fn IOFileControlBlockGetMount { fcb -- mount }
	fcb@ IOFileControlBlock_DeviceObject + @ mount!
end

fn IOFileControlBlockGetDeviceObject { fcb -- devobj }
	fcb@ IOFileControlBlock_DeviceObject + @ devobj!
end

fn IOFileControlBlockGetType { fcb -- filetype }
	fcb@ IOFileControlBlock_FileType + @ filetype!
end

fn IOFileControlBlockGetSize { fcb -- size }
	fcb@ IOFileControlBlock_SizeInBytes + @ size!
end

fn IOFileControlBlockSetSize { size fcb -- }
	size@ fcb@ IOFileControlBlock_SizeInBytes + !
end

fn IOFileControlBlockGetCacheInfoBlock { fcb -- cacheblock }
	fcb@ IOFileControlBlock_CacheInfoBlock + @ cacheblock!
end

fn IOFileControlBlockSetAccessTime { time fcb -- }
	time@ KeTime_SecPart + @ fcb@ IOFileControlBlock_AccessTime + KeTime_SecPart + !
	time@ KeTime_MsPart + @ fcb@ IOFileControlBlock_AccessTime + KeTime_MsPart + !
end

fn IOFileControlBlockSetModifyTime { time fcb -- }
	time@ KeTime_SecPart + @ fcb@ IOFileControlBlock_ModifyTime + KeTime_SecPart + !
	time@ KeTime_MsPart + @ fcb@ IOFileControlBlock_ModifyTime + KeTime_MsPart + !
end

fn IOFileControlBlockSetChangeTime { time fcb -- }
	time@ KeTime_SecPart + @ fcb@ IOFileControlBlock_ChangeTime + KeTime_SecPart + !
	time@ KeTime_MsPart + @ fcb@ IOFileControlBlock_ChangeTime + KeTime_MsPart + !
end

fn IOFileControlBlockGetAccessTime { fcb -- time }
	fcb@ IOFileControlBlock_AccessTime + time!
end

fn IOFileControlBlockGetModifyTime { fcb -- time }
	fcb@ IOFileControlBlock_ModifyTime + time!
end

fn IOFileControlBlockGetChangeTime { fcb -- time }
	fcb@ IOFileControlBlock_ChangeTime + time!
end

fn IOFileControlBlockGetSizeof { -- sizeof }
	IOFileControlBlock_SIZEOF sizeof!
end

fn IOFileControlBlockIsDoomed { fcb -- doomed }
	fcb@ IOFileControlBlock_Flags + @ IOFCBFLAG_DELETELASTREFERENCE & doomed!
end