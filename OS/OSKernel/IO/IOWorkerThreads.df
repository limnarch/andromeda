//
// Implements the IO worker threads.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

buffer IOFilesystemSyncTimer KeTimer_SIZEOF

const IOWRITEBEHINDINTERVAL 15000

const IOFSSYNCINTERVAL 5000

const IOSWAPFILECONTRACTINTERVAL 30000

const IOSWAPFILECONTRACTTICKS (IOSWAPFILECONTRACTINTERVAL IOFSSYNCINTERVAL /)

fn IOFilesystemSyncWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	"IOFilesystemSyncTimer" // name
	0 // function
	IOFilesystemSyncTimer // timer
	KeTimerInitialize

	auto objecttable
	8 alloc objecttable!

	IOSwapFileExtendEvent objecttable@!
	IOFilesystemSyncTimer objecttable@ 4 + !

	0 // context1
	0 // context2
	IOFSSYNCINTERVAL // interval
	IOFilesystemSyncTimer // timer
	KeTimerEnqueue

	auto ticks
	0 ticks!

	auto ok

	while (1)
		// iterate all mounted filesystems every 5 seconds and ask them
		// to flush any internal state. this kernel thread is also responsible
		// for expanding and contracting the swapfiles.

		auto reason
		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		OSWAIT_TIMEOUTINFINITE // timeout
		2 // objectcount
		objecttable@ // objecttable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ 0 s<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "IOFilesystemSyncWorker: failed to wait on event (%i)\n" KeCrash
				end
			end
		end

		if (reason@ 1 ==)
			IOFilesystemSyncAll ok!

			if (ok@)
				ok@ "IOFilesystemSyncWorker: failed to sync (%i)\n" KeCrash
			end

			1 ticks +=

			if (ticks@ IOSWAPFILECONTRACTTICKS ==)
				IOSwapFileContract

				0 ticks!
			end

			0 // context1
			0 // context2
			IOFSSYNCINTERVAL // interval
			IOFilesystemSyncTimer // timer
			KeTimerEnqueue
		end elseif (reason@ 0 ==)
			IOSwapFileExtend
		end
	end
end

fn IOWritebehindWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	auto objecttable
	8 alloc objecttable!

	IOWritebehindTimer objecttable@!
	IOWritebehindEvent objecttable@ 4 + !

	while (1)
		auto reason
		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		60000 // timeout
		2 // objectcount
		objecttable@ // objecttable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ 0 s<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "IOWritebehindWorker: failed to wait on event (%i)\n" KeCrash
				end
			end
		end

		auto modcount

		auto rs
		HALCPUInterruptDisable rs!

		IOCacheInfoBlockDirtyCount@ modcount!
		0 IOCacheInfoBlockDirtyCount!

		rs@ HALCPUInterruptRestore

		while (modcount@)
			auto cacheblock

			auto ipl
			IPLDPC KeIPLRaise ipl!

			IOCacheInfoBlockDirtyListHead@ cacheblock!

			if (cacheblock@ ~~)
				ipl@ KeIPLLower
				break
			end

			0 cacheblock@ IOCacheInfoBlock_ModifiedPageCount + !

			auto n
			cacheblock@ IOCacheInfoBlock_Next + @ n!

			n@ IOCacheInfoBlockDirtyListHead!

			if (n@ ~~)
				0 IOCacheInfoBlockDirtyListTail!
			end else
				0 n@ IOCacheInfoBlock_Prev + !
			end

			ipl@ KeIPLLower

			cacheblock@ IOCacheInfoBlockFlush drop

			cacheblock@ IOCacheInfoBlockDereference drop

			1 modcount -=
		end

		if (reason@ 0 ==)
			IOWritebehindTimer KeTimerReset drop
		end
	end
end

fn IOScheduleWritebehind { -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IOScheduleWritebehind: ipl != IPLDPC\n" KeCrash
		end
	end

	if (IOWritebehindTimer KeTimer_Enqueued + @ ~~)
		0 // context1
		0 // context2
		IOWRITEBEHINDINTERVAL // interval
		IOWritebehindTimer
		KeTimerEnqueue
	end
end

fn IOTriggerWritebehind { -- }
	fnsection "PAGE$text"

	// artifically signal the dirty page event to sweep all the dirty
	// pages to disk. returns asynchronously, up to the caller to query the
	// dirty page count and figure out when they've all been written.

	0 // priboost
	IOWritebehindEvent // event
	KeEventSignal
end