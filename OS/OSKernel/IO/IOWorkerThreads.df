//
// Implements the IO worker threads.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

buffer IOFilesystemSyncTimer KeTimer_SIZEOF

const IOWRITEBEHINDINTERVAL 5000

const IOFSSYNCINTERVAL 15000

const IOSWAPFILECONTRACTINTERVAL 30000

const IOSWAPFILECONTRACTTICKS (IOSWAPFILECONTRACTINTERVAL IOFSSYNCINTERVAL /)

fn IOFilesystemSyncWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	"IOFilesystemSyncTimer" // name
	0 // function
	IOFilesystemSyncTimer // timer
	KeTimerInitialize

	auto objecttable
	8 alloc objecttable!

	IOSwapFileExtendEvent objecttable@!
	IOFilesystemSyncTimer objecttable@ 4 + !

	0 // context1
	0 // context2
	IOFSSYNCINTERVAL // interval
	IOFilesystemSyncTimer // timer
	KeTimerEnqueue drop

	auto ticks
	0 ticks!

	auto ok

	while (1)
		// iterate all mounted filesystems every 5 seconds and ask them
		// to flush any internal state. this kernel thread is also responsible
		// for expanding and contracting the swapfiles.

		auto reason
		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		OSWAIT_TIMEOUTINFINITE // timeout
		2 // objectcount
		objecttable@ // objecttable
		0 // waitblocktable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ z<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "IOFilesystemSyncWorker: failed to wait on event (%i)\n" KeCrash
				end
			end
		end

		if (ExShuttingDown@)
			1 IOFilesystemSyncAll drop

			// let the shutdown thread know we did our bit
			2 ExShuttingDown!

			while (1)
				10000 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep drop
			end
		end

		if (reason@ 1 ==)
			0 IOFilesystemSyncAll drop

			1 ticks +=

			if (ticks@ IOSWAPFILECONTRACTTICKS ==)
				IOSwapFileContract

				0 ticks!
			end

			IOFilesystemSyncTimer KeTimerReset drop

			0 // context1
			0 // context2
			IOFSSYNCINTERVAL // interval
			IOFilesystemSyncTimer // timer
			KeTimerEnqueue drop
		end elseif (reason@ 0 ==)
			IOSwapFileExtend
		end
	end
end

fn (DPCFunction) IOWritebehindTimerDPCFunction { context1 context2 -- }
	IOWritebehindTimer KeTimerReset drop
end

fn IOWritebehindWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	auto objecttable
	8 alloc objecttable!

	IOWritebehindTimer objecttable@!
	IOWritebehindEvent objecttable@ 4 + !

	while (1)
		auto reason
		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		60000 // timeout
		2 // objectcount
		objecttable@ // objecttable
		0 // waitblocktable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ z<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "IOWritebehindWorker: failed to wait on event (%i)\n" KeCrash
				end
			end
		end

		auto modcount

		auto rs
		HALCPUInterruptDisable rs!

		IOCacheInfoBlockDirtyCount@ modcount!
		0 IOCacheInfoBlockDirtyCount!

		rs@ HALCPUInterruptRestore

		while (modcount@)
			auto cacheblock

			auto ipl
			IPLDPC KeIPLRaise ipl!

			IOCacheInfoBlockDirtyListHead@ cacheblock!

			if (cacheblock@ ~~)
				ipl@ KeIPLLower
				break
			end

			0 cacheblock@ IOCacheInfoBlock_ModifiedPageCount + !

			auto n
			cacheblock@ IOCacheInfoBlock_Next + @ n!

			n@ IOCacheInfoBlockDirtyListHead!

			if (n@ ~~)
				0 IOCacheInfoBlockDirtyListTail!
			end else
				0 n@ IOCacheInfoBlock_Prev + !
			end

			ipl@ KeIPLLower

			cacheblock@ IOCacheInfoBlockFlush drop

			cacheblock@ IOCacheInfoBlockDereference drop

			1 modcount -=
		end
	end
end

fn IOScheduleWritebehind { -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IOScheduleWritebehind: ipl != IPLDPC\n" KeCrash
		end
	end

	0 // context1
	0 // context2
	IOWRITEBEHINDINTERVAL // interval
	IOWritebehindTimer
	KeTimerEnqueue drop
end

fn IOTriggerWritebehind { -- }
	fnsection "PAGE$text"

	// artifically signal the dirty page event to sweep all the dirty
	// pages to disk. returns asynchronously, up to the caller to query the
	// dirty page count and figure out when they've all been written.

	0 // priboost
	IOWritebehindEvent // event
	KeEventSignal
end