//
// Implements the IO worker threads.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "IOInternal.h"

buffer IOiFilesystemSyncTimer KeTimer_SIZEOF

const IOWRITEBEHINDINTERVAL 5000

const IOFSSYNCINTERVAL 15000

const IOPAGEFILECONTRACTINTERVAL 30000

const IOPAGEFILECONTRACTTICKS (IOPAGEFILECONTRACTINTERVAL IOFSSYNCINTERVAL /)

fn IOiFilesystemSyncWorker { context1 context2 -- }
	fnsection "PAGE$text"

	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	auto waitblocktable
	KeDispatchWaitBlock_SIZEOF 3 * alloc waitblocktable!

	KeThreadCurrent@ // thread
	3 // count
	waitblocktable@ // waitblocktable
	KeDispatchWaitBlockTableInitialize

	"IOiFilesystemSyncTimer" // name
	0 // function
	IOiFilesystemSyncTimer // timer
	KeTimerInitialize

	auto objecttable
	12 alloc objecttable!

	IOPageFileExtendEvent objecttable@!
	IOiFilesystemSyncTimer objecttable@ 4 + !
	IOiFileControlBlockCacheTrimEvent objecttable@ 8 + !

	0 // context1
	0 // context2
	IOFSSYNCINTERVAL // interval
	IOiFilesystemSyncTimer // timer
	KeTimerEnqueue drop

	auto ticks
	0 ticks!

	auto ok

	while (1)
		// iterate all mounted filesystems every 5 seconds and ask them
		// to flush any internal state. this kernel thread is also responsible
		// for expanding and contracting the pagefiles, and trimming the FCB
		// cache.

		auto reason
		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		OSWAIT_TIMEOUTINFINITE // timeout
		3 // objectcount
		objecttable@ // objecttable
		waitblocktable@ // waitblocktable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ z<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "IOiFilesystemSyncWorker: failed to wait on event (%i)\n" KeCrash
				end
			end
		end

		if (ExShuttingDown@)
			1 IOiFilesystemSyncAll drop

			// let the shutdown thread know we did our bit
			2 ExShuttingDown!

			while (1)
				10000 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep drop
			end
		end

		if (reason@ 2 ==)
			IOiFilesystemReclaimFCB
		end elseif (reason@ 1 ==)
			0 IOiFilesystemSyncAll drop

			1 ticks +=

			if (ticks@ IOPAGEFILECONTRACTTICKS ==)
				IOiPageFileContract

				0 ticks!
			end

			IOiFilesystemSyncTimer KeTimerReset drop

			0 // context1
			0 // context2
			IOFSSYNCINTERVAL // interval
			IOiFilesystemSyncTimer // timer
			KeTimerEnqueue drop
		end elseif (reason@ 0 ==)
			IOiPageFileExtend
		end
	end
end

fn (DPCFunction) IOiWritebehindTimerDPCFunction { context1 context2 -- }
	IOiWritebehindTimer KeTimerReset drop
end

fn IOiWritebehindWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	auto objecttable
	8 alloc objecttable!

	IOiWritebehindTimer objecttable@!
	IOiWritebehindEvent objecttable@ 4 + !

	while (1)
		auto reason
		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		60000 // timeout
		2 // objectcount
		objecttable@ // objecttable
		0 // waitblocktable
		KeThreadWaitForMultipleObjects reason!

		if (DEBUGCHECKS)
			if (reason@ z<)
				if (reason@ STATUS_WAIT_TIMEOUT ~=)
					reason@ "IOiWritebehindWorker: failed to wait on event (%i)\n" KeCrash
				end
			end
		end

		auto modcount

		auto rs
		HALCPUInterruptDisable rs!

		IOCacheInfoBlockDirtyCount@ modcount!
		0 IOCacheInfoBlockDirtyCount!

		rs@ HALCPUInterruptRestore

		while (modcount@)
			auto cacheblock

			auto ipl
			IPLDPC KeIPLRaise ipl!

			IOiCacheInfoBlockDirtyListHead@ cacheblock!

			if (cacheblock@ ~~)
				ipl@ KeIPLLower
				break
			end

			0 cacheblock@ IOiCacheInfoBlock_ModifiedPageCount + !

			auto n
			cacheblock@ IOiCacheInfoBlock_Next + @ n!

			n@ IOiCacheInfoBlockDirtyListHead!

			if (n@ ~~)
				0 IOiCacheInfoBlockDirtyListTail!
			end else
				0 n@ IOiCacheInfoBlock_Prev + !
			end

			ipl@ KeIPLLower

			cacheblock@ IOCacheInfoBlockFlush drop

			cacheblock@ IOiCacheInfoBlockDereference drop

			1 modcount -=
		end
	end
end

fn IOiScheduleWritebehind { -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"IOiScheduleWritebehind: ipl != IPLDPC\n" KeCrash
		end
	end

	0 // context1
	0 // context2
	IOWRITEBEHINDINTERVAL // interval
	IOiWritebehindTimer
	KeTimerEnqueue drop
end

fn IOTriggerWritebehind { -- }
	fnsection "PAGE$text"

	// artifically signal the dirty page event to sweep all the dirty
	// pages to disk. returns asynchronously, up to the caller to query the
	// dirty page count and figure out when they've all been written.

	0 // priboost
	IOiWritebehindEvent // event
	KeEventSignal
end