//
// Implements the IO worker threads.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOFilesystemSyncWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	auto ok

	while (1)
		// iterate all mounted filesystems every 5 seconds and ask them
		// to flush any internal state.

		5000 // interval
		KERNELMODE // waitmode
		0 // alertable
		KeThreadSleep ok!

		if (DEBUGCHECKS)
			if (ok@ STATUS_WAIT_TIMEOUT ~=)
				ok@ "IOFilesystemSyncWorker: wait failed (%i)\n" KeCrash
			end
		end

		IOFilesystemSyncAll ok!

		if (ok@)
			ok@ "IOFilesystemSyncWorker: failed to sync (%i)\n" KeCrash
		end
	end
end

const IODIRTYWRITEINTERVALSEC 10 // how frequently should we flush?

buffer IODirtyPageEvent KeEvent_SIZEOF
public IODirtyPageEvent

fn IOWritebehindWorker { context1 context2 -- }
	PRIORITY_LOWREALTIME 1 + // priority
	KeThreadCurrent@ // thread
	KeThreadPrioritySet

	IPLLOW KeIPLLower // kernel threads start in IPLDPC

	auto objecttable
	8 alloc objecttable!

	MmEventLowMemory objecttable@!
	IODirtyPageEvent objecttable@ 4 + !

	KeThreadCurrent@ KeThreadIgnoreKill drop

	// the writebehind worker

	while (1)
		// write out all dirty pages every 10 seconds, whenever the system
		// is low on memory, and whenever the number of dirty pages crosses
		// the maximum.

		// XXX we don't do this currently, but it's possible that it would be
		// best to go to sleep for every, say, 64-128 pages written out, in
		// order to avoid tying up the disk controller for too long.

		auto ok
		auto waitok

		KERNELMODE // waitmode
		0 // alertable
		OSWAITANY // waittype
		IODIRTYWRITEINTERVALSEC 1000 * // timeout
		2 // objectcount
		objecttable@ // objecttable
		KeThreadWaitForMultipleObjects waitok!

		if (DEBUGCHECKS)
			if (waitok@ 0 s<)
				if (waitok@ STATUS_WAIT_TIMEOUT ~=)
					waitok@ "IOWritebehindWorker: failed to wait on low memory event (%i)\n" KeCrash
				end
			end
		end

		auto writescore
		0 writescore!

		auto modcount
		IOCachePagesDirtyCount@ modcount!

		while (1)
			if (modcount@ ~~)
				if (waitok@ 0 ==)
					// low memory event woke us. sleep for 100ms or until the
					// maximum threshold of dirty pages is crossed, to make
					// sure we don't infinite loop here since there aren't any
					// more dirty pages.

					KERNELMODE // waitmode
					0 // alertable
					100 // timeout
					IODirtyPageEvent // object
					KeThreadWaitForObject ok!

					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						if (DEBUGCHECKS)
							if (ok@ 0 ~=)
								ok@ "IOWritebehindWorker: failed to wait (%i)\n" KeCrash
							end
						end

						IOCachePagesDirtyCount@ modcount!

						continue
					end
				end

				break
			end elseif (waitok@ 0 ==)
				if (MmEventLowMemory KeDispatchIsSignaled ~~)
					// don't need to write any more, finish the rest after the
					// timeout expires

					break
				end
			end

			auto thresh

			if (modcount@ 1 ==)
				1 thresh!
			end else
				modcount@ 1 >> thresh!
			end

			if (writescore@ thresh@ >=)
				// if we tried to unsuccessfully write modcount/2 times in a
				// row, odds are we're stuck in an infinite loop and we need
				// to let user threads run for a bit in order to successfully
				// write out any more pages. go to sleep for 50ms.

				0 writescore!

				50 // interval
				KERNELMODE // waitmode
				0 // alertable
				KeThreadSleep ok!

				if (DEBUGCHECKS)
					if (ok@ STATUS_WAIT_TIMEOUT ~=)
						ok@ "IOWritebehindWorker: wait failed (%i)\n" KeCrash
					end
				end

				IOCachePagesDirtyCount@ modcount!

				0 ok!
			end

			auto ipl
			IPLDPC KeIPLRaise ipl!

			auto pfdbe
			IOCacheDirtyPageListHead@ pfdbe!

			if (pfdbe@)
				if (modcount@ ~~)
					if (MmEventLowMemory KeDispatchIsSignaled ~~)
						if (IOCachePagesDirtyCount@ IOCachePagesDirtyMaximum@ <)
							ipl@ KeIPLLower

							break
						end
					end
				end

				auto cacheblock
				pfdbe@ IOPageFrameEntryCache_FCB + @ IOFileControlBlock_CacheInfoBlock + @ cacheblock!

				cacheblock@ // cacheblock
				IOCacheInfoBlockTryLockShared ok!

				if (ok@)
					// locked successfully

					ipl@ KeIPLLower

					// write out page

					0 pfdbe@ IOCachePageWriteDirty drop

					cacheblock@ // cacheblock
					IOCacheInfoBlockUnlock

					if (modcount@)
						1 modcount -=
					end

					0 writescore!
				end else
					// lock failed, move this page to the tail so that we
					// don't try it infinitely

					if (pfdbe@ IOCacheDirtyPageListTail@ ~=)
						pfdbe@ IOCachePageRemoveDirty

						pfdbe@ IOCachePageInsertDirty
					end

					ipl@ KeIPLLower

					1 writescore +=
				end
			end else
				0 modcount!

				ipl@ KeIPLLower
			end
		end
	end
end

fn IOFlushDirtyPages { -- }
	// artifically signal the dirty page event to sweep all the dirty
	// pages to disk. returns asynchronously, up to the caller to query the
	// dirty page count and figure out when they've all been written.

	0 // priboost
	IODirtyPageEvent // event
	KeEventSignal
end