//
// Implements a generic typeahead buffer. Useful in any situation where a low-
// speed input device (like a teletype, mouse, or keyboard) requires buffering.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOTypeaheadBufferInitialize { sizelog quotablock pri header -- ok }
	fnsection "PAGE$text"

	auto size
	1 sizelog@ << size!

	auto qcharge
	size@ MmChargeBytesGet qcharge!

	0 ok!

	if (quotablock@)
		// charge quota for buffer

		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockChargePaged ok!
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockCharge ok!
		end

		if (ok@)
			return
		end

		quotablock@ MmQuotaBlockReference
	end

	// allocate buffer

	auto buf
	size@ // size
	'IOTa' // tag
	pri@ // flags
	MmAllocWithTag ok! buf!

	if (ok@)
		if (quotablock@)
			if (pri@ PAGED &)
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUnchargePaged
			end else
				qcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockUncharge
			end

			quotablock@ MmQuotaBlockDereference
		end

		return
	end

	buf@ header@ IOTypeaheadBufferHeader_Buffer + !

	// initialize other header fields

	pri@ header@ IOTypeaheadBufferHeader_Paged + !
	size@ header@ IOTypeaheadBufferHeader_BufferSize + !
	size@ header@ IOTypeaheadBufferHeader_RemainingSpace + !
	0 header@ IOTypeaheadBufferHeader_ReadIndex + !
	0 header@ IOTypeaheadBufferHeader_WriteIndex + !
	quotablock@ header@ IOTypeaheadBufferHeader_QuotaBlock + !

	0 header@ IOTypeaheadBufferHeader_UserBuffer + !
	0 header@ IOTypeaheadBufferHeader_UserBufferIndex + !
	0 header@ IOTypeaheadBufferHeader_UserTransferLength + !
end

fn IOTypeaheadBufferUninitialize { header -- }
	auto buf
	header@ IOTypeaheadBufferHeader_Buffer + @ buf!

	auto bufsize
	header@ IOTypeaheadBufferHeader_BufferSize + @ bufsize!

	auto pri
	header@ IOTypeaheadBufferHeader_Paged + @ pri!

	auto quotablock
	header@ IOTypeaheadBufferHeader_QuotaBlock + @ quotablock!

	auto qcharge
	bufsize@ MmChargeBytesGet qcharge!

	if (quotablock@)
		if (pri@ PAGED &)
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUnchargePaged
		end else
			qcharge@ // charge
			quotablock@ // quotablock
			MmQuotaBlockUncharge
		end

		quotablock@ MmQuotaBlockDereference
	end

	buf@ MmFree
end

fn IOTypeaheadBufferCopyIn { bytestocopy buf header -- bytescopied ok }
	// assumes synchronization from above thru mutex or elevated IPL.

	// NOTE -- if bytestocopy is 1, the value of buf is taken to be a literal
	// character rather than a pointer to a buffer!

	// copy values into the typeahead buffer. if the typeahead buffer is full,
	// report this condition. if a user buffer has been associated with the
	// typeahead buffer, then insert the value there instead. this
	// functionality requires the user buffer to have been locked into memory
	// iff the typeahead buffer is synchronized with elevated IPL, as is done
	// when it is accessed from interrupt context, etc. if there is a user
	// buffer and this action fills it up, report this to the caller so it can
	// complete that request appropriately.

	// TODO report when buffer is ~80% full so that serial driver can send an
	// XOFF control character and potentially save the world.

	0 ok!

	auto index
	auto bufp

	header@ IOTypeaheadBufferHeader_UserBuffer + @ bufp!

	if (bufp@)
		// copy to user buffer.

		header@ IOTypeaheadBufferHeader_UserBufferIndex + @ index!

		if (bytestocopy@ 1 ==)
			// common case optimization -- this is often called from interrupt
			// context so attention to detail is important. we don't need to
			// check if we're overflowing the buffer since if there's a user
			// buffer it is guaranteed to have space for at least one more
			// byte.

			1 bytescopied!

			buf@
			bufp@ index@ + sb
		end else
			header@ IOTypeaheadBufferHeader_UserTransferLength + @
			index@ - bytescopied!

			if (bytestocopy@ bytescopied@ <)
				bytestocopy@ bytescopied!
			end

			bufp@ index@ + // dest
			buf@ // src
			bytescopied@ // sz
			memcpy
		end

		bytescopied@ index@ + header@ IOTypeaheadBufferHeader_UserBufferIndex + !

		if (index@ bytescopied@ +
			header@ IOTypeaheadBufferHeader_UserTransferLength + @ ==)

			// user buffer was filled up by this action.

			0 header@ IOTypeaheadBufferHeader_UserBuffer + !

			STATUS_OTHER_CONDITION ok!
		end

		return
	end

	// copy as much into the ringbuffer as possible.

	0 ok!

	header@ IOTypeaheadBufferHeader_Buffer + @ bufp!

	header@ IOTypeaheadBufferHeader_RemainingSpace + @ bytescopied!

	if (bytestocopy@ bytescopied@ <)
		bytestocopy@ bytescopied!
	end elseif (bytestocopy@ bytescopied@ >)
		STATUS_RING_FULL ok!
	end

	if (bytescopied@ ~~)
		return
	end

	auto bufsize
	header@ IOTypeaheadBufferHeader_BufferSize + @ bufsize!

	auto bufmask
	bufsize@ 1 - bufmask!

	header@ IOTypeaheadBufferHeader_WriteIndex + @ index!

	if (bytestocopy@ 1 ==)
		buf@ bufp@ index@ bufmask@ & + sb

		index@ 1 + header@ IOTypeaheadBufferHeader_WriteIndex + !
		1 header@ IOTypeaheadBufferHeader_RemainingSpace + -=

		return
	end

	auto endp
	index@ bytescopied@ + endp!

	if (index@ bufmask@ ~ & endp@ bufmask@ ~ & ==)
		// doesn't cross the boundary, do a single copy

		bufp@ index@ bufmask@ & + // dest
		buf@ // src
		bytescopied@ // sz
		memcpy
	end else
		// crosses the boundary, do two copies

		bufp@ index@ bufmask@ & + // dest
		buf@ // src
		bufsize@ index@ bufmask@ & - // sz
		memcpy

		bufp@ // dest
		buf@ bufsize@ index@ bufmask@ & - + // src
		endp@ bufmask@ & // sz
		memcpy
	end

	endp@ header@ IOTypeaheadBufferHeader_WriteIndex + !
	bytescopied@ header@ IOTypeaheadBufferHeader_RemainingSpace + -=
end

fn IOTypeaheadBufferCopyOut { bytestocopy buf switch header -- bytescopied ok }
	// assumes synchronization from above thru mutex or elevated IPL.

	// copy as many bytes as possible from the typeahead buffer into the given
	// buffer. when the typeahead buffer has been emptied, atomically switch
	// it to point to the user buffer, so that future CopyIns will slap them
	// into that buffer instead of the typeahead buffer. report this to the
	// caller so he can wait for the transfer to fully complete in whatever
	// consumer-specific way that needs to be done in.

	if (DEBUGCHECKS)
		if (header@ IOTypeaheadBufferHeader_UserBuffer + @)
			"IOTypeaheadBufferCopyOut: user buffer already associated\n" KeCrash
		end
	end

	0 ok!

	auto rp
	header@ IOTypeaheadBufferHeader_ReadIndex + @ rp!

	header@ IOTypeaheadBufferHeader_WriteIndex + @ rp@ - bytescopied!

	if (bytestocopy@ bytescopied@ <)
		bytestocopy@ bytescopied!
	end elseif (bytestocopy@ bytescopied@ >)
		if (switch@)
			STATUS_OTHER_CONDITION ok!
		end else
			STATUS_RING_EMPTY ok!
		end
	end

	if (bytescopied@)
		auto bufp
		header@ IOTypeaheadBufferHeader_Buffer + @ bufp!

		auto bufsize
		header@ IOTypeaheadBufferHeader_BufferSize + @ bufsize!

		auto bufmask
		bufsize@ 1 - bufmask!

		auto endp
		rp@ bytescopied@ + endp!

		if (rp@ bufmask@ ~ & endp@ bufmask@ ~ & ==)
			// doesn't cross the boundary, do a single copy

			buf@ // dest
			bufp@ rp@ bufmask@ & + // src
			bytescopied@ // sz
			memcpy
		end else
			// crosses the boundary, do two copies

			buf@ // dest
			bufp@ rp@ bufmask@ & + // src
			bufsize@ rp@ bufmask@ & - // sz
			memcpy

			buf@ bufsize@ rp@ bufmask@ & - + // dest
			bufp@ // src
			endp@ bufmask@ & // sz
			memcpy
		end

		endp@ header@ IOTypeaheadBufferHeader_ReadIndex + !
		bytescopied@ header@ IOTypeaheadBufferHeader_RemainingSpace + +=
	end

	if (ok@ STATUS_OTHER_CONDITION ==)
		// switch to user buffer.

		buf@ bytescopied@ + header@ IOTypeaheadBufferHeader_UserBuffer + !
		0 header@ IOTypeaheadBufferHeader_UserBufferIndex + !
		bytestocopy@ bytescopied@ - header@ IOTypeaheadBufferHeader_UserTransferLength + !
	end
end

fn IOTypeaheadBufferRubout { header -- value ok }
	// un-write the last character and return the value.

	auto bufp
	header@ IOTypeaheadBufferHeader_UserBuffer + @ bufp!

	auto index

	if (bufp@)
		header@ IOTypeaheadBufferHeader_UserBufferIndex + @ index!

		if (index@ ~~)
			-1 ok!
			return
		end

		1 index -=

		bufp@ index@ + gb value!

		index@ header@ IOTypeaheadBufferHeader_UserBufferIndex + !

		return
	end

	header@ IOTypeaheadBufferHeader_WriteIndex + @ index!

	if (index@ header@ IOTypeaheadBufferHeader_ReadIndex + @ ==)
		-1 ok!
		return
	end

	header@ IOTypeaheadBufferHeader_Buffer + @ bufp!

	auto bufsize
	header@ IOTypeaheadBufferHeader_BufferSize + @ bufsize!

	auto bufmask
	bufsize@ 1 - bufmask!

	1 index -=

	bufp@ index@ bufmask@ & + gb value!

	index@ header@ IOTypeaheadBufferHeader_WriteIndex + !
	1 header@ IOTypeaheadBufferHeader_RemainingSpace + +=
end

fn IOTypeaheadBufferComplete { header -- bytescopied }
	if (DEBUGCHECKS)
		if (header@ IOTypeaheadBufferHeader_UserBuffer + @ ~~)
			"IOTypeaheadBufferComplete: completing a nonexistent user buffer\n" KeCrash
		end
	end

	header@ IOTypeaheadBufferHeader_UserBufferIndex + @ bytescopied!
	0 header@ IOTypeaheadBufferHeader_UserBuffer + !
end