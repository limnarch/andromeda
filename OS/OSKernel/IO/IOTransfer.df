//
// Implements IO transfer helper functions.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/IPC.h"

#include "IOInternal.h"

fn IOMDLTransfer { iop completionroutine functioncode flags kflags mdl offset fcb -- length ok }
	auto iopl

	auto type

	if (completionroutine@)
		IOPTYPE_PAGING type!
	end else
		IOPTYPE_NORMAL type!
	end

	if (iop@)
		0 // quotablock
		type@ // type
		kflags@ // kflags
		fcb@ IOFileControlBlock_StackDepth + @ // stacksize
		IOPFLAG_FREEMDL // iopflags
		iop@ // iop
		IOPacketInitialize iopl!

		fcb@ iopl@ IOPacketLocation_FileControlBlock + !

		// remember that we were given the packet.

		0 type!
	end else
		KERNELMODE // mode
		type@ // type
		kflags@ // kflags
		fcb@ // fcb
		IOPFLAG_FREEMDL // iopflags
		IOPacketAllocateForFile ok! iop! iopl!

		if (ok@)
			return
		end

		// remember that we allocated the packet.

		1 type!
	end

	if (completionroutine@ ~~)
		auto event
		KeEvent_SIZEOF alloc event!

		0 // signaled
		OSEVENT_NOTIF // type
		"IOMDLTransferEvent" // name
		event@ // event
		KeEventInitialize

		event@ iop@ IOPacketHeader_Event + !
	end else
		KeThreadCurrent@ // thread
		completionroutine@ // specialfunc
		0 // normalfunc
		iop@ IOPacketHeaderPagingIO_CompletionAPC + // apc
		KeAPCInitialize
	end

	mdl@ iop@ IOPacketHeader_MDL + !

	mdl@ MmMDLHeader_Length + @ iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Length + !
	mdl@ MmMDLHeader_Length + @ iopl@ IOPacketLocation_Length + !
	offset@ iopl@ IOPacketLocation_Offset + !
	flags@ iopl@ IOPacketLocation_Flags + !

	functioncode@ iopl@ IOPacketLocation_FunctionCodeB + sb

	iop@ IOPacketEnqueue ok!

	if (completionroutine@ ~~)
		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@ ~~)
			iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Status + @ ok!
			iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Length + @ length!
		end

		if (type@)
			// we allocated this packet, so let's free it.

			iop@ IOPacketFree
		end
	end
end

fn IOReadWriteAsync { context flags length offset buffer portobject fileobject functioncode -- ok }
	fnsection "PAGE$text"

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"IOReadWriteAsync: ipl != IPLLOW\n" KeCrash
		end
	end

	"NYI\n" KeCrash
end

fn IOReadWrite { timeout flags length offset buffer fileobject functioncode -- bytes ok }
	fnsection "PAGE$text"

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"IOReadWrite: ipl != IPLLOW\n" KeCrash
		end
	end

	auto cancelfunc
	fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ cancelfunc!

	auto waitmode
	auto alertable

	if (cancelfunc@)
		USERMODE waitmode!
		1 alertable!
	end else
		OSWAIT_TIMEOUTINFINITE timeout!
		KERNELMODE waitmode!
		0 alertable!
	end

	0 bytes!

	auto mdl
	length@ // length
	buffer@ // vaddr
	0 // kflags
	MmMDLAllocateWithQuota ok! mdl!

	if (ok@)
		return
	end

	MMMDL_FREE mdl@ MmMDLHeader_Flags + |=

	auto iop
	auto iopl

	USERMODE // mode
	IOPTYPE_NORMAL // type
	0 // kflags
	fileobject@ IOFile_FileControlBlock + @ // fcb
	IOPFLAG_FREEMDL IOPFLAG_QUOTA | // iopflags
	IOPacketAllocateForFile ok! iop! iopl!

	if (ok@)
		mdl@ MmMDLFree

		return
	end

	auto event
	KeEvent_SIZEOF alloc event!

	0 // signaled
	OSEVENT_NOTIF // type
	"IOReadWriteEvent" // name
	event@ // event
	KeEventInitialize

	event@ iop@ IOPacketHeader_Event + !
	mdl@ iop@ IOPacketHeader_MDL + !

	length@ iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Length + !
	length@ iopl@ IOPacketLocation_Length + !
	offset@ iopl@ IOPacketLocation_Offset + !
	flags@ iopl@ IOPacketLocation_Flags + !

	functioncode@ iopl@ IOPacketLocation_FunctionCodeB + sb

	iop@ IOPacketEnqueue ok!

	if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
		auto wok
		waitmode@ // waitmode
		alertable@ // alertable
		timeout@ // timeout
		event@ // object
		KeThreadWaitForObject wok!

		if (wok@)
			IPLAPC KeIPLRaise drop

			iop@ // iop
			cancelfunc@ IODispatchCancelFunction

			IPLLOW KeIPLLower

			if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
				KERNELMODE // waitmode
				0 // alertable
				OSWAIT_TIMEOUTINFINITE // timeout
				event@ // object
				KeThreadWaitForObject drop
			end
		end
	end

	if (ok@ ~~)
		iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Status + @ ok!
		iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Length + @ bytes!
	end

	iop@ IOPacketFree
end