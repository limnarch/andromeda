//
// Implements IO transfer helper functions.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

// These should be used when the caller has little information on the
// parameters. These may be pretty terrible in some places where situation-
// specific information is handily available.

fn IORead { timeout flags kflags length offset buffer fcb lastmode -- bytesread ok }
	auto mdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!

	auto readfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

	auto event
	KeEvent_SIZEOF alloc event!

	0 bytesread!

	while (length@ IOTRANSFERMAX >=)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOReadEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		IOTRANSFERMAX // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		auto chunkread
		timeout@ // timeout
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok! chunkread!

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@)
			0 length!
			break
		end

		chunkread@ bytesread +=

		if (chunkread@ IOTRANSFERMAX <)
			0 length!
			break
		end

		IOTRANSFERMAX offset +=
		IOTRANSFERMAX buffer +=
		IOTRANSFERMAX length -=
	end

	if (length@)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOReadEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		timeout@ // timeout
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok! bytesread +=

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@)
			return
		end
	end
end

fn IOWrite { flags kflags length offset buffer fcb lastmode -- byteswritten ok }
	auto mdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	auto event
	KeEvent_SIZEOF alloc event!

	0 byteswritten!

	while (length@ IOTRANSFERMAX >=)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOWriteEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		IOTRANSFERMAX // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		auto chunkwritten
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		writefunc@ IODispatchWriteFunction ok! chunkwritten!

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@)
			0 length!
			break
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			0 length!
			break
		end

		chunkwritten@ byteswritten +=

		if (chunkwritten@ IOTRANSFERMAX <)
			0 length!
			break
		end

		IOTRANSFERMAX offset +=
		IOTRANSFERMAX buffer +=
		IOTRANSFERMAX length -=
	end

	if (length@)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOWriteEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		writefunc@ IODispatchWriteFunction ok! byteswritten +=

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			0 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject drop
		end

		if (ok@)
			return
		end

		mdl@ MmMDLHeader_Status + @ ok!
	end
end