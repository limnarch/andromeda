//
// Implements IO transfer helper functions.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOReadWrite { timeout flags kflags length offset buffer portobject fileobject lastmode write -- bytes ok }
	fnsection "PAGE$text"

	0 bytes!

	auto mdl
	auto event

	auto waitmode
	lastmode@ waitmode!

	auto alertable
	1 alertable!

	// perform an I/O operation on behalf of a user process.

	if (flags@ OSACCESSFLAG_ASYNC &)
		// async request. bias the file and port object refcounts.

		fileobject@ ObObjectReferenceByPointer drop
		portobject@ ObObjectReferenceByPointer drop

		0 // extraspace
		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		0 // kflags
		MmMDLAllocateWithQuota ok! mdl! drop

		if (ok@)
			fileobject@ ObObjectDereferenceByPointer drop
			portobject@ ObObjectDereferenceByPointer drop

			return
		end

		fileobject@ mdl@ MmMDLHeader_FileObject + !

		KeEvent_SIZEOF alloc event!

		0 alertable!
		KERNELMODE waitmode!
		OSWAIT_TIMEOUTINFINITE timeout!

		// initialize completion message and store in MDL.

		// TODO that
	end else
		KeEvent_SIZEOF // extraspace
		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		0 // kflags
		MmMDLAllocateWithQuota ok! mdl! event!

		if (ok@)
			return
		end

		MMMDL_DELETE ~ mdl@ MmMDLHeader_Flags + &=

		if (fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ ~~)
			KERNELMODE waitmode!
			OSWAIT_TIMEOUTINFINITE timeout!
			0 alertable!
		end

		event@ mdl@ MmMDLHeader_Event + !
	end

	0 // signaled
	OSEVENT_NOTIF // type
	"IORWEvent" // name
	event@ // event
	KeEventInitialize

	auto wok

	if (write@)
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fileobject@ IOFile_FileControlBlock + @ // fcb
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ IODispatchWriteFunction ok!
	end else
		timeout@ // timeout
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fileobject@ IOFile_FileControlBlock + @ // fcb
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ IODispatchReadFunction ok!
	end

	if (ok@)
		// complete the MDL so we can wait for any fragments to finish

		0 alertable!
		KERNELMODE waitmode!
		OSWAIT_TIMEOUTINFINITE timeout!

		event@ mdl@ MmMDLHeader_Event + !

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		// the MDL may or may not exist after this point if asynchronous.
	end

	if (flags@ OSACCESSFLAG_ASYNC & ~~ ok@ ||)
		// the request is synchronous OR enqueuing it failed.
		// we wait on the event if there was a failed async enqueue because
		// the driver may have fragmented the request into several child
		// requests which are still pending, and we do not want to leave those
		// hanging while this thread continues on doing whatever.

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			waitmode@ // waitmode
			alertable@ // alertable
			timeout@ // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				// this is only possible if enqueuing the MDL succeeded, since
				// we wait unalertable when it fails. therefore this can never
				// try to cancel an MDL that has already been freed, since
				// this codepath is unreachable for a successful async enqueue

				wok@ ok!

				mdl@ // mdl
				fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ IODispatchCancelFunction
			end
		end
	end

	if (flags@ OSACCESSFLAG_ASYNC & ~~)
		if (ok@)
			mdl@ MmMDLFree

			return
		end

		mdl@ MmMDLHeader_Status + @ ok!
		mdl@ MmMDLHeader_Length + @ bytes!

		mdl@ MmMDLFree
	end
end