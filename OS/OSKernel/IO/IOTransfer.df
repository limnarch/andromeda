//
// Implements IO transfer helper functions.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

// These should be used when the caller has little information on the
// parameters. These may be pretty terrible in some places where situation-
// specific information is handily available.

fn IOReadWrite { timeout flags kflags length offset buffer fcb lastmode write -- bytes ok }
	fnsection "PAGE$text"

	auto event

	if (length@ IOTRANSFERMAX >)
		IOTRANSFERMAX event!
	end else
		length@ event!
	end

	buffer@ event@ MmMDLGetSize event!

	auto mdl
	event@ KeEvent_SIZEOF + // bytes
	'MMDL' // tag
	CANBLOCK // flags
	MmAllocWithTag ok! mdl!

	if (ok@)
		return
	end

	mdl@ event@ + event!

	auto func

	if (write@)
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ func!
	end else
		fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ func!
	end

	auto cancelfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ cancelfunc!

	auto waitmode
	lastmode@ waitmode!

	auto alertable
	1 alertable!

	if (cancelfunc@ ~~)
		KERNELMODE waitmode!
		OSWAIT_TIMEOUTINFINITE timeout!
		0 alertable!
	end

	auto wok

	0 bytes!

	while (length@ IOTRANSFERMAX >=)
		0 // signaled
		OSEVENT_NOTIF // type
		"IORWEvent" // name
		event@ // event
		KeEventInitialize

		0 // fileobject
		lastmode@ // mode
		IOTRANSFERMAX // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		if (write@)
			flags@ // flags
			kflags@ // kflags
			offset@ // offset
			mdl@ // mdl
			fcb@ // fcb
			func@ IODispatchWriteFunction ok!
		end else
			timeout@ // timeout
			flags@ // flags
			kflags@ // kflags
			offset@ // offset
			mdl@ // mdl
			fcb@ // fcb
			func@ IODispatchReadFunction ok!
		end

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			0 alertable!
			KERNELMODE waitmode!
			OSWAIT_TIMEOUTINFINITE timeout!

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			waitmode@ // waitmode
			alertable@ // alertable
			timeout@ // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				wok@ ok!
				mdl@ cancelfunc@ IODispatchCancelFunction
			end
		end

		if (ok@)
			0 length!
			break
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			0 length!
			break
		end

		mdl@ MmMDLHeader_Length + @ bytes +=

		if (mdl@ MmMDLHeader_Length + @ IOTRANSFERMAX <)
			0 length!
			break
		end

		IOTRANSFERMAX offset +=
		IOTRANSFERMAX buffer +=
		IOTRANSFERMAX length -=
	end

	if (length@)
		0 // signaled
		OSEVENT_NOTIF // type
		"IORWEvent" // name
		event@ // event
		KeEventInitialize

		0 // fileobject
		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		if (write@)
			flags@ // flags
			kflags@ // kflags
			offset@ // offset
			mdl@ // mdl
			fcb@ // fcb
			func@ IODispatchWriteFunction ok!
		end else
			timeout@ // timeout
			flags@ // flags
			kflags@ // kflags
			offset@ // offset
			mdl@ // mdl
			fcb@ // fcb
			func@ IODispatchReadFunction ok!
		end

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			0 alertable!
			KERNELMODE waitmode!
			OSWAIT_TIMEOUTINFINITE timeout!

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			waitmode@ // waitmode
			alertable@ // alertable
			timeout@ // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				wok@ ok!
				mdl@ cancelfunc@ IODispatchCancelFunction
			end
		end

		if (ok@ ~~)
			mdl@ MmMDLHeader_Status + @ ok!

			if (ok@ ~~)
				mdl@ MmMDLHeader_Length + @ bytes +=
			end
		end
	end

	mdl@ MmFree
end