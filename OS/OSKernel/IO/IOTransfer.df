//
// Implements IO transfer helper functions.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/IPC.h"

fn IOReadWrite { timeout flags kflags length offset buffer portobject fileobject lastmode write -- bytes ok }
	fnsection "PAGE$text"

	// NOTE: for async IO, timeout is the context

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"IOReadWrite: ipl != IPLLOW\n" KeCrash
		end
	end

	0 bytes!

	auto mdl
	auto event

	auto waitmode
	lastmode@ waitmode!

	auto alertable
	1 alertable!

	// perform an I/O operation on behalf of a user process.

	if (flags@ OSACCESSFLAG_ASYNC &)
		// async request. bias the file and port object refcounts.

		fileobject@ ObObjectReferenceByPointer drop
		portobject@ ObObjectReferenceByPointer drop

		0 // extraspace
		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		0 // kflags
		MmMDLAllocateWithQuota ok! mdl! drop

		if (ok@)
			fileobject@ ObObjectDereferenceByPointer drop
			portobject@ ObObjectDereferenceByPointer drop

			return
		end

		fileobject@ mdl@ MmMDLHeader_FileObject + !

		// allocate completion message from port object.

		// reuse event for the message.

		OSMessageHeaderIOCompletion_SIZEOF alloc event!

		0 event@ OSMessageHeader_LengthI + si
		OSNONE event@ OSMessageHeader_Handle + !

		0 // allowhandle
		event@ // umsg
		KERNELMODE // mode
		OSPORT_CONID_IOCOMPLETE // conid
		portobject@ // portobject
		IPCMessageAllocate ok! event! drop

		if (ok@)
			mdl@ MmMDLFree

			fileobject@ ObObjectDereferenceByPointer drop
			portobject@ ObObjectDereferenceByPointer drop

			return
		end

		// initialize completion message and store in MDL.

		OSPORT_MESSAGE_IOCOMPLETE event@ IPCKernelMessage_Header + OSMessageHeader_TypeB + sb

		0 event@ IPCKernelMessage_Header + OSMessageHeaderIOCompletion_BytesTransferred + !
		timeout@ event@ IPCKernelMessage_Header + OSMessageHeaderIOCompletion_Context + !
		0 event@ IPCKernelMessage_Header + OSMessageHeaderIOCompletion_Status + !

		event@ mdl@ MmMDLHeader_CompletionMessage + !

		// enqueue MDL in thread IO list.
		// mask out APCs to prevent them from messing with this list while we
		// are touching it. this works because this list is NEVER modified
		// except from the context of THIS thread.

		IPLAPC KeIPLRaise drop

		// reuse event for head
		KeThreadCurrent@ PsThread_IOListHead + @ event!

		event@ mdl@ MmMDLHeader_IOListNext + !

		if (event@)
			mdl@ event@ MmMDLHeader_IOListPrev + !
		end

		mdl@ KeThreadCurrent@ PsThread_IOListHead + !

		IPLLOW KeIPLLower

		1 fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_AsyncIOCount + KeInterlockedIncrement event!

		if (event@ 0 ==)
			// clear the event
			fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_AsyncIOEvent + // event
			KeEventReset drop
		end

		0 alertable!
		KERNELMODE waitmode!
		OSWAIT_TIMEOUTINFINITE timeout!

		KeEvent_SIZEOF alloc event!
	end else
		KeEvent_SIZEOF // extraspace
		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		0 // kflags
		MmMDLAllocateWithQuota ok! mdl! event!

		if (ok@)
			return
		end

		MMMDL_DELETE ~ mdl@ MmMDLHeader_Flags + &=

		if (fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ ~~)
			KERNELMODE waitmode!
			OSWAIT_TIMEOUTINFINITE timeout!
			0 alertable!
		end

		event@ mdl@ MmMDLHeader_Event + !
	end

	0 // signaled
	OSEVENT_NOTIF // type
	"IORWEvent" // name
	event@ // event
	KeEventInitialize

	auto wok

	if (write@)
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fileobject@ IOFile_FileControlBlock + @ // fcb
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ IODispatchWriteFunction ok!
	end else
		timeout@ // timeout
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fileobject@ IOFile_FileControlBlock + @ // fcb
		fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ IODispatchReadFunction ok!
	end

	if (ok@)
		// complete the MDL so we can wait for any fragments to finish

		0 alertable!
		KERNELMODE waitmode!
		OSWAIT_TIMEOUTINFINITE timeout!

		event@ mdl@ MmMDLHeader_Event + !

		if (flags@ OSACCESSFLAG_ASYNC &)
			// clean up this stuff so the thread doesn't get a spurious
			// completion message.

			IPLAPC KeIPLRaise drop

			mdl@ MmMDLHeader_IOListPrev + @ wok!
			mdl@ MmMDLHeader_IOListNext + @ bytes!

			if (mdl@ MmMDLHeader_IOListPrev + @)
				bytes@ wok@ MmMDLHeader_IOListNext + !
			end else
				bytes@ KeThreadCurrent@ PsThread_IOListHead + !
			end

			if (bytes@)
				wok@ bytes@ MmMDLHeader_IOListPrev + !
			end

			IPLLOW KeIPLLower

			mdl@ MmMDLHeader_CompletionMessage + @ IPCMessageFree
			0 mdl@ MmMDLHeader_CompletionMessage + !

			0 mdl@ MmMDLHeader_FileObject + !

			fileobject@ ObObjectDereferenceByPointer drop
			portobject@ ObObjectDereferenceByPointer drop
		end

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		// the MDL may or may not exist after this point if asynchronous.
	end

	if (flags@ OSACCESSFLAG_ASYNC & ~~ ok@ ||)
		// the request is synchronous OR enqueuing it failed.
		// we wait on the event if there was a failed async enqueue because
		// the driver may have fragmented the request into several child
		// requests which are still pending, and we do not want to leave those
		// hanging while this thread continues on doing whatever.

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			waitmode@ // waitmode
			alertable@ // alertable
			timeout@ // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				// this is only possible if enqueuing the MDL succeeded, since
				// we wait unalertable when it fails. therefore this can never
				// try to cancel an MDL that has already been freed, since
				// this codepath is unreachable for a successful async enqueue

				wok@ ok!

				IPLAPC KeIPLRaise drop

				mdl@ // mdl
				fileobject@ IOFile_FileControlBlock + @ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ IODispatchCancelFunction

				IPLLOW KeIPLLower
			end
		end
	end

	if (flags@ OSACCESSFLAG_ASYNC & ~~)
		if (ok@)
			mdl@ MmMDLFree

			return
		end

		mdl@ MmMDLHeader_Status + @ ok!
		mdl@ MmMDLHeader_Length + @ bytes!

		mdl@ MmMDLFree
	end
end