//
// Implements IO transfer helper functions.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

// These should be used when the caller has little information on the
// parameters. These may be pretty terrible in some places where situation-
// specific information is handily available.

fn IORead { timeout flags kflags length offset buffer fcb lastmode -- bytesread ok }
	fnsection "PAGE$text"

	auto mdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!

	auto readfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Read + @ readfunc!

	auto cancelfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ cancelfunc!

	auto alertable
	1 alertable!

	if (cancelfunc@ ~~)
		OSWAIT_TIMEOUTINFINITE timeout!
		0 alertable!
	end

	auto wok

	auto event
	KeEvent_SIZEOF alloc event!

	0 bytesread!

	while (length@ IOTRANSFERMAX >=)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOReadEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		IOTRANSFERMAX // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		timeout@ // timeout
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok! drop

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			0 alertable!
			OSWAIT_TIMEOUTINFINITE timeout!

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			alertable@ // alertable
			timeout@ // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				wok@ ok!
				mdl@ cancelfunc@ IODispatchCancelFunction
			end
		end

		if (ok@)
			0 length!
			break
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			0 length!
			break
		end

		mdl@ MmMDLHeader_Length + @ bytesread +=

		if (mdl@ MmMDLHeader_Length + @ IOTRANSFERMAX <)
			0 length!
			break
		end

		IOTRANSFERMAX offset +=
		IOTRANSFERMAX buffer +=
		IOTRANSFERMAX length -=
	end

	if (length@)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOReadEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		timeout@ // timeout
		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		readfunc@ IODispatchReadFunction ok! drop

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			0 alertable!
			OSWAIT_TIMEOUTINFINITE timeout!

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			alertable@ // alertable
			timeout@ // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				wok@ ok!
				mdl@ cancelfunc@ IODispatchCancelFunction
			end
		end

		if (ok@)
			return
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			return
		end

		mdl@ MmMDLHeader_Length + @ bytesread +=
	end
end

fn IOWrite { flags kflags length offset buffer fcb lastmode -- byteswritten ok }
	fnsection "PAGE$text"

	auto mdl
	MmMDLHeader_SIZEOF IOTRANSFERMAX PAGESHIFT >> 1 + 4 * + alloc mdl!

	auto writefunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Write + @ writefunc!

	auto cancelfunc
	fcb@ IOFileControlBlock_DispatchTable + @ IODispatchTable_Cancel + @ cancelfunc!

	auto alertable
	1 alertable!

	if (cancelfunc@ ~~)
		0 alertable!
	end

	auto wok

	auto event
	KeEvent_SIZEOF alloc event!

	0 byteswritten!

	while (length@ IOTRANSFERMAX >=)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOWriteEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		IOTRANSFERMAX // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		writefunc@ IODispatchWriteFunction ok! drop

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			0 alertable!

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			alertable@ // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				wok@ ok!
				mdl@ cancelfunc@ IODispatchCancelFunction
			end
		end

		if (ok@)
			0 length!
			break
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			0 length!
			break
		end

		mdl@ MmMDLHeader_Length + @ byteswritten +=

		if (mdl@ MmMDLHeader_Length + @ IOTRANSFERMAX <)
			0 length!
			break
		end

		IOTRANSFERMAX offset +=
		IOTRANSFERMAX buffer +=
		IOTRANSFERMAX length -=
	end

	if (length@)
		0 // signaled
		OSEVENT_NOTIF // type
		"IOWriteEvent" // name
		event@ // event
		KeEventInitialize

		lastmode@ // mode
		length@ // length
		buffer@ // vaddr
		mdl@ // mdl
		MmMDLInitialize

		event@ mdl@ MmMDLHeader_Event + !

		flags@ // flags
		kflags@ // kflags
		offset@ // offset
		mdl@ // mdl
		fcb@ // fcb
		writefunc@ IODispatchWriteFunction ok! drop

		if (ok@)
			// complete the MDL so we can wait for any fragments to finish

			0 alertable!

			ok@ // status
			0 // priboost
			mdl@ // mdl
			MmMDLComplete
		end

		if (event@ KeEvent_DispatchHeader + KeDispatchHeader_Signaled + @ ~~)
			KERNELMODE // waitmode
			alertable@ // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			event@ // object
			KeThreadWaitForObject wok!

			if (wok@)
				wok@ ok!
				mdl@ cancelfunc@ IODispatchCancelFunction
			end
		end

		if (ok@)
			return
		end

		mdl@ MmMDLHeader_Status + @ ok!

		if (ok@)
			return
		end

		mdl@ MmMDLHeader_Length + @ byteswritten +=
	end
end