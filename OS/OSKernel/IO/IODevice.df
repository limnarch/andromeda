//
// Implements device objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IODeviceDirectoryInsert { deviceobject -- ok }
	fnsection "PAGE$text"

	deviceobject@ // object
	IODevicesDirectoryObject@ // directory
	ObDirectoryInsertByPointers ok!
end

fn IODeviceCreateFileControlBlock { deviceobject -- fcb ok }
	fnsection "PAGE$text"

	auto driver
	deviceobject@ IODevice_Driver + @ driver!

	driver@ IODriver_DispatchTable + @ // dispatchtable
	deviceobject@ // devobj
	driver@ IODriver_DeviceType + @ // filetype
	0 // flags
	IOFileControlBlockCreate ok! fcb!
end

fn IODeviceCreateFileObject { flags fcb deviceobject -- fileobject ok }
	fnsection "PAGE$text"

	deviceobject@ ObObjectReferenceByPointer drop
	fcb@ IOFileControlBlockReference drop

	auto fullpath
	OBNAMEMAX 4 + alloc fullpath!

	':' fullpath@ sb
	fullpath@ 1 + // dest
	deviceobject@ ObObjectName // src
	strcpy

	fullpath@ // openedpath
	flags@ // flags
	deviceobject@ ObObjectPagedHeader ObPagedHeader_Permissions + @ // permissions
	fcb@ // fcb
	IOFileCreateObject ok! fileobject!

	if (ok@)
		fcb@ IOFileControlBlockDereference drop
		deviceobject@ ObObjectDereferenceByPointer drop
	end else
		deviceobject@ ObObjectPagedHeader ObPagedHeader_UID + @
		fileobject@ ObObjectPagedHeader ObPagedHeader_UID + !

		deviceobject@ ObObjectPagedHeader ObPagedHeader_GID + @
		fileobject@ ObObjectPagedHeader ObPagedHeader_GID + !
	end
end

fn IODeviceCreateEx { name sizeinbytes driver permissions permanent -- deviceobject ok }
	fnsection "PAGE$text"

	auto flags

	if (permanent@)
		OBFLAGS_PERMANENT flags!
	end else
		0 flags!
	end

	name@ // name
	flags@ // flags
	permissions@ // permissions
	0 // npquotabias
	0 // pquotabias
	IODevice_SIZEOF driver@ IODriver_ExtensionSize + @ + // bodysize
	IODeviceTypeObject@ // type
	ObObjectCreate ok! deviceobject!

	if (ok@)
		return
	end

	driver@ deviceobject@ IODevice_Driver + !
	deviceobject@ IODevice_SIZEOF + deviceobject@ IODevice_Extension + !
	0 deviceobject@ IODevice_BlockLog + !
	0 deviceobject@ IODevice_ConsoleHeader + !

	auto fcb
	deviceobject@ IODeviceCreateFileControlBlock ok! fcb!

	if (ok@)
		deviceobject@ ObObjectDeallocate

		return
	end

	fcb@ deviceobject@ IODevice_FileControlBlock + !

	sizeinbytes@ fcb@ IOFileControlBlock_SizeInBytes + !
end

fn IODeviceCreate { name sizeinbytes driver permissions -- deviceobject ok }
	fnsection "PAGE$text"

	// makes the device object permanent and inserts it in the Devices object
	// directory. useful for physical device drivers.

	if (name@ ~~)
		"IODeviceCreate: no name\n" KeCrash
	end

	if (driver@ IODriver_VersionMajor + @ IOVERSION_MAJOR ~=)
		name@ "Failed to create device '%s'.\n" "IODeviceCreate" HALLog

		-1 ok!

		return
	end

	if (driver@ IODriver_VersionMinor + @ IOVERSION_MINOR ~=)
		name@ "Device '%s' has mismatched driver interface.\n" "IODeviceCreate" HALLog
	end

	name@ // name
	sizeinbytes@ // sizeinbytes
	driver@ // driver
	permissions@ // permissions
	1 // permanent
	IODeviceCreateEx ok! deviceobject!

	if (ok@)
		return
	end

	deviceobject@ IODeviceDirectoryInsert ok!

	if (ok@)
		"IODeviceCreate: failed to insert in Devices directory\n" KeCrash
	end
end

fn IODeviceGetExtension { deviceobject -- extension }
	deviceobject@ IODevice_Extension + @ extension!
end

fn IODeviceSetConsoleHeader { console deviceobject -- }
	fnsection "PAGE$text"
	console@ deviceobject@ IODevice_ConsoleHeader + !
end

fn IODeviceGetConsoleHeader { deviceobject -- console }
	fnsection "PAGE$text"
	deviceobject@ IODevice_ConsoleHeader + @ console!
end

fn IODeviceSetBlockLog { blocklog deviceobject -- }
	fnsection "PAGE$text"
	blocklog@ deviceobject@ IODevice_BlockLog + !
end

fn IODeviceGetBlockLog { deviceobject -- blocklog }
	deviceobject@ IODevice_BlockLog + @ blocklog!
end

fn IODeviceDeallocateObject { object -- }
	fnsection "PAGE$text"

	auto fcb
	object@ IODevice_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ IOFileControlBlock_References + @)
			"IODeviceDeallocateObject: fcb had refs\n" KeCrash
		end
	end

	-1 // writeout
	fcb@ // fcb
	IOFileControlBlockDelete drop

	object@ ObObjectDeallocate
end

fn (IODispatchDeleteObjectFunction) IODeviceDeleteObject { object -- ok }
	fnsection "PAGE$text"

	0 ok!

	auto fcb
	object@ IODevice_FileControlBlock + @ fcb!

	if (DEBUGCHECKS)
		if (fcb@ IOFileControlBlock_References + @)
			"IODeviceDeleteObject: fcb had refs\n" KeCrash
		end
	end

	auto deletefunc
	object@ IODevice_Driver + @ IODriver_DispatchTable + @ IODispatchTable_DeleteDeviceObject + @ deletefunc!

	if (deletefunc@)
		object@ // object
		deletefunc@ IODispatchDeleteDeviceObjectFunction
	end

	-1 // writeout
	fcb@ // fcb
	IOFileControlBlockDelete drop
end

fn (IODispatchDeleteObjectFunction) IODeviceDeleteFileObject { object -- ok }
	fnsection "PAGE$text"

	// generic function for deleting a file object for device drivers

	0 ok!

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	fcb@ IOFileControlBlockDereference drop
	fcb@ IOFileControlBlock_DeviceObject + @ ObObjectDereferenceByPointer drop
end