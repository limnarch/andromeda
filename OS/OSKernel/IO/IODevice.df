//
// Implements device objects.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

#include "IOInternal.h"

fn IODeviceGetAttached { deviceobject -- attacheddeviceobject } 
	fnsection "PAGE$text"

	deviceobject@ attacheddeviceobject!

	while (deviceobject@ IODevice_AttachedBy + @)
		deviceobject@ IODevice_AttachedBy + @ attacheddeviceobject!

		if (attacheddeviceobject@ IODevice_Driver + @ IODriver_Flags + @ IODRIVER_NOCHAIN &)
			// driver doesn't want us to follow the device chain into its
			// device object.

			deviceobject@ attacheddeviceobject!

			break
		end

		attacheddeviceobject@ deviceobject!

		if (deviceobject@ IODevice_Driver + @ IODriver_Flags + @ IODRIVER_CHAINSTOP &)
			// driver wants us to stop the chain at its device object.

			break
		end
	end
end

fn IODeviceAttachObject { chain deviceobject todeviceobject -- ok }
	fnsection "PAGE$text"

	if (todeviceobject@ IODevice_AttachedBy + @)
		if (chain@ ~~)
			STATUS_ALREADY_EXISTS ok!

			return
		end

		todeviceobject@ IODeviceGetAttached todeviceobject!

		if (todeviceobject@ IODevice_AttachedBy + @)
			STATUS_ALREADY_EXISTS ok!

			return
		end
	end

	0 ok!

	deviceobject@ todeviceobject@ IODevice_AttachedBy + !
	todeviceobject@ IODevice_BlockLog + @ deviceobject@ IODevice_BlockLog + !

	// only set the stack depth on the device object if it would increase.
	// otherwise multiple attachments might result in there being insufficient
	// IOP stack space for some of the lower devices on the stack.

	if (todeviceobject@ IODevice_StackDepth + @ 1 +
		deviceobject@ IODevice_StackDepth + @ >)
		todeviceobject@ IODevice_StackDepth + @ 1 + deviceobject@ IODevice_StackDepth + !
	end
end

fn IODeviceDirectoryInsert { deviceobject -- ok }
	fnsection "PAGE$text"

	deviceobject@ // object
	IODevicesDirectoryObject@ // directory
	ObDirectoryInsertByPointers ok!
end

fn IODeviceCreateFileControlBlock { deviceobject -- fcb ok }
	fnsection "PAGE$text"

	auto driver
	deviceobject@ IODevice_Driver + @ driver!

	deviceobject@ // devobj
	driver@ IODriver_DeviceType + @ // filetype
	0 // flags
	IOFileControlBlockCreate ok! fcb!
end

fn IODeviceCreateFileObject { flags fcb deviceobject -- fileobject ok }
	fnsection "PAGE$text"

	deviceobject@ ObObjectReferenceByPointer drop

	auto fullpath
	OBNAMEMAX 4 + alloc fullpath!

	':' fullpath@ sb

	if (deviceobject@ ObObjectName)
		fullpath@ 1 + // dest
		deviceobject@ ObObjectName // src
		strcpy
	end

	fullpath@ // openedpath
	flags@ // flags
	deviceobject@ ObObjectPermissions // permissions
	fcb@ // fcb
	IOFileCreateObject ok! fileobject!

	if (ok@)
		deviceobject@ ObObjectDereferenceByPointer drop
	end else
		auto uid
		auto gid

		deviceobject@ ObObjectUIDGID gid! uid!

		uid@ fileobject@ ObObjectSetUID
		gid@ fileobject@ ObObjectSetGID
	end
end

fn IODeviceCreateEx { name sizeinbytes driver permissions permanent -- deviceobject ok }
	fnsection "PAGE$text"

	auto flags

	if (permanent@)
		OBFLAGS_PERMANENT flags!
	end else
		0 flags!
	end

	name@ // name
	flags@ // flags
	permissions@ // permissions
	0 // npquotabias
	0 // pquotabias
	IODevice_SIZEOF driver@ IODriver_ExtensionSize + @ + // bodysize
	IODeviceTypeObject@ // type
	ObObjectCreate ok! deviceobject!

	if (ok@)
		return
	end

	driver@ deviceobject@ IODevice_Driver + !
	deviceobject@ IODevice_SIZEOF + deviceobject@ IODevice_Extension + !
	0 deviceobject@ IODevice_BlockLog + !
	0 deviceobject@ IODevice_ConsoleHeader + !
	0 deviceobject@ IODevice_Mount + !

	1 deviceobject@ IODevice_StackDepth + !
	0 deviceobject@ IODevice_AttachedBy + !
	0 deviceobject@ IODevice_Flags + !

	auto fcb
	deviceobject@ IODeviceCreateFileControlBlock ok! fcb!

	if (ok@)
		deviceobject@ ObObjectDeallocate

		return
	end

	fcb@ deviceobject@ IODevice_FileControlBlock + !

	sizeinbytes@ fcb@ IOFileControlBlockSetSize
end

fn IODeviceCreate { name sizeinbytes driver permissions -- deviceobject ok }
	fnsection "PAGE$text"

	// makes the device object permanent and inserts it in the Devices object
	// directory. useful for physical device drivers.

	if (name@ ~~)
		"IODeviceCreate: no name\n" KeCrash
	end

	if (driver@ IODriver_VersionMajor + @ IOVERSION_MAJOR ~=)
		name@ "Failed to create device '%s'.\n" "IODeviceCreate" HALLog

		-1 ok!

		return
	end

	if (driver@ IODriver_VersionMinor + @ IOVERSION_MINOR ~=)
		name@ "Device '%s' has mismatched driver interface.\n" "IODeviceCreate" HALLog
	end

	name@ // name
	sizeinbytes@ // sizeinbytes
	driver@ // driver
	permissions@ // permissions
	1 // permanent
	IODeviceCreateEx ok! deviceobject!

	if (ok@)
		return
	end

	deviceobject@ IODeviceDirectoryInsert ok!

	if (ok@)
		"IODeviceCreate: failed to insert in Devices directory\n" KeCrash
	end
end

fn IODeviceGetExtension { deviceobject -- extension }
	deviceobject@ IODevice_Extension + @ extension!
end

fn IODeviceSetConsoleHeader { console deviceobject -- }
	fnsection "PAGE$text"
	console@ deviceobject@ IODevice_ConsoleHeader + !
end

fn IODeviceGetConsoleHeader { deviceobject -- console }
	fnsection "PAGE$text"
	deviceobject@ IODevice_ConsoleHeader + @ console!
end

fn IODeviceSetBlockLog { blocklog deviceobject -- }
	fnsection "PAGE$text"
	blocklog@ deviceobject@ IODevice_BlockLog + !
end

fn IODeviceGetBlockLog { deviceobject -- blocklog }
	deviceobject@ IODevice_BlockLog + @ blocklog!
end

fn IODeviceDeallocateObject { object -- }
	fnsection "PAGE$text"

	auto fcb
	object@ IODevice_FileControlBlock + @ fcb!

	-1 // writeout
	fcb@ // fcb
	IOFileControlBlockDelete drop

	object@ ObObjectDeallocate
end

fn (IODispatchDeleteObjectFunction) IODeviceDeleteObject { object -- ok }
	fnsection "PAGE$text"

	0 ok!

	auto fcb
	object@ IODevice_FileControlBlock + @ fcb!

	auto deletefunc
	object@ IODevice_Driver + @ IODriver_DispatchTable + @ IODispatchTable_DeleteDeviceObject + @ deletefunc!

	if (deletefunc@)
		object@ // object
		deletefunc@ IODispatchDeleteDeviceObjectFunction
	end

	-1 // writeout
	fcb@ // fcb
	IOFileControlBlockDelete drop
end

fn (IODispatchDeleteObjectFunction) IODeviceDeleteFileObject { object -- ok }
	fnsection "PAGE$text"

	// generic function for deleting a file object for device drivers

	0 ok!

	object@ IOFile_FileControlBlock + @
	IOFileControlBlockGetDeviceObject
	ObObjectDereferenceByPointer drop
end