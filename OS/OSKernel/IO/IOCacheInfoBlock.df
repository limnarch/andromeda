//
// Implements MINTIA page cache management routines.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOCacheInfoBlockCreate { -- cacheblock ok }
	IOCacheInfoBlock_SIZEOF // bytes
	'Cach' // tag
	CANBLOCK POOLALLOC | // flags
	MmAllocWithTag ok! cacheblock!

	if (ok@)
		// allocation failed

		return
	end

	0 cacheblock@ IOCacheInfoBlock_MapCount + !
	0 cacheblock@ IOCacheInfoBlock_Flags + !
	0 cacheblock@ IOCacheInfoBlock_SplayTreeRoot + !

	"IOCacheInfoBlockRwLock" // name
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockInitialize
end

fn IOCacheInfoBlockLock { cacheblock -- ok }
	1 // alertable
	0 // nowait
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireExclusive ok!
end

fn IOCacheInfoBlockTryLock { cacheblock -- ok }
	0 // alertable
	1 // nowait
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireExclusive ok!

	if (ok@ 0 s<)
		0 ok!
	end
end

fn IOCacheInfoBlockLockShared { cacheblock -- ok }
	1 // alertable
	0 // nowait
	0 // canstarve
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireShared ok!
end

fn IOCacheInfoBlockTryLockShared { cacheblock -- ok }
	0 // alertable
	1 // nowait
	0 // canstarve
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireShared ok!

	if (ok@ 0 s<)
		0 ok!
	end
end

fn IOCacheInfoBlockUnlock { cacheblock -- }
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockRelease
end

fn IOCacheInfoBlockTryReference { cacheblock -- oldcount ok }
	0 ok!

	auto rs
	HALCPUInterruptDisable rs!

	if (cacheblock@ IOCacheInfoBlock_Flags + @ IOCACHEBLOCKFLAG_TRUNCATING &)
		rs@ HALCPUInterruptRestore

		STATUS_TRY_AGAIN_LATER ok!

		return
	end

	cacheblock@ IOCacheInfoBlock_MapCount + @ oldcount!

	oldcount@ 1 + cacheblock@ IOCacheInfoBlock_MapCount + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockDereference { cacheblock -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	cacheblock@ IOCacheInfoBlock_MapCount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"IOCacheInfoBlockDereference: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - cacheblock@ IOCacheInfoBlock_MapCount + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockFlush { cacheblock -- ok }
	// flush all of the cacheblock's dirty pages.

	cacheblock@ // cacheblock
	IOCacheInfoBlockLock ok!

	if (ok@)
		return
	end

	auto pfdbe

	auto ipl
	IPLDPC KeIPLRaise ipl!

	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + @ ExSplayTreeNodeFirst pfdbe!

	while (pfdbe@)
		IOPageFrameEntryCache_Parent pfdbe -=

		if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
			pfdbe@ MmEvictablePageReference drop

			ipl@ KeIPLLower

			0 // kflags
			pfdbe@ // pfdbe
			IOCachePageWrite drop

			IPLDPC KeIPLRaise ipl!

			pfdbe@ MmEvictablePageDereference drop
		end

		pfdbe@ IOPageFrameEntryCache_Parent + // node
		ExSplayTreeNodeNext pfdbe!
	end

	ipl@ KeIPLLower

	cacheblock@ // cacheblock
	IOCacheInfoBlockUnlock
end

fn IOCacheInfoBlockTruncate { newsize writeout cacheblock -- ok }
	// attempt to evict all of the cacheblock's page frames beyond newsize.
	// also evicts the page that contains newsize, to prevent a weird
	// interaction with the dirty page writer.

	auto maxpage
	newsize@ PAGENUMBERMASK & maxpage!

	cacheblock@ // cacheblock
	IOCacheInfoBlockLock ok!

	if (ok@)
		return
	end

	auto rs
	HALCPUInterruptDisable rs!

	if (cacheblock@ IOCacheInfoBlock_MapCount + @)
		// this file is currently mapped. truncation isn't allowed.

		rs@ HALCPUInterruptRestore

		cacheblock@ IOCacheInfoBlockUnlock

		STATUS_TRY_AGAIN_LATER ok!

		return
	end

	IOCACHEBLOCKFLAG_TRUNCATING cacheblock@ IOCacheInfoBlock_Flags + |=

	rs@ HALCPUInterruptRestore

	auto pfdbe

	auto ipl
	IPLDPC KeIPLRaise ipl!

	cacheblock@ IOCacheInfoBlock_SplayTreeRoot + @ ExSplayTreeNodeFirst pfdbe!

	while (pfdbe@)
		IOPageFrameEntryCache_Parent pfdbe -=

		if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ newsize@ >=)
			pfdbe@ MmEvictablePageReference drop

			if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_MODIFIED &)
				if (writeout@)
					// this is a dirty page, and caller wants us to
					// write them out to disk. the alternative is
					// writeout==0, which means the caller says its fine
					// to ignore and throw them out.

					ipl@ KeIPLLower

					0 // kflags
					pfdbe@ // pfdbe
					IOCachePageWrite drop

					IPLDPC KeIPLRaise ipl!
				end
			end

			auto npfdbe
			pfdbe@ IOPageFrameEntryCache_Parent + // node
			ExSplayTreeNodeNext npfdbe!

			pfdbe@ IOPageFrameEntryCache_Parent + // node
			cacheblock@ IOCacheInfoBlock_SplayTreeRoot + // rootptr
			ExSplayTreeRemove

			pfdbe@ MmEvictablePageDelete

			pfdbe@ MmEvictablePageDereference drop

			npfdbe@ pfdbe!

			1 IOCachePagesUsed -=
		end elseif (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ maxpage@ ==)
			if (pfdbe@ MmPageFrameEntryEvictable_EvictionFlagsB + gb MMEVICTFLAG_VALID &)
				// zero out the end of the page

				pfdbe@ MmEvictablePageReference drop

				ipl@ KeIPLLower

				auto pageframe
				pfdbe@ MmPageFrameDatabase@ - MmPageFrameEntry_SIZEOF / PAGESHIFT << IDENTITYSPACE | pageframe!

				pageframe@ newsize@ PAGEOFFSETMASK & + // ptr
				PAGESIZE newsize@ PAGEOFFSETMASK & - // size
				0 // word
				memset

				pfdbe@ // pfdbe
				0 // process
				MmEvictablePageModify

				IPLDPC KeIPLRaise ipl!

				pfdbe@ MmEvictablePageDereference drop
			end

			pfdbe@ IOPageFrameEntryCache_Parent + // node
			ExSplayTreeNodeNext pfdbe!
		end else
			pfdbe@ IOPageFrameEntryCache_Parent + // node
			ExSplayTreeNodeNext pfdbe!
		end
	end

	ipl@ KeIPLLower

	HALCPUInterruptDisable rs!
	IOCACHEBLOCKFLAG_TRUNCATING ~ cacheblock@ IOCacheInfoBlock_Flags + &=
	rs@ HALCPUInterruptRestore

	cacheblock@ // cacheblock
	IOCacheInfoBlockUnlock
end

fn IOCacheInfoBlockDestroy { writeout cacheblock -- ok }
	// assumes caller made sure there's no way this cacheblock can be used by
	// anybody else.

	KeThreadCurrent@ KeThreadIgnoreKill drop

	0 // newsize
	writeout@ // writeout
	cacheblock@ // cacheblock
	IOCacheInfoBlockTruncate ok!

	if (ok@ ~~)
		cacheblock@ IOCacheInfoBlock_RwLock + ExRwLockUninitialize

		cacheblock@ MmFree
	end

	KeThreadCurrent@ KeThreadAcceptKill drop
end