//
// Implements MINTIA page cache management routines.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<ll>/OSDLL/OS.h"

fn IOCacheInfoBlockCreate { -- cacheblock ok }
	IOCacheInfoBlock_SIZEOF // bytes
	'Cach' // tag
	CANBLOCK POOLALLOC | // flags
	MmAllocWithTag ok! cacheblock!

	if (ok@)
		// allocation failed

		return
	end

	0 cacheblock@ IOCacheInfoBlock_PageReferences + !
	0 cacheblock@ IOCacheInfoBlock_DirtyPages + !
	0 cacheblock@ IOCacheInfoBlock_Flags + !

	"IOCacheInfoBlockRwLock" // name
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockInitialize

	auto buckets
	IOCACHEPAGEBUCKETS buckets!

	auto mutex
	cacheblock@ IOCacheInfoBlock_PageBucketMutexes + mutex!

	while (buckets@)
		"IOCacheInfoBucketMutex" // name
		KERNELMODE // mode
		mutex@ // mutex
		KeMutexInitialize

		KeMutex_SIZEOF mutex +=
		1 buckets -=
	end

	cacheblock@ IOCacheInfoBlock_PageBucketListHeads + // ptr
	IOCACHEPAGEBUCKETS 8 * // size
	0 // word
	memset
end

fn IOCacheInfoBlockLock { cacheblock -- ok }
	1 // alertable
	0 // nowait
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireExclusive ok!
end

fn IOCacheInfoBlockTryLock { cacheblock -- ok }
	0 // alertable
	1 // nowait
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireExclusive ok!

	if (ok@ 0 s<)
		0 ok!
	end
end

fn IOCacheInfoBlockLockShared { cacheblock -- ok }
	1 // alertable
	0 // nowait
	0 // canstarve
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireShared ok!
end

fn IOCacheInfoBlockTryLockShared { cacheblock -- ok }
	0 // alertable
	1 // nowait
	0 // canstarve
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockAcquireShared ok!

	if (ok@ 0 s<)
		0 ok!
	end
end

fn IOCacheInfoBlockUnlock { cacheblock -- }
	cacheblock@ IOCacheInfoBlock_RwLock + // rwlock
	ExRwLockRelease
end

fn IOCacheInfoBlockLockBucket { bucket cacheblock -- ok }
	if (DEBUGCHECKS)
		if (bucket@ IOCACHEPAGEBUCKETS >=)
			"IOCacheInfoBlockLockBucket: bucket >= IOCACHEPAGEBUCKETS\n" KeCrash
		end
	end

	KERNELMODE // waitmode
	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	cacheblock@ IOCacheInfoBlock_PageBucketMutexes + bucket@ KeMutex_SIZEOF * + // object
	KeThreadWaitForObject ok!
end

fn IOCacheInfoBlockTryLockBucket { bucket cacheblock -- locked }
	if (DEBUGCHECKS)
		if (bucket@ IOCACHEPAGEBUCKETS >=)
			"IOCacheInfoBlockLockBucket: bucket >= IOCACHEPAGEBUCKETS\n" KeCrash
		end
	end

	KERNELMODE // waitmode
	0 // alertable
	0 // timeout
	cacheblock@ IOCacheInfoBlock_PageBucketMutexes + bucket@ KeMutex_SIZEOF * + // object
	KeThreadWaitForObject locked!
end

fn IOCacheInfoBlockUnlockBucket { bucket cacheblock -- }
	if (DEBUGCHECKS)
		if (bucket@ IOCACHEPAGEBUCKETS >=)
			"IOCacheInfoBlockUnlockBucket: bucket >= IOCACHEPAGEBUCKETS\n" KeCrash
		end
	end

	0 // abandon
	cacheblock@ IOCacheInfoBlock_PageBucketMutexes + bucket@ KeMutex_SIZEOF * + // mutex
	KeMutexRelease drop
end

fn IOCacheInfoBlockReference { cacheblock -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	cacheblock@ IOCacheInfoBlock_PageReferences + @ oldcount!

	oldcount@ 1 + cacheblock@ IOCacheInfoBlock_PageReferences + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockTryReference { cacheblock -- oldcount ok }
	0 ok!

	auto rs
	HALCPUInterruptDisable rs!

	if (cacheblock@ IOCacheInfoBlock_Flags + @ IOCACHEBLOCKFLAG_TRUNCATING &)
		rs@ HALCPUInterruptRestore

		STATUS_TRY_AGAIN_LATER ok!

		return
	end

	cacheblock@ IOCacheInfoBlock_PageReferences + @ oldcount!

	oldcount@ 1 + cacheblock@ IOCacheInfoBlock_PageReferences + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockDereference { cacheblock -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	cacheblock@ IOCacheInfoBlock_PageReferences + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"IOCacheInfoBlockDereference: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - cacheblock@ IOCacheInfoBlock_PageReferences + !

	rs@ HALCPUInterruptRestore
end

fn IOCacheInfoBlockFlush { cacheblock -- ok }
	// flush all of the cacheblock's dirty pages.

	cacheblock@ // cacheblock
	IOCacheInfoBlockLock ok!

	if (ok@)
		return
	end

	// iterate each bucket from 0 to IOCACHEPAGEBUCKETS-1.
	// for each bucket, iterate all pages. if a page if dirty, write it
	// out to disk.

	// ensure thread can't receive signals while writing out dirty pages
	KeThreadCurrent@ KeThreadIgnoreKill drop

	auto i
	0 i!

	while (i@ IOCACHEPAGEBUCKETS <)
		auto buckethead
		cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + buckethead!

		auto pfdbe

		auto ipl
		IPLDPC KeIPLRaise ipl!

		// get the tail so that we can go backwards thru the bucket.
		// reason for this is that LRU -> MRU is the most likely
		// order to go "in order" on the disk surface
		buckethead@ 4 + @ pfdbe!

		while (pfdbe@)
			if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
				ipl@ KeIPLLower

				1 pfdbe@ IOCachePageWriteDirty drop

				IPLDPC KeIPLRaise ipl!

				pfdbe@ MmEvictablePageDereference drop
			end

			pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ pfdbe!
		end

		ipl@ KeIPLLower

		1 i +=
	end

	// allow thread to receive signals again
	KeThreadCurrent@ KeThreadAcceptKill drop

	cacheblock@ // cacheblock
	IOCacheInfoBlockUnlock
end

fn IOCacheInfoBlockTruncate { newsize writeout cacheblock -- ok }
	// attempt to evict all of the cacheblock's page frames beyond newsize.
	// also evicts the page that contains newsize, to prevent a weird
	// interaction with the dirty page writer.

	auto maxpage
	newsize@ PAGENUMBERMASK & maxpage!

	cacheblock@ // cacheblock
	IOCacheInfoBlockLock ok!

	if (ok@)
		return
	end

	auto rs
	HALCPUInterruptDisable rs!

	if (cacheblock@ IOCacheInfoBlock_DirtyPages + @ cacheblock@ IOCacheInfoBlock_PageReferences + @ ~=)
		// one or more page frames in this cache is currently in use.
		// don't allow truncation for now.

		if (DEBUGCHECKS)
			if (cacheblock@ IOCacheInfoBlock_PageReferences + @ cacheblock@ IOCacheInfoBlock_DirtyPages + @ <)
				"IOCacheInfoBlockTruncate: page references < dirty page count\n" KeCrash
			end
		end

		rs@ HALCPUInterruptRestore

		cacheblock@ IOCacheInfoBlockUnlock

		STATUS_TRY_AGAIN_LATER ok!

		return
	end

	IOCACHEBLOCKFLAG_TRUNCATING cacheblock@ IOCacheInfoBlock_Flags + |=

	rs@ HALCPUInterruptRestore

	if (DEBUGCHECKS)
		if (cacheblock@ IOCacheInfoBlock_PageReferences + @ cacheblock@ IOCacheInfoBlock_DirtyPages + @ ~=)
			// they should both either be zero (all dirty pages written out and zero other references),
			// or both be equal (only dirty pages, and writeout==0)

			cacheblock@ IOCacheInfoBlock_DirtyPages + @
			cacheblock@ IOCacheInfoBlock_PageReferences + @
			"IOCacheInfoBlockTruncate: page references (%d) != dirty page count (%d)\n" KeCrash
		end
	end

	// iterate each bucket from 0 to IOCACHEPAGEBUCKETS-1.
	// for each bucket, free all cached pages. if a page is dirty,
	// and caller wanted us to write out dirty pages (writeout==1),
	// write the page out first.

	// ensure thread can't receive signals while writing out dirty pages
	KeThreadCurrent@ KeThreadIgnoreKill drop

	auto i
	0 i!

	while (i@ IOCACHEPAGEBUCKETS <)
		auto buckethead
		cacheblock@ IOCacheInfoBlock_PageBucketListHeads + i@ 3 << + buckethead!

		auto pfdbe

		auto ipl
		IPLDPC KeIPLRaise ipl!

		// get the tail so that we can go backwards thru the bucket.
		// reason for this is that LRU -> MRU is the most likely
		// order to go "in order" on the disk surface
		buckethead@ 4 + @ pfdbe!

		while (pfdbe@)
			if (DEBUGCHECKS)
				if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
					if (pfdbe@ IOPageFrameEntryCache_References + @ 1 ~=)
						pfdbe@
						pfdbe@ IOPageFrameEntryCache_References + @
						"IOCacheInfoBlockTruncate: found page with strange refcount %d (0x%08x)\n" KeCrash
					end
				end elseif (pfdbe@ IOPageFrameEntryCache_References + @ 0 ~=)
					pfdbe@
					pfdbe@ IOPageFrameEntryCache_References + @
					"IOCacheInfoBlockTruncate: 2 found page with strange refcount %d (0x%08x)\n" KeCrash
				end
			end

			auto npfdbe

			// get this now, because who knows what will happen to it
			pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ npfdbe!

			if (pfdbe@ IOPageFrameEntryCache_OffsetInFile + @ maxpage@ >=)
				if (pfdbe@ IOPageFrameEntryCache_Flags + @ IOCACHEPAGEFLAG_DIRTY &)
					if (writeout@)
						// this is a dirty page, and caller wants us to
						// write them out to disk. the alternative is
						// writeout==0, which means the caller says its fine
						// to ignore and throw them out.

						ipl@ KeIPLLower

						1 pfdbe@ IOCachePageWriteDirty drop

						IPLDPC KeIPLRaise ipl!
					end else
						// this is a dirty page and the caller doesn't want
						// us to write it to disk, so we need to clean it up
						// ourselves by decrementing this cacheblock's
						// dirty page count and removing it from the
						// dirty list.

						pfdbe@ IOCachePageDirtyCleanup drop
					end

					pfdbe@ MmEvictablePageDereference drop
				end

				if (DEBUGCHECKS)
					if (pfdbe@ IOPageFrameEntryCache_References + @)
						"IOCacheInfoBlockTruncate: page acquired references\n" KeCrash
					end
				end

				pfdbe@ MmEvictablePageRemoveForDeletion

				pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ npfdbe!

				pfdbe@ // pfdbe
				buckethead@ // buckethead
				IOCachePageRemove

				pfdbe@ IOPageFrameEntryCache_PFN + @ MmPageFree

				npfdbe@ pfdbe!

				1 IOCachePagesUsed -=
			end else
				pfdbe@ IOPageFrameEntryCache_PrevCachePage + @ pfdbe!
			end
		end

		ipl@ KeIPLLower

		1 i +=
	end

	HALCPUInterruptDisable rs!
	IOCACHEBLOCKFLAG_TRUNCATING ~ cacheblock@ IOCacheInfoBlock_Flags + &=
	rs@ HALCPUInterruptRestore

	// allow thread to receive signals again
	KeThreadCurrent@ KeThreadAcceptKill drop

	cacheblock@ // cacheblock
	IOCacheInfoBlockUnlock
end

fn IOCacheInfoBlockZeroEnd { pfdbe offset fcb -- }
	KeThreadCurrent@ KeThreadIgnoreKill drop

	auto pageframe
	auto ok

	if (pfdbe@ ~~)
		0 // flags
		IOKFLAG_URGENT // kflags
		offset@ // offset
		fcb@ // fcb
		IOCachePageRead ok! pfdbe! pageframe!

		if (ok@)
			ok@ "IOCacheInfoBlockZeroEnd: failed to read page (%i)\n" KeCrash
		end
	end else
		pfdbe@ IOPageFrameEntryCache_PFN + @ PAGESHIFT << IDENTITYSPACE | pageframe!
	end

	pageframe@ offset@ PAGEOFFSETMASK & + // ptr
	PAGESIZE offset@ PAGEOFFSETMASK & - // size
	0 // word
	memset

	fcb@ IOFileControlBlock_SizeInBytes + @ // extent
	pfdbe@ // pfdbe
	IOCachePageDirtyFunction ok!

	if (DEBUGCHECKS)
		if (ok@)
			ok@ "IOCacheInfoBlockZeroEnd: failed to dirty page (%i)\n" KeCrash
		end
	end

	KeThreadCurrent@ KeThreadAcceptKill drop
end

fn IOCacheInfoBlockDestroy { writeout cacheblock -- ok }
	// assumes caller made sure there's no way this cacheblock can be used by
	// anybody else.

	KeThreadCurrent@ KeThreadIgnoreKill drop

	0 // newsize
	writeout@ // writeout
	cacheblock@ // cacheblock
	IOCacheInfoBlockTruncate ok!

	if (ok@ 0 ==)
		cacheblock@ MmFree
	end

	KeThreadCurrent@ KeThreadAcceptKill drop
end