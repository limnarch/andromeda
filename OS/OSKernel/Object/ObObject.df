//
// Implements executive object management routines.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Object.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn ObObjectClose { handle -- ok }
	fnsection "PAGE$text"

	handle@
	KeProcessCurrent
	ObObjectCloseProcess ok!
end

fn ObObjectCloseProcess { handle process -- ok }
	fnsection "PAGE$text"

	auto handletable
	process@ PsProcess_PagedArea + @ PsProcessPaged_HandleTable + @ handletable!

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"ObObjectCloseProcess: ipl != IPLLOW\n" KeCrash
		end

		if (handletable@ ~~)
			"ObObjectCloseProcess: process has no handle table\n" KeCrash
		end
	end

	OSHANDLEBITS handle >>=

	auto object
	auto entryptr

	handletable@ ExHandleTableLock ok!

	if (ok@)
		return
	end

	handle@ // handle
	handletable@ // handletable
	1 // locked
	ExHandleDelete ok! object! entryptr!

	if (ok@)
		handletable@ ExHandleTableUnlock

		return
	end

	if (DEBUGCHECKS)
		if (object@ ~~)
			"ObObjectCloseProcess: object was null\n" KeCrash
		end
	end

	auto access
	entryptr@ ObObjectTableEntry_Access + @ access!

	// object directory race condition avoided because other threads in this
	// process can no longer access this handle. unlocking is safe.
	handletable@ ExHandleTableUnlock

	object@ ObObjectHandleCountDecrement drop

	auto type
	object@ ObObjectType type!

	if (type@)
		auto closefunc
		type@ ObType_CloseFunction + @ closefunc!

		if (closefunc@)
			access@ // access
			object@ // object
			process@ // process
			closefunc@ ObTypeCloseFunction
		end
	end

	object@ ObObjectDereferenceByPointer drop
end

fn ObObjectUncharge { object -- }
	fnsection "PAGE$text"

	auto npheader
	object@ ObObjectNonpagedHeader npheader!

	auto quotablock
	npheader@ ObNonpagedHeader_QuotaBlock + @ quotablock!

	if (DEBUGCHECKS)
		if (quotablock@ ~~)
			"ObObjectUncharge: no quotablock\n" KeCrash
		end
	end

	0 npheader@ ObNonpagedHeader_QuotaBlock + !

	auto pheader
	object@ ObObjectPagedHeader pheader!

	pheader@ ObPagedHeader_PagedQuotaCharge + @ // charge
	quotablock@ // quotablock
	MmQuotaBlockUnchargePaged

	pheader@ ObPagedHeader_NonpagedQuotaCharge + @ // charge
	quotablock@ // quotablock
	MmQuotaBlockUncharge

	quotablock@ MmQuotaBlockDereference
end

fn ObObjectOpen { nocheck access object -- handle ok }
	fnsection "PAGE$text"

	nocheck@ // nocheck
	access@ // access
	object@ // object
	KeProcessCurrent // process
	ObObjectOpenProcess ok! handle!
end

fn ObObjectOpenProcess { nocheck access object process -- handle ok }
	auto handletable
	process@ PsProcess_PagedArea + @ PsProcessPaged_HandleTable + @ handletable!

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"ObObjectOpenProcess: ipl != IPLLOW\n" KeCrash
		end

		if (handletable@ ~~)
			"ObObjectOpenProcess: process has no handle table\n" KeCrash
		end
	end

	auto npheader
	object@ ObObjectNonpagedHeader npheader!

	auto pheader
	object@ ObObjectPagedHeader pheader!

	auto type
	npheader@ ObNonpagedHeader_TypeObject + @ type!

	auto flags
	pheader@ ObPagedHeader_Flags + @ flags!

	auto quotablock
	process@ PsProcess_PagedArea + @ PsProcessPaged_QuotaBlock + @ quotablock!

	auto pcharge
	auto npcharge

	if (npheader@ ObNonpagedHeader_QuotaBlock + @ ~~)
		pheader@ ObPagedHeader_PagedQuotaCharge + @ pcharge!
		pheader@ ObPagedHeader_NonpagedQuotaCharge + @ npcharge!

		auto ipl
		IPLDPC KeIPLRaise ipl!

		if (npheader@ ObNonpagedHeader_QuotaBlock + @ ~~)
			if (flags@ OBFLAGS_PERMANENT & ~~)
				// no quotablock and object isnt permanent; claim quota for
				// current process

				pcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockChargePaged ok!

				if (ok@)
					ipl@ KeIPLLower

					return
				end

				npcharge@ // charge
				quotablock@ // quotablock
				MmQuotaBlockCharge ok!

				if (ok@)
					pcharge@ // charge
					quotablock@ // quotablock
					MmQuotaBlockUnchargePaged

					ipl@ KeIPLLower

					return
				end

				quotablock@ MmQuotaBlockReference

				quotablock@ npheader@ ObNonpagedHeader_QuotaBlock + !
			end else
				0 quotablock!
			end
		end else
			0 quotablock!
		end

		ipl@ KeIPLLower
	end else
		0 quotablock!
	end

	handletable@ ExHandleTableLock ok!

	if (ok@)
		if (quotablock@)
			object@ ObObjectUncharge
		end

		return
	end

	if (nocheck@ ~~)
		access@ // access
		object@ // object
		KeProcessCurrent // process
		SeCheckAccessObjectUserX ok!

		if (ok@)
			if (quotablock@)
				object@ ObObjectUncharge
			end

			handletable@ ExHandleTableUnlock

			return
		end
	end

	auto entryptr

	object@ // entryvalue
	handletable@ // handletable
	1 // locked
	ExHandleCreate ok! entryptr! handle!

	if (ok@)
		if (quotablock@)
			object@ ObObjectUncharge
		end

		handletable@ ExHandleTableUnlock

		return
	end

	access@ entryptr@ ObObjectTableEntry_Access + !

	if (type@)
		auto openfunc
		type@ ObType_OpenFunction + @ openfunc!

		if (openfunc@)
			access@ // access
			object@ // object
			process@ // process
			openfunc@ ObTypeOpenFunction ok!

			if (ok@)
				if (quotablock@)
					object@ ObObjectUncharge
				end

				handle@ // handle
				handletable@ // handletable
				1 // locked
				ExHandleDelete access! drop drop

				if (DEBUGCHECKS)
					if (access@)
						"ObObjectOpenProcess: failed to delete handle\n" KeCrash
					end
				end

				handletable@ ExHandleTableUnlock

				return
			end
		end
	end

	object@ ObObjectHandleCountIncrement drop

	handletable@ ExHandleTableUnlock

	OSHANDLEBITS handle <<=
end

fn ObObjectReferenceByHandle { type handle -- access object ok }
	fnsection "PAGE$text"

	if (handle@ OSCURRENTPROCESS ==)
		if (type@)
			if (type@ PsProcessObjectType@ ~=)
				STATUS_INVALID_OBJECT_TYPE ok!

				return
			end
		end

		0 ok!

		KeProcessCurrent object!
		ACCESS_ALL access!
		object@ ObObjectReferenceByPointer drop
		return
	end elseif (handle@ OSCURRENTTHREAD ==)
		if (type@)
			if (type@ PsThreadObjectType@ ~=)
				STATUS_INVALID_OBJECT_TYPE ok!

				return
			end
		end

		0 ok!

		KeThreadCurrent@ object!
		ACCESS_ALL access!
		object@ ObObjectReferenceByPointer drop
		return
	end

	type@
	handle@
	KeProcessCurrent
	ObObjectReferenceByHandleProcess ok! object! access!
end

fn ObObjectReferenceByHandleProcess { type handle process -- access object ok }
	fnsection "PAGE$text"

	auto handletable
	process@ PsProcess_PagedArea + @ PsProcessPaged_HandleTable + @ handletable!

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLLOW ~=)
			"ObObjectReferenceByHandleProcess: ipl != IPLLOW\n" KeCrash
		end

		if (handletable@ ~~)
			"ObObjectReferenceByHandleProcess: process has no handle table\n" KeCrash
		end
	end

	OSHANDLEBITS handle >>=

	handletable@ ExHandleTableLockShared ok!

	if (ok@)
		return
	end

	auto entryptr

	handle@ // handle
	handletable@ // handletable
	1 // locked
	ExHandleLookup ok! entryptr!

	if (ok@)
		handletable@ ExHandleTableUnlock

		return
	end

	entryptr@ ObObjectTableEntry_Object + @ object!
	entryptr@ ObObjectTableEntry_Access + @ access!

	if (type@)
		if (object@ ObObjectType type@ ~=)
			handletable@ ExHandleTableUnlock

			STATUS_INVALID_OBJECT_TYPE ok!

			return
		end
	end

	object@ ObObjectReferenceByPointer drop

	handletable@ ExHandleTableUnlock
end

fn ObObjectHandleCountIncrement { object -- oldcount }
	auto npheader
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_NonpagedHeader + @ npheader!

	auto rs
	HALCPUInterruptDisable rs!

	npheader@ ObNonpagedHeader_HandleCount + @ oldcount!

	oldcount@ 1 + npheader@ ObNonpagedHeader_HandleCount + !

	rs@ HALCPUInterruptRestore
end

fn ObObjectHandleCountDecrement { object -- oldcount }
	auto npheader
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_NonpagedHeader + @ npheader!

	auto rs
	HALCPUInterruptDisable rs!

	npheader@ ObNonpagedHeader_HandleCount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"ObObjectHandleCountDecrement: attempt to decrement below 0\n" KeCrash
		end

		// if (oldcount@ object@ ObHeader_PointerCount + @ ==)
		// 	"ObObjectHandleCountDecrement: attempt to decrement below pointer count\n" KeCrash
		// end
	end

	oldcount@ 1 - npheader@ ObNonpagedHeader_HandleCount + !

	rs@ HALCPUInterruptRestore

	if (oldcount@ 1 ==)
		if (object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ ObPagedHeader_DirectoryObject + @)
			0 ObRootDirectoryLock drop

			// locking the root directory successfully serializes this case
			// because it is also acquired during any attempt to open an
			// object via namespace path, which is the ONLY time the object
			// can be acquired by name.

			// test the handle count again to make sure it's still 0.

			if (npheader@ ObNonpagedHeader_HandleCount + @ 0 ==)
				if (object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ ObPagedHeader_DirectoryObject + @)
					if (object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ ObPagedHeader_Flags + @ OBFLAGS_PERMANENT & ~~)
						1 // locked
						object@ // object
						ObDirectoryRemoveByPointer drop
					end
				end
			end

			ObRootDirectoryUnlock
		end
	end
end

fn ObObjectReferenceByPointerCapturedHeader { npheader -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	npheader@ ObNonpagedHeader_PointerCount + @ oldcount!

	oldcount@ 1 + npheader@ ObNonpagedHeader_PointerCount + !

	rs@ HALCPUInterruptRestore
end

fn ObObjectReferenceByPointer { object -- oldcount }
	auto npheader
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_NonpagedHeader + @ npheader!

	auto rs
	HALCPUInterruptDisable rs!

	npheader@ ObNonpagedHeader_PointerCount + @ oldcount!

	oldcount@ 1 + npheader@ ObNonpagedHeader_PointerCount + !

	rs@ HALCPUInterruptRestore
end

fn ObObjectDereferenceByPointer { object -- oldcount }
	auto npheader
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_NonpagedHeader + @ npheader!

	auto rs
	HALCPUInterruptDisable rs!

	npheader@ ObNonpagedHeader_PointerCount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"ObObjectDereferenceByPointer: underflow\n" KeCrash
		end

		// if (oldcount@ 1 - object@ ObHeader_HandleCount + @ <)
		// 	"ObObjectDereferenceByPointer: pointer count < handle count\n" KeCrash
		// end
	end

	oldcount@ 1 - npheader@ ObNonpagedHeader_PointerCount + !

	// the following comment applied to a field that no longer exists. the
	// current check involves just checking if the PointerCount is 0.
	//
	// atomically mark the object deleted -- this is useful for locking
	// out auxiliary methods of acquiring an object pointer i.e. taking a
	// process object by its PID. these aren't dangerous because the
	// assumption is that the object type's deletion routine will
	// eliminate that method of acquisition, i.e. delete the PID,
	// between now and the object's final deallocation. whatever routine
	// performs this acquisition needs to check this value BEFORE it
	// references the object by pointer, otherwise everything will
	// explode. locking considerations can be complex.

	rs@ HALCPUInterruptRestore

	auto ok

	if (oldcount@ 1 ==)
		// just decremented the pointer count to zero. delete the object

		if (DEBUGCHECKS)
			if (object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ ObPagedHeader_DirectoryObject + @)
				"ObObjectDereferenceByPointer: object was still linked into a directory\n" KeCrash
			end
		end

		if (KeIPLCurrentGet IPLLOW ==)
			// delete immediately

			// make sure to ignore weird wait effects etc due to having been
			// nuked. these are undesirable while doing something like
			// cleaning up a dead object.
			KeThreadCurrent@ KeThreadIgnoreKill drop

			object@ ObObjectFree ok!

			if (DEBUGCHECKS)
				if (ok@)
					"ObObjectDereferenceByPointer: failed to free object\n" KeCrash
				end
			end

			KeThreadCurrent@ KeThreadAcceptKill drop
		end else
			// can't delete objects at >=IPLAPC, queue a work item

			"ObObjectDereferenceByPointer: work items NYI\n" KeCrash
		end
	end
end

fn ObObjectNonpagedHeader { object -- npheader }
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_NonpagedHeader + @ npheader!
end

fn ObObjectPagedHeader { object -- pheader }
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ pheader!
end

fn ObObjectName { object -- name }
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_Name + @ name!
end

fn ObObjectType { object -- type }
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_NonpagedHeader + @ ObNonpagedHeader_TypeObject + @ type!
end

fn ObObjectQueryObject { object query -- ok }
	fnsection "PAGE$text"

	0 ok!

	query@ // ptr
	OSObjectQuery_SIZEOF // size
	0 // word
	memset

	ObCommonHeader_SIZEOF object -=

	auto npheader
	object@ ObCommonHeader_NonpagedHeader + @ npheader!

	auto pheader
	object@ ObCommonHeader_PagedHeader + @ pheader!

	auto typeobj
	npheader@ ObNonpagedHeader_TypeObject + @ typeobj!

	auto name
	0 name!

	if (typeobj@)
		typeobj@ ObCommonHeader_SIZEOF - ObCommonHeader_Name + @ name!
	end

	if (name@)
		query@ OSObjectQuery_TypeName + // dest
		name@ // src
		strcpy
 	end else
		0 query@ OSObjectQuery_TypeName + sb
	end

	object@ ObCommonHeader_Name + @ name!

	if (name@)
		query@ OSObjectQuery_Name + // dest
		name@ // src
		strcpy
	end else
		0 query@ OSObjectQuery_Name + sb
	end

	npheader@ ObNonpagedHeader_HandleCount + @ query@ OSObjectQuery_HandleCount + !
	npheader@ ObNonpagedHeader_PointerCount + @ query@ OSObjectQuery_PointerCount + !

	pheader@ ObPagedHeader_Permissions + @ query@ OSObjectQuery_Permissions + !

	pheader@ ObPagedHeader_UID + @ query@ OSObjectQuery_UID + !
	pheader@ ObPagedHeader_GID + @ query@ OSObjectQuery_GID + !
end

fn ObObjectQuery { objecthandle query -- ok }
	fnsection "PAGE$text"

	auto object

	0 // type
	objecthandle@ // handle
	ObObjectReferenceByHandle ok! object! drop

	if (ok@)
		return
	end

	object@ // object
	query@ // query
	ObObjectQueryObject ok!

	object@ ObObjectDereferenceByPointer drop
end

fn ObObjectSetUID { uid object -- }
	auto pheader
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ pheader!

	uid@ pheader@ ObPagedHeader_UID + !
end

fn ObObjectSetGID { gid object -- }
	auto pheader
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ pheader!

	gid@ pheader@ ObPagedHeader_GID + !
end

fn ObSetSecurityObject { uid gid permissions object -- ok }
	fnsection "PAGE$text"

	auto typeobj
	object@ ObObjectType typeobj!

	auto pheader
	object@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ pheader!

	if (typeobj@ ObType_SetSecurityFunction + @)
		uid@ ACCESS_SET_ONLY_EID ~ & // uid
		gid@ ACCESS_SET_ONLY_EID ~ & // gid
		permissions@ // permissions
		object@ // object
		typeobj@ ObType_SetSecurityFunction + @ ObTypeSetSecurityFunction ok!

		if (ok@)
			return
		end
	end

	if (uid@ -1 ~=)
		if (uid@ ACCESS_SET_ONLY_EID & ~~)
			uid@ pheader@ ObPagedHeader_UID + !
		end
	end

	if (gid@ -1 ~=)
		if (gid@ ACCESS_SET_ONLY_EID & ~~)
			gid@ pheader@ ObPagedHeader_GID + !
		end
	end

	if (permissions@ -1 ~=)
		permissions@ pheader@ ObPagedHeader_Permissions + !
	end

	0 ok!
end

fn ObSetSecurity { uid gid permissions handle -- ok }
	fnsection "PAGE$text"

	if (permissions@ -1 ~=)
		ACCESS_ALL_ALL permissions &=
	end

	auto notadmin
	SeAmIAdmin notadmin!

	if (notadmin@)
		// not an admin

		auto process
		KeProcessCurrent process!

		if (uid@ -1 ~=)
			// changing UID
			if (process@ PsProcess_PagedArea + @ PsProcessPaged_UID + @ uid@ ~=)
				// not setting to the same UID, forbidden
				STATUS_FORBIDDEN_OPERATION ok!
				return
			end
		end

		if (gid@ -1 ~=)
			// changing GID
			if (process@ PsProcess_PagedArea + @ PsProcessPaged_GID + @ gid@ ~=)
				// not setting to the same GID, forbidden
				STATUS_FORBIDDEN_OPERATION ok!
				return
			end
		end
	end

	auto object
	auto access

	0 // type
	handle@ // handle
	ObObjectReferenceByHandle ok! object! access!

	if (ok@)
		return
	end

	if (notadmin@)
		if (object@ ObObjectPagedHeader ObPagedHeader_UID + @
			process@ PsProcess_PagedArea + @ PsProcessPaged_UID + @ ~=)
			// not the owner of the object, forbidden
			
			object@ ObObjectDereferenceByPointer drop

			STATUS_PERMISSION_DENIED ok!

			return
		end
	end

	uid@ // uid
	gid@ // gid
	permissions@ // permissions
	object@ // object
	ObSetSecurityObject ok!

	object@ ObObjectDereferenceByPointer drop
end