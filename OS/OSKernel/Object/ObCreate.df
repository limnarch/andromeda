//
// Implements executive object creation.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Object.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

externptr ObFullyNonpagedObjects

fn ObObjectCreate { name flags permissions quotabias bodysize type -- object ok }
	0 ok!

	auto tag
	auto paged

	if (type@)
		type@ ObType_Tag + @ tag!
		type@ ObType_Paged + @ paged!
	end else
		'Objt' tag!
		0 paged!
	end

	auto pheader
	auto npheader
	auto cheader
	auto obname

	auto npcharge
	auto pcharge

	auto namelen

	if (name@)
		name@ strlen namelen!
		namelen@ 1 + 3 + 3 ~ & namelen!
	end else
		0 namelen!
	end

	// see Object.h for an explanation on these structures.

	if (ObFullyNonpagedObjects@)
		ObNonpagedHeader_SIZEOF
		ObPagedHeader_SIZEOF +
		namelen@ +
		ObCommonHeader_SIZEOF +
		bodysize@ + // bytes

		tag@ // tag
		CANBLOCK // flags
		MmAllocWithTag ok! npheader!

		if (ok@)
			return
		end

		npheader@ ObNonpagedHeader_SIZEOF + pheader!
		pheader@ ObPagedHeader_SIZEOF + obname!
		obname@ namelen@ + cheader!
		cheader@ ObCommonHeader_SIZEOF + object!

		npheader@ MmBlockChargeGet npcharge!

		0 pcharge!
	end elseif (paged@)
		ObPagedHeader_SIZEOF
		namelen@ +
		ObCommonHeader_SIZEOF +
		bodysize@ + // bytes

		tag@ // tag
		PAGED // flags
		MmAllocWithTag ok! pheader!

		if (ok@)
			return
		end

		pheader@ ObPagedHeader_SIZEOF + obname!
		obname@ namelen@ + cheader!
		cheader@ ObCommonHeader_SIZEOF + object!

		ObNonpagedHeader_SIZEOF // bytes
		'ObNH' // tag
		CANBLOCK // flags
		MmAllocWithTag ok! npheader!

		if (ok@)
			pheader@ MmFree

			return
		end

		npheader@ MmBlockChargeGet npcharge!
		pheader@ MmBlockChargeGet pcharge!
	end else
		ObNonpagedHeader_SIZEOF
		namelen@ +
		ObCommonHeader_SIZEOF +
		bodysize@ + // bytes

		tag@ // tag
		CANBLOCK // flags
		MmAllocWithTag ok! npheader!

		if (ok@)
			return
		end

		npheader@ ObNonpagedHeader_SIZEOF + obname!
		obname@ namelen@ + cheader!
		cheader@ ObCommonHeader_SIZEOF + object!

		ObPagedHeader_SIZEOF // bytes
		'ObPH' // tag
		CANBLOCK // flags
		MmAllocWithTag ok! pheader!

		if (ok@)
			npheader@ MmFree

			return
		end

		npheader@ MmBlockChargeGet npcharge!
		pheader@ MmBlockChargeGet pcharge!
	end

	if (name@ ~~)
		0 obname!
	end else
		obname@ // dest
		name@ // src
		strcpy
	end

	pheader@ cheader@ ObCommonHeader_PagedHeader + !
	npheader@ cheader@ ObCommonHeader_NonpagedHeader + !
	obname@ cheader@ ObCommonHeader_Name + !

	type@ npheader@ ObNonpagedHeader_TypeObject + !
	0 npheader@ ObNonpagedHeader_HandleCount + !
	1 npheader@ ObNonpagedHeader_PointerCount + !
	0 npheader@ ObNonpagedHeader_QuotaBlock + !

	0 pheader@ ObPagedHeader_TypeListNext + !
	0 pheader@ ObPagedHeader_TypeListPrev + !

	0 pheader@ ObPagedHeader_DirectoryListNext + !
	0 pheader@ ObPagedHeader_DirectoryListPrev + !
	0 pheader@ ObPagedHeader_DirectoryObject + !

	flags@ pheader@ ObPagedHeader_Flags + !

	auto h
	KeProcessCurrent h!

	h@ PsProcess_UID + @ pheader@ ObPagedHeader_UID + !
	h@ PsProcess_GID + @ pheader@ ObPagedHeader_GID + !
	permissions@ pheader@ ObPagedHeader_Permissions + !

	pcharge@ pheader@ ObPagedHeader_PagedQuotaCharge + !
	npcharge@ pheader@ ObPagedHeader_NonpagedQuotaCharge + !

	if (type@)
		type@ ObTypeLock

		type@ ObType_ObjectListHead + @ h!

		if (h@)
			h@ pheader@ ObPagedHeader_TypeListNext + !
			object@ h@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ ObPagedHeader_TypeListPrev + !
		end

		object@ type@ ObType_ObjectListHead + !

		type@ ObTypeUnlock
	end
end

fn ObObjectFree { object -- ok }
	0 ok!

	ObCommonHeader_SIZEOF object -=

	if (DEBUGCHECKS)
		if (object@ ObCommonHeader_PagedHeader + @ ObPagedHeader_Flags + @ OBFLAGS_PERMANENT &)
			"ObObjectFree: attempt to free PERMANENT object\n" KeCrash
		end

		if (object@ ObCommonHeader_NonpagedHeader + @ ObNonpagedHeader_HandleCount + @)
			"ObObjectFree: attempt to free object with nonzero handle count\n" KeCrash
		end

		if (object@ ObCommonHeader_NonpagedHeader + @ ObNonpagedHeader_PointerCount + @)
			"ObObjectFree: attempt to free object with nonzero pointer count\n" KeCrash
		end
	end

	auto type
	object@ ObCommonHeader_NonpagedHeader + @ ObNonpagedHeader_TypeObject + @ type!

	ObCommonHeader_SIZEOF object +=

	if (type@)
		auto deletefunc

		type@ ObType_DeleteFunction + @ deletefunc!

		if (deletefunc@)
			object@ deletefunc@ ObTypeDeleteFunction
		end
	end

	object@ ObObjectDeallocate
end

fn ObObjectDeallocate { object -- }
	ObCommonHeader_SIZEOF object -=

	auto npheader
	object@ ObCommonHeader_NonpagedHeader + @ npheader!

	auto pheader
	object@ ObCommonHeader_PagedHeader + @ pheader!

	auto type
	object@ ObCommonHeader_NonpagedHeader + @ ObNonpagedHeader_TypeObject + @ type!

	if (type@)
		// remove from type list

		type@ ObTypeLock

		auto n
		pheader@ ObPagedHeader_TypeListNext + @ n!

		auto l
		pheader@ ObPagedHeader_TypeListPrev + @ l!

		if (n@)
			l@ n@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ ObPagedHeader_TypeListPrev + !
		end

		if (l@)
			n@ l@ ObCommonHeader_SIZEOF - ObCommonHeader_PagedHeader + @ ObPagedHeader_TypeListNext + !
		end else
			// no prev means we were the listhead

			n@ type@ ObType_ObjectListHead + !
		end

		type@ ObTypeUnlock
	end

	auto quotablock
	npheader@ ObNonpagedHeader_QuotaBlock + @ quotablock!

	auto pcharge
	pheader@ ObPagedHeader_PagedQuotaCharge + @ pcharge!

	auto npcharge
	pheader@ ObPagedHeader_NonpagedQuotaCharge + @ npcharge!

	pheader@ MmFree
	npheader@ MmFree

	if (quotablock@)
		npcharge@ // charge
		quotablock@ // quotablock
		MmQuotaBlockUncharge

		pcharge@ // charge
		quotablock@ // quotablock
		MmQuotaBlockUnchargePaged

		quotablock@ MmQuotaBlockDereference
	end
end

fn ObTypeInitializerInitialize { initializer -- }
	// initialize the initializer.
	// yeah.

	initializer@ // ptr
	ObTypeInitializer_SIZEOF // size
	0 // word
	memset

	-1 initializer@ ObTypeInitializer_WaitOffset + !
end

fn ObTypeCreate { initializer -- type ok }
	auto typetype
	ObTypeObjectType@ typetype!

	initializer@ ObTypeInitializer_Name + @ // name
	OBFLAGS_PERMANENT // flags
	ACCESS_OWNER_ALL ACCESS_GROUP_ALL | // permissions
	0 // quotabias
	initializer@ ObTypeInitializer_BodySize + @ ObType_SIZEOF + // bodysize
	typetype@ // type
	ObObjectCreate ok! type!

	if (ok@)
		return
	end

	initializer@ ObTypeInitializer_Tag + @ type@ ObType_Tag + !

	// initialize function fields
	initializer@ ObTypeInitializer_OpenFunction + @ type@ ObType_OpenFunction + !
	initializer@ ObTypeInitializer_CloseFunction + @ type@ ObType_CloseFunction + !
	initializer@ ObTypeInitializer_DeleteFunction + @ type@ ObType_DeleteFunction + !
	initializer@ ObTypeInitializer_ParseFunction + @ type@ ObType_ParseFunction + !
	initializer@ ObTypeInitializer_SetSecurityFunction + @ type@ ObType_SetSecurityFunction + !

	initializer@ ObTypeInitializer_Paged + @ type@ ObType_Paged + !
	initializer@ ObTypeInitializer_WaitOffset + @ type@ ObType_WaitOffset + !

	0 type@ ObType_ObjectListHead + !

	"ObTypeMutex" // name
	KERNELMODE // mode
	type@ ObType_Mutex + // mutex
	KeMutexInitialize

	if (typetype@ ~~)
		type@ ObTypeObjectType!
		type@ type@ ObType_ObjectListHead + !

		type@ type@ ObCommonHeader_SIZEOF - ObCommonHeader_NonpagedHeader + @ ObNonpagedHeader_TypeObject + !
	end elseif (ObObjectTypesDirectoryObject@)
		type@ // object
		ObObjectTypesDirectoryObject@ // directory
		ObDirectoryInsertByPointers ok!

		if (ok@)
			ok@ type@ ObCommonHeader_SIZEOF - ObCommonHeader_Name + @ "ObTypeCreate: couldn't insert type '%s' into /ObjectTypes (%i)\n" KeCrash
		end
	end
end

fn ObTypeLock { type -- }
	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	type@ ObType_Mutex + // object
	KeThreadWaitForObject drop
end

fn ObTypeUnlock { type -- }
	0 // abandon
	type@ ObType_Mutex + // mutex
	KeMutexRelease drop
end