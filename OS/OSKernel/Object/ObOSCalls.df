//
// Implements the system calls for the object manager subsystem.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Object.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

fn OSObjectOpen { flags access initialobjecthandle path -- handle ok }
	auto kpath

	OSFILEPATHMAX // max
	path@ // string
	ExCallGetString ok! kpath!

	if (ok@)
		return
	end

	flags@ // flags
	access@ // access
	initialobjecthandle@ // initialobjecthandle
	kpath@ // path
	ObObjectOpenByPath ok! handle!

	kpath@ ExCallFreeString
end

fn OSQuery { handle query -- ok }
	auto kquery
	OSObjectQuery_SIZEOF alloc kquery!

	kquery@ // ptr
	OSObjectQuery_SIZEOF // size
	0 // word
	memset

	handle@ // objecthandle
	kquery@ // query
	ObObjectQuery ok!

	if (ok@)
		return
	end

	query@ // dest
	kquery@ // src
	OSObjectQuery_SIZEOF // size
	KeSafeCopyOut ok!
end

fn OSClose { handle -- ok }
	handle@ ObObjectClose ok!
end

fn OSWaitForMultipleObjects { alertable waittype timeout objectcount objecthandletable -- ok }
	auto ktable

	objectcount@ 4 * MmQuotaChargeBuffer ok!

	if (ok@)
		return
	end

	objectcount@ 4 * // bytes
	'ObWK' // tag
	0 // flags
	MmAllocWithTag ok! ktable!

	if (ok@)
		objectcount@ 4 * MmQuotaUnchargeBuffer
		return
	end

	ktable@ // dest
	objecthandletable@ // src
	objectcount@ 4 * // size
	KeSafeCopyIn ok!

	if (ok@)
		ktable@ MmFree
		objectcount@ 4 * MmQuotaUnchargeBuffer
		return
	end

	alertable@ // alertable
	waittype@ // waittype
	timeout@ // timeout
	objectcount@ // objectcount
	ktable@ // objecthandletable
	ObWaitForMultipleObjects ok!

	ktable@ MmFree
	objectcount@ 4 * MmQuotaUnchargeBuffer
end

fn OSWaitForObject { alertable timeout objecthandle -- ok }
	alertable@ timeout@ objecthandle@ ObWaitForObject ok!
end

fn OSHandleDuplicate { handle access srcprocesshandle destprocesshandle -- newhandle ok }
	handle@ access@ srcprocesshandle@ destprocesshandle@ ObHandleDuplicate ok! newhandle!
end

fn OSDirectoryCountQuery { directoryhandle -- count ok }
	directoryhandle@ ObDirectoryCountQuery ok! count!
end

fn OSDirectoryQueryAll { buffer maxquery directoryhandle -- count ok }
	// this is dumb because we're using the handle twice instead of just once
	// which is slower, but we must tolerate it because the alternative is
	// uglier and more effort and this won't get called with extreme frequency
	// since it is slow by nature anyway.

	auto maxcount
	directoryhandle@ ObDirectoryCountQuery ok! maxcount!

	if (ok@)
		return
	end

	maxcount@ maxquery@ min maxquery!

	maxquery@ OSObjectQuery_SIZEOF * MmQuotaChargeBuffer ok!

	if (ok@)
		return
	end

	auto kbuffer
	maxquery@ OSObjectQuery_SIZEOF * // bytes
	'ObQa' // tag
	0 // flags
	MmAllocWithTag ok! kbuffer!

	if (ok@)
		maxquery@ OSObjectQuery_SIZEOF * MmQuotaUnchargeBuffer
		return
	end

	kbuffer@ // buffer
	maxquery@ // maxquery
	directoryhandle@ // directoryhandle
	ObDirectoryQueryAll ok! count!

	if (ok@)
		kbuffer@ MmFree
		maxquery@ OSObjectQuery_SIZEOF * MmQuotaUnchargeBuffer
		return
	end

	buffer@ // dest
	kbuffer@ // src
	maxquery@ OSObjectQuery_SIZEOF * // size
	KeSafeCopyOut ok!

	kbuffer@ MmFree
	maxquery@ OSObjectQuery_SIZEOF * MmQuotaUnchargeBuffer
end

fn OSSetSecurity { uid gid permissions handle -- ok }
	uid@ gid@ permissions@ handle@ ObSetSecurity ok!
end