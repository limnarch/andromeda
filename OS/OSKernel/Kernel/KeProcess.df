//
// Implements the kernel process object.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"

#include "<inc>/Kernel.h"

#include "<ll>/OSDLL/OS.h"

var KeProcessListHead 0
public KeProcessListHead

fn KeProcessInitialize { name asid parentprocess process -- }
	process@ KeProcess_Name + name@ KEPROCESSNAMELEN 1 - strncpy

	0 process@ KeProcess_ThreadCount + !
	0 process@ KeProcess_ThreadListHead + !

	PROCESSSTATUS_READY process@ KeProcess_ProcessStatus + !

	PRIORITY_DEFAULT process@ KeProcess_BasePriority + !

	0 process@ KeProcess_SignalThread + !
	0 process@ KeProcess_Signaled + !

	if (parentprocess@)
		parentprocess@ KeProcess_AcceptMask + @ process@ KeProcess_AcceptMask + !
	end else
		0 process@ KeProcess_AcceptMask + !
	end

	0 process@ KeProcess_Terminated + !
	0 process@ KeProcess_KilledStatus + !

	0 process@ KeProcess_PageDirectory + !
	asid@ process@ KeProcess_ASID + !

	asid@ HALCPUASIDRegister
end

fn KeProcessUninitialize { process -- }
	process@ KeProcess_ASID + @ HALCPUASIDUnregister
end

fn KeProcessCurrent { -- current }
	KeThreadCurrent@ KeThread_Process + @ current!
end

fn KeProcessSignal { signal process -- ok }
	if (signal@ ~~)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	if (signal@ 32 >=)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	0 ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (process@ KeProcess_Terminated + @)
		ipl@ KeIPLLower
		return
	end

	if (process@ KeProcess_SignalThread + @ ~~)
		ipl@ KeIPLLower
		return
	end

	if (signal@ OSSIGNAL_CONT ==)
		auto sig
		process@ KeProcess_Signaled + @ sig!

		if (sig@ 1 OSSIGNAL_STOP << &)
			// turn stop signal off
			1 OSSIGNAL_STOP << ~ sig@ & process@ KeProcess_Signaled + !

			// resume all threads
			auto thread
			process@ KeProcess_ThreadListHead + @ thread!

			while (thread@)
				if (thread@ KeThread_Suspended + @)
					thread@ KeThreadResume
				end

				thread@ KeThread_ProcessNext + @ thread!
			end
		end

		ipl@ KeIPLLower

		return
	end

	if (process@ KeProcess_AcceptMask + @ 1 signal@ << & ~~)
		ipl@ KeIPLLower
		return
	end

	1 signal@ << process@ KeProcess_Signaled + |=

	process@ KeProcessWakeForSignal

	ipl@ KeIPLLower
end

fn KeProcessMaskSignal { signal process -- ok }
	if (signal@ ~~)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	if (signal@ 32 >=)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	0 ok!

	auto rs
	HALCPUInterruptDisable rs!
	1 signal@ << ~ process@ KeProcess_AcceptMask + &=
	rs@ HALCPUInterruptRestore
end

fn KeProcessUnmaskSignal { signal process -- ok }
	if (signal@ ~~)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	if (signal@ 32 >=)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	0 ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 signal@ << process@ KeProcess_AcceptMask + |=

	process@ KeProcessWakeForSignal

	ipl@ KeIPLLower
end

fn KeProcessWakeForSignal { process -- }
	// should be called whenever signal state or acceptmask is changed

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeProcessWakeForSignal: ipl != IPLDPC\n" KeCrash
		end
	end

	auto signalthread
	process@ KeProcess_SignalThread + @ signalthread!

	auto sig
	process@ KeProcess_Signaled + @ sig!

	auto wakeall

	if (sig@ 1 OSSIGNAL_STOP << &)
		1 wakeall!
	end elseif (sig@ 1 OSSIGNAL_KILL << &)
		1 wakeall!
	end elseif (process@ KeProcess_AcceptMask + @ sig@ &)
		0 wakeall!
	end else
		// no signals that are being accepted, do nothing
		return
	end

	if (wakeall@ ~~)
		// wake only the signal thread

		if (signalthread@ KeThread_Suspended + @)
			signalthread@ KeThreadResume
		end else
			sig@ // sig
			signalthread@ // thread
			KeThreadWakeForSignal
		end
	end else
		// wake all threads

		auto thread
		process@ KeProcess_ThreadListHead + @ thread!

		while (thread@)
			if (thread@ KeThread_Suspended + @)
				thread@ KeThreadResume
			end else
				sig@ // sig
				thread@ // thread
				KeThreadWakeForSignal
			end

			thread@ KeThread_ProcessNext + @ thread!
		end
	end
end