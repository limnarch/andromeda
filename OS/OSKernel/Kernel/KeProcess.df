#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"

#include "<inc>/Kernel.h"

#include "<ll>/OSDLL/OS.h"

var KeProcessListHead 0
public KeProcessListHead

fn KeProcessInitialize { name asid process -- }
	process@ KeProcess_Name + name@ KEPROCESSNAMELEN 1 - strncpy

	0 process@ KeProcess_ThreadCount + !
	0 process@ KeProcess_ThreadListHead + !

	PROCESSSTATUS_READY process@ KeProcess_ProcessStatus + !

	PRIORITY_DEFAULT process@ KeProcess_BasePriority + !

	0 process@ KeProcess_SignalThread + !
	0          process@ KeProcess_Signaled + !
	0xCF66FFFF process@ KeProcess_AcceptMask + !

	0 process@ KeProcess_Terminated + !
	0 process@ KeProcess_KilledStatus + !

	0 process@ KeProcess_PageDirectory + !
	asid@ process@ KeProcess_ASID + !

	asid@ HALCPUASIDRegister
end

fn KeProcessUninitialize { process -- }
	process@ KeProcess_ASID + @ HALCPUASIDUnregister
end

fn KeProcessCurrent { -- current }
	KeThreadCurrent@ KeThread_Process + @ current!
end

fn KeProcessSignal { signal process -- ok }
	if (signal@ ~~)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	if (signal@ 32 >=)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	0 ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (process@ KeProcess_Terminated + @)
		ipl@ KeIPLLower

		STATUS_PROCESS_IS_TERMINATED ok!

		return
	end

	if (process@ KeProcess_SignalThread + @ ~~)
		ipl@ KeIPLLower

		STATUS_PROCESS_NO_THREAD ok!

		return
	end

	1 signal@ << process@ KeProcess_Signaled + |=

	process@ KeProcessWakeForSignal

	ipl@ KeIPLLower
end

fn KeProcessWakeForSignal { process -- }
	// should be called whenever signal state or acceptmask is changed

	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeProcessWakeForSignal: ipl != IPLDPC\n" KeCrash
		end
	end

	auto signalthread
	process@ KeProcess_SignalThread + @ signalthread!

	auto sig
	process@ KeProcess_Signaled + @ sig!

	auto wakeall

	if (sig@ 1 OSSIGNAL_STOP << &)
		1 wakeall!
	end elseif (sig@ 1 OSSIGNAL_KILL << &)
		1 wakeall!
	end elseif (process@ KeProcess_AcceptMask + @ sig@ &)
		0 wakeall!
	end else
		// no signals that are being accepted, do nothing
		return
	end

	if (wakeall@ ~~)
		// wake only the signal thread

		if (signalthread@ KeThread_Suspended + @)
			signalthread@ KeThreadResume
		end else
			sig@ // sig
			signalthread@ // thread
			KeThreadWakeForSignal
		end
	end else
		// wake all threads

		auto thread
		process@ KeProcess_ThreadListHead + @ thread!

		while (thread@)
			if (thread@ KeThread_Suspended + @)
				thread@ KeThreadResume
			end else
				sig@ // sig
				thread@ // thread
				KeThreadWakeForSignal
			end

			thread@ KeThread_ProcessNext + @ thread!
		end
	end
end