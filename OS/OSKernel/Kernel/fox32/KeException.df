#include "<df>/dragonfruit.h"
#include "<inc>/HALCrash.h"

#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALConsole.h"

#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

// if this seems janked up, its because it is, because this all used to be in
// the HAL, and the process of moving it into the kernel was rough.

const ECAUSEINTERRUPT 1
const ECAUSESYS       2
const ECAUSENMI       5
const ECAUSEBRK       6
const ECAUSEINVALID   7
const ECAUSEPRIVVIOL  8
const ECAUSEUNALIGNED 9
const ECAUSEPAGEFAULT 12
const ECAUSEPAGEWRITE 13

externptr HALfox32InterruptHandlers

externptr KeThreadCurrentStackTop
externptr KeThreadCurrentStackBottom
externptr HALInterruptStackTop

externptr OSCallCount
externptr OSCallTable

externptr KeIPLCurrent

externptr HALfox32InterruptsDisabled

extern HALfox32TLBFlushAll { -- }

asm "

KeFox32DismissVector:
	reti

KeFox32VsyncVector:
	push 0 ;badaddr
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0xFF
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

KeFox32DivideZeroVector:
	push 0 ;badaddr
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0x100
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

KeFox32InvalidOpcodeVector:
	push 0 ;badaddr
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0x101
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

KeFox32PageFaultVector:
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0x102
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

KeFox32PageFaultWriteVector:
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0x103
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

; a0 - tf
KeFox32Syscall:
.global KeFox32Syscall

	ret

ThreadTrampoline:
	mov  [HALfox32InterruptsDisabled], 0
	ise
	jmp  a2

KeIPLCurrentGet:
.global KeIPLCurrentGet
	mov  a0, [KeIPLCurrent]
	ret

"

extern ThreadTrampoline { -- }

extern KeLimn2600Syscall { tf -- }

const EXCNAMESMAX 4

table ExceptionNames
	"DIVZERO"
	"INVINST"
	"PF"
	"PFW"
endtable

extern PsPrepareUsermode { trapframe -- }

fn KeStackOverflow { rs -- }
	auto current
	KeThreadCurrent@ current!

	if (current@)
		current@ KeThread_Name +
		current@ KeThread_Process + @ KeProcess_Name +
		"process '%s' thread '%s' kernel stack overflow\n" KeCrash
	end

	rs@ "Kernel stack overflow %x\n" KeCrash
end

fn KeCopySignalFrame { signum dispatchfunc thread trapframe -- recheck }
	0 recheck!

	auto usp
	trapframe@ OSContext_sp + @ usp!

	if (DEBUGCHECKS)
		if (trapframe@ OSContext_eflagsB + gb FOX32_RS_USER & ~~)
			trapframe@ "KeCopySignalFrame: not usermode trapframe %x\n" KeCrash
		end
	end

	OSContext_SIZEOF usp -=

	auto ok
	usp@ // dest
	trapframe@ // src
	OSContext_SIZEOF // sz
	KeSafeCopyOut ok!

	if (ok@)
		// failed to copy out signal frame, this is fatal to the entire
		// process.
		// XXX should it be???

		128 OSSIGNAL_KILL + thread@ KeThread_Process + @ KeProcess_KilledStatus + !

		OSSIGNAL_KILL // signal
		thread@ KeThread_Process + @ // process
		KeProcessSignal drop

		1 recheck!

		return
	end

	usp@ trapframe@ OSContext_sp + !
	dispatchfunc@ trapframe@ OSContext_epc + !
	signum@ trapframe@ OSContext_a0 + !
	usp@ trapframe@ OSContext_a1 + !

	auto process
	thread@ KeThread_Process + @ process!

	auto rs
	HALCPUInterruptDisable rs!

	1 signum@ << ~ thread@ KeThread_Signals + &=

	rs@ HALCPUInterruptRestore
end

fn KeThreadContinue { context thread -- }
	auto tf
	thread@ KeThread_TrapFrame + @ tf!

	auto ers
	tf@ OSContext_eflagsB + gb ers!

	if (DEBUGCHECKS)
		if (ers@ FOX32_RS_USER & ~~)
			tf@ "KeThreadContinue: not usermode trapframe %x\n" KeCrash
		end
	end

	tf@ // dest
	context@ // src
	OSContext_SIZEOF // size
	memcpy

	// don't modify ers lest we allow our user programs to get kernelmode...
	ers@ tf@ OSContext_eflagsB + sb
end

fn DebugGetSymbolByAddress { address dll -- symbase symname symbol ok }
	if (address@ dll@ ComDLL_Base + @ <)
		-1 ok!
		return
	end

	if (address@ dll@ ComDLL_End + @ >=)
		-1 ok!
		return
	end

	auto head
	dll@ ComDLL_HeadVAddr + @ head!

	auto sectiontable
	head@ XLOFFHeader_SectionTableOffset + @ head@ + sectiontable!

	head@ XLOFFHeader_SymbolTableOffset + @ head@ + symbol!

	auto i
	0 i!

	auto count
	head@ XLOFFHeader_SymbolCount + @ count!

	auto strtab
	head@ XLOFFHeader_StringTableOffset + @ head@ + strtab!

	auto lastsym
	0 lastsym!

	-1 ok!

	while (i@ count@ <)
		if (symbol@ XLOFFSymbol_TypeB + gb XLOFF_SYMTYPE_GLOBAL ==)
			auto sectionheader
			sectiontable@ symbol@ XLOFFSymbol_SectionIndexI + gi XLOFFSectionHeader_SIZEOF * + sectionheader!

			auto sbase
			symbol@ XLOFFSymbol_Value + @ sectionheader@ XLOFFSectionHeader_VirtualAddress + @ + sbase!

			if (address@ sbase@ >=)
				symbol@ XLOFFSymbol_NameOffset + @ symname!

				if (symname@ 0xFFFFFFFF ==)
					0 symname!
				end else
					strtab@ symname +=
				end

				symbol@ lastsym!
				sbase@ symbase!
			end elseif (address@ sbase@ <)
				if (lastsym@)
					0 ok!
				end

				lastsym@ symbol!

				return
			end
		end

		XLOFFSymbol_SIZEOF symbol +=
		1 i +=
	end

	if (lastsym@)
		0 ok!
	end

	lastsym@ symbol!
end

fn DebugGetSymbol { name dll -- symbol ok }
	auto head
	dll@ ComDLL_HeadVAddr + @ head!

	head@ XLOFFHeader_SymbolTableOffset + @ head@ + symbol!

	auto i
	0 i!

	auto count
	head@ XLOFFHeader_SymbolCount + @ count!

	auto strtab
	head@ XLOFFHeader_StringTableOffset + @ head@ + strtab!

	-1 ok!

	while (i@ count@ <)
		if (symbol@ XLOFFSymbol_TypeB + gb XLOFF_SYMTYPE_GLOBAL ==)
			auto sname
			symbol@ XLOFFSymbol_NameOffset + @ sname!

			if (sname@ 0xFFFFFFFF ~=)
				strtab@ sname +=

				if (sname@ name@ strcmp)
					0 ok!
					return
				end
			end
		end

		XLOFFSymbol_SIZEOF symbol +=
		1 i +=
	end
end

#include "../../../OSLoader/OSLoaderGlobal.h"

externptr HALLoaderInfo

fn DebugGetSymbolAddress { name dll -- address ok }
	auto symbol
	name@ dll@ DebugGetSymbol ok! symbol!

	if (ok@)
		return
	end

	auto head
	dll@ ComDLL_HeadVAddr + @ head!

	auto sectionheader
	head@ XLOFFHeader_SectionTableOffset + @ head@ + sectionheader!

	symbol@ XLOFFSymbol_SectionIndexI + gi XLOFFSectionHeader_SIZEOF * sectionheader +=

	symbol@ XLOFFSymbol_Value + @ address!

	sectionheader@ XLOFFSectionHeader_VirtualAddress + @ address +=
end

fn DebugGetSymDLL { address -- dll symbase symname symbol ok }
	HALLoaderInfo@ LdrInfo_DLLListHead + @ dll!

	-1 ok!

	while (dll@)
		address@ // address
		dll@ // dll
		DebugGetSymbolByAddress ok! symbol! symname! symbase!

		if (ok@ ~~)
			return
		end

		dll@ ComDLL_Next + @ dll!
	end
end

const EXCPAGEFAULT 2
const EXCPAGEFAULTWRITE 3

fn KeFox32Exception { ecause tf -- }
	auto olddis
	HALfox32InterruptsDisabled@ olddis!
	1 HALfox32InterruptsDisabled!

	auto excname

	auto handled
	1 handled!

	if (olddis@)
		0 handled!
	end

	if (handled@)
		0 handled!

		if (ecause@ 0x100 <)
			// interrupt

			auto ipl
			KeIPLCurrent@ ipl!
			IPLHIGH KeIPLCurrent!

			tf@ // trapframe
			ecause@ // int
			[ecause@]HALPlatformInterruptHandlers@ HALInterruptHandler

			// this is an inlined version of what KeIPLLower also does

			if (ipl@ IPLDPC <)
				IPLDPC KeIPLCurrent!

				while (KeDPCListHead@ KeThreadNext@ ||)
					if (KeDPCListHead@)
						KeDPCDispatchQueue
					end

					if (KeThreadNext@)
						HALCPUInterruptEnable

						KeThreadNextSwitch

						HALCPUInterruptDisable drop
					end
				end
			end

			ipl@ KeIPLCurrent!

			1 handled!
		end else
			if (ecause@ 0x100 - EXCPAGEFAULT ==)
				0 // writing
				tf@ OSContext_badaddr + @ // badaddr
				tf@ // trapframe
				MmPageFault handled!
			end elseif (ecause@ 0x100 - EXCPAGEFAULTWRITE ==)
				1 // writing
				tf@ OSContext_badaddr + @ // badaddr
				tf@ // trapframe
				MmPageFault handled!
			end
		end
	end

	if (handled@ ~~)
		if (ecause@ 0x100 >=)
			// exception
			if (ecause@ 0x100 - EXCNAMESMAX >=)
				"UNKNOWN" excname!
			end else
				[ecause@ 0x100 -]ExceptionNames@ excname!
			end
		end else
			"?" excname!
		end

		auto ok
		auto symname
		auto dll

		tf@ OSContext_epc + @
		DebugGetSymDLL ok! drop symname! drop dll!

		if (ok@ ~~)
			symname@
			dll@ ComDLL_Name + @
			excname@
			tf@ OSContext_badaddr + @
			tf@ OSContext_epc + @
			tf@ OSContext_eflagsB + gb
			KeIPLCurrent@
			olddis@
			"I%d,IP%d,EF%02x,PC%08x,VA%08x,%s,%s!%s\n" KeCrash
		end else
			excname@
			tf@ OSContext_badaddr + @
			tf@ OSContext_epc + @
			tf@ OSContext_eflagsB + gb
			KeIPLCurrent@
			olddis@
			"I%d,IP%d,EF%02x,PC%08x,VA%08x,%s\n" KeCrash
		end
	end

	if (tf@ OSContext_eflagsB + gb FOX32_RS_USER &)
		// we interrupted usermode code

		tf@ PsPrepareUsermode
	end

	olddis@ HALfox32InterruptsDisabled!
end

fn KeCPUInit { -- }
	fnsection "INIT$text"

	auto i
	256 i!

	auto vec
	IDENTITYSPACE vec!

	while (i@)
		pointerof KeFox32DismissVector vec@!

		1 i -=
		4 vec +=
	end

	// set the interrupt vectors

	pointerof KeFox32VsyncVector
	0xFF 4 * IDENTITYSPACE + !

	// set the exception vectors

	256 4 * IDENTITYSPACE | vec!

	pointerof KeFox32DivideZeroVector vec@!
	4 vec +=

	pointerof KeFox32InvalidOpcodeVector vec@!
	4 vec +=

	pointerof KeFox32PageFaultVector vec@!
	4 vec +=

	pointerof KeFox32PageFaultWriteVector vec@!
	4 vec +=

	// enable interrupts

	0 HALfox32InterruptsDisabled!
end

fn HALCPUIsUserTrapFrame { tf -- user }
	tf@ OSContext_eflagsB + gb FOX32_RS_USER & user!
end

fn HALCPUTrapFrameAbort { abort tf -- }
	abort@ tf@ OSContext_epc + !
end

fn HALCPUContextInit { context1 context2 startfunc kstack process -- ctx }
	8 kstack -=

	0 kstack@!
	startfunc@ kstack@ 4 + !

	kstack@ OSContext_SIZEOF - ctx!

	ctx@ OSContext_SIZEOF 0 memset

	startfunc@ ctx@ OSContext_a2 + !
	context1@ ctx@ OSContext_a1 + !
	context2@ ctx@ OSContext_a0 + !

	// enable interrupts and paging in the thread's context
	FOX32_RS_KTHREAD ctx@ OSContext_eflagsB + sb

	pointerof ThreadTrampoline ctx@ OSContext_epc + !

	kstack@ ctx@ OSContext_sp + !
end