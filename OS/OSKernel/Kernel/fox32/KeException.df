#include "<df>/dragonfruit.h"
#include "<inc>/HALCrash.h"

#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALConsole.h"

#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

// if this seems janked up, its because it is, because this all used to be in
// the HAL, and the process of moving it into the kernel was rough.

const ECAUSEINTERRUPT 1
const ECAUSESYS       2
const ECAUSENMI       5
const ECAUSEBRK       6
const ECAUSEINVALID   7
const ECAUSEPRIVVIOL  8
const ECAUSEUNALIGNED 9
const ECAUSEPAGEFAULT 12
const ECAUSEPAGEWRITE 13

externptr HALfox32InterruptHandlers

externptr KeThreadCurrentStackTop
externptr KeThreadCurrentStackBottom
externptr HALInterruptStackTop

externptr OSCallCount
externptr OSCallTable

externptr KeIPLCurrent

externptr HALfox32InterruptsDisabled

extern HALfox32TLBFlushAll { -- }

asm "

KeFox32DismissVector:
	reti

KeFox32VsyncVector:
	push 0 ;badaddr
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0xFF
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

KeFox32DivideZeroVector:
	push 0 ;badaddr
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0x100
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

KeFox32InvalidOpcodeVector:
	push 0 ;badaddr
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0x101
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

KeFox32PageFaultVector:
	push r31
	push tp
	push at
	push s17
	push s16
	push s15
	push s14
	push s13
	push s12
	push s11
	push s10
	push s9
	push s8
	push s7
	push s6
	push s5
	push s4
	push s3
	push s2
	push s1
	push s0
	push a3
	push a2
	push a1
	push a0
	push t6
	push t5
	push t4
	push t3
	push t2
	push t1
	push t0

	mov  a1, 0x102
	mov  a0, sp
	call KeFox32Exception

	pop  t0
	pop  t1
	pop  t2
	pop  t3
	pop  t4
	pop  t5
	pop  t6
	pop  a0
	pop  a1
	pop  a2
	pop  a3
	pop  s0
	pop  s1
	pop  s2
	pop  s3
	pop  s4
	pop  s5
	pop  s6
	pop  s7
	pop  s8
	pop  s9
	pop  s10
	pop  s11
	pop  s12
	pop  s13
	pop  s14
	pop  s15
	pop  s16
	pop  s17
	pop  at
	pop  tp
	pop  r31
	add  sp, 4
	reti

; a0 - tf
KeFox32Syscall:
.global KeFox32Syscall

	ret

ThreadTrampoline:
	mov  [HALfox32InterruptsDisabled], 0
	ise
	jmp  a2

KeIPLCurrentGet:
.global KeIPLCurrentGet
	mov  a0, [KeIPLCurrent]
	ret

"

extern ThreadTrampoline { -- }

extern KeLimn2600Syscall { tf -- }

const EXCNAMESMAX 3

table ExceptionNames
	"DIVIDEBYZERO"
	"INVALIDINSTRUCTION"
	"PAGEFAULT"
endtable

extern PsPrepareUsermode { trapframe -- }

fn KeStackOverflow { rs -- }
	auto current
	KeThreadCurrent@ current!

	if (current@)
		current@ KeThread_Name +
		current@ KeThread_Process + @ KeProcess_Name +
		"process '%s' thread '%s' kernel stack overflow\n" KeCrash
	end

	rs@ "Kernel stack overflow %x\n" KeCrash
end

fn KeCopySignalFrame { signum dispatchfunc thread trapframe -- recheck }
	0 recheck!

	auto usp
	trapframe@ OSContext_sp + @ usp!

	if (DEBUGCHECKS)
		if (trapframe@ OSContext_eflagsB + gb FOX32_RS_USER & ~~)
			trapframe@ "KeCopySignalFrame: not usermode trapframe %x\n" KeCrash
		end
	end

	OSContext_SIZEOF usp -=

	auto ok
	usp@ // dest
	trapframe@ // src
	OSContext_SIZEOF // sz
	KeSafeCopyOut ok!

	if (ok@)
		// failed to copy out signal frame, this is fatal to the entire
		// process.
		// XXX should it be???

		128 OSSIGNAL_KILL + thread@ KeThread_Process + @ KeProcess_KilledStatus + !

		OSSIGNAL_KILL // signal
		thread@ KeThread_Process + @ // process
		KeProcessSignal drop

		1 recheck!

		return
	end

	usp@ trapframe@ OSContext_sp + !
	dispatchfunc@ trapframe@ OSContext_epc + !
	signum@ trapframe@ OSContext_a0 + !
	usp@ trapframe@ OSContext_a1 + !

	auto process
	thread@ KeThread_Process + @ process!

	auto rs
	HALCPUInterruptDisable rs!

	1 signum@ << ~ thread@ KeThread_Signals + &=

	rs@ HALCPUInterruptRestore
end

fn KeThreadContinue { context thread -- }
	auto tf
	thread@ KeThread_TrapFrame + @ tf!

	auto ers
	tf@ OSContext_eflagsB + gb ers!

	if (DEBUGCHECKS)
		if (ers@ FOX32_RS_USER & ~~)
			tf@ "KeThreadContinue: not usermode trapframe %x\n" KeCrash
		end
	end

	tf@ // dest
	context@ // src
	OSContext_SIZEOF // size
	memcpy

	// don't modify ers lest we allow our user programs to get kernelmode...
	ers@ tf@ OSContext_eflagsB + sb
end

fn KeFox32Exception { ecause tf -- }
	auto olddis
	HALfox32InterruptsDisabled@ olddis!
	1 HALfox32InterruptsDisabled!

	auto excname

	auto handled
	0 handled!

	if (ecause@ 0x100 <)
		// interrupt

		auto ipl
		KeIPLCurrent@ ipl!
		IPLHIGH KeIPLCurrent!

		tf@ // trapframe
		ecause@ // int
		[ecause@]HALPlatformInterruptHandlers@ HALInterruptHandler

		// this is an inlined version of what KeIPLLower also does

		if (ipl@ IPLDPC <)
			IPLDPC KeIPLCurrent!

			while (KeDPCListHead@ KeThreadNext@ ||)
				if (KeDPCListHead@)
					KeDPCDispatchQueue
				end

				if (KeThreadNext@)
					HALCPUInterruptEnable

					KeThreadNextSwitch

					HALCPUInterruptDisable drop
				end
			end
		end

		ipl@ KeIPLCurrent!

		1 handled!
	end else
		// exception
		if (ecause@ 0x100 - EXCNAMESMAX >=)
			"UNKNOWN" excname!
		end else
			[ecause@ 0x100 -]ExceptionNames@ excname!
		end
	end

	if (handled@ ~~)
		excname@
		tf@ OSContext_badaddr + @
		tf@ OSContext_epc + @
		tf@ OSContext_eflagsB + gb
		KeIPLCurrent@
		"Fault: IPL=%d EFLAG=%02x EPC=%08x BADADDR=%08x ECAUSE=%s\n" KeCrash
	end

	if (tf@ OSContext_eflagsB + gb FOX32_RS_USER &)
		// we interrupted usermode code

		tf@ PsPrepareUsermode
	end

	olddis@ HALfox32InterruptsDisabled!
end

fn KeCPUInit { -- }
	fnsection "INIT$text"

	auto i
	256 i!

	auto vec
	IDENTITYSPACE vec!

	while (i@)
		pointerof KeFox32DismissVector vec@!

		1 i -=
		4 vec +=
	end

	// set the interrupt vectors

	pointerof KeFox32VsyncVector
	0xFF 4 * IDENTITYSPACE + !

	// set the exception vectors

	256 4 * IDENTITYSPACE | vec!

	pointerof KeFox32DivideZeroVector vec@!
	4 vec +=

	pointerof KeFox32InvalidOpcodeVector vec@!
	4 vec +=

	pointerof KeFox32PageFaultVector vec@!
	4 vec +=

	// enable interrupts

	0 HALfox32InterruptsDisabled!
end

fn HALCPUIsUserTrapFrame { tf -- user }
	tf@ OSContext_eflagsB + gb FOX32_RS_USER & user!
end

fn HALCPUTrapFrameAbort { abort tf -- }
	abort@ tf@ OSContext_epc + !
end

fn HALCPUContextInit { context1 context2 startfunc kstack process -- ctx }
	8 kstack -=

	0 kstack@!
	startfunc@ kstack@ 4 + !

	kstack@ OSContext_SIZEOF - ctx!

	ctx@ OSContext_SIZEOF 0 memset

	startfunc@ ctx@ OSContext_a2 + !
	context1@ ctx@ OSContext_a1 + !
	context2@ ctx@ OSContext_a0 + !

	// enable interrupts and paging in the thread's context
	FOX32_RS_KTHREAD ctx@ OSContext_eflagsB + sb

	pointerof ThreadTrampoline ctx@ OSContext_epc + !

	kstack@ ctx@ OSContext_sp + !
end