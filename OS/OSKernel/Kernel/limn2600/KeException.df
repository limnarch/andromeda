#include "<df>/dragonfruit.h"
#include "<inc>/HALCrash.h"

#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALConsole.h"

#include "<inc>/HALDebug.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Process.h"

#include "<ll>/OSDLL/OS.h"

// if this seems janked up, its because it is, because this all used to be in
// the HAL, and the process of moving it into the kernel was rough.

const ECAUSEINTERRUPT 1
const ECAUSESYS       2
const ECAUSENMI       6
const ECAUSEINVALID   7
const ECAUSEPRIVVIOL  8
const ECAUSEUNALIGNED 9
const ECAUSEPAGEFAULT 12
const ECAUSEPAGEWRITE 13

externptr HALLIMNstationInterruptHandlers

externptr HALLIMNstationLSICClaimComplete

externptr HALLimn2500SavedEV

externptr KeThreadCurrentStackTop
externptr KeThreadCurrentStackBottom
externptr HALInterruptStackTop

externptr OSCallCount
externptr OSCallTable

externptr KeIPLCurrent

asm "

KeLimn2600ExceptionVector:
.global KeLimn2600ExceptionVector
	mtcr k0, t0 ; save t0 to free it as scratch
	mtcr k1, t1 ; ditto with t1
	mtcr k2, sp ; save stack pointer
	mtcr k3, sp ; save trace link

	mfcr t0, ers

	andi t1, t0, LIMN2600_RS_USER
	beq  t1, .waskernel

	la   t1, KeThreadCurrentStackTop
	mov  sp, long [t1] ; load new sp for current thread

	mtcr k3, zero ; this was a usermode sp, zero out the trace link

.waskernel:
	subi sp, sp, OSContext_SIZEOF

	la   t1, KeInterruptNested
	mov  t1, long [t1]
	bne  t1, .skipoverflowcheck

	la   t1, KeThreadCurrentStackBottom
	mov  t1, long [t1]
	sub  t1, sp, t1
	blt  t1, .overflow

.skipoverflowcheck:
	mfcr t1, k2
	mov  long [sp + OSContext_sp],  t1
	mov  long [sp + OSContext_ers], t0 ; ers was still in t0

	mfcr t0, epc
	mov  long [sp + OSContext_epc], t0

	mfcr t1, k0
	mov  long [sp + OSContext_t0],  t1

	mfcr t1, k1
	mov  long [sp + OSContext_t1],  t1

	mov  long [sp + OSContext_t2],  t2
	mov  long [sp + OSContext_t3],  t3
	mov  long [sp + OSContext_t4],  t4
	mov  long [sp + OSContext_t5],  t5
	mov  long [sp + OSContext_a0],  a0
	mov  long [sp + OSContext_a1],  a1
	mov  long [sp + OSContext_a2],  a2
	mov  long [sp + OSContext_a3],  a3
	mov  long [sp + OSContext_s0],  s0
	mov  long [sp + OSContext_s1],  s1
	mov  long [sp + OSContext_s2],  s2
	mov  long [sp + OSContext_s3],  s3
	mov  long [sp + OSContext_s4],  s4
	mov  long [sp + OSContext_s5],  s5
	mov  long [sp + OSContext_s6],  s6
	mov  long [sp + OSContext_s7],  s7
	mov  long [sp + OSContext_s8],  s8
	mov  long [sp + OSContext_s9],  s9
	mov  long [sp + OSContext_s10], s10
	mov  long [sp + OSContext_s11], s11
	mov  long [sp + OSContext_s12], s12
	mov  long [sp + OSContext_s13], s13
	mov  long [sp + OSContext_s14], s14
	mov  long [sp + OSContext_s15], s15
	mov  long [sp + OSContext_s16], s16
	mov  long [sp + OSContext_s17], s17
	mov  long [sp + OSContext_s18], s18
	mov  long [sp + OSContext_lr],  lr

	mfcr a1, ecause
	mfcr a2, ebadaddr
	mov  a0, sp ; give KeLimn2600Exception our context

	subi sp, sp, 8
	mfcr t0, epc
	mov  long [sp + 4], t0
	mfcr t0, k3
	mov  long [sp], t0

	jal  KeLimn2600Exception ; call KeLimn2600Exception, to handle the exception

	addi sp, sp, 8

	mov  t0, long [sp + OSContext_ers]
	mtcr ers, t0

	mov  t0, long [sp + OSContext_epc]
	mtcr epc, t0

	mov  t0,  long [sp + OSContext_t0]
	mov  t1,  long [sp + OSContext_t1]
	mov  t2,  long [sp + OSContext_t2]
	mov  t3,  long [sp + OSContext_t3]
	mov  t4,  long [sp + OSContext_t4]
	mov  t5,  long [sp + OSContext_t5]
	mov  a0,  long [sp + OSContext_a0]
	mov  a1,  long [sp + OSContext_a1]
	mov  a2,  long [sp + OSContext_a2]
	mov  a3,  long [sp + OSContext_a3]
	mov  s0,  long [sp + OSContext_s0]
	mov  s1,  long [sp + OSContext_s1]
	mov  s2,  long [sp + OSContext_s2]
	mov  s3,  long [sp + OSContext_s3]
	mov  s4,  long [sp + OSContext_s4]
	mov  s5,  long [sp + OSContext_s5]
	mov  s6,  long [sp + OSContext_s6]
	mov  s7,  long [sp + OSContext_s7]
	mov  s8,  long [sp + OSContext_s8]
	mov  s9,  long [sp + OSContext_s9]
	mov  s10, long [sp + OSContext_s10]
	mov  s11, long [sp + OSContext_s11]
	mov  s12, long [sp + OSContext_s12]
	mov  s13, long [sp + OSContext_s13]
	mov  s14, long [sp + OSContext_s14]
	mov  s15, long [sp + OSContext_s15]
	mov  s16, long [sp + OSContext_s16]
	mov  s17, long [sp + OSContext_s17]
	mov  s18, long [sp + OSContext_s18]

	mov  lr, long [sp + OSContext_lr]
	mov  sp, long [sp + OSContext_sp]

	rfe

.overflow:
	la   sp, HALInterruptStackTop
	mov  sp, long [sp]

	subi sp, sp, 8
	mfcr t0, epc
	mov  long [sp + 4], t0
	mfcr t0, k3
	mov  long [sp], t0

	j    KeStackOverflow

LoadInitialContext:
.global LoadInitialContext
	mov  t0, long [sp + OSContext_ers]
	mtcr ers, t0

	mov  t0, long [sp + OSContext_epc]
	mtcr epc, t0

	mov  t0,  long [sp + OSContext_t0]
	mov  t1,  long [sp + OSContext_t1]
	mov  t2,  long [sp + OSContext_t2]
	mov  t3,  long [sp + OSContext_t3]
	mov  t4,  long [sp + OSContext_t4]
	mov  t5,  long [sp + OSContext_t5]
	mov  a0,  long [sp + OSContext_a0]
	mov  a1,  long [sp + OSContext_a1]
	mov  a2,  long [sp + OSContext_a2]
	mov  a3,  long [sp + OSContext_a3]
	mov  s0,  long [sp + OSContext_s0]
	mov  s1,  long [sp + OSContext_s1]
	mov  s2,  long [sp + OSContext_s2]
	mov  s3,  long [sp + OSContext_s3]
	mov  s4,  long [sp + OSContext_s4]
	mov  s5,  long [sp + OSContext_s5]
	mov  s6,  long [sp + OSContext_s6]
	mov  s7,  long [sp + OSContext_s7]
	mov  s8,  long [sp + OSContext_s8]
	mov  s9,  long [sp + OSContext_s9]
	mov  s10, long [sp + OSContext_s10]
	mov  s11, long [sp + OSContext_s11]
	mov  s12, long [sp + OSContext_s12]
	mov  s13, long [sp + OSContext_s13]
	mov  s14, long [sp + OSContext_s14]
	mov  s15, long [sp + OSContext_s15]
	mov  s16, long [sp + OSContext_s16]
	mov  s17, long [sp + OSContext_s17]
	mov  s18, long [sp + OSContext_s18]

	mov  lr, long [sp + OSContext_lr]
	mov  sp, long [sp + OSContext_sp]

	rfe

; a0 - tf
KeLimn2600Syscall:
.global KeLimn2600Syscall
	subi sp, sp, 20
	mov  long [sp], zero
	mov  long [sp + 4], s0
	mov  long [sp + 8], s1
	mov  long [sp + 12], s18
	mov  long [sp + 16], lr

	mov  s18, a0 ;trampolines expect trapframe in s18

	mov  t1, long [a0 + OSContext_t0]
	beq  t1, .sysout

	la   t0, OSCallCount
	mov  t0, long [t0]
	slt  t0, t0, t1
	bne  t0, .sysout

	la   t0, OSCallTable
	mov  t0, long [t0 + t1 LSH 2]

	mfcr s0, rs
	ori  s1, s0, LIMN2600_RS_INT
	mtcr rs, s1

	jalr lr, t0, 0

	mtcr rs, s0

.sysout:
	mov  lr, long [sp + 16]
	mov  s18, long [sp + 12]
	mov  s1, long [sp + 8]
	mov  s0, long [sp + 4]
	addi sp, sp, 20

	ret

KeCPUInit:
.global KeCPUInit
	la   t0, HALLimn2500SavedEV
	mfcr t1, evec
	mov  long [t0], t1

	la   t0, KeLimn2600ExceptionVector
	mtcr evec, t0

	mtcr ebadaddr, zero

	subi t0, zero, 1
	ftlb t0, t0
	
	ret

KeIPLCurrentGet:
.global KeIPLCurrentGet
	la   a0, KeIPLCurrent
	mov  a0, long [a0]
	ret

"

extern KeLimn2600Syscall { tf -- }

const EXCNAMESMAX 15

table ExceptionNames
	"EXC0"
	"INTERRUPT"
	"SYSCALL"
	"FWCALL"
	"BUSERROR"
	"EXC5"
	"BREAKPOINT"
	"INVALIDINSTRUCTION"
	"PRIVILEGEVIOLATION"
	"UNALIGNEDADDR"
	"EXC10"
	"EXC11"
	"PAGEFAULT(READ)"
	"PAGEFAULT(WRITE)"
	"EXC14"
	"EXC15"
endtable

extern PsPrepareUsermode { trapframe -- }

fn KeStackOverflow { -- }
	auto current
	KeThreadCurrent@ current!

	if (current@)
		current@ KeThread_Name +
		current@ KeThread_Process + @ KeProcess_Name +
		"process '%s' thread '%s' kernel stack overflow\n" KeCrash
	end

	"Kernel stack overflow\n" KeCrash
end

fn KeCopySignalFrame { signum dispatchfunc thread trapframe -- recheck }
	0 recheck!

	auto usp
	trapframe@ OSContext_sp + @ usp!

	if (DEBUGCHECKS)
		if (trapframe@ OSContext_ers + @ LIMN2600_RS_USER & ~~)
			trapframe@ "KeCopySignalFrame: not usermode trapframe %x\n" KeCrash
		end
	end

	OSContext_SIZEOF usp -=

	auto ok
	usp@ // dest
	trapframe@ // src
	OSContext_SIZEOF // sz
	KeSafeCopyOut ok!

	if (ok@)
		OSSIGNAL_KILL // signal
		thread@ KeThread_Process + @ // process
		KeProcessSignal drop

		1 recheck!

		return
	end

	usp@ trapframe@ OSContext_sp + !
	dispatchfunc@ trapframe@ OSContext_epc + !
	signum@ trapframe@ OSContext_a0 + !
	usp@ trapframe@ OSContext_a1 + !

	auto process
	thread@ KeThread_Process + @ process!

	auto rs
	HALCPUInterruptDisable rs!

	1 signum@ << ~ thread@ KeThread_ExceptionSignals + &=
	1 signum@ << ~ process@ KeProcess_Signaled + &=

	rs@ HALCPUInterruptRestore
end

fn KeThreadContinue { context thread -- }
	auto tf
	thread@ KeThread_TrapFrame + @ tf!

	auto ers
	tf@ OSContext_ers + @ ers!

	if (DEBUGCHECKS)
		if (ers@ LIMN2600_RS_USER & ~~)
			tf@ "KeThreadContinue: not usermode trapframe %x\n" KeCrash
		end
	end

	tf@ // dest
	context@ // src
	OSContext_SIZEOF // size
	memcpy

	// don't modify ers lest we allow our user programs to get kernelmode...
	ers@ tf@ OSContext_ers + !
end

externptr KeInterruptNested

fn KeLimn2600Exception { badaddr ecause tf -- }
	auto handled
	0 handled!
	
	auto signal
	0 signal!

	badaddr@ tf@ OSContext_badaddr + !

	if (tf@ OSContext_ers + @ LIMN2600_RS_USER &)
		tf@ KeThreadCurrent@ KeThread_TrapFrame + !
	end

	if (ecause@ ECAUSEINTERRUPT ==)
		pointerof KeInterrupt // keint
		HALPlatformInterrupt
		1 handled!
	end elseif (ecause@ ECAUSESYS ==)
		tf@ KeLimn2600Syscall
		1 handled!
	end elseif (ecause@ ECAUSEPAGEFAULT ==)
		4 tf@ OSContext_epc + -=

		0 // writing
		badaddr@ // badaddr
		tf@ // trapframe
		MmPageFault handled!
	end elseif (ecause@ ECAUSEPAGEWRITE ==)
		4 tf@ OSContext_epc + -=

		1 // writing
		badaddr@ // badaddr
		tf@ // trapframe
		MmPageFault handled!
	end elseif (ecause@ ECAUSEINVALID ==)
		OSSIGNAL_ILL signal!
	end elseif (ecause@ ECAUSEPRIVVIOL ==)
		OSSIGNAL_ILL signal!
	end elseif (ecause@ ECAUSEUNALIGNED ==)
		OSSIGNAL_SEGV signal!
	end

	if (signal@)
		if (tf@ OSContext_ers + @ LIMN2600_RS_USER &)
			4 tf@ OSContext_epc + -=

			signal@ // signal
			KeThreadCurrent@ // thread
			KeThreadException drop

			1 handled!
		end elseif (ecause@ ECAUSEUNALIGNED ==)
			auto abort
			KeThreadCurrent@ KeThread_SafeAccessAbort + @ abort!

			if (abort@)
				// thought this might happen.
				abort@ tf@ HALCPUTrapFrameAbort
			end
		end
	end

	if (handled@ ~~)
		auto excname

		if (ecause@ EXCNAMESMAX >)
			"UNKNOWN" excname!
		end else
			[ecause@]ExceptionNames@ excname!
		end

		if (ecause@ ECAUSENMI ==)
			if (HALDebug)
				return
			end

			return
		end

		ecause@ excname@ badaddr@ tf@ OSContext_epc + @ tf@ OSContext_ers + @
		"Fault: ERS=%08x EPC=%08x BADADDR=%08x ECAUSE=%s (%d)\n" KeCrash
	end

	if (tf@ OSContext_ers + @ LIMN2600_RS_USER &)
		// we interrupted usermode code

		tf@ PsPrepareUsermode
	end

	// while (1) end
end

fn HALCPUIsUserTrapFrame { tf -- user }
	tf@ OSContext_ers + @ LIMN2600_RS_USER & user!
end

fn HALCPUTrapFrameAbort { abort tf -- }
	abort@ tf@ OSContext_epc + !
end

fn HALCPUContextInit { context1 context2 startfunc kstack -- ctx }
	8 kstack -=

	0 kstack@!
	startfunc@ kstack@ 4 + !

	kstack@ OSContext_SIZEOF - ctx!

	ctx@ OSContext_SIZEOF 0 memset

	context1@ ctx@ OSContext_a1 + !
	context2@ ctx@ OSContext_a0 + !

	// enable interrupts and paging in the thread's context
	LIMN2600_RS_KTHREAD ctx@ OSContext_ers + !

	startfunc@ ctx@ OSContext_epc + !

	kstack@ ctx@ OSContext_sp + !

	OSContext_SIZEOF ctx -=

	pointerof LoadInitialContext ctx@ OSContext_lr + !
end