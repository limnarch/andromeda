#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALRTC.h"

#include "<inc>/Kernel.h"

#include "<ll>/OSDLL/OSStatus.h"

// initializes a KeMutex

fn KeMutexInitialize { name mode mutex -- ok }
	name@ DISPATCHOBJECT_MUTEX mutex@ KeDispatchInitialize ok!

	if (ok@)
		return
	end

	0 mutex@ KeMutex_OwningThread + !
	0 mutex@ KeMutex_Locked + !
	mode@ mutex@ KeMutex_Mode + !

	0 mutex@ KeMutex_Prev + !
	0 mutex@ KeMutex_Next + !

	1 mutex@ KeMutex_DispatchHeader + KeDispatchHeader_Signaled + !
end

fn KeMutexOwnerSet { thread mutex -- ok }
	0 ok!

	thread@ mutex@ KeMutex_OwningThread + !
	1 mutex@ KeMutex_Locked + !

	auto h
	thread@ KeThread_MutexListHead + @ h!

	h@ mutex@ KeMutex_Next + !

	if (h@)
		mutex@ h@ KeMutex_Prev + !
	end

	mutex@ thread@ KeThread_MutexListHead + !

	0 mutex@ KeMutex_DispatchHeader + KeDispatchHeader_Signaled + !
end

fn KeMutexRelease { abandon mutex -- ok }
	0 ok!

	// if kernelmode mutex, there is NO possible return value except for 0.
	// so, when unlocking a kernelmode mutex, its safe to drop the return value.

	auto current
	KeThreadCurrent@ current!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (DEBUGCHECKS)
		if (KeDPCActive@)
			"KeMutexRelease: DPC active\n" KeCrash
		end

		if (abandon@)
			if (mutex@ KeMutex_Mode + @ KERNELMODE ==)
				"KeMutexRelease: attempt to abandon kernel mutex\n" KeCrash
			end
		end
	end

	auto lock

	if (abandon@)
		mutex@ KeMutex_OwningThread + @ current!

		if (current@ ~~)
			ipl@ KeIPLLower

			STATUS_MUTEX_NOT_OWNED ok!

			return
		end

		1 lock!
		1 mutex@ KeMutex_Locked + !
	end else
		mutex@ KeMutex_Locked + @ lock!

		if (mutex@ KeMutex_OwningThread + @ current@ ~=)
			// we didn't own it...

			if (mutex@ KeMutex_Mode + @ KERNELMODE ==)
				mutex@ KeMutex_DispatchHeader + KeDispatchHeader_Name + @
				current@ KeThread_Name +
				"KeMutexRelease: thread '%s' didn't own mutex '%s'\n" KeCrash
			end else
				ipl@ KeIPLLower

				STATUS_MUTEX_NOT_OWNED ok!

				return
			end
		end
	end

	if (DEBUGCHECKS)
		if (lock@ ~~)
			// it wasn't locked...

			mutex@ KeMutex_DispatchHeader + KeDispatchHeader_Name + @
			current@ KeThread_Name +
			"KeMutexRelease: thread '%s' owns mutex '%s' but lockcount=0\n" KeCrash
		end
	end

	1 lock -=

	if (lock@ ~~)
		// just unlocked it, remove it from the thread's owned mutex list

		auto ls
		mutex@ KeMutex_Prev + @ ls!

		auto ns
		mutex@ KeMutex_Next + @ ns!

		if (ls@)
			ns@ ls@ KeMutex_Next + !
		end else
			ns@ current@ KeThread_MutexListHead + !
		end

		if (ns@)
			ls@ ns@ KeMutex_Prev + !
		end

		0 mutex@ KeMutex_Prev + !
		0 mutex@ KeMutex_Next + !

		// try to wake up a waiter.

		auto wokenthread

		if (mutex@ KeMutex_Mode + @ KERNELMODE ==)
			// kernel mode mutex, boost waiter priority by 1

			0 // waitstatus
			1 // priboost
			mutex@ // object
			1 // signal
			KeDispatchSatisfyFirst ok! wokenthread!
		end else
			0 // waitstatus
			1 // priboost
			mutex@ // object
			1 // signal
			KeDispatchSatisfyFirst ok! wokenthread!
		end

		if (DEBUGCHECKS)
			if (ok@)
				"KeMutexRelease: couldn't KeDispatchSatisfyFirst\n" KeCrash
			end
		end

		if (wokenthread@)
			// we woke up a thread who was waiting. make him the owner of the mutex

			wokenthread@ mutex@ KeMutexOwnerSet ok!

			if (DEBUGCHECKS)
				if (ok@)
					"KeMutexRelease: couldn't KeMutexOwnerSet\n" KeCrash
				end
			end
		end else
			// just unown the mutex

			0 mutex@ KeMutex_OwningThread + !
			0 mutex@ KeMutex_Locked + !
		end
	end else
		lock@ mutex@ KeMutex_Locked + !
	end

	ipl@ KeIPLLower
end

fn KeMutexIsLocked { mutex -- locked }
	mutex@ KeMutex_Locked + @ locked!
end