//
// Implements the kernel thread object and scheduler.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALRTC.h"

#include "<inc>/Kernel.h"

#include "<ll>/OSDLL/OS.h"

table KeThreadPriorityQueueHeads[PRIORITIES]
public KeThreadPriorityQueueHeads

table KeThreadPriorityQueueTails[PRIORITIES]

var KeThreadCurrent 0
public KeThreadCurrent

externptr KeThreadCurrentStackTop
externptr KeThreadCurrentStackBottom

var KeThreadNext 0
public KeThreadNext

var KeThreadNextReason 0
public KeThreadNextReason

var KeThreadSwapInListHead 0
public KeThreadSwapInListHead

const THREADDEFAULTQUANTUMUNITS (THREADDEFAULTQUANTUM HALRTCINTERVAL / QUANTUMUNITSPERTICK *)

externptr KeThreadTimerWake

// 'context1' and 'context2' are parameters passed to the start function

fn KeThreadInitializeAddToList { thread process -- }
	auto rs
	HALCPUInterruptDisable rs!

	auto h
	process@ KeProcess_ThreadListHead + @ h!

	0 thread@ KeThread_ProcessNext + !
	0 thread@ KeThread_ProcessPrev + !

	if (h@)
		thread@ h@ KeThread_ProcessPrev + !
		h@ thread@ KeThread_ProcessNext + !
	end

	thread@ process@ KeProcess_ThreadListHead + !

	1 process@ KeProcess_ThreadCount + +=
	1 process@ KeProcess_ResidentStackCount + +=

	rs@ HALCPUInterruptRestore
end

fn KeThreadInitialize { context1 context2 startfunc process kstack name thread -- }
	fnsection "PAGE$text"

	thread@ KeThread_Name + name@ KETHREADNAMELEN 1 - strncpy

	THREADSTATUS_INITIALIZED thread@ KeThread_Status + !

	THREADDEFAULTQUANTUMUNITS thread@ KeThread_BaseQuantum + !
	THREADDEFAULTQUANTUMUNITS thread@ KeThread_Quantum + !

	process@ thread@ KeThread_Process + !

	process@ KeProcess_BasePriority + @ thread@ KeThread_Priority + !
	process@ KeProcess_BasePriority + @ thread@ KeThread_BasePriority + !

	context1@ // context1
	context2@ // context2
	startfunc@ // startfunc
	kstack@ KETHREADSTACKSIZE + // kstack
	process@ // process
	HALCPUContextInit thread@ KeThread_Context + !

	kstack@ thread@ KeThread_KernelStackBottom + !
	kstack@ KETHREADSTACKSIZE + thread@ KeThread_KernelStackTop + !

	// add to the process's thread list

	thread@ // thread
	process@ // process
	KeThreadInitializeAddToList

	0 thread@ KeThread_QueueNext + !
	0 thread@ KeThread_QueuePrev + !

	0 thread@ KeThread_SwapListNext + !
	0 thread@ KeThread_PendingSwapIn + !
	1 thread@ KeThread_KernelStackCanBeSwapped + !
	1 thread@ KeThread_KernelStackResident + !

	0 thread@ KeThread_Enqueued + !

	0 thread@ KeThread_WaitStatus + !
	0 thread@ KeThread_WaitMode + !
	0 thread@ KeThread_WaitIPL + !

	0 thread@ KeThread_MutexListHead + !

	0 thread@ KeThread_WaitCount + !

	0 thread@ KeThread_IgnoreKill + !

	0 thread@ KeThread_KilledStatus + !

	0 thread@ KeThread_Suspended + !

	if (process@ KeProcess_SignalThread + @ ~~)
		// this is synchronized by the CreateDeleteMutex
		thread@ process@ KeProcess_SignalThread + !
	end

	auto i
	0 i!

	auto p
	thread@ KeThread_WaitBlocks + p!

	while (i@ THREADWAITBLOCKS <)
		thread@ p@ KeDispatchWaitBlockInitialize

		1 i +=
		KeDispatchWaitBlock_SIZEOF p +=
	end

	thread@ thread@ KeThread_TimeoutWaitBlock + KeDispatchWaitBlockInitialize

	0 thread@ KeThread_SafeAccessAbort + !
	0 thread@ KeThread_SafeAccessSP + !

	"NA" 0 thread@ KeThread_Timer + KeTimerInitialize

	0 thread@ KeThread_Signals + !
	0 thread@ KeThread_SignalAcceptMask + !

	0 thread@ KeThread_TrapFrame + !

	0 thread@ KeThread_UserTimeMs + !
	0 thread@ KeThread_SystemTimeMs + !
	0 thread@ KeThread_DPCTimeMs + !

	0 thread@ KeThread_APCListHead + !
	0 thread@ KeThread_APCListTail + !
	0 thread@ KeThread_APCInProgress + !
	0 thread@ KeThread_APCDisableCount + !
end

fn KeThreadUninitialize { thread -- }
	// remove from process thread list

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (DEBUGCHECKS)
		if (thread@ KeThread_KernelStackResident + @ ~~)
			"KeThreadUninitialize: stack not resident\n" KeCrash
		end
	end

	auto process
	thread@ KeThread_Process + @ process!

	if (process@ KeProcess_SignalThread + @ thread@ ==)
		thread@ KeThread_ProcessNext + @ process@ KeProcess_SignalThread + !

		if (process@ KeProcess_SignalThread + @ ~~)
			thread@ KeThread_ProcessPrev + @ process@ KeProcess_SignalThread + !
		end
	end

	auto n
	thread@ KeThread_ProcessNext + @ n!

	auto l
	thread@ KeThread_ProcessPrev + @ l!

	if (n@)
		l@ n@ KeThread_ProcessPrev + !
	end

	if (l@)
		n@ l@ KeThread_ProcessNext + !
	end else
		// no prev means we were the listhead

		n@ process@ KeProcess_ThreadListHead + !
	end

	if (DEBUGCHECKS)
		if (process@ KeProcess_ThreadCount + @ ~~)
			"KeThreadUninitialize: thread count underflow\n" KeCrash
		end
	end

	1 process@ KeProcess_ThreadCount + -=
	1 process@ KeProcess_ResidentStackCount + -=

	ipl@ KeIPLLower
end

fn KeThreadAPCDisable { thread -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	thread@ KeThread_APCDisableCount + @ oldcount!

	oldcount@ 1 + thread@ KeThread_APCDisableCount + !

	rs@ HALCPUInterruptRestore
end

fn KeThreadAPCEnable { thread -- oldcount }
	// we use IPL sync here to ensure that APCs are dispatched if we happen to
	// lower to zero here.

	auto ipl
	IPLDPC KeIPLRaise ipl!

	thread@ KeThread_APCDisableCount + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"KeThreadAPCEnable: attempt to accept APC more than APC was ignored\n" KeCrash
		end
	end

	oldcount@ 1 - thread@ KeThread_APCDisableCount + !

	if (oldcount@ 1 ==)
		if (thread@ KeThreadCurrent@ ==)
			if (thread@ KeThread_APCListHead + @)
				IPLAPC KeSoftwareInterruptRequest
			end
		end
	end

	ipl@ KeIPLLower
end

fn KeThreadIgnoreKill { thread -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	thread@ KeThread_IgnoreKill + @ oldcount!

	1 thread@ KeThread_IgnoreKill + +=

	rs@ HALCPUInterruptRestore
end

fn KeThreadAcceptKill { thread -- oldcount }
	auto rs
	HALCPUInterruptDisable rs!

	thread@ KeThread_IgnoreKill + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ 0 ==)
			"KeThreadAcceptKill: attempt to accept kill more than kill was ignored\n" KeCrash
		end
	end

	1 thread@ KeThread_IgnoreKill + -=

	rs@ HALCPUInterruptRestore
end

fn KeThreadTerminate { status thread -- }
	fnsection "PAGE$text"

	status@ thread@ KeThread_KilledStatus + !

	OSSIGNAL_KILL // signal
	thread@ // thread
	KeThreadSignal drop
end

fn KeThreadSuspend { thread -- }
	fnsection "PAGE$text"

	// XXX this would not work at all in SMP. IPI needed here.
	// and also in like 50 other places, like TLB shootdown, etc etc

	1 thread@ KeThread_Suspended + !
end

fn KeThreadResume { thread -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	0 thread@ KeThread_Suspended + !

	if (thread@ KeThread_Status + @ THREADSTATUS_SUSPENDED ==)
		0 // waitstatus
		0 // priboost
		thread@ // thread
		KeThreadWakeup drop
	end

	ipl@ KeIPLLower
end

fn KeThreadMaskSignal { signal thread -- ok }
	if (signal@ ~~)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	if (signal@ 32 >=)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	0 ok!

	auto rs
	HALCPUInterruptDisable rs!
	1 signal@ << ~ thread@ KeThread_SignalAcceptMask + &=
	rs@ HALCPUInterruptRestore
end

fn KeThreadUnmaskSignal { signal thread -- ok }
	if (signal@ ~~)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	if (signal@ 32 >=)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	0 ok!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 signal@ << thread@ KeThread_SignalAcceptMask + |=

	thread@ KeThreadWakeForSignal

	ipl@ KeIPLLower
end

fn KeThreadWakeForSignal { thread -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadWakeForSignal: ipl != IPLDPC\n" KeCrash
		end
	end

	// determine whether we need to wake the thread up

	if (thread@ KeThread_IgnoreKill + @)
		// no
		return
	end

	auto sig
	thread@ KeThread_Signals + @ sig!

	auto status
	if (sig@ 1 OSSIGNAL_KILL << &)
		STATUS_KILLED status!
	end elseif (sig@ thread@ KeThread_SignalAcceptMask + @ &)
		STATUS_SIGNALLED status!
	end else
		return
	end

	if (thread@ KeThread_Suspended + @)
		thread@ KeThreadResume
	end

	if (thread@ KeThread_Status + @ THREADSTATUS_WAITINGALERTABLE ==)
		// yes, wake it up

		status@ // waitstatus
		0 // priboost
		thread@ // thread
		KeThreadWakeup drop
	end elseif (thread@ KeThread_Status + @ THREADSTATUS_WAITINGUNALERTABLE ==)
		if (thread@ KeThread_WaitMode + @ USERMODE ==)
			if (sig@ 1 OSSIGNAL_KILL << &)
				// yes, wake it up

				status@ // waitstatus
				0 // priboost
				thread@ // thread
				KeThreadWakeup drop
			end
		end
	end
end

fn KeThreadRundown { thread -- }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto mutex
	thread@ KeThread_MutexListHead + @ mutex!

	auto next

	while (mutex@)
		mutex@ KeMutex_Next + @ next!

		if (mutex@ KeMutex_Mode + @ KERNELMODE ==)
			mutex@ KeMutex_DispatchHeader + KeDispatchHeader_Name + @
			"KeThreadRundown: thread held a kernelmode mutex '%s' at rundown time\n" KeCrash
		end

		1 // abandon
		mutex@ // mutex
		KeMutexRelease drop

		next@ mutex!
	end

	ipl@ KeIPLLower
end

fn KeThreadNextSignal { thread -- signum }
	// assumes IPLDPC or equivalent.

	auto excsignals
	thread@ KeThread_Signals + @ excsignals!

	0 signum!

	while (signum@ 32 <)
		if (excsignals@ 1 signum@ << &)
			return
		end

		1 signum +=
	end

	0 signum!
end

fn KeThreadIsKilled { mode alertable thread -- ok }
	// gives the status code that should be returned for the thread's signal
	// state. this only determines what should interrupt a syscall and be
	// passed to OSDLL; actual signal dispatch and certain actions like core
	// dumping are to be performed in usermode OSDLL code.

	0 ok!

	if (thread@ KeThread_IgnoreKill + @)
		// all signals are being hard-ignored by the system
		return
	end

	if (alertable@ ~~)
		if (mode@ KERNELMODE ==)
			// kernel mode unalertable can block all signals
			return
		end
	end

	auto process
	thread@ KeThread_Process + @ process!

	auto sig
	thread@ KeThread_Signals + @ sig!

	if (process@ KeProcess_Terminated + @)
		1 OSSIGNAL_KILL << sig |=
	end

	if (sig@ ~~)
		// no signals, return now
		return
	end

	if (sig@ 1 OSSIGNAL_KILL << &)
		// OSSIGNAL_KILL cannot be ignored
		STATUS_KILLED ok!
		return
	end

	if (alertable@ ~~)
		// usermode unalertable can block all signals except OSSIGNAL_KILL
		return
	end

	if (thread@ KeThread_SignalAcceptMask + @ sig@ &)
		STATUS_SIGNALLED ok!
	end
end

fn KeThreadSignal { signal thread -- ok }
	if (signal@ ~~)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	if (signal@ 32 >=)
		STATUS_INVALID_ARGUMENT ok!
		return
	end

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 signal@ << thread@ KeThread_Signals + |=

	thread@ KeThreadWakeForSignal

	ipl@ KeIPLLower
end

fn KeThreadEnqueue { front thread -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadEnqueue: ipl != IPLDPC\n" KeCrash
		end
	end

	// add thread to the tail of the proper ready queue for its priority level

	if (DEBUGCHECKS)
		if (thread@ KeThread_Enqueued + @)
			"KeThreadEnqueue: attempt to enqueue an enqueued thread\n" KeCrash
		end
	end

	1 thread@ KeThread_Enqueued + !

	auto pri
	thread@ KeThread_Priority + @ pri!

	auto t

	if (front@)
		[pri@]KeThreadPriorityQueueHeads@ t!

		if (t@ ~~)
			thread@ [pri@]KeThreadPriorityQueueTails!

			0 thread@ KeThread_QueueNext + !
			0 thread@ KeThread_QueuePrev + !
		end else
			t@ thread@ KeThread_QueueNext + !
			thread@ t@ KeThread_QueuePrev + !

			0 thread@ KeThread_QueuePrev + !
		end

		thread@ [pri@]KeThreadPriorityQueueHeads!
	end else
		[pri@]KeThreadPriorityQueueTails@ t!

		if (t@ ~~)
			thread@ [pri@]KeThreadPriorityQueueHeads!

			0 thread@ KeThread_QueueNext + !
			0 thread@ KeThread_QueuePrev + !
		end else
			thread@ t@ KeThread_QueueNext + !
			t@ thread@ KeThread_QueuePrev + !

			0 thread@ KeThread_QueueNext + !
		end

		thread@ [pri@]KeThreadPriorityQueueTails!
	end
end

fn KeThreadDequeue { thread -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadDequeue: ipl != IPLDPC\n" KeCrash
		end
	end

	// remove thread from the proper ready queue for its priority level

	if (DEBUGCHECKS)
		if (thread@ KeThread_Enqueued + @ ~~)
			"KeThreadDequeue: attempt to dequeue a dequeued thread\n" KeCrash
		end
	end

	0 thread@ KeThread_Enqueued + !

	auto pri
	thread@ KeThread_Priority + @ pri!

	auto n
	thread@ KeThread_QueueNext + @ n!

	if (n@)
		thread@ KeThread_QueuePrev + @ n@ KeThread_QueuePrev + !
	end else // no next means we were the tail
		thread@ KeThread_QueuePrev + @ [pri@]KeThreadPriorityQueueTails!
	end

	auto p
	thread@ KeThread_QueuePrev + @ p!

	if (p@)
		thread@ KeThread_QueueNext + @ p@ KeThread_QueueNext + !
	end else // no prev means we were the head
		thread@ KeThread_QueueNext + @ [pri@]KeThreadPriorityQueueHeads!
	end

	0 thread@ KeThread_QueueNext + !
	0 thread@ KeThread_QueuePrev + !
end

// implements the thread transition state machine

fn KeThreadTransition { status thread front -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadTransition: ipl != IPLDPC\n" KeCrash
		end
	end

	auto oldstatus
	thread@ KeThread_Status + @ oldstatus!

	if (status@ oldstatus@ ==)
		// no change, return
		return
	end

	if (oldstatus@ THREADSTATUS_READY ==)
		// no longer ready, dequeue

		thread@ KeThreadDequeue
	end elseif (status@ THREADSTATUS_READY ==)
		// now ready, enqueue

		front@ thread@ KeThreadEnqueue

		auto current
		KeThreadCurrent@ current!

		if (DEBUGCHECKS)
			if (current@ ~~)
				"KeThreadTransition: no current thread\n" KeCrash
			end
		end

		if (thread@ KeThread_Priority + @ current@ KeThread_Priority + @ >)
			// this thread's priority is greater than the current thread's

			thread@ THREADYIELD_PREEMPTED KeThreadNextSelect
		end
	end

	status@ thread@ KeThread_Status + !
end

externptr MmSwapEvent

fn KeThreadReady { front thread -- }
	auto readytime
	KeTime_SIZEOF alloc readytime!

	readytime@ HALUptimeQuery
	readytime@ KeTime_SecPart + @ thread@ KeThread_WaitOrReadyTimeSec + !

	auto process
	thread@ KeThread_Process + @ process!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	if (process@ KeProcess_MemoryState + @ PROCESSSTATE_RESIDENT ~=)
		// place on process's list of threads pending swapin

		if (DEBUGCHECKS)
			if (thread@ KeThread_SwapListNext + @
				process@ KeProcess_DeferredThreadListHead + @ thread@ == ||)
				thread@ "KeThreadReady: (1) thread %x enqueued on swaplist twice\n" KeCrash
			end
		end

		1 thread@ KeThread_PendingSwapIn + !

		process@ KeProcess_DeferredThreadListHead + @ thread@ KeThread_SwapListNext + !
		thread@ process@ KeProcess_DeferredThreadListHead + !

		if (process@ KeProcess_MemoryState + @ PROCESSSTATE_OUTSWAPPED ==)
			// enqueue process to be swapped in

			PROCESSSTATE_TRANSITION process@ KeProcess_MemoryState + !

			KeProcessSwapInListHead@ process@ KeProcess_SwapListNext + !
			process@ KeProcessSwapInListHead!
		end

		ipl@ KeIPLLower

		0 // priboost
		MmSwapEvent // event
		KeEventSignal

		return
	end elseif (thread@ KeThread_KernelStackResident + @ ~~)
		// place on global list of threads pending swapin

		if (DEBUGCHECKS)
			if (thread@ KeThread_SwapListNext + @
				KeThreadSwapInListHead@ thread@ == ||)
				thread@ "KeThreadReady: (2) thread %x enqueued on swaplist twice\n" KeCrash
			end
		end

		1 thread@ KeThread_PendingSwapIn + !

		KeThreadSwapInListHead@ thread@ KeThread_SwapListNext + !
		thread@ KeThreadSwapInListHead!

		1 process@ KeProcess_ResidentStackCount + +=

		ipl@ KeIPLLower

		0 // priboost
		MmSwapEvent // event
		KeEventSignal

		return
	end

	THREADSTATUS_READY // status
	thread@ // thread
	front@ // front
	KeThreadTransition

	ipl@ KeIPLLower
end

fn KeThreadQuantumIncrement { inc thread -- qt }
	auto rs
	HALCPUInterruptDisable rs!

	thread@ KeThread_Quantum + @ qt!

	inc@ qt +=

	qt@ thread@ KeThread_Quantum + !

	rs@ HALCPUInterruptRestore
end

fn KeThreadQuantumDecrement { dec thread -- qt }
	auto rs
	HALCPUInterruptDisable rs!

	thread@ KeThread_Quantum + @ qt!

	if (qt@ dec@ <=)
		0 qt!
	end else
		dec@ qt -=
	end

	qt@ thread@ KeThread_Quantum + !

	rs@ HALCPUInterruptRestore
end

fn KeThreadQuantumEnd { -- }
	auto current
	KeThreadCurrent@ current!

	if (DEBUGCHECKS)
		if (current@ KeThread_Status + @ THREADSTATUS_RUNNING ~=)
			"KeThreadQuantumEnd: current thread isn't RUNNING\n" KeCrash
		end

		if (current@ KeThread_Enqueued + @)
			"KeThreadQuantumEnd: current thread is RUNNING yet enqueued\n" KeCrash
		end
	end

	// decrement the thread's priority in order to decay boosting.

	auto pri
	current@ KeThread_Priority + @ pri!

	if (pri@ PRIORITY_IDLE >)
		if (pri@ PRIORITY_LOWREALTIME <)
			auto newpri
			pri@ 1 - newpri!

			if (newpri@ current@ KeThread_BasePriority + @ >=)
				newpri@ current@ KeThread_Priority + !
			end
		end
	end

	KeThreadNextPick THREADYIELD_QUANTUMEND KeThreadNextSelect
end

fn (DPCFunction) KeThreadQuantumDPCFunction { context1 context2 -- }
	KeThreadQuantumEnd
end

fn KeThreadNextPick { -- thread }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadNextPick: ipl != IPLDPC\n" KeCrash
		end
	end

	auto i
	PRIORITIES i!

	while (i@)
		1 i -=

		auto h
		[i@]KeThreadPriorityQueueHeads@ h!

		while (h@)
			if (h@ KeThread_Status + @ THREADSTATUS_READY ==)
				h@ thread!

				return
			end else
				"KeThreadNextPick: thread on ready queue but not READY\n" KeCrash
			end

			h@ KeThread_QueueNext + @ h!
		end
	end

	// must be the idle thread, just continue
	KeThreadCurrent@ thread!
end

var InitialContext 0

// should be called with interrupts disabled at IPLDPC.
// current thread should have been transitioned to the proper state beforehand

// XXX maybe this function should be rolled into KeThreadNextSwitch?

fn KeThreadSwitch { thread -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadSwitch: ipl ~= IPLDPC\n" KeCrash
		end
	end

	auto current
	KeThreadCurrent@ current!

	THREADSTATUS_RUNNING // status
	thread@ // thread
	QUEUEBACK // front
	KeThreadTransition

	if (thread@ current@ ==)
		return
	end

	auto old

	if (current@)
		current@ KeThread_Context + old!

		auto nextproc
		thread@ KeThread_Process + @ nextproc!

		if (current@ KeThread_Process + @ KeProcess_PageDirectory + @ nextproc@ KeProcess_PageDirectory + @ ~=)
			nextproc@ KeProcess_ASID + @ // asid
			nextproc@ KeProcess_PageDirectory + @ // addrinfo
			HALCPUAddressSpaceSwitch
		end
	end else
		if (InitialContext@)
			"KeThreadSwitch: two initial contexts?\n" KeCrash
		end

		InitialContext old!
	end

	thread@ KeThreadCurrent!

	auto rs
	HALCPUInterruptDisable rs!

	thread@ KeThread_KernelStackTop + @ KeThreadCurrentStackTop!
	thread@ KeThread_KernelStackBottom + @ KeThreadCurrentStackBottom!

	old@ thread@ KeThread_Context + @ HALCPUContextSwitch

	rs@ HALCPUInterruptRestore

	auto qtm
	current@ KeThread_Quantum + @ qtm!

	if (qtm@ ~~)
		// no more quantum, do a quantum end

		KeThreadQuantumEnd
	end

	if (current@ KeThread_APCListHead + @)
		IPLAPC KeSoftwareInterruptRequest
	end
end

fn KeThreadPrioritySet { priority thread -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadPrioritySet: ipl != IPLDPC\n" KeCrash
		end
	end

	auto pri
	thread@ KeThread_Priority + @ pri!

	if (pri@ priority@ ==)
		return
	end

	if (priority@ pri@ >)
		// the priority has been raised. if the thread is running or waiting,
		// do nothing. however, if the thread is in a ready queue, it must be
		// requeued. if this action raises its priority above that of the
		// current thread, ask the scheduler to run.

		if (thread@ KeThread_Status + @ THREADSTATUS_READY ==)
			thread@ KeThreadDequeue

			priority@ thread@ KeThread_Priority + !

			QUEUEBACK thread@ KeThreadEnqueue

			if (priority@ KeThreadCurrent@ KeThread_Priority + @ >)
				thread@ THREADYIELD_PREEMPTED KeThreadNextSelect
			end
		end else
			if (DEBUGCHECKS)
				if (thread@ KeThread_Enqueued + @)
					"KeThreadPrioritySet: thread was enqueued despite not being READY\n" KeCrash
				end
			end

			priority@ thread@ KeThread_Priority + !
		end
	end else
		// the priority has been lowered. if the thread is in a ready queue,
		// it must be requeued. if the thread is currently running, see if
		// there is now a higher priority thread that can run. if so, ask the
		// scheduler to run.

		auto status
		thread@ KeThread_Status + @ status!

		if (status@ THREADSTATUS_READY ==)
			thread@ KeThreadDequeue

			priority@ thread@ KeThread_Priority + !

			QUEUEBACK thread@ KeThreadEnqueue
		end elseif (status@ THREADSTATUS_RUNNING ==)
			if (DEBUGCHECKS)
				if (thread@ KeThreadCurrent@ ~=)
					"KeThreadPrioritySet: thread is RUNNING, but is not the current thread\n" KeCrash
				end
			end

			priority@ thread@ KeThread_Priority + !

			auto i
			PRIORITIES 1 - i!

			while (i@ priority@ >)
				auto qh
				[i@]KeThreadPriorityQueueHeads@ qh!

				if (qh@)
					qh@ THREADYIELD_PREEMPTED KeThreadNextSelect

					break
				end

				1 i -=
			end
		end
	end
end

fn KeThreadNextSelect { next reason -- }
	auto onext
	KeThreadNext@ onext!

	auto curpri
	KeThreadCurrent@ KeThread_Priority + @ curpri!

	if (reason@ THREADYIELD_QUANTUMEND ==)
		if (curpri@ PRIORITY_IDLE ~=)
			1 KeStatistics OSStatistics_QuantumEnds + +=
		end

		if (curpri@ next@ KeThread_Priority + @ >)
			return
		end
	end elseif (reason@ THREADYIELD_PREEMPTED ==)
		if (curpri@ PRIORITY_IDLE ~=)
			1 KeStatistics OSStatistics_Preemptions + +=
		end
	end

	if (onext@)
		if (next@ KeThread_Priority + @ onext@ KeThread_Priority + @ >=)
			next@ KeThreadNext!
			reason@ KeThreadNextReason!
		end
	end else
		next@ KeThreadNext!
		reason@ KeThreadNextReason!
	end

	if (KeThreadNext@ KeThreadCurrent@ ==)
		// no reschedule required

		0 KeThreadNext!
	end else
		IPLDPC KeSoftwareInterruptRequest
	end
end

fn KeThreadPriorityBoost { boost thread -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadPriorityBoost: ipl != IPLDPC\n" KeCrash
		end
	end

	auto pri
	thread@ KeThread_Priority + @ pri!

	if (pri@ PRIORITY_LOWREALTIME <)
		auto newpri
		thread@ KeThread_BasePriority + @ boost@ + newpri!

		if (newpri@ PRIORITY_HIGHUSER >)
			PRIORITY_HIGHUSER newpri!
		end

		if (newpri@ pri@ >)
			newpri@ thread@ KeThreadPrioritySet
		end
	end
end

fn KeThreadNextSwitch { -- }
	auto next
	KeThreadNext@ next!

	0 KeThreadNext!

	auto current
	KeThreadCurrent@ current!

	auto cause
	KeThreadNextReason@ cause!

	0 KeThreadNextReason!

	if (cause@ THREADYIELD_QUANTUMEND ==)
		// the quantum ended, place it at the back

		current@ KeThread_BaseQuantum + @ current@ KeThread_Quantum + !

		THREADSTATUS_READY current@ QUEUEBACK KeThreadTransition
	end elseif (cause@ THREADYIELD_PREEMPTED ==)
		// it was preempted, place it at the front

		1 current@ KeThreadQuantumDecrement drop

		THREADSTATUS_READY current@ QUEUEFRONT KeThreadTransition
	end else
		cause@ "KeThreadNextSwitch: weird cause (0x%x)\n" KeCrash
	end

	// if a reschedule was deferred, do it here

	// this is done here instead of in a DPC to ensure that the entire
	// DPC queue is processed before the thread switch occurs.

	next@ KeThreadSwitch
end

// for when you want to yield NOW and in a particular state
// this function is used e.g. when waiting on an object

// only called in normal thread context at IPLDPC

fn KeThreadYield { yieldstatus -- }
	if (KeDPCActive@)
		"KeThreadYield: DPC active\n" KeCrash
	end

	auto current
	KeThreadCurrent@ current!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	yieldstatus@ // status
	current@ // thread
	QUEUEBACK // front
	KeThreadTransition

	0 KeThreadNextReason!
	0 KeThreadNext!

	KeThreadNextPick KeThreadSwitch

	ipl@ KeIPLLower
end