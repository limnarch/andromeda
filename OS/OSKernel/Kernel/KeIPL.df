//
// Implements Interrupt Priority Level (IPL) management.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"

#include "<inc>/Kernel.h"

#include "<inc>/HALInterrupt.h"

#include "<ll>/OSDLL/OSStatistics.h"
#include "<ll>/OSDLL/OSContext.h"

#include "KeInternal.h"

externptr KeIPLCurrent

var KiOldIPL 0
public KiOldIPL

var KiDispatchEvents 0
public KiDispatchEvents

fn KeIPLRaise { newipl -- oldipl }
	KeIPLCurrent@ oldipl!

	if (newipl@ oldipl@ ==)
		return
	end

	if (newipl@ oldipl@ <)
		[newipl@]HALIPLNames@ [oldipl@]HALIPLNames@ "IPL not greater or equal (old=%s new=%s)\n" KeCrash
	end

	// only call into the HAL if hardware interrupt level changed.
	// no need to call in for software interrupt levels IPLLOW-IPLDPC.

	newipl@ KeIPLCurrent!

	if (newipl@ IPLDPC >)
		newipl@ HALPlatformIPLSet
	end
end

fn KeIPLLower { newipl -- }
	auto oldipl
	KeIPLCurrent@ oldipl!

	if (newipl@ oldipl@ ==)
		return
	end

	if (newipl@ oldipl@ >)
		[newipl@]HALIPLNames@ [oldipl@]HALIPLNames@ "IPL not less or equal (old=%s new=%s)\n" KeCrash
	end

	if (oldipl@ IPLDPC >)
		newipl@ KeIPLCurrent!
		newipl@ HALPlatformIPLSet
	end

	if (newipl@ IPLDPC >=)
		newipl@ KeIPLCurrent!
		return
	end

	auto rs
	HALCPUInterruptDisable rs!

	if (KiPendingSoftwareInterrupts@)
		auto p
		KiPendingSoftwareInterrupts@ [newipl@]KiPendingSoftwareInterruptMask@ & p!

		while (p@)
			[p@]KiPendingSoftwareInterruptFirst@ KiSoftwareInterruptHandlerF

			KiPendingSoftwareInterrupts@ [newipl@]KiPendingSoftwareInterruptMask@ & p!
		end
	end

	newipl@ KeIPLCurrent!

	rs@ HALCPUInterruptRestore
end

var KiPendingSoftwareInterrupts 0
public KiPendingSoftwareInterrupts

table KiPendingSoftwareInterruptMask
	6 // IPLLOW (none masked)
	4 // IPLAPC (APCs masked)
endtable
public KiPendingSoftwareInterruptMask

table KiPendingSoftwareInterruptFirst // which to service first based on the mask
	0                                // 0
	0                                // 1
	pointerof KiSoftwareInterruptAPC // 2
	pointerof KiSoftwareInterruptAPC // 3
	pointerof KiSoftwareInterruptDPC // 4
	pointerof KiSoftwareInterruptDPC // 5
	pointerof KiSoftwareInterruptDPC // 6
	pointerof KiSoftwareInterruptDPC // 7
endtable
public KiPendingSoftwareInterruptFirst

fn (KiSoftwareInterruptHandlerF) KiSoftwareInterruptAPC { -- }
	1 IPLAPC << ~ KiPendingSoftwareInterrupts &=

	IPLAPC KeIPLCurrent!

	if (KeThreadCurrent@ KeThread_APCListHead + @)
		HALCPUInterruptEnable

		KiAPCDispatchQueue

		HALCPUInterruptDisable drop
	end
end

fn (KiSoftwareInterruptHandlerF) KiSoftwareInterruptDPC { -- }
	1 IPLDPC << ~ KiPendingSoftwareInterrupts &=

	auto events
	KiDispatchEvents@ events!
	0 KiDispatchEvents!

	IPLDPC KeIPLCurrent!

	HALCPUInterruptEnable

	if (events@ KIDISPATCHIRQ_DPC &)
		KiDPCDispatchQueue
	end

	if (events@ KIDISPATCHIRQ_TIMER &)
		KiTimerExpiration
	end

	if (events@ KIDISPATCHIRQ_QUANTUMEND &)
		KiThreadQuantumEnd
	end

	if (KiThreadNext@)
		KiThreadNextSwitch
	end

	HALCPUInterruptDisable drop
end

fn KiSoftwareInterruptRequest { ipl -- }
	auto rs
	HALCPUInterruptDisable rs!

	1 ipl@ << KiPendingSoftwareInterrupts |=

	rs@ HALCPUInterruptRestore
end

fn KeClockTick { uptime interval trapframe -- }
	// run from interrupt context.

	auto stats
	KeStatistics stats!

	// update the number of clock ticks.

	1 stats@ OSStatistics_ClockTicks + +=

	// update the amount of time spent at the previous IPL.

	interval@ stats@ OSStatistics_IPLTimes + KiOldIPL@ 2 << + +=

	auto cmp
	KiTimerExpirationEarliest KeTime_SecPart + @ uptime@ KeTime_SecPart + @ - cmp!

	if (cmp@ ~~)
		if (KiTimerExpirationEarliest KeTime_MsPart + @ uptime@ KeTime_MsPart + @ <=)
			KIDISPATCHIRQ_TIMER KiDispatchEvents |=
			1 IPLDPC << KiPendingSoftwareInterrupts |=
		end
	end elseif (cmp@ z<)
		KIDISPATCHIRQ_TIMER KiDispatchEvents |=
		1 IPLDPC << KiPendingSoftwareInterrupts |=
	end

	if (KeDPCActive@)
		interval@ stats@ OSStatistics_DPCTimeMs + +=
	end

	auto cth
	KeThreadCurrent@ cth!

	if (cth@ ~~)
		return
	end

	auto process
	cth@ KeThread_Process + @ process!

#ifdef XR17032
	if (trapframe@ OSContext_ers + @ XR17032_ERS_USER &)
#endif
#ifdef FOX32
	if (trapframe@ OSContext_eflagsB + gb FOX32_RS_USER &)
#endif
		interval@ cth@ KeThread_UserTimeMs + +=
		interval@ process@ KeProcess_UserTimeMs + +=
	end elseif (KiOldIPL@ IPLDPC ==)
		interval@ cth@ KeThread_DPCTimeMs + +=
		interval@ process@ KeProcess_DPCTimeMs + +=
	end else
		interval@ cth@ KeThread_SystemTimeMs + +=
		interval@ process@ KeProcess_SystemTimeMs + +=
	end

	auto qt
	cth@ KeThread_QuantumB + gb qt!

	QUANTUMUNITSPERTICK qt -=

	if (qt@ z<)
		0 qt!
	end

	if (qt@ ~~)
		KIDISPATCHIRQ_QUANTUMEND KiDispatchEvents |=
		1 IPLDPC << KiPendingSoftwareInterrupts |=
	end

	qt@ cth@ KeThread_QuantumB + sb
end