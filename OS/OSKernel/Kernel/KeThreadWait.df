//
// Implements object dispatch.
// Supports waiting for multiple objects at a time, and for any (OSWAITANY)
// or all (OSWAITALL) to become signalled.
//

#include "<df>/dragonfruit.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALRTC.h"

#include "<inc>/Kernel.h"

#include "<ll>/OSDLL/OS.h"

var KeThreadWaitListHead 0
public KeThreadWaitListHead

// initializes a dispatch object's header

fn KeDispatchInitialize { name type dobject -- }
	0 dobject@ KeDispatchHeader_Signaled + !

	type@ dobject@ KeDispatchHeader_Type + !

	name@ dobject@ KeDispatchHeader_Name + !

	0 dobject@ KeDispatchHeader_WaitBlockListHead + !
	0 dobject@ KeDispatchHeader_WaitBlockListTail + !
end

fn KeDispatchIsSignaled { dobject -- signaled }
	dobject@ KeDispatchHeader_Signaled + @ z> signaled!
end

// initializes a WaitBlock

fn KeDispatchWaitBlockInitialize { thread waitblock -- }
	0 waitblock@ KeDispatchWaitBlock_Prev + !
	0 waitblock@ KeDispatchWaitBlock_Next + !

	0 waitblock@ KeDispatchWaitBlock_WaitStatusReturn + !
	0 waitblock@ KeDispatchWaitBlock_WaitType + !

	thread@ waitblock@ KeDispatchWaitBlock_Thread + !

	0 waitblock@ KeDispatchWaitBlock_Object + !

	0 waitblock@ KeDispatchWaitBlock_WaitIndex + !
end

fn KeDispatchWaitBlockDequeue { waitstatus waitblock -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeDispatchWaitBlockDequeue: ipl != IPLDPC\n" KeCrash
		end

		if (waitblock@ KeDispatchWaitBlock_Object + @ ~~)
			"KeDispatchWaitBlockDequeue: attempt to dequeue a non-enqueued WaitBlock\n" KeCrash
		end
	end

	auto object
	waitblock@ KeDispatchWaitBlock_Object + @ object!

	auto n
	waitblock@ KeDispatchWaitBlock_Next + @ n!

	if (n@)
		waitblock@ KeDispatchWaitBlock_Prev + @ n@ KeDispatchWaitBlock_Prev + !
	end else // no next means we were the tail
		waitblock@ KeDispatchWaitBlock_Prev + @ object@ KeDispatchHeader_WaitBlockListTail + !
	end

	auto p
	waitblock@ KeDispatchWaitBlock_Prev + @ p!

	if (p@)
		waitblock@ KeDispatchWaitBlock_Next + @ p@ KeDispatchWaitBlock_Next + !
	end else // no prev means we were the head
		waitblock@ KeDispatchWaitBlock_Next + @ object@ KeDispatchHeader_WaitBlockListHead + !
	end

	0 waitblock@ KeDispatchWaitBlock_Next + !
	0 waitblock@ KeDispatchWaitBlock_Prev + !

	0 waitblock@ KeDispatchWaitBlock_Object + !

	waitstatus@ waitblock@ KeDispatchWaitBlock_WaitStatusReturn + !
end

// adds a WaitBlock to the tail of a dispatch object's WaitBlockList

fn KeDispatchWaitBlockEnqueue { waitindex waittype waitblock object -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeDispatchWaitBlockInsert: ipl != IPLDPC\n" KeCrash
		end

		if (waitblock@ KeDispatchWaitBlock_Object + @)
			"KeDispatchWaitBlockEnqueue: attempt to queue an enqueued WaitBlock\n" KeCrash
		end
	end

	object@ waitblock@ KeDispatchWaitBlock_Object + !
	waittype@ waitblock@ KeDispatchWaitBlock_WaitType + !
	waitindex@ waitblock@ KeDispatchWaitBlock_WaitIndex + !

	auto t
	object@ KeDispatchHeader_WaitBlockListTail + @ t!

	if (t@ ~~)
		waitblock@ object@ KeDispatchHeader_WaitBlockListHead + !
		waitblock@ object@ KeDispatchHeader_WaitBlockListTail + !
		return
	end

	// seek to the appropriate place to put this waitblock based on priority.

	auto pri
	waitblock@ KeDispatchWaitBlock_Thread + @ KeThread_Priority + @ pri!

	while (t@)
		if (t@ KeDispatchWaitBlock_Thread + @ KeThread_Priority + @ pri@ >=)
			break
		end

		t@ KeDispatchWaitBlock_Prev + @ t!
	end

	// insert after t.

	if (t@ ~~)
		// nobody was higher priority, place at head

		object@ KeDispatchHeader_WaitBlockListHead + @ t!

		waitblock@ t@ KeDispatchWaitBlock_Prev + !
		t@ waitblock@ KeDispatchWaitBlock_Next + !

		waitblock@ object@ KeDispatchHeader_WaitBlockListHead + !

		return
	end

	auto n
	t@ KeDispatchWaitBlock_Next + @ n!

	if (n@)
		waitblock@ n@ KeDispatchWaitBlock_Prev + !
		n@ waitblock@ KeDispatchWaitBlock_Next + !
	end else
		waitblock@ object@ KeDispatchHeader_WaitBlockListTail + !
	end

	waitblock@ t@ KeDispatchWaitBlock_Next + !

	t@ waitblock@ KeDispatchWaitBlock_Prev + !
end

// satisfies a WaitBlock

fn KeDispatchWaitBlockSatisfy { waitstatus priboost waitblock -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeDispatchWaitBlockSatisfy: ipl != IPLDPC\n" KeCrash
		end
	end

	waitstatus@ waitblock@ KeDispatchWaitBlockDequeue

	auto thread
	waitblock@ KeDispatchWaitBlock_Thread + @ thread!

	1 thread@ KeThread_WaitCount + -=

	auto wt
	waitblock@ KeDispatchWaitBlock_WaitType + @ wt!

	if (wt@ OSWAITANY ==)
		waitblock@ KeDispatchWaitBlock_WaitIndex + @ // waitstatus
		priboost@ // priboost
		thread@ // thread
		KeThreadWakeup drop
	end elseif (wt@ OSWAITALL ==)
		if (thread@ KeThread_WaitCount + @ 0 ==)
			0 priboost@ thread@ KeThreadWakeup drop
		end
	end
end

// satisfies all waiters on a dispatch object
// this SIGNALS the object

fn KeDispatchSatisfyAll { waitstatus priboost object -- count }
	0 count!

	auto ipl
	IPLDPC KeIPLRaise ipl!

	1 object@ KeDispatchHeader_Signaled + !

	auto h
	object@ KeDispatchHeader_WaitBlockListHead + @ h!

	auto wb

	while (h@)
		h@ wb!
		h@ KeDispatchWaitBlock_Next + @ h!

		waitstatus@ priboost@ wb@ KeDispatchWaitBlockSatisfy

		1 count +=
	end

	ipl@ KeIPLLower
end

// satisfies the highest priority, earliest wait on a dispatch object.
// this signals the object if no thread was awoken and signal is 1.

fn KeDispatchSatisfyFirst { waitstatus priboost object signal -- wokenthread }
	auto ipl
	IPLDPC KeIPLRaise ipl!

	auto h
	object@ KeDispatchHeader_WaitBlockListHead + @ h!

	if (h@)
		h@ KeDispatchWaitBlock_Thread + @ wokenthread!
		waitstatus@ priboost@ h@ KeDispatchWaitBlockSatisfy
	end elseif (signal@)
		0 wokenthread!
		1 object@ KeDispatchHeader_Signaled + !
	end

	ipl@ KeIPLLower
end

fn KeThreadWaitForMultipleObjects { waitmode alertable waittype timeout objectcount objecttable -- ok }
	0 ok!

	if (objectcount@ 0 ==)
		return
	end

	if (objectcount@ THREADWAITBLOCKS >)
		"KeThreadWaitForMultipleObjects: objectcount>THREADWAITBLOCKS\n" KeCrash
	end

	auto current
	KeThreadCurrent@ current!

	auto i
	0 i!

	auto waitblock
	current@ KeThread_WaitBlocks + waitblock! // now points to current thread's first waitblock

	auto satisfied

	waittype@ OSWAITANY ~= satisfied!

	auto waitipl
	IPLDPC KeIPLRaise waitipl!

	while (i@ objectcount@ <)
		auto object
		objecttable@ i@ 2 << + @ object!

		if (waittype@ OSWAITANY ==)
			if (object@ KeDispatchHeader_Type + @ DISPATCHOBJECT_MUTEX ==)
				if (object@ KeDispatchHeader_Signaled + @ z>)
					// yoink!

					current@ // thread
					object@ // mutex
					KeMutexOwnerSet

					i@ ok!

					1 satisfied!

					break
				end elseif (object@ KeMutex_OwningThread + @ current@ ==)
					if (object@ KeDispatchHeader_Signaled + @ 0x80000000 ==)
						// recursively acquiring this mutex again would cause
						// an underflow.

						current@ KeThreadWaitBlocksDequeue

						waitipl@ KeIPLLower

						STATUS_OVERFLOW ok!

						return
					end

					i@ ok!

					1 object@ KeDispatchHeader_Signaled + -=

					1 satisfied!

					break
				end
			end else
				if (object@ KeDispatchHeader_Signaled + @ z>)
					if (object@ KeDispatchHeader_Type + @ DISPATCHOBJECT_EVENTSYNCH ==)
						0 object@ KeDispatchHeader_Signaled + !
					end elseif (object@ KeDispatchHeader_Type + @ DISPATCHOBJECT_SEMAPHORE ==)
						1 object@ KeDispatchHeader_Signaled + -=
					end

					i@ ok!

					1 satisfied!

					break
				end
			end
		end else
			if (object@ KeDispatchHeader_Type + @ DISPATCHOBJECT_MUTEX ==)
				if (object@ KeDispatchHeader_Signaled + @ z> ~~)
					if (object@ KeMutex_OwningThread + @ current@ ==)
						if (object@ KeDispatchHeader_Signaled + @ 0x80000000 ==)
							// recursively acquiring this mutex again would cause
							// an underflow.

							current@ KeThreadWaitBlocksDequeue

							waitipl@ KeIPLLower

							STATUS_OVERFLOW ok!

							return
						end
					end else
						0 satisfied!
					end
				end
			end elseif (object@ KeDispatchHeader_Signaled + @ z> ~~)
				0 satisfied!
			end
		end

		if (timeout@)
			i@ // waitindex
			waittype@ // waittype
			waitblock@ // waitblock
			object@ // object
			KeDispatchWaitBlockEnqueue
		end

		KeDispatchWaitBlock_SIZEOF waitblock +=
		1 i +=
	end

	if (timeout@ ~~)
		// no timeout. just return even if the wait wasn't satisfied

		waitipl@ KeIPLLower

		satisfied@ ok!

		return
	end elseif (satisfied@)
		// the wait is already satisfied. dequeue any wait blocks we just
		// enqueued and then return.

		current@ KeThreadWaitBlocksDequeue

		waitipl@ KeIPLLower

		return
	end

	waitmode@ // mode
	alertable@ // alertable
	current@ // thread
	KeThreadIsKilled ok!

	if (ok@)
		// we died, don't sleep

		current@ KeThreadWaitBlocksDequeue

		waitipl@ KeIPLLower

		return
	end

	objectcount@ current@ KeThread_WaitCount + !

	if (timeout@ OSWAIT_TIMEOUTINFINITE ~=)
		// there's a timeout and its not infinite, set up a timer waitblock

		"WaitTimeout" // name
		0 // function
		current@ KeThread_Timer + // timer
		KeTimerInitialize

		current@ KeThread_TimeoutWaitBlock + waitblock!

		STATUS_WAIT_TIMEOUT // waitindex
		OSWAITANY // waittype
		waitblock@ // waitblock
		current@ KeThread_Timer + // object
		KeDispatchWaitBlockEnqueue

		0 // context1
		0 // context2
		timeout@ // interval
		current@ KeThread_Timer + // timer
		KeTimerEnqueue
	end

	waitipl@ // waitipl
	waitmode@ // waitmode
	alertable@ // alertable
	KeThreadWait ok!

	waitipl@ KeIPLLower
end

fn KeThreadWaitForObject { waitmode alertable timeout object -- ok }
	// implemented redundantly with KeThreadWaitForMultipleObjects because
	// this is the most common case and is therefore speed-critical.

	auto current
	KeThreadCurrent@ current!

	0 ok!

	auto waitipl
	IPLDPC KeIPLRaise waitipl!

	if (object@ KeDispatchHeader_Type + @ DISPATCHOBJECT_MUTEX ==)
		if (object@ KeDispatchHeader_Signaled + @ z>)
			// yoink!

			current@ // thread
			object@ // mutex
			KeMutexOwnerSet

			waitipl@ KeIPLLower

			if (timeout@ ~~)
				1 ok!
			end

			return
		end elseif (object@ KeMutex_OwningThread + @ current@ ==)
			if (object@ KeDispatchHeader_Signaled + @ 0x80000000 ==)
				// recursively acquiring this mutex again would cause
				// an underflow.

				waitipl@ KeIPLLower

				STATUS_OVERFLOW ok!

				return
			end

			1 object@ KeDispatchHeader_Signaled + -=

			waitipl@ KeIPLLower

			if (timeout@ ~~)
				1 ok!
			end

			return
		end
	end else
		if (object@ KeDispatchHeader_Signaled + @ z>)
			if (object@ KeDispatchHeader_Type + @ DISPATCHOBJECT_EVENTSYNCH ==)
				0 object@ KeDispatchHeader_Signaled + !
			end elseif (object@ KeDispatchHeader_Type + @ DISPATCHOBJECT_SEMAPHORE ==)
				1 object@ KeDispatchHeader_Signaled + -=
			end

			waitipl@ KeIPLLower

			if (timeout@ ~~)
				1 ok!
			end

			return
		end
	end

	if (timeout@ ~~)
		// no timeout. just return that the wait wasn't satisfied

		waitipl@ KeIPLLower

		0 ok!

		return
	end

	waitmode@ // mode
	alertable@ // alertable
	current@ // thread
	KeThreadIsKilled ok!

	if (ok@)
		// we died, don't go to sleep

		waitipl@ KeIPLLower

		return
	end

	0 // waitindex
	OSWAITANY // waittype
	current@ KeThread_WaitBlocks + // waitblock
	object@ // object
	KeDispatchWaitBlockEnqueue

	if (timeout@ OSWAIT_TIMEOUTINFINITE ~=)
		// there's a timeout and its not infinite, set up a timer waitblock

		"WaitTimeout" // name
		0 // function
		current@ KeThread_Timer + // timer
		KeTimerInitialize

		STATUS_WAIT_TIMEOUT // waitindex
		OSWAITANY // waittype
		current@ KeThread_TimeoutWaitBlock + // waitblock
		current@ KeThread_Timer + // object
		KeDispatchWaitBlockEnqueue

		0 // context1
		0 // context2
		timeout@ // interval
		current@ KeThread_Timer + // timer
		KeTimerEnqueue
	end

	waitipl@ // waitipl
	waitmode@ // waitmode
	alertable@ // alertable
	KeThreadWait ok!

	waitipl@ KeIPLLower
end

fn KeThreadWakeup { waitstatus priboost thread -- woken }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadWakeup: ipl != IPLDPC\n" KeCrash
		end
	end

	0 woken!

	auto status
	thread@ KeThread_Status + @ status!

	if (status@ THREADSTATUS_WAITINGALERTABLE ~= status@ THREADSTATUS_WAITINGUNALERTABLE ~= &&)
		// thread isn't waiting

		return
	end

	// remove from global wait list

	auto n
	thread@ KeThread_QueueNext + @ n!

	if (n@)
		thread@ KeThread_QueuePrev + @ n@ KeThread_QueuePrev + !
	end

	auto p
	thread@ KeThread_QueuePrev + @ p!

	if (p@)
		thread@ KeThread_QueueNext + @ p@ KeThread_QueueNext + !
	end else // no prev means we were the head
		thread@ KeThread_QueueNext + @ KeThreadWaitListHead!
	end

	0 thread@ KeThread_QueueNext + !
	0 thread@ KeThread_QueuePrev + !

	// wake up thread

	thread@ KeThreadWaitBlocksDequeue

	if (thread@ KeThread_Timer + KeTimer_Enqueued + @)
		thread@ KeThread_Timer + KeTimerDequeue
	end

	if (priboost@)
		priboost@ thread@ KeThreadPriorityBoost
	end

	waitstatus@ thread@ KeThread_WaitStatus + !
	QUEUEBACK thread@ KeThreadReady

	1 woken!
end

fn KeThreadWaitBlocksDequeue { thread -- }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadWaitBlocksDequeue: ipl != IPLDPC\n" KeCrash
		end
	end

	auto wb
	thread@ KeThread_WaitBlocks + wb!

	auto i
	0 i!

	while (i@ THREADWAITBLOCKS <)
		if (wb@ KeDispatchWaitBlock_Object + @)
			0 // waitstatus
			wb@ // waitblock
			KeDispatchWaitBlockDequeue
		end

		1 i +=
		KeDispatchWaitBlock_SIZEOF wb +=
	end

	thread@ KeThread_TimeoutWaitBlock + wb!

	if (wb@ KeDispatchWaitBlock_Object + @)
		0 // waitstatus
		wb@ // waitblock
		KeDispatchWaitBlockDequeue
	end
end

fn KeThreadWait { waitipl waitmode alertable -- ok }
	if (DEBUGCHECKS)
		if (KeIPLCurrentGet IPLDPC ~=)
			"KeThreadWait: ipl != IPLDPC\n" KeCrash
		end

		if (waitipl@ IPLDPC >=)
			"KeThreadWait: waitipl >= IPLDPC\n" KeCrash
		end
	end

	auto current
	KeThreadCurrent@ current!

	// insert in global wait list

	auto h
	KeThreadWaitListHead@ h!

	0 current@ KeThread_QueueNext + !
	0 current@ KeThread_QueuePrev + !

	if (h@)
		current@ h@ KeThread_QueuePrev + !
		h@ current@ KeThread_QueueNext + !
	end

	current@ KeThreadWaitListHead!

	// go to sleep

	auto waittime
	KeTime_SIZEOF alloc waittime!

	waittime@ HALUptimeQuery
	waittime@ KeTime_SecPart + @ current@ KeThread_WaitOrReadyTimeSec + !

	waitmode@ current@ KeThread_WaitMode + !
	waitipl@ current@ KeThread_WaitIPL + !
	0 current@ KeThread_WaitStatus + !

	if (alertable@)
		THREADSTATUS_WAITINGALERTABLE KeThreadYield
	end else
		THREADSTATUS_WAITINGUNALERTABLE KeThreadYield
	end

	current@ KeThread_WaitStatus + @ ok!
end

fn KeThreadSleep { ms waitmode alertable -- ok }
	0 ok!	

	if (ms@ 0 ==)
		THREADSTATUS_READY KeThreadYield

		return
	end

	auto current
	KeThreadCurrent@ current!

	"KeThreadSleep" // name
	0 // function
	current@ KeThread_Timer + // timer
	KeTimerInitialize

	0 // context1
	0 // context2
	ms@ // interval
	current@ KeThread_Timer + // timer
	KeTimerEnqueue

	waitmode@ // waitmode
	alertable@ // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	current@ KeThread_Timer + // object
	KeThreadWaitForObject ok!

	if (ok@ ~~)
		STATUS_WAIT_TIMEOUT ok!
	end
end