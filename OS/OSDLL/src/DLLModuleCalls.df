#include "<df>/dragonfruit.h"

#include "<inc>/OSCalls.h"
#include "<inc>/OSMap.h"
#include "<inc>/OSFile.h"
#include "<inc>/OSAbort.h"
#include "<inc>/OSAccess.h"
#include "<inc>/OSObject.h"
#include "<inc>/OSStatus.h"
#include "<inc>/OSModule.h"
#include "<inc>/OSAlloc.h"
#include "<inc>/OSWait.h"

#include "OSDLL.h"
#include "LOFF.h"
#include "Module.h"

fn OSGetSymbolAddress { name dll -- address ok }
	auto symbol
	name@ dll@ DLLGetSymbol ok! symbol!

	if (ok@)
		return
	end

	auto head
	dll@ OSModule_HeadVAddr + @ head!

	auto sectionheader

	if (symbol@ LOFFSymbol_Section + @ LOFFTEXT ==)
		head@ LOFFHeader_TextHeader + @ head@ + sectionheader!
	end elseif (symbol@ LOFFSymbol_Section + @ LOFFDATA ==)
		head@ LOFFHeader_DataHeader + @ head@ + sectionheader!
	end elseif (symbol@ LOFFSymbol_Section + @ LOFFBSS ==)
		head@ LOFFHeader_BSSHeader + @ head@ + sectionheader!
	end else
		STATUS_BAD_EXECUTABLE ok!

		return
	end

	symbol@ LOFFSymbol_Value + @ address!

	sectionheader@ LOFFSectionHeader_LinkedAddress + @ address +=
end

fn OSModuleLoad { flags name -- dll ok }
	name@ DLLModuleFindByName ok! dll!

	if (ok@ ~~)
		// already loaded, increment load count and return

		1 dll@ OSModule_LoadCount + +=

		return
	end

	// not loaded. load it

	auto handle
	name@ DLLModuleOpenFile ok! handle!

	if (ok@)
		if (flags@ OSMODULELOAD_MAINIMAGE & ~~)
			if (DLLProcessInit@)
				ok@ OSStatusGetName
				name@
				"LINK ERROR: couldn't open image %s: %s\n" OSGetStdErr FPrintf

				if (ok@ STATUS_NOT_FOUND ==)
					STATUS_BAD_EXECUTABLE ok!
				end
			end
		end

		return
	end

	auto header
	LOFFHeader_SIZEOF alloc header!

	auto bytesread

	// read in header

	OSWAIT_TIMEOUTINFINITE // timeout
	0 // flags
	LOFFHeader_SIZEOF // length
	header@ // buffer
	handle@ // filehandle
	OSFileRead ok! bytesread!

	if (ok@)
		handle@ OSClose drop

		return
	end

	// verify parameters

	if (bytesread@ LOFFHeader_SIZEOF <)
		handle@ OSClose drop

		STATUS_BAD_EXECUTABLE ok!
		return
	end

	if (header@ LOFFHeader_Magic + @ LOFFMAGIC ~=)
		handle@ OSClose drop

		STATUS_BAD_EXECUTABLE ok!
		return
	end

	if (header@ LOFFHeader_TargetArchitecture + @ LOFFARCHITECTURE ~=)
		handle@ OSClose drop

		STATUS_EXEC_NOT_FOR_ARCH ok!
		return
	end

	// create a module block

	name@ DLLModuleCreate ok! dll!

	if (ok@)
		handle@ OSClose drop

		return
	end

	auto section

	// create section

	PAGEACCESS_READ PAGEACCESS_EXEC | // pageprotection
	0 // anonsize
	handle@ // filehandle
	ACCESS_OWNER_ALL // permissions
	0 // name
	OSSectionCreate ok! section!

	// don't need file handle anymore
	handle@ OSClose drop

	if (ok@)
		dll@ DLLModuleDelete

		return
	end

	// find out head size

	auto headsz
	header@ LOFFHeader_BSSHeader + @ LOFFSectionHeader_SIZEOF + headsz!

	auto head

	// map in the head

	headsz@ // length
	OSDLLHEAD // startva
	0 // sectionoffset
	section@ // sectionhandle
	OSCURRENTPROCESS // processhandle
	PAGEACCESS_READ PAGEACCESS_WRITECOPY | // pageprotection
	0 // flags
	OSSectionMapView ok! head!

	if (ok@)
		dll@ DLLModuleDelete

		section@ OSClose drop

		return
	end

	// initialize module block.

	head@ dll@ OSModule_HeadVAddr + !
	headsz@ dll@ OSModule_HeadLength + !
	OSMODULEFORMAT_LOFF dll@ OSModule_Format + !

	dll@ DLLModuleDoImports ok!

	if (ok@)
		dll@ DLLModuleDelete

		headsz@ // length
		head@ // vaddr
		OSCURRENTPROCESS // processhandle
		OSUnmapView drop

		section@ OSClose drop

		return
	end

	if (name@ "OSDLL.dll" strcmp ~~)
		OSMODULEFLAGS_SHOULDINIT dll@ OSModule_Flags + |=

		// map module sections.
		// skip this part for OSDLL since the kernel maps that in for us.

		section@ // section
		dll@ // dll
		DLLModuleMap ok!

		// don't need section handle anymore

		section@ OSClose drop

		if (ok@)
			-1 dll@ DLLModuleUndoImports

			dll@ DLLModuleDelete

			headsz@ // length
			head@ // vaddr
			OSCURRENTPROCESS // processhandle
			OSUnmapView drop

			return
		end
	end else
		section@ OSClose drop
	end

	if (dll@ OSModule_Flags + @ OSMODULEFLAGS_REBASEEITHER &)
		// needs to be rebased

		dll@ DLLModuleRebase ok!

		if (ok@)
			dll@ DLLModuleUnmap

			-1 dll@ DLLModuleUndoImports

			dll@ DLLModuleDelete

			headsz@ // length
			head@ // vaddr
			OSCURRENTPROCESS // processhandle
			OSUnmapView drop

			return
		end
	end

	// add to tail of module list.

	auto ospeb
	OSPEB ospeb!

	auto t
	ospeb@ OSPEBs_DLLListTail + @ t!

	if (t@ ~~)
		0 dll@ OSModule_Next + !
		0 dll@ OSModule_Prev + !

		dll@ ospeb@ OSPEBs_DLLListHead + !
		dll@ ospeb@ OSPEBs_DLLListTail + !
	end else
		0 dll@ OSModule_Next + !

		t@ dll@ OSModule_Prev + !
		dll@ t@ OSModule_Next + !
		dll@ ospeb@ OSPEBs_DLLListTail + !
	end

	// call init function

	auto func

	if (dll@ OSModule_Flags + @ OSMODULEFLAGS_SHOULDINIT &)
		"DLLMain" // name
		dll@ // dll
		OSGetSymbolAddress ok! func!

		if (ok@ ~~)
			func@ OSModuleMainFunction ok!

			if (ok@)
				dll@ OSModuleUnload

				return
			end
		end

		0 ok!
	end
end

fn OSModuleUnload { dll -- }
	// unloads an already fully loaded module

	if (dll@ OSModule_LoadCount + @ 0 ==)
		"OSModuleUnload: underflow\n" OSAbort
	end

	1 dll@ OSModule_LoadCount + -=

	if (dll@ OSModule_LoadCount + @)
		// still has references

		return
	end

	// no more references, unload for real

	if (dll@ OSModule_Name + @ "OSDLL.dll" strcmp)
		1 dll@ OSModule_LoadCount + !
		return
	end

	auto ok
	auto func

	// call unload function
	"DLLUnload" // name
	dll@ // dll
	OSGetSymbolAddress ok! func!

	if (ok@ ~~)
		func@ OSModuleUnloadFunction
	end

	// unmap sections
	dll@ DLLModuleUnmap

	// unload dependencies
	-1 dll@ DLLModuleUndoImports

	// unmap head
	dll@ OSModule_HeadLength + @ // length
	dll@ OSModule_HeadVAddr + @ // vaddr
	OSCURRENTPROCESS // processhandle
	OSUnmapView drop

	// unlink from module list

	auto ls
	dll@ OSModule_Prev + @ ls!

	auto ns
	dll@ OSModule_Next + @ ns!

	if (ls@)
		ns@ ls@ OSModule_Next + !
	end else
		ns@ OSPEB OSPEBs_DLLListHead + !
	end

	if (ns@)
		ls@ ns@ OSModule_Prev + !
	end else
		ls@ OSPEB OSPEBs_DLLListTail + !
	end

	0 dll@ OSModule_Prev + !
	0 dll@ OSModule_Next + !

	// destroy
	dll@ DLLModuleDelete
end