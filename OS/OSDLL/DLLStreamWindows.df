//
// Implements stream window management.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OSCalls.h"
#include "<ll>/OSDLL/OSMap.h"
#include "<ll>/OSDLL/OSFile.h"
#include "<ll>/OSDLL/OSAbort.h"
#include "<ll>/OSDLL/OSAccess.h"
#include "<ll>/OSDLL/OSObject.h"
#include "<ll>/OSDLL/OSStatus.h"
#include "<ll>/OSDLL/OSStream.h"
#include "<ll>/OSDLL/OSFastMutex.h"
#include "<ll>/OSDLL/OSWait.h"

#include "OSDLL.h"

//
// A stream window is a region into which a buffered file can be mapped.
// These are managed globally (to the process).
//

buffer DLLStreamWCBTable (DLLStreamWCB_SIZEOF DLLSTREAMWCBCOUNT *)

var DLLStreamWCBFreeListHead 0

var DLLStreamWCBReclaimableListHead 0
var DLLStreamWCBReclaimableListTail 0

var DLLStreamWCBAvailableEvent 0
var DLLStreamWCBWaiters 0

buffer DLLStreamWCBFastMutex OSFastMutex_SIZEOF

fn DLLStreamInit { -- }
	"DLLStreamWCBFastMutex" // name
	DLLStreamWCBFastMutex // fastmutex
	OSFastMutexInitialize

	// link all of the WCBs into the free list

	auto i
	0 i!

	auto wcb
	DLLStreamWCBTable wcb!

	while (i@ DLLSTREAMWCBCOUNT <)
		DLLStreamWCBFreeListHead@ wcb@ DLLStreamWCB_FreeNext + !

		if (DLLStreamWCBFreeListHead@)
			wcb@ DLLStreamWCBFreeListHead@ DLLStreamWCB_FreePrev + !
		end

		wcb@ DLLStreamWCBFreeListHead!

		DLLStreamWCB_SIZEOF wcb +=
		1 i +=
	end

	// create stream for stdout

	auto ok
	-1 ok!

	auto stream

	if (OSPEB OSPEBs_StdOut + @ DLLNOSTREAM ~=)
		OSSTREAMTYPE_LINEBUFFER // flags
		ACCESS_WRITE // access
		OSPEB OSPEBs_StdOut + @ // filehandle
		OSStreamObjectCreate ok! stream!

		if (ok@ ~~)
			stream@ DLLStdOutStream!
		end
	end
end

// a global DLLStreamWCBFastMutex protects the free and reclaimable WCB lists.
// when a WCB is in use by a transfer, it is refcounted to remove it from the
// reclaimable list. this is to avoid having to hold that mutex during the
// entire transfer. if an allocation occurs while there are no free or
// reclaimable WCBs available, then an event object is allocated from the
// kernel (if that has not already been done) and it is slept on until a WCB
// is available. the event is signalled when a transfer completes and a WCB is
// released onto the reclaimable or free list.

fn DLLStreamWindowAllocate { offset streamptr -- wcb ok }
	// assumes DLLStreamWCBFastMutex held.

	0 ok!

	DLLStreamWindowGet wcb!

	if (wcb@ ~~)
		if (DLLStreamWCBAvailableEvent@ ~~)
			0 // signaled
			OSEVENT_SYNCH // type
			ACCESS_OWNER_ALL // permissions
			"DLLStreamWCBAvailableEvent" // name
			OSEventCreate ok! DLLStreamWCBAvailableEvent!

			if (ok@)
				return
			end
		end

		auto wcbmutex
		DLLStreamWCBFastMutex wcbmutex!

		while (wcb@ ~~)
			1 DLLStreamWCBWaiters +=

			wcbmutex@ OSFastMutexRelease

			1 // alertable
			250 // timeout
			DLLStreamWCBAvailableEvent@ // objecthandle
			OSWaitForObject ok!

			wcbmutex@ OSFastMutexAcquire

			1 DLLStreamWCBWaiters -=

			if (ok@)
				if (ok@ STATUS_WAIT_TIMEOUT ~=)
					return
				end
			end

			DLLStreamWindowGet wcb!
		end
	end

	// initialize the WCB

	0 wcb@ DLLStreamWCB_FreeNext + !
	0 wcb@ DLLStreamWCB_FreePrev + !

	streamptr@ wcb@ DLLStreamWCB_StreamPtr + !

	1 wcb@ DLLStreamWCB_RefCount + !

	0 wcb@ DLLStreamWCB_VirtualAddress + !

	offset@ wcb@ DLLStreamWCB_FileOffset + !

	// insert in stream list

	auto h
	streamptr@ OSStream_BufferOrListHead + @ h!

	h@ wcb@ DLLStreamWCB_StreamNext + !
	0 wcb@ DLLStreamWCB_StreamPrev + !

	if (h@)
		wcb@ h@ DLLStreamWCB_StreamPrev + !
	end

	wcb@ streamptr@ OSStream_BufferOrListHead + !

	// try to map a full size of a window first.
	// if that fails with status STATUS_END_OF_FILE, query the filesize and
	// only map up to that point.

	auto vaddr
	DLLSTREAMWINDOWSIZE // length
	HEAPSTART // startva
	offset@ // sectionoffset
	streamptr@ OSStream_FileHandle + @ // mappedhandle
	OSCURRENTPROCESS // processhandle
	streamptr@ OSStream_Access + @ ACCESS_ALL & // pageprotection
	0 // flags
	OSMapView ok! vaddr!

	if (ok@ ~~)
		vaddr@ wcb@ DLLStreamWCB_VirtualAddress + !
		DLLSTREAMWINDOWSIZE wcb@ DLLStreamWCB_Length + !
		return
	end

	if (ok@ STATUS_END_OF_FILE ~=)
		wcb@ DLLStreamWindowFree

		return
	end

	auto query
	OSFileInformation_SIZEOF alloc query!

	streamptr@ OSStream_FileHandle + @ // filehandle
	query@ // query
	OSFileQuery ok!

	if (ok@)
		wcb@ DLLStreamWindowFree

		return
	end

	if (offset@ query@ OSFileInformation_Size + @ >=)
		// the window is totally beyond the size of the file. return a
		// real STATUS_END_OF_FILE error.

		wcb@ DLLStreamWindowFree

		STATUS_END_OF_FILE ok!

		return
	end

	auto wcblen
	query@ OSFileInformation_Size + @ offset@ - wcblen!

	wcblen@ // length
	HEAPSTART // startva
	offset@ // sectionoffset
	streamptr@ OSStream_FileHandle + @ // mappedhandle
	OSCURRENTPROCESS // processhandle
	streamptr@ OSStream_Access + @ ACCESS_ALL & // pageprotection
	0 // flags
	OSMapView ok! vaddr!

	if (ok@)
		// managed to fail a second time. just give up.

		wcb@ DLLStreamWindowFree

		return
	end

	wcblen@ wcb@ DLLStreamWCB_Length + !
	vaddr@ wcb@ DLLStreamWCB_VirtualAddress + !
end

fn DLLStreamWindowGet { -- wcb }
	// check the free list for a WCB first

	DLLStreamWCBFreeListHead@ wcb!

	if (wcb@)
		wcb@ DLLStreamWCB_FreeNext + @ DLLStreamWCBFreeListHead!

		if (DLLStreamWCBFreeListHead@)
			0 DLLStreamWCBFreeListHead@ DLLStreamWCB_FreePrev + !
		end

		return
	end

	// check the reclaimable list

	DLLStreamWCBReclaimableListHead@ wcb!

	if (wcb@)
		wcb@ DLLStreamWindowRelease

		return
	end
end

fn DLLStreamWindowFreeAll { streamptr -- }
	// free all of the WCBs for a stream

	auto wcbmutex
	DLLStreamWCBFastMutex wcbmutex!

	wcbmutex@ OSFastMutexAcquire

	auto wcb
	streamptr@ OSStream_BufferOrListHead + @ wcb!

	while (wcb@)
		auto nwcb
		wcb@ DLLStreamWCB_StreamNext + @ nwcb!

		wcb@ DLLStreamWindowFree

		nwcb@ wcb!
	end

	0 streamptr@ OSStream_BufferOrListHead + !

	wcbmutex@ OSFastMutexRelease
end

fn DLLStreamWindowFree { wcb -- }
	wcb@ DLLStreamWindowRelease

	// place on free list

	DLLStreamWCBFreeListHead@ wcb@ DLLStreamWCB_FreeNext + !

	if (DLLStreamWCBFreeListHead@)
		wcb@ DLLStreamWCBFreeListHead@ DLLStreamWCB_FreePrev + !
	end

	wcb@ DLLStreamWCBFreeListHead!

	if (DLLStreamWCBWaiters@)
		DLLStreamWCBAvailableEvent@ OSEventSignal drop
	end
end

fn DLLStreamWindowRelease { wcb -- }
	// unmap a WCB and remove it from reclaimable and stream list.
	// does not place it on the free list.

	auto streamptr
	wcb@ DLLStreamWCB_StreamPtr + @ streamptr!

	auto n

	if (wcb@ DLLStreamWCB_RefCount + @ ~~)
		// remove from reclaimable list.

		auto ls
		wcb@ DLLStreamWCB_FreePrev + @ ls!

		wcb@ DLLStreamWCB_FreeNext + @ n!

		if (ls@)
			n@ ls@ DLLStreamWCB_FreeNext + !
		end else
			n@ DLLStreamWCBReclaimableListHead!
		end

		if (n@)
			ls@ n@ DLLStreamWCB_FreePrev + !
		end else
			ls@ DLLStreamWCBReclaimableListTail!
		end
	end

	// remove from stream list.

	wcb@ DLLStreamWCB_StreamPrev + @ ls!

	wcb@ DLLStreamWCB_StreamNext + @ n!

	if (ls@)
		n@ ls@ DLLStreamWCB_StreamNext + !
	end else
		n@ streamptr@ OSStream_BufferOrListHead + !
	end

	if (n@)
		ls@ n@ DLLStreamWCB_StreamPrev + !
	end

	if (wcb@ DLLStreamWCB_VirtualAddress + @)
		// unmap window.

		auto ok
		wcb@ DLLStreamWCB_Length + @ // length
		wcb@ DLLStreamWCB_VirtualAddress + @ // vaddr
		OSCURRENTPROCESS // processhandle
		OSUnmapView ok!

		if (DEBUGCHECKS)
			if (ok@)
				ok@ OSStatusGetName "DLLStreamWindowRelease: %s\n" OSAbort
			end
		end
	end
end

// for each transfer, if the transfer crosses a window boundary, it is simply
// done as a direct syscall. otherwise, the correct WCB is looked up and the
// transfer is performed as a memcpy to/from the window. if the window is not
// mapped, a WCB is allocated and mapped as a window into the file, and then
// the transfer is performed.

fn DLLStreamWindowRead { length buffer streamptr -- bytesread ok }
	auto seek
	streamptr@ OSStream_BufferedLengthOrSeek + @ seek!

	auto tend
	seek@ length@ + 1 - tend!

	0 ok!

	if (seek@ DLLSTREAMWINDOWNUMBERMASK & tend@ DLLSTREAMWINDOWNUMBERMASK & ~=)
		// crosses a window boundary, do direct

		seek@ // offset
		streamptr@ OSStream_FileHandle + @ // filehandle
		OSSEEK_SET // mode
		OSFileSeek ok! drop

		if (ok@)
			return
		end

		OSWAIT_TIMEOUTINFINITE // timeout
		0 // flags
		length@ // length
		buffer@ // buffer
		streamptr@ OSStream_FileHandle + @ // filehandle
		OSFileRead ok! bytesread!

		if (ok@)
			return
		end

		bytesread@ streamptr@ OSStream_BufferedLengthOrSeek + +=

		return
	end

	auto wcbmutex
	DLLStreamWCBFastMutex wcbmutex!

	wcbmutex@ OSFastMutexAcquire

	// look up the WCB

	auto wcb
	streamptr@ OSStream_BufferOrListHead + @ wcb!

	while (wcb@)
		if (wcb@ DLLStreamWCB_FileOffset + @ DLLSTREAMWINDOWNUMBERMASK & seek@ DLLSTREAMWINDOWNUMBERMASK & ==)
			break
		end

		wcb@ DLLStreamWCB_StreamNext + @ wcb!
	end

	auto n

	if (wcb@ ~~)
		// didn't find the WCB, must allocate one

		seek@ DLLSTREAMWINDOWNUMBERMASK & // offset
		streamptr@ // streamptr
		DLLStreamWindowAllocate ok! wcb!

		if (ok@)
			wcbmutex@ OSFastMutexRelease

			if (ok@ STATUS_END_OF_FILE ==)
				0 ok!
				0 bytesread!
			end

			return
		end
	end else
		// found the WCB. increment refcount and remove from reclaimable list
		// if necessary.

		1 wcb@ DLLStreamWCB_RefCount + +=

		if (wcb@ DLLStreamWCB_RefCount + @ 1 ==)
			// remove

			auto ls
			wcb@ DLLStreamWCB_FreePrev + @ ls!

			wcb@ DLLStreamWCB_FreeNext + @ n!

			if (ls@)
				n@ ls@ DLLStreamWCB_FreeNext + !
			end else
				n@ DLLStreamWCBReclaimableListHead!
			end

			if (n@)
				ls@ n@ DLLStreamWCB_FreePrev + !
			end else
				ls@ DLLStreamWCBReclaimableListTail!
			end
		end
	end

	wcbmutex@ OSFastMutexRelease

	auto off
	seek@ DLLSTREAMWINDOWOFFSETMASK & off!

	auto wcblen
	wcb@ DLLStreamWCB_Length + @ wcblen!

	if (off@ wcblen@ >=)
		// goes beyond the end of the file
		0 bytesread!
		return
	end

	if (off@ length@ + wcblen@ >=)
		wcblen@ off@ - length!
	end

	// read from the file through the magic of virtual memory.

	buffer@ // dest
	wcb@ DLLStreamWCB_VirtualAddress + @ off@ + // src
	length@ // sz
	memcpy

	length@ bytesread!

	length@ streamptr@ OSStream_BufferedLengthOrSeek + +=

	wcbmutex@ OSFastMutexAcquire

	// decrement refcount and place on reclaimable list if necessary.

	1 wcb@ DLLStreamWCB_RefCount + -=

	if (wcb@ DLLStreamWCB_RefCount + @ ~~)
		// insert

		DLLStreamWCBReclaimableListTail@ n!

		if (n@ ~~)
			0 wcb@ DLLStreamWCB_FreeNext + !
			0 wcb@ DLLStreamWCB_FreePrev + !

			wcb@ DLLStreamWCBReclaimableListHead!
			wcb@ DLLStreamWCBReclaimableListTail!
		end else
			0 wcb@ DLLStreamWCB_FreeNext + !

			n@ wcb@ DLLStreamWCB_FreePrev + !
			wcb@ n@ DLLStreamWCB_FreeNext + !
			wcb@ DLLStreamWCBReclaimableListTail!
		end

		if (DLLStreamWCBWaiters@)
			DLLStreamWCBAvailableEvent@ OSEventSignal drop
		end
	end

	wcbmutex@ OSFastMutexRelease
end

fn DLLStreamWindowWrite { length buffer streamptr -- byteswritten ok }
	auto seek
	streamptr@ OSStream_BufferedLengthOrSeek + @ seek!

	auto tend
	seek@ length@ + 1 - tend!

	auto direct
	0 direct!

	if (seek@ DLLSTREAMWINDOWNUMBERMASK & tend@ DLLSTREAMWINDOWNUMBERMASK & ~=)
		1 direct!
	end elseif (length@ OSPAGESIZE >=)
		1 direct!
	end

	0 ok!

	if (direct@)
		seek@ // offset
		streamptr@ OSStream_FileHandle + @ // filehandle
		OSSEEK_SET // mode
		OSFileSeek ok! drop

		if (ok@)
			return
		end

		0 // flags
		length@ // length
		buffer@ // buffer
		streamptr@ OSStream_FileHandle + @ // filehandle
		OSFileWrite ok! byteswritten!

		if (ok@)
			return
		end

		byteswritten@ streamptr@ OSStream_BufferedLengthOrSeek + +=

		return
	end

	auto wcbmutex
	DLLStreamWCBFastMutex wcbmutex!

	wcbmutex@ OSFastMutexAcquire

	// look up the WCB

	auto wcb
	streamptr@ OSStream_BufferOrListHead + @ wcb!

	while (wcb@)
		if (wcb@ DLLStreamWCB_FileOffset + @ DLLSTREAMWINDOWNUMBERMASK & seek@ DLLSTREAMWINDOWNUMBERMASK & ==)
			break
		end

		wcb@ DLLStreamWCB_StreamNext + @ wcb!
	end

	auto n

	if (wcb@ ~~)
		// didn't find the WCB, must allocate one

		seek@ DLLSTREAMWINDOWNUMBERMASK & // offset
		streamptr@ // streamptr
		DLLStreamWindowAllocate ok! wcb!

		if (ok@)
			wcbmutex@ OSFastMutexRelease

			if (ok@ STATUS_END_OF_FILE ==)
				// do direct

				seek@ // offset
				streamptr@ OSStream_FileHandle + @ // filehandle
				OSSEEK_SET // mode
				OSFileSeek ok! drop

				if (ok@)
					return
				end

				0 // flags
				length@ // length
				buffer@ // buffer
				streamptr@ OSStream_FileHandle + @ // filehandle
				OSFileWrite ok! byteswritten!

				if (ok@)
					return
				end

				byteswritten@ streamptr@ OSStream_BufferedLengthOrSeek + +=
			end

			return
		end
	end else
		// found the WCB. increment refcount and remove from reclaimable list
		// if necessary.

		1 wcb@ DLLStreamWCB_RefCount + +=

		if (wcb@ DLLStreamWCB_RefCount + @ 1 ==)
			// remove

			auto ls
			wcb@ DLLStreamWCB_FreePrev + @ ls!

			wcb@ DLLStreamWCB_FreeNext + @ n!

			if (ls@)
				n@ ls@ DLLStreamWCB_FreeNext + !
			end else
				n@ DLLStreamWCBReclaimableListHead!
			end

			if (n@)
				ls@ n@ DLLStreamWCB_FreePrev + !
			end else
				ls@ DLLStreamWCBReclaimableListTail!
			end
		end
	end

	auto off
	seek@ DLLSTREAMWINDOWOFFSETMASK & off!

	auto wcblen
	wcb@ DLLStreamWCB_Length + @ wcblen!

	if (off@ length@ + wcblen@ >=)
		if (off@ length@ + OSPAGEOFFSETMASK + OSPAGESHIFT >> wcblen@ OSPAGEOFFSETMASK + OSPAGESHIFT >> ~=)
			// the WCB mapping is the wrong length of pages.
			// free the WCB so it can get re-allocated with an appropriate
			// size for the growth.

			wcb@ DLLStreamWindowFree

			wcbmutex@ OSFastMutexRelease

			seek@ // offset
			streamptr@ OSStream_FileHandle + @ // filehandle
			OSSEEK_SET // mode
			OSFileSeek ok! drop

			if (ok@)
				return
			end

			0 // flags
			length@ // length
			buffer@ // buffer
			streamptr@ OSStream_FileHandle + @ // filehandle
			OSFileWrite ok! byteswritten!

			if (ok@)
				return
			end

			byteswritten@ streamptr@ OSStream_BufferedLengthOrSeek + +=

			return
		end

		wcbmutex@ OSFastMutexRelease

		// grow the file

		wcb@ DLLStreamWCB_FileOffset + @ off@ + length@ + // newsize
		1 // growing
		streamptr@ OSStream_FileHandle + @ // handle
		OSFileTruncate ok! drop
	end else
		wcbmutex@ OSFastMutexRelease
	end

	if (ok@ ~~)
		// write to the file through the magic of virtual memory.

		wcb@ DLLStreamWCB_VirtualAddress + @ off@ + // dest
		buffer@ // src
		length@ // sz
		memcpy

		length@ byteswritten!

		length@ streamptr@ OSStream_BufferedLengthOrSeek + +=
	end

	wcbmutex@ OSFastMutexAcquire

	// decrement refcount and place on reclaimable list if necessary.

	1 wcb@ DLLStreamWCB_RefCount + -=

	if (wcb@ DLLStreamWCB_RefCount + @ ~~)
		// insert

		DLLStreamWCBReclaimableListTail@ n!

		if (n@ ~~)
			0 wcb@ DLLStreamWCB_FreeNext + !
			0 wcb@ DLLStreamWCB_FreePrev + !

			wcb@ DLLStreamWCBReclaimableListHead!
			wcb@ DLLStreamWCBReclaimableListTail!
		end else
			0 wcb@ DLLStreamWCB_FreeNext + !

			n@ wcb@ DLLStreamWCB_FreePrev + !
			wcb@ n@ DLLStreamWCB_FreeNext + !
			wcb@ DLLStreamWCBReclaimableListTail!
		end

		if (DLLStreamWCBWaiters@)
			DLLStreamWCBAvailableEvent@ OSEventSignal drop
		end
	end

	wcbmutex@ OSFastMutexRelease
end