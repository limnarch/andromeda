#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "Stress.h"

fn (StressTestF) ForkbombTest { -- ok }
	while (1)
		auto phandle
		auto thandle

		"forkbomb"
		ArgTable@@ // path
		0 // creationflags
		0 // creationparams
		ACCESS_OWNER_ALL // permissions
		"forkbomb" // name
		OSSpawn ok! phandle! thandle!

		if (ok@)
			ok@ OSStatusGetName "forkbomb: %s\n" OSError
		end

		phandle@ OSClose drop
		thandle@ OSClose drop
	end
end

fn MSTime { -- mstime }
	auto sec
	auto ms

	OSQueryTime ms! sec!

	sec@ 1000 * ms@ + mstime!
end

fn (StressTestF) SwapTest { -- ok }
	auto hugeareasize
	0 hugeareasize!

	if (ArgCount@ 3 ==)
		ArgTable@ 2 4 * + @ atoi hugeareasize!
	end

	if (hugeareasize@ ~~)
		6 1024 * 1024 * hugeareasize!
	end

	hugeareasize@ OSPAGEOFFSETMASK + OSPAGENUMBERMASK & hugeareasize!

	hugeareasize@ 1024 /
	"swaptest: swapping aggressively on a %dKB area\n" Printf

	auto hugearea
	hugeareasize@ OSHeapAllocate ok! hugearea!

	if (ok@)
		ok@ OSStatusGetName "swaptest: couldn't allocate area: %s\nTry specifying a smaller area size as the second argument in the command line.\n" OSError
	end

	hugearea@ "\nhugearea = 0x%08x\n" Printf

	"swaptest: writing: one dot represents 128KB\n" Printf

	auto mstime
	MSTime mstime!

	auto ptr
	hugearea@ ptr!

	auto size
	hugeareasize@ size!

	while (size@)
		if (size@ 131071 & ~~)
			'.' Putc
			OSFlushLine
		end

		0xAA55AA55 ptr@!

		OSPAGESIZE ptr +=
		OSPAGESIZE size -=
	end

	auto endtime
	MSTime endtime!

	auto diff
	endtime@ mstime@ - diff!

	diff@ 1000 %
	diff@ 1000 /
	"done in %dsec %dms\n" Printf

	hugearea@ OSHeapFree
end

fn (StressTestF) NullptrTest { -- ok }
	0 0!
end

fn (StressTestF) OverflowTest { -- ok }
	OverflowTest drop
end

fn (StressTestF) FastMutexTest { -- ok }
	auto count
	39 count!

	while (count@)
		auto thandle
		0 // context
		pointerof FastMutexTestThread // startfunc
		0 // creationflags
		ACCESS_OWNER_ALL // permissions
		"TestFastMutexThread" // name
		OSCURRENTPROCESS // processhandle
		OSThreadCreate ok! thandle!

		if (ok@)
			return
		end

		thandle@ OSClose drop

		1 count -=
	end

	0 FastMutexTestThread drop
end

table HeapBlockSizes
	32
	17
	1023
	63
	4095
	8191
	72
	45
endtable

fn FastMutexTestThread { context -- ret }
	auto count
	0 count!

	while (1)
		auto block
		[count@ 7 &]HeapBlockSizes@ OSHeapAllocate ret! block!

		if (ret@)
			ret@ OSStatusGetName "FastMutexTestThread: %s\n" OSError
		end

		block@ // ptr
		[count@ 7 &]HeapBlockSizes@ // sz
		0 // word
		memset

		0 OSThreadSleep drop

		block@ OSHeapFree

		1 count +=
	end
end

buffer TestBuffer 131072

fn (StressTestF) StreamReadTest { -- ok }
	auto count
	35 count!

	while (count@)
		auto thandle
		0 // context
		pointerof StreamReadTestThread // startfunc
		0 // creationflags
		ACCESS_OWNER_ALL // permissions
		"StreamReadTestThread" // name
		OSCURRENTPROCESS // processhandle
		OSThreadCreate ok! thandle!

		if (ok@)
			return
		end

		thandle@ OSClose drop

		1 count -=
	end

	0 StreamReadTestThread drop
end

fn StreamReadTestThread { context -- ret }
	auto ok

	while (1)
		auto stream

		0 // streamflags
		0 // flags
		ACCESS_READ // access
		"/mintia/SystemInit.cfg" // path
		OSFILETYPE_FILE // ftype
		OSStreamOpen ok! stream!

		if (ok@)
			ok@ OSStatusGetName "%s\n" OSError
		end

		// stream@ "%x\n" OSGetStdErr FPrintf

		auto bytesread
		OSWAIT_TIMEOUTINFINITE // timeout
		0 // flags
		65536 // length
		TestBuffer // buffer
		stream@ // stream
		OSStreamRead ok! bytesread!

		if (ok@)
			ok@ OSStatusGetName "read: %s\n" OSError
		end

		bytesread@ "%d " Printf

		stream@ OSStreamClose ok!

		if (ok@)
			ok@ OSStatusGetName "close: %s\n" OSError
		end
	end
end

fn (StressTestF) StreamWriteTest { -- ok }
	auto count
	35 count!

	while (count@)
		auto thandle
		0 // context
		pointerof StreamWriteTestThread // startfunc
		0 // creationflags
		ACCESS_OWNER_ALL // permissions
		"StreamWriteTestThread" // name
		OSCURRENTPROCESS // processhandle
		OSThreadCreate ok! thandle!

		if (ok@)
			return
		end

		thandle@ OSClose drop

		1 count -=
	end

	0 StreamWriteTestThread drop
end

fn StreamWriteTestThread { context -- ret }
	auto ok

	auto stream
	0 // streamflags
	OSDEFAULTFILEPERMISSIONS // permissions
	0 // flags
	ACCESS_WRITE // access
	"streamtest" // path
	OSStreamCreate ok! stream!

	if (ok@)
		ok@ OSStatusGetName "%s\n" OSError
	end

	auto writtentotal
	0 writtentotal!

	while (1)
		auto byteswritten
		0 // flags
		11 // length
		"MINTIATEST\n" // buffer
		stream@ // stream
		OSStreamWrite ok! byteswritten!

		if (ok@)
			ok@ OSStatusGetName "write: %s\n" OSError
		end

		byteswritten@ writtentotal +=

		if (writtentotal@ 0x100000 >=)
			break
		end
	end
end

const CFGTESTCOUNT 1000

fn (StressTestF) ConfigReadTest { -- ok }
	auto count
	CFGTESTCOUNT count!

	auto starttime
	MSTime starttime!

	while (count@)
		auto cfg

		"test.cfg" // path
		0 // create
		0 // write
		OSConfigFileLoad ok! cfg!

		if (ok@)
			ok@ OSStatusGetName "couldn't open test config file 'test.cfg': %s\n" OSError
		end

		cfg@ OSConfigFileFree

		1 count -=
	end

	auto endtime
	MSTime endtime!

	CFGTESTCOUNT
	endtime@ starttime@ - "took %dms to load and free a config file %d times\n" Printf
end

fn (StressTestF) ConfigWriteTest { -- ok }
	auto count
	CFGTESTCOUNT count!

	auto starttime
	MSTime starttime!

	while (count@)
		auto cfg

		"test.cfg" // path
		0 // create
		1 // write
		OSConfigFileLoad ok! cfg!

		if (ok@)
			ok@ OSStatusGetName "couldn't open test config file 'test.cfg': %s\n" OSError
		end

		cfg@ OSConfigFileWrite ok!

		if (ok@)
			ok@ OSStatusGetName "couldn't write config file: %s\n" OSError
		end

		cfg@ OSConfigFileFree

		1 count -=
	end

	auto endtime
	MSTime endtime!

	CFGTESTCOUNT
	endtime@ starttime@ - "took %dms to load, write, and free a config file %d times\n" Printf
end

struct IPCTestMsgBody
	4 Thing1
	4 Thing2
	4 Thing3
endstruct

fn (StressTestF) IPCTestServer { -- ok }
	auto porthandle
	0 // flags
	IPCTestMsgBody_SIZEOF // maxlen
	ACCESS_OWNER_ALL // permissions
	"TestPort"
	OSPortCreate ok! porthandle!

	if (ok@)
		ok@ ok@ OSStatusGetName "couldn't create port: %s %i\n" OSError
	end

	auto dirh
	0 // flags
	ACCESS_WRITE // access
	"//:/" // path
	OSOpen ok! dirh!

	if (ok@)
		ok@ OSStatusGetName "couldn't open object directory: %s\n" OSError
	end

	porthandle@ // objecthandle
	dirh@ // directoryhandle
	OSDirectoryInsert ok!

	if (ok@)
		ok@ OSStatusGetName "couldn't insert port: %s\n" OSError
	end

	auto rxmsg
	OSMessageHeader_SIZEOF IPCTestMsgBody_SIZEOF + alloc rxmsg!

	auto replymsg
	0 replymsg!

	while (1)
		rxmsg@ // rxmsg
		replymsg@ // txmsg
		OSWAIT_TIMEOUTINFINITE // timeout
		porthandle@ // porthandle
		OSPortSendAndWaitReceive ok!

		if (ok@)
			ok@ OSStatusGetName "[server] couldn't receive: %s\n" OSError
		end

		0 replymsg!

		if (rxmsg@ OSMessageHeader_TypeB + gb OSPORT_MESSAGE_CONNECTION ==)
			rxmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing3 + @
			rxmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing2 + @
			rxmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing1 + @
			rxmsg@ OSMessageHeader_ClientID + @ "[server] connection received from %d: %x %x %x\n" Printf

			0xAA55AA55 rxmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing1 + !

			0xDEADBEEF // context
			rxmsg@ // txmsg
			0 // reject
			porthandle@ // porthandle
			OSPortAccept ok!

			ok@ OSStatusGetName "[server] accept status: %s\n" Printf
		end elseif (rxmsg@ OSMessageHeader_TypeB + gb OSPORT_MESSAGE_DISCONNECT ==)
			rxmsg@ OSMessageHeader_Context + @
			rxmsg@ OSMessageHeader_ClientID + @ "[server] %d disconnected: ctx=%x\n" Printf
		end elseif (rxmsg@ OSMessageHeader_TypeB + gb OSPORT_MESSAGE_REQUEST ==)
			rxmsg@ OSMessageHeader_Handle + @
			rxmsg@ OSMessageHeader_SubtypeB + gb
			rxmsg@ OSMessageHeader_ClientID + @ "[server] request from %d: %d (handle %i)\n" Printf

			auto realva
			0x10000 // length
			HEAPSTART // startva
			0 // sectionoffset
			rxmsg@ OSMessageHeader_Handle + @ // mappedhandle
			OSCURRENTPROCESS // processhandle
			ACCESS_READ ACCESS_WRITE | // pageprotection
			0 // flags
			OSMapView ok! realva!

			if (ok@)
				ok@ OSStatusGetName "[server] couldn't map section: %s\n" OSError
			end

			realva@@ "[server] realva@@ = %x\n" Printf
			realva@ 0x10000 4 - + @ "[server] realva@ 0x10000 4 - + @ = %x\n" Printf

			0x10000 // length
			realva@ // vaddr
			OSCURRENTPROCESS // processhandle
			OSUnmapView drop

			rxmsg@ OSMessageHeader_Handle + @ OSClose drop

			OSPORT_MESSAGE_REPLY rxmsg@ OSMessageHeader_TypeB + sb
			realva@ rxmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing1 + !
			OSNONE rxmsg@ OSMessageHeader_Handle + !

			rxmsg@ replymsg!
		end else
			rxmsg@ OSMessageHeader_TypeB + gb "[server] dunno type %d\n" Printf
		end
	end

	porthandle@ OSClose drop
end

fn (StressTestF) IPCTestClient { -- ok }
	auto sectionhandle
	ACCESS_READ ACCESS_WRITE | // pageprotection
	0x10000 // anonsize
	ACCESS_OWNER_ALL // permissions
	0 // name
	OSSectionCreate ok! sectionhandle!

	if (ok@)
		ok@ OSStatusGetName "couldn't create section: %s\n" OSError
	end

	auto realva
	0x10000 // length
	HEAPSTART // startva
	0 // sectionoffset
	sectionhandle@ // mappedhandle
	OSCURRENTPROCESS // processhandle
	ACCESS_READ ACCESS_WRITE | // pageprotection
	0 // flags
	OSMapView ok! realva!

	if (ok@)
		ok@ OSStatusGetName "couldn't map section: %s\n" OSError
	end

	0xAABBCCDD realva@!
	0x01020304 realva@ 0x10000 4 - + !

	auto txmsg
	OSMessageHeader_SIZEOF IPCTestMsgBody_SIZEOF + alloc txmsg!

	IPCTestMsgBody_SIZEOF txmsg@ OSMessageHeader_LengthI + si
	OSNONE txmsg@ OSMessageHeader_Handle + !

	3 txmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing3 + !
	2 txmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing2 + !
	1 txmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing1 + !

	auto rxmsg
	OSMessageHeader_SIZEOF IPCTestMsgBody_SIZEOF + alloc rxmsg!

	auto porthandle
	rxmsg@ // rxmsg
	txmsg@ // txmsg
	OSWAIT_TIMEOUTINFINITE // timeout
	"//:/TestPort" // path
	OSPortConnect ok! porthandle!

	if (ok@)
		ok@ OSStatusGetName "[client] couldn't connect: %s\n" OSError
	end

	OSPORT_MESSAGE_REQUEST txmsg@ OSMessageHeader_TypeB + sb
	32 txmsg@ OSMessageHeader_SubtypeB + sb
	sectionhandle@ txmsg@ OSMessageHeader_Handle + !
	ACCESS_READ ACCESS_WRITE | txmsg@ OSMessageHeader_Access + !

	rxmsg@ // rxmsg
	txmsg@ // txmsg
	OSWAIT_TIMEOUTINFINITE // timeout
	porthandle@ // porthandle
	OSPortSendAndWaitReply ok!

	if (ok@)
		ok@ OSStatusGetName "[client] couldn't request: %s\n" OSError
	end

	rxmsg@ OSMessageHeader_SIZEOF + IPCTestMsgBody_Thing1 + @ "[client] server response: %x\n" Printf

	porthandle@ OSClose drop
end