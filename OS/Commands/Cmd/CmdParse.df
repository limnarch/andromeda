#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "Cmd.h"

const CMDARGUMENTSMAX 512
table CmdArguments[CMDARGUMENTSMAX]

var CmdLastStatusCode 0
public CmdLastStatusCode

const ARGSIZE 1024

fn CmdArgumentsCleanup { topindex -- }
	while (topindex@)
		1 topindex -=
		[topindex@]CmdArguments@ OSHeapFree
	end
end

fn CmdDoNextStatement { -- done ok }
	auto argindex
	0 argindex!

	0 done!
	0 ok!

	auto length
	auto tokentype

	auto argcn
	0 argcn!

	auto wait
	1 wait!

	while (1)
		auto argbuffer
		ARGSIZE OSHeapAllocate ok! argbuffer!

		if (ok@)
			argindex@ CmdArgumentsCleanup
			return
		end

		argbuffer@ [argindex@]CmdArguments!
		1 argindex +=

		argbuffer@ // tokenbuf
		ARGSIZE // bufsize
		0 // issyntactic
		CmdGetNextToken ok! tokentype! length!

		if (ok@)
			argindex@ CmdArgumentsCleanup
			return
		end

		if (tokentype@ CMDTOKENTYPE_UNFINISHEDSTRING ==)
			argindex@ CmdArgumentsCleanup
			CmdTokenLineNumber@ "cmd: line %d: unfinished string\n" OSGetStdErr FPrintf
			1 done!
			return
		end

		if (argbuffer@ "&" strcmp)
			0 wait!
			break
		end elseif (argbuffer@ "&&" strcmp)
			break
		end

		1 argcn +=

		if (tokentype@ CMDTOKENTYPE_EOF ==)
			1 done!
			break
		end elseif (tokentype@ CMDTOKENTYPE_EOL ==)
			if (length@ ~~)
				1 argcn -=
			end

			break
		end
	end

	if (done@ ~~)
		auto commandname
		[0]CmdArguments@ commandname!

		if (commandname@ gb)
			auto ran

			CmdArguments // argvt
			argcn@ // argcn
			CmdBuiltinRun ok! ran!

			if (ok@)
				argindex@ CmdArgumentsCleanup
				return
			end

			if (ran@ ~~)
				CmdArguments // argvt
				argcn@ // argcn
				wait@ // wait
				CmdProgramRun ok!

				if (ok@)
					argindex@ CmdArgumentsCleanup
					return
				end
			end
		end
	end

	argindex@ CmdArgumentsCleanup
end

buffer PathBuffer OSFILEPATHMAX

fn CmdProgramRun { argvt argcn wait -- ok }
	0 ok!

	auto name
	argvt@@ name!

	auto p
	name@ p!

	auto path
	0 path!

	auto hasextension
	0 hasextension!

	while (p@ gb)
		if (p@ gb '/' ==)
			0 hasextension!
			1 path!
			break
		end elseif (p@ gb '.' ==)
			1 hasextension!
		end

		1 p +=
	end

	auto status

	if (path@)
		// run directly

		argvt@ // argvt
		argcn@ // argcn
		name@ // path
		wait@ // wait
		CmdProgramRunPath ok! status!
	end else
		// try all the PATH things

		auto pathvar
		"PATH" OSFindEnvironmentVariable ok! pathvar! drop

		if (ok@)
			STATUS_NOT_FOUND ok!
		end else
			auto pathbuf
			PathBuffer pathbuf!

			auto lenleft
			OSFILEPATHMAX 1 - lenleft!

			while (1)
				if (lenleft@ ~~)
					"cmd: PATH component too long\n" OSGetStdErr FPrintf
					-1 ok!
					break
				end

				if (pathvar@ gb ~~ pathvar@ gb '$' == ||)
					'/' pathbuf@ sb
					1 pathbuf +=
					1 lenleft -=

					auto namelen
					name@ strlen namelen!

					if (namelen@ 4 + lenleft@ >)
						"cmd: PATH component too long when combined with executable name\n" OSGetStdErr FPrintf
						-1 ok!
						break
					end

					pathbuf@ // dest
					name@ // src
					strcpy

					if (hasextension@ ~~)
						pathbuf@ namelen@ + // dest
						".exe" // src
						strcpy
					end

					argvt@ // argvt
					argcn@ // argcn
					PathBuffer // path
					wait@ // wait
					CmdProgramRunPath ok! status!

					if (ok@ ~~)
						break
					end

					if (ok@ STATUS_NOT_FOUND ~=)
						break
					end

					if (pathvar@ gb ~~)
						break
					end

					PathBuffer pathbuf!
					OSFILEPATHMAX lenleft!
				end else
					pathvar@ gb pathbuf@ sb

					1 lenleft -=
					1 pathbuf +=
				end

				1 pathvar +=
			end
		end
	end

	if (wait@)
		status@ CmdLastStatusCode!
	end

	if (ok@)
		ok@ OSStatusGetName
		name@
		"%s: %s\n" OSGetStdErr FPrintf

		ok@ CmdLastStatusCode!

		0 ok!
	end
end

fn CmdProgramRunPath { argvt argcn path wait -- status ok }
	auto creationparams
	OSCreationParams_SIZEOF alloc creationparams!

	creationparams@ OSCreationBlockInitialize

	if (CmdSymbolStdInHandle@ OSNONE ~=)
		CmdSymbolStdInHandle@ creationparams@ OSCreationParams_StdIn + !
	end else
		OSGetStdIn creationparams@ OSCreationParams_StdIn + !
	end

	if (CmdSymbolStdOutHandle@ OSNONE ~=)
		CmdSymbolStdOutHandle@ creationparams@ OSCreationParams_StdOut + !
	end else
		OSGetStdOut creationparams@ OSCreationParams_StdOut + !
	end

	if (CmdSymbolStdErrHandle@ OSNONE ~=)
		CmdSymbolStdErrHandle@ creationparams@ OSCreationParams_StdErr + !
	end else
		OSGetStdErr creationparams@ OSCreationParams_StdErr + !
	end

	auto threadhandle
	auto processhandle

	argcn@ 1 - // argcn
	argvt@ 4 + // argvt
	path@ // path
	OSPROCESS_NOINHERIT // creationflags
	creationparams@ // creationparams
	ACCESS_OWNER_ALL // permissions
	path@ OSLastComponent // name
	OSSpawnV ok! processhandle! threadhandle!

	if (ok@)
		return
	end

	threadhandle@ OSClose drop

	if (wait@)
		OSWAIT_TIMEOUTINFINITE // timeout
		processhandle@ // objecthandle
		OSWaitForObject ok!

		if (ok@)
			processhandle@ OSClose drop
			return
		end

		processhandle@ // processhandle
		OSProcessReadStatus ok! status!
	end

	processhandle@ OSClose drop
end