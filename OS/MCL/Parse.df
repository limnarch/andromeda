//
// Implements the parser for the MINTIA Command Language.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"
#include "<ll>/MCL/Mcl.h"

#include "Mcl.h"

fn MclpParseDiagnostic { ... fmt node ctx -- }
	auto linenum
	auto fname

	if (node@)
		node@ MclpParseNode_LineNumber + @ linenum!
		node@ MclpParseNode_FileName + @ fname!
	end else
		ctx@ MclpParseContext_LexLineNumber + @ linenum!
		ctx@ MclpParseContext_FileName + @ fname!
	end

	linenum@
	fname@
	"%s:%d: " OSGetStdErr FPrintf

	argv // argvt
	argc@ // argcn
	fmt@ // fmt
	OSGetStdErr // fd
	VFPrintf
end

fn MclpParseContextInitialize { ctx -- }
	ctx@ // ptr
	MclpParseContext_SIZEOF // sz
	0 // word
	memset

	LEX_NEWSTATEMENT ctx@ MclpParseContext_LexFlags + !
end

fn MclpParseNodeCreate { type size ctx -- node ok }
	size@ OSHeapAllocate ok! node!

	if (ok@)
		return
	end

	ctx@ MclpParseContext_LexLineNumber + @ node@ MclpParseNode_LineNumber + !
	ctx@ MclpParseContext_FileName + @ node@ MclpParseNode_FileName + !

	type@ node@ MclpParseNode_Type + !
	0 node@ MclpParseNode_Next + !
end

fn MclpParseContextUninitialize { ctx -- }
	if (ctx@ MclpParseContext_LexBuffer + @)
		if (ctx@ MclpParseContext_LexFlags + @ LEX_INTERACTIVE &)
			// free buffer

			ctx@ MclpParseContext_LexBuffer + @ OSHeapFree
		end else
			// unmap buffer

			ctx@ MclpParseContext_LexInputLength + @ // length
			ctx@ MclpParseContext_LexBuffer + @ // vaddr
			OSCURRENTPROCESS // processhandle
			OSUnmapView drop
		end
	end
end

fn MclpQueryFileLength { ctx -- ok }
	auto query
	OSFileInformation_SIZEOF alloc query!

	ctx@ MclpParseContext_StreamHandle + @ OSStreamGetFileHandle // filehandle
	query@ // query
	OSFileQuery ok!

	if (ok@)
		return
	end

	query@ OSFileInformation_Size + @ ctx@ MclpParseContext_LexInputLength + !
end

fn MclpParseFile { filename interactive streamhandle machine -- rootblock ok }
	auto ctx
	MclpParseContext_SIZEOF alloc ctx!

	ctx@ MclpParseContextInitialize

	if (interactive@)
		LEX_INTERACTIVE ctx@ MclpParseContext_LexFlags + |=
	end

	if (filename@)
		filename@ ctx@ MclpParseContext_FileName + !
	end else
		"????" ctx@ MclpParseContext_FileName + !
	end

	streamhandle@ ctx@ MclpParseContext_StreamHandle + !

	0 ctx@ MclpParseContext_LexBuffer + !
	0 ctx@ MclpParseContext_LexLastOffset + !
	0 ctx@ MclpParseContext_LexOffset + !
	0 ctx@ MclpParseContext_LexValidLength + !
	1 ctx@ MclpParseContext_LexLineNumber + !

	machine@ ctx@ MclpParseContext_Machine + !

	if (interactive@)
		// endless input (at least until EOF)
		-1 ctx@ MclpParseContext_LexInputLength + !
	end else
		ctx@ MclpQueryFileLength ok!

		if (ok@)
			return
		end
	end

	0 // endtoken
	ctx@ // ctx
	MclpParseBlock ok! rootblock!

	ctx@ MclpParseContextUninitialize
end

fn MclpParseSubtreeFree { node -- }
	if (node@ ~~)
		return
	end

	auto subnode
	auto nsubnode

	if (node@ MclpParseNode_Type + @ PARSENODE_BLOCK ==)
		node@ MclpParseNodeBlock_NodeListHead + @ subnode!

		while (subnode@)
			subnode@ MclpParseNode_Next + @ nsubnode!

			subnode@ MclpParseSubtreeFree

			nsubnode@ subnode!
		end
	end elseif (node@ MclpParseNode_Type + @ PARSENODE_PIPELINE ==)
		node@ MclpParseNodePipeline_CmdListHead + @ subnode!

		while (subnode@)
			subnode@ MclpParseNode_Next + @ nsubnode!

			subnode@ MclpParseSubtreeFree

			nsubnode@ subnode!
		end

		if (node@ MclpParseNodePipeline_StdInRedirectionPath + @)
			node@ MclpParseNodePipeline_StdInRedirectionPath + @ MclpParseSubtreeFree
		end

		if (node@ MclpParseNodePipeline_StdOutRedirectionPath + @)
			node@ MclpParseNodePipeline_StdOutRedirectionPath + @ MclpParseSubtreeFree
		end

		if (node@ MclpParseNodePipeline_StdErrRedirectionPath + @)
			node@ MclpParseNodePipeline_StdErrRedirectionPath + @ MclpParseSubtreeFree
		end
	end elseif (node@ MclpParseNode_Type + @ PARSENODE_COMMAND ==)
		node@ MclpParseNodeCommand_ArgListHead + @ subnode!

		while (subnode@)
			subnode@ MclpParseNode_Next + @ nsubnode!

			subnode@ MclpParseSubtreeFree

			nsubnode@ subnode!
		end

		node@ MclpParseNodeCommand_Name + @ MclpParseSubtreeFree
	end elseif (node@ MclpParseNode_Type + @ PARSENODE_FUNCCALL ==)
		node@ MclpParseNodeFunctionCall_ArgListHead + @ subnode!

		while (subnode@)
			subnode@ MclpParseNode_Next + @ nsubnode!

			subnode@ MclpParseSubtreeFree

			nsubnode@ subnode!
		end

		node@ MclpParseNodeFunctionCall_Name + @ MclpParseSubtreeFree
	end elseif (node@ MclpParseNode_Type + @ PARSENODE_COND ==
				node@ MclpParseNode_Type + @ PARSENODE_WHILE == ||)

		if (node@ MclpParseNodeConditionalBlock_Conditional + @)
			node@ MclpParseNodeConditionalBlock_Conditional + @ MclpParseSubtreeFree
		end

		if (node@ MclpParseNodeConditionalBlock_Body + @)
			node@ MclpParseNodeConditionalBlock_Body + @ MclpParseSubtreeFree
		end
	end elseif (node@ MclpParseNode_Type + @ PARSENODE_IF ==)
		node@ MclpParseNodeIf_CondListHead + @ subnode!

		while (subnode@)
			subnode@ MclpParseNode_Next + @ nsubnode!

			subnode@ MclpParseSubtreeFree

			nsubnode@ subnode!
		end
	end

	node@ OSHeapFree
end

fn MclpParseBlock { endtoken ctx -- block ok }
	PARSENODE_BLOCK // type
	MclpParseNodeBlock_SIZEOF // size
	ctx@ // ctx
	MclpParseNodeCreate ok! block!

	if (ok@)
		return
	end

	auto nodes
	0 nodes!

	1 ctx@ MclpParseContext_Depth + +=

	auto hp
	auto tp

	block@ MclpParseNodeBlock_NodeListHead + hp!
	block@ MclpParseNodeBlock_NodeListTail + tp!

	0 hp@!
	0 tp@!

	auto tokbuf
	ctx@ MclpParseContext_TokBuffer + tokbuf!

	while (1)
		auto tokflag
		auto toklen
		0 // peek
		tokbuf@ // tokbuf
		ctx@ // ctx
		MclpLexNextToken ok! toklen! tokflag!

		if (ok@)
			if (endtoken@ ~~)
				if (ok@ STATUS_END_OF_FILE ==)
					0 ok!
				end
			end

			if (ok@)
				block@ MclpParseSubtreeFree
			end

			break
		end

		if (toklen@ ~~ tokflag@ LEXTOK_LITERAL & ~~ &&)
			if (endtoken@ ~~ ctx@ MclpParseContext_LexFlags + @ LEX_INTERACTIVE & &&)
				break
			end else
				continue
			end
		end

		if (endtoken@ tokflag@ LEXTOK_LITERAL & ~~ &&)
			if (tokbuf@ endtoken@ strcmp)
				break
			end
		end

		auto node
		0 node!

		0 ok!

		if (tokbuf@ "!" strcmp tokflag@ LEXTOK_LITERAL & ~~ &&)
			ctx@ MclpParseDirective ok! node!
		end elseif (tokbuf@ "{" strcmp tokflag@ LEXTOK_LITERAL & ~~ &&)
			"}" // endtoken
			ctx@ // ctx
			MclpParseBlock ok! node!
		end else
			// command statement

			ctx@ MclpLexLastToken

			endtoken@ // endtoken
			ctx@ // ctx
			MclpParsePipeline ok! node!
		end

		if (ok@)
			block@ MclpParseSubtreeFree

			break
		end

		if (node@)
			// add to block list

			if (hp@@ ~~)
				node@ hp@!
				node@ tp@!
			end else
				node@ tp@@ MclpParseNode_Next + !
				node@ tp@!
			end

			1 nodes +=
		end

		if (endtoken@ ~~ ctx@ MclpParseContext_LexFlags + @ LEX_INTERACTIVE & &&)
			break
		end
	end

	1 ctx@ MclpParseContext_Depth + -=

	if (ok@ ~~)
		if (nodes@ ~~)
			block@ MclpParseSubtreeFree
			0 block!
		end
	end
end

fn MclpParseDirective { ctx -- node ok }
	0 ok!
	0 node!

	auto tokbuf
	ctx@ MclpParseContext_TokBuffer + tokbuf!

	1 ctx@ MclpParseContext_Depth + +=

	auto tokflag
	auto toklen

	0 // stopnl
	tokbuf@ // tokbuf
	ctx@ // ctx
	MclpLexNextNonemptyToken ok! toklen! tokflag!

	if (ok@)
		1 ctx@ MclpParseContext_Depth + -=

		return
	end

	if (tokbuf@ "IF" strcmp)
		ctx@ MclpParseIfStatement ok! node!
	end elseif (tokbuf@ "WHILE" strcmp)
		ctx@ MclpParseWhileStatement ok! node!
	end elseif (tokbuf@ "SET" strcmp)
		ctx@ MclpParseSetStatement ok! node!
	end elseif (tokbuf@ "FUNC" strcmp)
		ctx@ MclpParseFuncStatement ok! node!
	end else
		tokbuf@
		"unknown directive '%s'\n" // fmt
		0 // node
		ctx@ // ctx
		MclpParseDiagnostic

		STATUS_SYNTAX_ERROR ok!
	end

	1 ctx@ MclpParseContext_Depth + -=
end

//
//  VVVVVVVVVV      DO THESE NEXT     VVVVVVVVVVVVV
//

fn MclpParseIfStatement { ctx -- node ok }
	0 node!
	0 ok!

	// conditional and then a block
	// then if there is an elseif, another conditional and another block
	// then if there is an else, another block
end

fn MclpParseWhileStatement { ctx -- node ok }
	0 node!
	0 ok!

	// conditional and then a block
end

fn MclpParseSetStatement { ctx -- node ok }
	0 node!
	0 ok!

	// parse set variable
end

fn MclpParseFuncStatement { ctx -- node ok }
	0 node!
	0 ok!

	// something something argument name list appended to node.
	// when called, we create a child symbol table and load the arguments into
	// it initially.
	// avoid duplicate argument names.
end

//
//  ^^^^^^^^^^^        DO THOSE NEXT         ^^^^^^^^^^^^^^
//

fn MclpParseExpression { endtoken ctx -- tokflag node ok }
	auto tokbuf
	ctx@ MclpParseContext_TokBuffer + tokbuf!

	1 ctx@ MclpParseContext_Depth + +=

	auto toklen
	0 // stopnl
	tokbuf@ // tokbuf
	ctx@ // ctx
	MclpLexNextNonemptyToken ok! toklen! tokflag!

	if (ok@)
		1 ctx@ MclpParseContext_Depth + -=

		return
	end

	if (endtoken@ tokflag@ LEXTOK_LITERAL & ~~ &&)
		if (tokbuf@ endtoken@ strcmp)
			ctx@ MclpLexLastToken

			0 node!

			1 ctx@ MclpParseContext_Depth + -=

			return
		end
	end

	if (tokbuf@ "$" strcmp tokflag@ LEXTOK_LITERAL & ~~ &&)
		// var ref

		0 // stopnl
		tokbuf@ // tokbuf
		ctx@ // ctx
		MclpLexNextNonemptyToken ok! toklen! tokflag!

		if (ok@)
			1 ctx@ MclpParseContext_Depth + -=

			return
		end

		PARSENODE_VARREF // type
		MclpParseNodeVarRef_SIZEOF toklen@ + 1 + // size
		ctx@ // ctx
		MclpParseNodeCreate ok! node!

		if (ok@)
			1 ctx@ MclpParseContext_Depth + -=

			return
		end

		node@ MclpParseNodeVarRef_Name + // dest
		tokbuf@ // src
		strcpy
	end elseif (tokbuf@ "(" strcmp tokflag@ LEXTOK_LITERAL & ~~ &&)
		// func call

		auto subnode
		")" // endtoken
		ctx@ // ctx
		MclpParseExpression ok! subnode! tokflag!

		if (ok@)
			1 ctx@ MclpParseContext_Depth + -=

			return
		end

		if (subnode@ ~~)
			1 ctx@ MclpParseContext_Depth + -=

			"expected a function name\n" // fmt
			0 // node
			ctx@ // ctx
			MclpParseDiagnostic

			STATUS_SYNTAX_ERROR ok!

			return
		end

		PARSENODE_FUNCCALL // type
		MclpParseNodeFunctionCall_SIZEOF // size
		ctx@ // ctx
		MclpParseNodeCreate ok! node!

		if (ok@)
			1 ctx@ MclpParseContext_Depth + -=

			subnode@ MclpParseSubtreeFree

			return
		end

		subnode@ node@ MclpParseNodeFunctionCall_Name + !

		auto hp
		auto tp

		node@ MclpParseNodeFunctionCall_ArgListHead + hp!
		node@ MclpParseNodeFunctionCall_ArgListTail + tp!

		0 hp@!
		0 tp@!

		0 node@ MclpParseNodeFunctionCall_ArgCount + !

		while (1)
			")" // endtoken
			ctx@ // ctx
			MclpParseExpression ok! subnode! tokflag!

			if (ok@)
				1 ctx@ MclpParseContext_Depth + -=

				node@ MclpParseSubtreeFree

				return
			end

			if (subnode@ ~~)
				break
			end

			// add to arg list

			if (hp@@ ~~)
				subnode@ hp@!
				subnode@ tp@!
			end else
				subnode@ tp@@ MclpParseNode_Next + !
				subnode@ tp@!
			end

			1 node@ MclpParseNodeFunctionCall_ArgCount + +=
		end
	end else
		// ident

		PARSENODE_LITERAL // type
		MclpParseNodeLiteral_SIZEOF toklen@ + 1 + // size
		ctx@ // ctx
		MclpParseNodeCreate ok! node!

		if (ok@)
			1 ctx@ MclpParseContext_Depth + -=

			return
		end

		node@ MclpParseNodeLiteral_Word + // dest
		tokbuf@ // src
		strcpy
	end

	1 ctx@ MclpParseContext_Depth + -=
end

const WHYRETURN_TERM     1
const WHYRETURN_REDIRECT 2
const WHYRETURN_PIPE     3

fn MclpParsePipeline { endtoken ctx -- node ok }
	PARSENODE_PIPELINE // type
	MclpParseNodePipeline_SIZEOF // size
	ctx@ // ctx
	MclpParseNodeCreate ok! node!

	if (ok@)
		return
	end

	auto hp
	auto tp

	node@ MclpParseNodePipeline_CmdListHead + hp!
	node@ MclpParseNodePipeline_CmdListTail + tp!

	0 hp@!
	0 tp@!

	0 node@ MclpParseNodePipeline_StdInRedirectionPath + !
	0 node@ MclpParseNodePipeline_StdOutRedirectionPath + !
	0 node@ MclpParseNodePipeline_StdErrRedirectionPath + !

	0 node@ MclpParseNodePipeline_Flags + !

	auto tokbuf
	ctx@ MclpParseContext_TokBuffer + tokbuf!

	while (1)
		// parse each fragment of the pipeline in sequence until we encounter
		// either newline, EOF, redirection, or the endtoken.

		auto whyreturn
		auto cmdnode
		endtoken@ // endtoken
		ctx@ // ctx
		MclpParseCommand ok! cmdnode! whyreturn!

		if (ok@)
			node@ MclpParseSubtreeFree

			return
		end

		if (cmdnode@)
			if (hp@@ ~~)
				cmdnode@ hp@!
				cmdnode@ tp@!
			end else
				cmdnode@ tp@@ MclpParseNode_Next + !
				cmdnode@ tp@!
			end
		end

		if (whyreturn@ WHYRETURN_PIPE ==)
			continue
		end

		if (whyreturn@ WHYRETURN_REDIRECT ==)
			node@ // node
			ctx@ // ctx
			MclpParseRedirection ok!

			if (ok@)
				node@ MclpParseSubtreeFree

				return
			end
		end

		break
	end
end

fn MclpParseRedirection { node ctx -- ok }
	auto tokbuf
	ctx@ MclpParseContext_TokBuffer + tokbuf!

	while (1)
		auto toklen
		auto tokflag

		0 // stopnl
		tokbuf@ // tokbuf
		ctx@ // ctx
		MclpLexNextNonemptyToken ok! toklen! tokflag!

		if (ok@)
			break
		end

		auto off

		if (tokbuf@ "<" strcmp)
			MclpParseNodePipeline_StdInRedirectionPath off!
		end elseif (tokbuf@ gb '>' ==)
			if (tokbuf@ ">" strcmp)
				MclpParseNodePipeline_StdOutRedirectionPath off!
				PIPELINEFLAG_OUTAPPEND ~ node@ MclpParseNodePipeline_Flags + &=
			end elseif (tokbuf@ ">>" strcmp)
				MclpParseNodePipeline_StdOutRedirectionPath off!
				PIPELINEFLAG_OUTAPPEND node@ MclpParseNodePipeline_Flags + |=
			end elseif (tokbuf@ ">>>" strcmp)
				MclpParseNodePipeline_StdErrRedirectionPath off!
				PIPELINEFLAG_ERRAPPEND ~ node@ MclpParseNodePipeline_Flags + &=
			end elseif (tokbuf@ ">>>>" strcmp)
				MclpParseNodePipeline_StdErrRedirectionPath off!
				PIPELINEFLAG_ERRAPPEND node@ MclpParseNodePipeline_Flags + |=
			end else
				"unknown redirection\n" // fmt
				0 // node
				ctx@ // ctx
				MclpParseDiagnostic

				STATUS_SYNTAX_ERROR ok!
				break
			end
		end else
			"odd redirection\n" // fmt
			0 // node
			ctx@ // ctx
			MclpParseDiagnostic

			STATUS_SYNTAX_ERROR ok!
			break
		end

		auto redirnode
		0 // endtoken
		ctx@ // ctx
		MclpParseExpression ok! redirnode! tokflag!

		if (ok@)
			break
		end

		if (node@ off@ + @)
			node@ off@ + @ MclpParseSubtreeFree
		end

		redirnode@ node@ off@ + !

		if (tokflag@ LEXTOK_NEWLINE &)
			break
		end
	end
end

fn MclpParseCommand { endtoken ctx -- whyreturn node ok }
	auto tokbuf
	ctx@ MclpParseContext_TokBuffer + tokbuf!

	0 node!
	0 ok!
	0 whyreturn!

	auto namenode
	auto tokflag

	endtoken@ // endtoken
	ctx@ // ctx
	MclpParseExpression ok! namenode! tokflag!

	if (ok@)
		return
	end

	if (namenode@ ~~)
		WHYRETURN_TERM whyreturn!
		return
	end

	PARSENODE_COMMAND // type
	MclpParseNodeCommand_SIZEOF // size
	ctx@ // ctx
	MclpParseNodeCreate ok! node!

	if (ok@)
		return
	end

	auto hp
	auto tp

	node@ MclpParseNodeCommand_ArgListHead + hp!
	node@ MclpParseNodeCommand_ArgListTail + tp!

	0 hp@!
	0 tp@!

	0 node@ MclpParseNodeCommand_ArgCount + !

	namenode@ node@ MclpParseNodeCommand_Name + !

	if (tokflag@ LEXTOK_NEWLINE &)
		WHYRETURN_TERM whyreturn!
		return
	end

	while (1)
		// parse all of the arguments

		auto toklen
		1 // stopnl
		tokbuf@ // tokbuf
		ctx@ // ctx
		MclpLexNextNonemptyToken ok! toklen! tokflag!

		if (ok@)
			return
		end

		if (toklen@ ~~)
			WHYRETURN_TERM whyreturn!
			break
		end

		if (tokflag@ LEXTOK_LITERAL & ~~)
			if (tokbuf@ "|" strcmp)
				WHYRETURN_PIPE whyreturn!
			end elseif (tokbuf@ "<" strcmp)
				WHYRETURN_REDIRECT whyreturn!
			end elseif (tokbuf@ gb '>' ==)
				WHYRETURN_REDIRECT whyreturn!
			end

			if (whyreturn@)
				if (whyreturn@ WHYRETURN_REDIRECT ==)
					ctx@ MclpLexLastToken
				end

				break
			end
		end

		ctx@ MclpLexLastToken

		auto argnode
		endtoken@ // endtoken
		ctx@ // ctx
		MclpParseExpression ok! argnode! tokflag!

		if (ok@)
			return
		end

		if (argnode@ ~~)
			WHYRETURN_TERM whyreturn!
			break
		end

		if (hp@@ ~~)
			argnode@ hp@!
			argnode@ tp@!
		end else
			argnode@ tp@@ MclpParseNode_Next + !
			argnode@ tp@!
		end

		if (tokflag@ LEXTOK_NEWLINE &)
			WHYRETURN_TERM whyreturn!
			break
		end
	end
end