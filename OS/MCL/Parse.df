//
// Implements the parser for the MINTIA Command Language.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"
#include "<ll>/MCL/Mcl.h"

#include "Mcl.h"

fn MclpParseDiagnostic { ... fmt ctx -- }
	ctx@ MclpParseContext_LexLineNumber + @
	ctx@ MclpParseContext_FileName + @
	"%s:%d: " Printf

	argv // argvt
	argc@ // argcn
	fmt@ // fmt
	OSGetStdErr // fd
	VFPrintf
end

fn MclpParseContextInitialize { ctx -- }
	ctx@ // ptr
	MclpParseContext_SIZEOF // sz
	0 // word
	memset

	LEX_NEWSTATEMENT ctx@ MclpParseContext_LexFlags + !
end

fn MclpParseNodeCreate { type size -- node ok }
	size@ OSHeapAllocate ok! node!

	if (ok@)
		return
	end

	type@ node@ MclpParseNode_Type + !
	0 node@ MclpParseNode_Next + !
end

fn MclpParseContextUninitialize { ctx -- }
	if (ctx@ MclpParseContext_LexBuffer + @)
		if (ctx@ MclpParseContext_LexFlags + @ LEX_INTERACTIVE &)
			// free buffer

			ctx@ MclpParseContext_LexBuffer + @ OSHeapFree
		end else
			// unmap buffer

			ctx@ MclpParseContext_LexInputLength + @ // length
			ctx@ MclpParseContext_LexBuffer + @ // vaddr
			OSCURRENTPROCESS // processhandle
			OSUnmapView drop
		end
	end
end

fn MclpQueryFileLength { ctx -- ok }
	auto query
	OSFileInformation_SIZEOF alloc query!

	ctx@ MclpParseContext_StreamHandle + @ OSStreamGetFileHandle // filehandle
	query@ // query
	OSFileQuery ok!

	if (ok@)
		return
	end

	query@ OSFileInformation_Size + @ ctx@ MclpParseContext_LexInputLength + !
end

extern MclpLexNextCharacter { ctx -- lastpos char ok }

fn MclpParseFile { filename interactive streamhandle machine -- rootblock ok }
	auto ctx
	MclpParseContext_SIZEOF alloc ctx!

	ctx@ MclpParseContextInitialize

	if (interactive@)
		LEX_INTERACTIVE ctx@ MclpParseContext_LexFlags + |=
	end

	if (filename@)
		filename@ ctx@ MclpParseContext_FileName + !
	end else
		"????" ctx@ MclpParseContext_FileName + !
	end

	streamhandle@ ctx@ MclpParseContext_StreamHandle + !

	0 ctx@ MclpParseContext_LexBuffer + !
	0 ctx@ MclpParseContext_LexOffset + !
	0 ctx@ MclpParseContext_LexValidLength + !
	1 ctx@ MclpParseContext_LexLineNumber + !

	machine@ ctx@ MclpParseContext_Machine + !

	if (interactive@)
		// endless input (at least until EOF)
		-1 ctx@ MclpParseContext_LexInputLength + !
	end else
		ctx@ MclpQueryFileLength ok!

		if (ok@)
			return
		end
	end

	0 // endtoken
	ctx@ // ctx
	MclpParseBlock ok! rootblock!

	ctx@ MclpParseContextUninitialize
end

fn MclpParseSubtreeFree { node -- }
	if (node@ MclpParseNode_Type + @ PARSENODE_BLOCK ==)
		auto subnode
		node@ MclpParseNodeBlock_NodeListHead + @ subnode!

		while (subnode@)
			subnode@ MclpParseSubtreeFree

			subnode@ MclpParseNode_Next + @ subnode!
		end
	end

	node@ OSHeapFree
end

fn MclpParseBlock { endtoken ctx -- block ok }
	PARSENODE_BLOCK // type
	MclpParseNodeBlock_SIZEOF // size
	MclpParseNodeCreate ok! block!

	if (ok@)
		return
	end

	auto hp
	auto tp

	block@ MclpParseNodeBlock_NodeListHead + hp!
	block@ MclpParseNodeBlock_NodeListTail + tp!

	0 hp@!
	0 tp@!

	auto tokbuf
	TOKBUFFERSIZE alloc tokbuf!

	while (1)
		auto toklen
		0 // peek
		tokbuf@ // tokbuf
		ctx@ // ctx
		MclpLexNextToken ok! toklen!

		if (ok@)
			if (endtoken@ ~~)
				if (ok@ STATUS_END_OF_FILE ==)
					0 ok!
				end
			end

			if (ok@)
				block@ MclpParseSubtreeFree
			end

			return
		end

		if (endtoken@)
			if (tokbuf@ endtoken@ strcmp)
				break
			end
		end

		auto node
		0 node!

		if (node@)
			// add to block list

			if (hp@@ ~~)
				node@ hp@!
				node@ tp@!
			end else
				node@ tp@@ MclpParseNode_Next + !
				node@ tp@!
			end
		end

		if (endtoken@ ~~ ctx@ MclpParseContext_LexFlags + @ LEX_INTERACTIVE & &&)
			break
		end
	end

	0 ok!
end