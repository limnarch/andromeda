#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<ll>/OSDLL/OSBootFlags.h"

buffer BootDevicePath OSFILEPATHMAX
buffer BootFilesystemName OBNAMEMAX

buffer BootMemoryInformation OSMemoryInformation_SIZEOF

buffer SwapFileInformation OSFileInformation_SIZEOF

var BootFlags 0

fn SetSystemConsole { path -- ok }
	auto handle
	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	path@ // path
	0 // ftype
	OSFileOpen ok! handle!

	if (ok@ ~~)
		handle@ OSSetSystemConsole ok!

		if (ok@)
			ok@ OSStatusGetName "Failed to set system console: %s\n" OSAbort
		end

		handle@ OSSetStdOut
		handle@ OSSetStdErr
		handle@ OSSetStdIn
	end
end

fn TrySystemConsole { -- ok }
	":ttyV0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS1" // path
	SetSystemConsole ok!
end

fn SetSwapFile { config -- ok }
	auto section
	"SwapFile" // sectionname
	config@ // config
	OSConfigGetSection ok! section!

	if (ok@)
		STATUS_INVALID_CONFIG_FILE ok!
		return
	end

	auto path
	"name" // keyname
	section@ // section
	OSConfigGetKey ok! path!

	if (ok@)
		"/mintia/SwapFile.sys" path!
	end else
		path@ OSConfigGetKeyValue path!
	end

	auto size
	"size" // keyname
	section@ // section
	OSConfigGetKey ok! size!

	if (ok@)
		1024 1024 * size!
	end else
		size@ OSConfigGetKeyValue atoi size!
	end

	auto handle
	ACCESS_OWNER_READ ACCESS_OWNER_WRITE | ACCESS_GROUP_READ | ACCESS_GROUP_WRITE | // permissions
	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	path@ // path
	OSFileCreate ok! handle!

	if (ok@)
		return
	end

	size@ // newsize
	0 // growing
	handle@ // handle
	OSFileTruncate ok! drop

	if (ok@)
		handle@ OSClose drop

		return
	end

	auto sizeinpages
	handle@ // filehandle
	OSSwapFileCreate ok! sizeinpages!

	if (ok@)
		handle@ OSClose drop

		return
	end

	handle@ OSClose drop

	sizeinpages@
	sizeinpages@ OSPAGESHIFT << 1024 /
	path@
	"Swapfile is %s (%dKB; %d pages)\n" Printf
end

extern LotsOfTests { -- }

var DeadSystemEvent 0

fn Main { ... -- ret }
	18 OSSetUMask

	OSSignalSetDefaults

	"/" OSChangeCWD drop

	TrySystemConsole ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to set system console: %s\n" OSAbort
	end

	OSGetBootFlags ret! BootFlags!

	if (ret@)
		ret@ OSStatusGetName "Failed to get bootflags: %s\n" OSAbort
	end

	BootDevicePath OSGetBootDevicePath ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to get boot device path: %s\n" OSAbort
	end

	auto bootdevicehandle

	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	BootDevicePath // path
	OSFILETYPE_BLOCKDEVICE // ftype
	OSFileOpen ret! bootdevicehandle!

	if (ret@)
		ret@ OSStatusGetName "Failed to open boot device: %s\n" OSAbort
	end

	BootFilesystemName // buffer
	bootdevicehandle@ // handle
	OSMountGetFilesystemName ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to get boot filesystem name: %s\n" OSAbort
	end

	BootFilesystemName
	BootDevicePath
	"Boot device is %s (%s)\n" Printf

	// TODO check boot filesystem using program "[BootFilesystemName]Check.exe"

	// try to make boot filesystem writable

	0
	bootdevicehandle@ // handle
	OSMountUpdateFlags ret!

	if (ret@)
		ret@ OSStatusGetName "Couldn't remount writable: %s\n" Printf
		"Continuing with readonly boot filesystem\n" Printf
	end

	bootdevicehandle@ OSClose drop

	if (BootFlags@ OSBOOTFLAG_SINGLEUSERMODE &)
		"\n" Printf

		SingleUserMode ret!

		if (ret@)
			ret@ OSStatusGetName "Singleuser mode failed: %s\n" Printf
		end
	end

	0 // signaled
	OSEVENT_SYNCH // type
	ACCESS_OWNER_ALL // permissions
	"DeadSystemEvent" // name
	OSEventCreate ret! DeadSystemEvent!

	if (ret@)
		ret@ OSStatusGetName "Couldn't create DeadSystemEvent\n" OSError
	end

	while (1)
		auto config
		"/mintia/SystemInit.cfg" // path
		0 // create
		0 // write
		OSConfigFileLoad ret! config!

		if (ret@ ~~)
			config@ StartLines

			config@ SetSwapFile ret!

			if (ret@)
				ret@ OSStatusGetName "Failed to establish swapfile: %s\n" Printf
			end

			config@ OSConfigFileFree
		end else
			ret@ OSStatusGetName "Couldn't open /mintia/SystemInit.cfg: %s\n" Printf
		end

		if (LineCount@)
			OSWorkingSetPurge drop

			1 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			DeadSystemEvent@ // objecthandle
			OSWaitForObject drop
		end

		"\nNo managed lines, or all failed. Entering singleuser mode.\n" Printf

		SingleUserMode ret!

		if (ret@)
			ret@ OSStatusGetName "Singleuser mode failed: %s\n" Printf

			OSSHUTDOWN_HALT OSShutdownSystem drop
		end
	end
end

fn SingleUserMode { -- ok }
	"Strike ^D to start multiuser mode.\n" Printf

	auto phandle
	auto thandle

	"/mintia/bin/cmd.exe" // path
	0 // creationflags
	0 // creationparams
	ACCESS_OWNER_ALL // permissions
	"cmd.exe" // name
	OSSpawn ok! phandle! thandle!

	if (ok@)
		return
	end

	thandle@ OSClose drop

	OSWorkingSetPurge drop

	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	phandle@ // objecthandle
	OSWaitForObject drop

	phandle@ OSClose drop
end

struct Line
	OSFILEPATHMAX Manager
	OSFILEPATHMAX TTYName
endstruct

var LineCount 0

fn StartLines { config -- }
	auto ok

	auto iterator
	"DeviceManagers" // sectionname
	config@ // config
	OSConfigGetKeyIterator ok! iterator!

	if (ok@)
		ok@ OSStatusGetName "bad config: %s\n" OSError
	end

	while (iterator@)
		auto key
		auto manager
		auto ttyname
		iterator@ // iterator
		config@ // config
		OSConfigNextKey ok! iterator! manager! key!

		if (ok@)
			ok@ OSStatusGetName "bad config: %s\n" OSError
		end

		key@ OSConfigGetKeyName ttyname!

		auto line
		Line_SIZEOF OSHeapAllocate ok! line!

		if (ok@)
			ok@ OSStatusGetName "%s\n" OSAbort
		end

		line@ Line_Manager + // dest
		manager@ // src
		strcpy

		line@ Line_TTYName + // dest
		ttyname@ // src
		strcpy

		auto handle
		line@ // context
		pointerof ManageLineThread // startfunc
		0 // creationflags
		ACCESS_OWNER_ALL // permissions
		ttyname@ // name
		OSCURRENTPROCESS // processhandle
		OSThreadCreate ok! handle!

		if (ok@)
			ok@ OSStatusGetName "failed to create thread: %s\n" OSError
		end

		handle@ OSClose drop

		1 // inc
		LineCount // ptr
		OSInterlockedIncrement drop
	end
end

fn ManageLineThread { context -- ret }
	while (1)
		auto phandle
		auto thandle

		context@ Line_TTYName + // arg
		context@ Line_Manager + // path
		OSPROCESS_DETACHCONSOLE OSPROCESS_NOINHERITH | // creationflags
		0 // creationparams
		ACCESS_OWNER_ALL // permissions
		context@ Line_Manager + OSLastComponent // name
		OSSpawn ret! phandle! thandle!

		if (ret@)
			ret@ OSStatusGetName
			context@ Line_Manager +
			context@ Line_TTYName +
			"%s: %s failed to start: %s\n" Printf

			break
		end

		thandle@ OSClose drop

		OSWorkingSetPurge drop

		1 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		phandle@ // objecthandle
		OSWaitForObject ret!

		auto status
		phandle@ OSProcessReadStatus drop status!

		phandle@ OSClose drop

		if (status@)
			break
		end
	end

	context@ OSHeapFree

	auto oldcount
	1 // dec
	LineCount
	OSInterlockedDecrement oldcount!

	if (oldcount@ 1 ==)
		DeadSystemEvent@ OSEventSignal drop
	end
end