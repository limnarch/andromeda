#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<ll>/OSDLL/OSVideoControl.h"

buffer BootDevicePath OSFILEPATHMAX
buffer BootFilesystemName OBNAMEMAX

buffer BootMemoryInformation OSMemoryInformation_SIZEOF

var BootFlags 0

fn SetSystemConsole { path -- ok }
	auto handle
	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	path@ // path
	0 // ftype
	OSFileOpen ok! handle!

	if (ok@ ~~)
		handle@ OSSetSystemConsole ok!

		if (ok@)
			ok@ OSStatusGetName "SystemInit: failed to set system console: %s\n" OSAbort
		end

		handle@ OSSetStdOut
		handle@ OSSetStdErr
		handle@ OSSetStdIn

		path@ "SystemInit: system console is %s\n" Printf
	end
end

fn TrySystemConsole { -- ok }
	":ttyV0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS1" // path
	SetSystemConsole ok!
end

fn SetSwapFile { path -- ok }
	path@ "SystemInit: swapfile is %s" Printf

	auto handle

	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	path@ // path
	0 // ftype
	OSFileOpen ok! handle!

	if (ok@)
		'\n' Putc
		return
	end

	auto sizeinpages
	handle@ // filehandle
	OSSwapFileCreate ok! sizeinpages!

	if (ok@)
		handle@ OSClose drop

		'\n' Putc
		return
	end

	handle@ OSClose drop

	// aim to swap out 32/128 = 25% of evicted pages.
	// before this call, the swappiness starts at 0, which means swap is never
	// used.
	32 OSSetSwappiness ok!

	if (ok@)
		ok@ OSStatusGetName "\nSystemInit: failed to set swappiness: %s\n" OSAbort
	end

	sizeinpages@
	sizeinpages@ OSPAGESHIFT << 1024 /
	" (%dKB; %d pages)\n" Printf
end

fn Main { ... -- ret }
	TrySystemConsole ret!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: failed to set system console: %s\n" OSAbort
	end

	"\nSystemInit: Hello from dynamically-linked, demand-paged userspace!\n" Printf

	OSGetBootFlags ret! BootFlags!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: failed to get bootflags: %s\n" OSAbort
	end

	BootFlags@ "SystemInit: bootflags are %08x\n" Printf

	":dks2" SetSwapFile ret!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: failed to establish swapfile: %s\n" Printf

		if (ret@ STATUS_FORBIDDEN_OPERATION ==)
			"SystemInit: I shouldn't be run as a subprocess!\n" OSGetStdErr FPrintf
			-1 OSExit
		end
	end

	auto swapfilename
	OSFILEPATHMAX alloc swapfilename!

	while (ret@)
		"\nEnter swapfile name [none]: " Printf
		
		swapfilename@ // s
		OSFILEPATHMAX 1 - // max
		Gets

		if (swapfilename@ gb ~~)
			"SystemInit: no swapfile -- NOT RECOMMENDED!\n" Printf

			break
		end

		swapfilename@ SetSwapFile ret!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to establish swapfile: %s\n" Printf
		end
	end

	BootDevicePath OSGetBootDevicePath ret!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: failed to get boot device path: %s\n" OSAbort
	end

	auto bootdevicehandle

	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	BootDevicePath // path
	OSFILETYPE_BLOCKDEVICE // ftype
	OSFileOpen ret! bootdevicehandle!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: failed to open boot device: %s\n" OSAbort
	end

	BootFilesystemName // buffer
	bootdevicehandle@ // handle
	OSMountGetFilesystemName ret!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: failed to get boot filesystem name: %s\n" OSAbort
	end

	BootFilesystemName
	BootDevicePath
	"SystemInit: boot device is %s (%s)\n" Printf

	// TODO check boot filesystem using program "[BootFilesystemName]Check.exe"

	// try to make boot filesystem writable

	0
	bootdevicehandle@ // handle
	OSMountUpdateFlags ret!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: couldn't remount writable: %s\n" Printf
		"SystemInit: continuing with readonly boot filesystem\n" Printf
	end

	bootdevicehandle@ OSClose drop

	LotsOfTests

	BootMemoryInformation OSMemoryQuery ret!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: couldn't query system memory usage: %s\n" Printf
	end else
		BootMemoryInformation OSMemoryInformationDump
	end

	'\n' Putc

	auto processhandle
	auto threadhandle

	"/mintia/bin/cmd.exe" // path
	0 // creationflags
	0 // creationparams
	ACCESS_OWNER_ALL // permissions
	0 // name
	OSSpawn ret! processhandle! threadhandle!

	if (ret@)
		ret@ OSStatusGetName "SystemInit: failed to execute /mintia/bin/cmd.exe: %s\n" OSAbort
	end

	threadhandle@ OSClose drop
	processhandle@ OSClose drop

	while (1)
		1000 OSThreadSleep drop
	end
end

var Seed 0x12AB34CD

fn SimpleRandom { -- num }
	Seed@ num!

	num@ 1103515245 * 12345 + 0xFFFFFFFF % num!

	num@ Seed!
end

buffer TestBuffer 8192

fn UsermodeThreadTest { context -- ret }
	context@ "Hi! 0x%08x\n" Printf

	// usermode mutex test

	auto handle
	ACCESS_OWNER_ALL // permissions
	0 // name
	OSMutexCreate ret! handle!

	if (ret@)
		ret@ OSStatusGetName "failed to create: %s\n" OSAbort
	end

	2000 // timeout
	handle@ // objecthandle
	OSWaitForObject ret!

	ret@ "hi %i\n" Printf

	1000 OSThreadSleep drop

	0xDEADBEEF ret!
end

fn LotsOfTests { -- }
	auto ret

	if (0)
		// usermode thread test

		0xAABBCCDD // context
		pointerof UsermodeThreadTest // startfunc
		0 // creationflags
		ACCESS_OWNER_ALL // permissions
		"UsermodeThreadTest" // name
		OSCURRENTPROCESS // processhandle
		OSThreadCreate ret! handle!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to create thread: %s\n" OSAbort
		end

		OSWAIT_TIMEOUTINFINITE // timeout
		handle@ // objecthandle
		OSWaitForObject ret!

		auto status
		handle@ OSThreadReadStatus ret! status!

		ret@ "%i\n" Printf
		status@ "0x%08x\n" Printf

		handle@ OSClose drop
	end

	if (0)
		// usermode process test

		auto processhandle
		auto threadhandle

		"/mintia/cmd.exe" // path
		0 // creationflags
		0 // creationparams
		ACCESS_OWNER_ALL // permissions
		0 // name
		OSSpawn ret! processhandle! threadhandle!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to create process: %s\n" OSAbort
		end

		threadhandle@ OSClose drop
		processhandle@ OSClose drop
	end

	if (0)
		// serial tty test

		0 // flags
		ACCESS_READ ACCESS_WRITE | // access
		"//:/Devices/ttyS0" // path
		0 // ftype
		OSFileOpen ret! handle!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to open e: %s\n" OSAbort
		end

		handle@ OSSetStdOut

		while (1)
			OSWAIT_TIMEOUTINFINITE // timeout
			0 // flags
			8191 // length
			TestBuffer // buffer
			handle@ // filehandle
			OSFileRead ret! written!

			0 TestBuffer written@ + sb

			TestBuffer "read %s\n" Printf
			written@ "read %d bytes\n" Printf
			ret@ OSStatusGetName "status: %s\n" Printf
		end
	end

	if (0)
		// framebuffer mmap test

		auto query
		0 // flags
		ACCESS_READ ACCESS_WRITE | // access
		":kinnowfb0" // path
		0 // ftype
		OSFileOpen ret! handle!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to open e: %s\n" OSAbort
		end

		OSVideoQuery_SIZEOF alloc query!

		query@ // arg2
		OSVIDEOIOCONTROL_QUERY // arg1
		handle@ // filehandle
		OSIOControl ret! drop

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to get video parameters: %s\n" OSAbort
		end

		query@ OSVideoQuery_Height + @
		query@ OSVideoQuery_Width + @ "%dx%d\n" Printf

		ACCESS_READ ACCESS_WRITE | // pageprotection
		0 // anonsize
		handle@ // filehandle
		ACCESS_OWNER_ALL // permissions
		0 // name
		OSSectionCreate ret! handle2!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to make section: %s\n" OSAbort
		end

		query@ OSVideoQuery_Width + @ query@ OSVideoQuery_Height + @ * 2 * // length
		HEAPSTART // startva
		0 // sectionoffset
		handle2@ // sectionhandle
		OSCURRENTPROCESS // processhandle
		PAGEACCESS_READ PAGEACCESS_WRITE | PAGEACCESS_NONCACHED | // pageprotection
		0 // flags
		OSSectionMapView ret! realva!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to map section: %s\n" OSAbort
		end

		while (1)
			query@ OSVideoQuery_Width + @ query@ OSVideoQuery_Height + @ * 2 * hugeareasize!
			realva@ ptr!

			while (hugeareasize@)
				SimpleRandom ptr@!

				4 hugeareasize -=
				4 ptr +=
			end
		end
	end

	if (0)
		auto i
		10 i!

		while (i@)
			// usermode mutex test

			auto handle
			ACCESS_OWNER_ALL // permissions
			0 // name
			OSMutexCreate ret! handle!

			if (ret@)
				ret@ OSStatusGetName "failed to create: %s\n" OSAbort
			end

			2000 // timeout
			handle@ // objecthandle
			OSWaitForObject ret!

			ret@ OSStatusGetName "hi: %s\n" Printf

			2000 // timeout
			handle@ // objecthandle
			OSWaitForObject ret!

			ret@ OSStatusGetName "hi: %s\n" Printf

			auto handles
			8 alloc handles!

			handle@ handles@!
			handle@ handles@ 4 + !

			OSWAITANY // waittype
			2000 // timeout
			2 // objectcount
			handles@ // objecthandletable
			OSWaitForMultipleObjects ret!

			ret@ OSStatusGetName "hi: %s\n" Printf

			handle@ OSMutexRelease ret!
			ret@ OSStatusGetName "bye: %s\n" Printf

			handle@ OSMutexRelease ret!
			ret@ OSStatusGetName "bye: %s\n" Printf

			handle@ OSMutexRelease ret!
			ret@ OSStatusGetName "bye: %s\n" Printf

			handle@ OSClose drop

			1 i -=
		end
	end

	auto realva
	auto hugeareasize
	auto written

	if (0)
		// disk write test

		8192 hugeareasize!
		TestBuffer realva!

		while (hugeareasize@)
			SimpleRandom realva@!

			4 realva +=
			4 hugeareasize -=
		end

		0 // flags
		PAGEACCESS_READ PAGEACCESS_WRITE | // access
		":dks3" // path
		0 // ftype
		OSFileOpen ret! handle!

		if (ret@)
			ret@ OSStatusGetName "SystemInit.exe: failed to open e: %s\n" OSAbort
		end

		while (1)
			0 // flags
			8192 // length
			TestBuffer // buffer
			handle@ // filehandle
			OSFileWrite ret! written!

			if (written@ 8192 ~=)
				break
			end
		end
	end

	if (0)
		// mmap disk write test

		0 // flags
		PAGEACCESS_READ PAGEACCESS_WRITE | // access
		":dks3" // path
		0 // ftype
		OSFileOpen ret! handle!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to open e: %s\n" OSAbort
		end

		auto handle2
		PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
		0 // anonsize
		handle@ // filehandle
		ACCESS_OWNER_ALL // permissions
		0 // name
		OSSectionCreate ret! handle2!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to make section: %s\n" OSAbort
		end

		16 1024 * 1024 * // length
		HEAPSTART // startva
		0 // sectionoffset
		handle2@ // sectionhandle
		OSCURRENTPROCESS // processhandle
		PAGEACCESS_READ PAGEACCESS_WRITE | // pageprotection
		0 // flags
		OSSectionMapView ret! realva!

		if (ret@)
			ret@ OSStatusGetName "SystemInit: failed to map section: %s\n" OSAbort
		end

		realva@ "0x%08x\n" Printf

		// extern OSUnmapView { length vaddr processhandle -- ok }

		16 1024 * 1024 * hugeareasize!

		while (hugeareasize@)
			SimpleRandom realva@!

			4 hugeareasize -=
			4 realva +=
		end
	end

	if (0)
		// swap test

		12 1024 * 1024 * hugeareasize!

		auto hugearea
		hugeareasize@ Malloc hugearea!

		hugearea@ "\nhugearea = 0x%08x\n" Printf

		"swap test: writing a 12MB region with random data\n" Printf

		"if you didn't specify a swapfile the system will bsod in about 5 seconds\n" Printf
		"one dot represents 64KB\n" Printf

		auto ptr
		hugearea@ ptr!

		while (hugeareasize@)
			if (hugeareasize@ 65535 & ~~)
				'.' Putc
				OSFlushLine
			end

			SimpleRandom ptr@!

			4 ptr +=
			4 hugeareasize -=
		end

		"\npulled it off even though we don't even have that much RAM!\n" Printf
		"behold the power of swap\n" Printf

		hugearea@ Free
	end
end