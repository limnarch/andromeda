#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<ll>/OSDLL/OSBootFlags.h"
#include "<ll>/OSDLL/OSConsoleControl.h"

buffer BootDevicePath OSFILEPATHMAX
buffer BootFilesystemName OBNAMEMAX

buffer BootMemoryInformation OSMemoryInformation_SIZEOF

buffer SwapFileInformation OSFileInformation_SIZEOF

var BootFlags 0

var SwapFileCount 0

fn SetSystemConsole { path -- ok }
	auto handle
	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	path@ // path
	0 // ftype
	OSFileOpen ok! handle!

	if (ok@ ~~)
		handle@ OSSetSystemConsole ok!

		if (ok@)
			ok@ OSStatusGetName "Failed to set system console: %s\n" OSAbort
		end

		0 // arg2
		OSCONSOLEIOCONTROL_RESETMODE // arg1
		handle@ // filehandle
		OSIOControl drop drop

		handle@ OSSetStdOut
		handle@ OSSetStdErr
		handle@ OSSetStdIn
	end
end

fn TrySystemConsole { -- ok }
	":ttyV0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS1" // path
	SetSystemConsole ok!
end

fn SetSwapFile { section -- }
	auto ok
	auto key
	auto path
	auto maxsize
	auto minsize
	auto priority

	"name" section@ OSConfigGetKey ok! key!

	if (ok@)
		"* Bad swapfile specification: no path\n" Printf
		return
	end

	key@ OSConfigGetKeyValue path!

	"minsize" section@ OSConfigGetKey ok! key!

	if (ok@)
		"* Bad swapfile specification: no minsize\n" Printf
		return
	end

	key@ OSConfigGetKeyValue atoi minsize!

	"maxsize" section@ OSConfigGetKey ok! key!

	if (ok@)
		"* Bad swapfile specification: no maxsize\n" Printf
		return
	end

	key@ OSConfigGetKeyValue atoi maxsize!

	"priority" section@ OSConfigGetKey ok! key!

	if (ok@)
		"* Bad swapfile specification: no priority\n" Printf
		return
	end

	key@ OSConfigGetKeyValue atoi priority!

	minsize@ OSPAGESHIFT >> // minpages
	maxsize@ OSPAGESHIFT >> // maxpages
	priority@ // pri
	path@ // path
	OSSwapFileCreate ok!

	if (ok@)
		ok@ OSStatusGetName path@ "* Failed to create %s: %s\n" Printf
		return
	end

	1 SwapFileCount +=
end

fn SetSwapFiles { config -- ok }
	auto iterator
	config@ OSConfigGetSectionIterator ok! iterator!

	while (1)
		auto section
		iterator@ config@ OSConfigNextSection ok! iterator! section!

		if (ok@)
			break
		end

		if (section@ OSConfigGetSectionName "SwapFile" strcmp)
			section@ SetSwapFile
		end
	end

	OSFlushModifiedPages drop

	0 ok!
end

extern LotsOfTests { -- }

var DeadSystemEvent 0

fn Main { ... -- ret }
	auto count
	OSProcessCountQuery drop count!

	if (count@ 2 ~=)
		"SystemInit: cannot be directly invoked\n" OSError
	end

	18 OSSetUMask

	OSSignalSetDefaults

	"/" OSChangeCWD drop

	TrySystemConsole ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to set system console: %s\n" OSAbort
	end

	OSGetBootFlags ret! BootFlags!

	if (ret@)
		ret@ OSStatusGetName "Failed to get bootflags: %s\n" OSAbort
	end

	BootDevicePath OSGetBootDevicePath ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to get boot device path: %s\n" OSAbort
	end

	auto bootdevicehandle

	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	BootDevicePath // path
	OSFILETYPE_BLOCKDEVICE // ftype
	OSFileOpen ret! bootdevicehandle!

	if (ret@)
		ret@ OSStatusGetName "Failed to open boot device: %s\n" OSAbort
	end

	BootFilesystemName // buffer
	bootdevicehandle@ // handle
	OSMountGetFilesystemName ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to get boot filesystem name: %s\n" OSAbort
	end

	BootFilesystemName
	BootDevicePath
	"Boot device is %s (%s)\n" Printf

	// TODO check boot filesystem using program "[BootFilesystemName]Check.exe"

	// try to make boot filesystem writable

	0
	bootdevicehandle@ // handle
	OSMountUpdateFlags ret!

	if (ret@)
		ret@ OSStatusGetName "Couldn't remount writable: %s\n" Printf
		"Continuing with readonly boot filesystem\n" Printf
	end

	bootdevicehandle@ OSClose drop

	0 // signaled
	OSEVENT_SYNCH // type
	ACCESS_OWNER_ALL // permissions
	"DeadSystemEvent" // name
	OSEventCreate ret! DeadSystemEvent!

	if (ret@)
		ret@ OSStatusGetName "Couldn't create DeadSystemEvent\n" OSError
	end

	auto config
	"/mintia/SystemInit.cfg" // path
	0 // create
	0 // write
	OSConfigFileLoad ret! config!

	while (ret@)
		ret@ OSStatusGetName "Couldn't open /mintia/SystemInit.cfg: %s\nPlease correct this.\n\n" Printf

		SingleUserMode ret!

		if (ret@)
			ret@ OSStatusGetName "Singleuser mode failed: %s\n" Printf

			OSSHUTDOWN_HALT OSShutdownSystem drop
		end

		"/mintia/SystemInit.cfg" // path
		0 // create
		0 // write
		OSConfigFileLoad ret! config!
	end

	config@ SetSwapFiles ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to establish swapfiles: %s\n" Printf
	end

	if (BootFlags@ OSBOOTFLAG_SINGLEUSERMODE &)
		"\n" Printf

		SingleUserMode ret!

		if (ret@)
			ret@ OSStatusGetName "Singleuser mode failed: %s\n" Printf
		end
	end

	if (SwapFileCount@ ~~)
		"* WARNING: No swapfiles! The system may behave strangely.\n" Printf
	end

	while (1)
		DeadSystemEvent@ OSEventReset drop drop

		config@ StartLines

		if (LineCount@)
			OSWorkingSetPurge drop

			1 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			DeadSystemEvent@ // objecthandle
			OSWaitForObject drop
		end

		"\nNo managed lines, or all failed. Entering singleuser mode.\n" Printf

		SingleUserMode ret!

		if (ret@)
			ret@ OSStatusGetName "Singleuser mode failed: %s\n" Printf

			OSSHUTDOWN_HALT OSShutdownSystem drop
		end
	end
end

fn SingleUserMode { -- ok }
	if (SwapFileCount@ ~~)
		"* WARNING: No swapfiles! The system may behave strangely.\n\n" Printf
	end

	"Strike ^D to start multiuser mode.\n" Printf

	auto phandle
	auto thandle

	"/mintia/bin/cmd.exe" // path
	0 // creationflags
	0 // creationparams
	ACCESS_OWNER_ALL // permissions
	"cmd.exe" // name
	OSSpawn ok! phandle! thandle!

	if (ok@)
		return
	end

	thandle@ OSClose drop

	OSWorkingSetPurge drop

	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	phandle@ // objecthandle
	OSWaitForObject drop

	phandle@ OSClose drop
end

struct Line
	OSFILEPATHMAX Manager
	OSFILEPATHMAX TTYName
endstruct

var LineCount 0

fn StartLines { config -- }
	auto ok

	auto iterator
	"DeviceManagers" // sectionname
	config@ // config
	OSConfigGetKeyIterator ok! iterator!

	if (ok@)
		ok@ OSStatusGetName "bad config: %s\n" OSError
	end

	while (iterator@)
		auto key
		auto manager
		auto ttyname
		iterator@ // iterator
		config@ // config
		OSConfigNextKey ok! iterator! manager! key!

		if (ok@)
			ok@ OSStatusGetName "bad config: %s\n" OSError
		end

		key@ OSConfigGetKeyName ttyname!

		auto line
		Line_SIZEOF OSHeapAllocate ok! line!

		if (ok@)
			ok@ OSStatusGetName "%s\n" OSAbort
		end

		line@ Line_Manager + // dest
		manager@ // src
		strcpy

		line@ Line_TTYName + // dest
		ttyname@ // src
		strcpy

		auto handle
		line@ // context
		pointerof ManageLineThread // startfunc
		0 // creationflags
		ACCESS_OWNER_ALL // permissions
		ttyname@ // name
		OSCURRENTPROCESS // processhandle
		OSThreadCreate ok! handle!

		if (ok@)
			ok@ OSStatusGetName "failed to create thread: %s\n" OSError
		end

		handle@ OSClose drop

		1 // inc
		LineCount // ptr
		OSInterlockedIncrement drop
	end
end

fn ManageLineThread { context -- ret }
	auto tries
	5 tries!

	while (tries@)
		auto phandle
		auto thandle

		context@ Line_TTYName + // arg
		context@ Line_Manager + // path
		OSPROCESS_DETACHCONSOLE OSPROCESS_NOINHERITH | // creationflags
		0 // creationparams
		ACCESS_OWNER_ALL // permissions
		context@ Line_Manager + OSLastComponent // name
		OSSpawn ret! phandle! thandle!

		if (ret@)
			ret@ OSStatusGetName
			context@ Line_Manager +
			context@ Line_TTYName +
			"%s: %s failed to start: %s\n" Printf

			break
		end

		thandle@ OSClose drop

		OSWorkingSetPurge drop

		1 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		phandle@ // objecthandle
		OSWaitForObject ret!

		auto status
		phandle@ OSProcessReadStatus drop status!

		phandle@ OSClose drop

		if (status@)
			1 tries -=
		end
	end

	context@ OSHeapFree

	auto oldcount
	-1 // dec
	LineCount
	OSInterlockedIncrement oldcount!

	if (oldcount@ 1 ==)
		DeadSystemEvent@ OSEventSignal drop
	end
end