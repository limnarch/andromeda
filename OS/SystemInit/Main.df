#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

buffer BootDevicePath OSFILEPATHMAX
buffer BootFilesystemName OBNAMEMAX

buffer BootMemoryInformation OSMemoryInformation_SIZEOF

var BootFlags 0

fn SetSystemConsole { path -- ok }
	auto handle
	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	path@ // path
	0 // ftype
	OSFileOpen ok! handle!

	if (ok@ ~~)
		handle@ OSSetSystemConsole ok!

		if (ok@)
			ok@ OSStatusGetName "Failed to set system console: %s\n" OSAbort
		end

		handle@ OSSetStdOut
		handle@ OSSetStdErr
		handle@ OSSetStdIn
	end
end

fn TrySystemConsole { -- ok }
	":ttyV0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS0" // path
	SetSystemConsole ok!

	if (ok@ ~~)
		return
	end

	":ttyS1" // path
	SetSystemConsole ok!
end

fn CreateSwapFilePrompt { path -- handle ok }
	auto response
	128 alloc response!

	path@ "%s: not found or too small. create? [y] " Printf
	
	response@ // s
	127 // max
	Gets

	if (response@ gb)
		if (response@ gb 'y' ~=)
			STATUS_NOT_FOUND ok!
			return
		end
	end

	BootMemoryInformation OSMemoryQuery drop

	auto totalpagecount
	BootMemoryInformation OSMemoryInformation_PageTotalCount + @ totalpagecount!

	auto recommended
	totalpagecount@ 2 * OSPAGESHIFT << recommended!

	auto minimum
	totalpagecount@ OSPAGESHIFT << minimum!

	"\nStrike ^D to cancel.\n" Printf

	while (1)
		recommended@ 1024 /
		minimum@ 1024 /
		"Enter the desired size in kilobytes (minimum %d) [%d]: " Printf

		if (response@ 127 OSReadline)
			"\n\n" Printf
			STATUS_NOT_FOUND ok!
			return
		end

		auto size

		if (response@ gb)
			response@ atoi 1024 * size!

			if (size@ minimum@ <)
				size@ 1024 / "Error: %dKB below minimum.\n" Printf
				continue
			end
		end else
			recommended@ size!
		end

		ACCESS_OWNER_READ ACCESS_OWNER_WRITE | ACCESS_GROUP_READ | ACCESS_GROUP_WRITE | // permissions
		0 // flags
		ACCESS_READ ACCESS_WRITE | // access
		path@ // path
		OSFileCreate ok! handle!

		if (ok@)
			return
		end

		size@ "sizing swapfile to %d bytes... " Printf
		OSFlushLine

		size@ // newsize
		1 // growing
		handle@ // handle
		OSFileTruncate ok! drop

		if (ok@)
			handle@ OSClose drop

			if (ok@ STATUS_END_OF_DISK ==)
				size@ "exceeded the capacity of the disk.\n" Printf
				continue
			end

			'\n' Putc

			return
		end

		"succeeded\n\n" Printf

		OSFlushModifiedPages drop

		return
	end
end

fn SetSwapFile { path -- ok }
	auto handle

	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	path@ // path
	0 // ftype
	OSFileOpen ok! handle!

	if (ok@)
		if (ok@ STATUS_NOT_FOUND ~=)
			return
		end

		path@ CreateSwapFilePrompt ok! handle!

		if (ok@)
			return
		end
	end

	auto sizeinpages

	while (1)
		handle@ // filehandle
		OSSwapFileCreate ok! sizeinpages!

		if (ok@ ~~)
			break
		end

		handle@ OSClose drop

		if (ok@ STATUS_SWAP_TOO_SMALL ~=)
			return
		end

		path@ CreateSwapFilePrompt ok! handle!

		if (ok@)
			return
		end
	end

	handle@ OSClose drop

	// aim to swap out 32/128 = 25% of evicted pages.
	// before this call, the swappiness starts at 0, which means swap is never
	// used.
	32 OSSetSwappiness ok!

	if (ok@)
		ok@ OSStatusGetName "\nFailed to set swappiness: %s\n" OSAbort
	end

	sizeinpages@
	sizeinpages@ OSPAGESHIFT << 1024 /
	path@
	"Swapfile is %s (%dKB; %d pages)\n" Printf
end

fn CenterPrint { string -- }
	auto padding
	40 string@ strlen 2 / - padding!

	while (padding@)
		' ' Putc
		1 padding -=
	end

	string@ "%s\n" Printf
end

extern LotsOfTests { -- }

var DeadSystemEvent 0

fn Main { ... -- ret }
	18 OSSetUMask

	OSSignalSetDefaults

	"/" OSChangeCWD drop

	TrySystemConsole ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to set system console: %s\n" OSAbort
	end

	"Welcome to the MINTIA Operating System" CenterPrint
	"Copyright 2020-2022 Will.  All Rights Reserved" CenterPrint

	'\n' Putc

	OSGetBootFlags ret! BootFlags!

	if (ret@)
		ret@ OSStatusGetName "Failed to get bootflags: %s\n" OSAbort
	end

	BootDevicePath OSGetBootDevicePath ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to get boot device path: %s\n" OSAbort
	end

	auto bootdevicehandle

	0 // flags
	ACCESS_READ ACCESS_WRITE | // access
	BootDevicePath // path
	OSFILETYPE_BLOCKDEVICE // ftype
	OSFileOpen ret! bootdevicehandle!

	if (ret@)
		ret@ OSStatusGetName "Failed to open boot device: %s\n" OSAbort
	end

	BootFilesystemName // buffer
	bootdevicehandle@ // handle
	OSMountGetFilesystemName ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to get boot filesystem name: %s\n" OSAbort
	end

	BootFilesystemName
	BootDevicePath
	"Boot device is %s (%s)\n" Printf

	// TODO check boot filesystem using program "[BootFilesystemName]Check.exe"

	// try to make boot filesystem writable

	0
	bootdevicehandle@ // handle
	OSMountUpdateFlags ret!

	if (ret@)
		ret@ OSStatusGetName "Couldn't remount writable: %s\n" Printf
		"Continuing with readonly boot filesystem\n" Printf
	end

	bootdevicehandle@ OSClose drop

	"/mintia/SwapFile.sys" SetSwapFile ret!

	if (ret@)
		ret@ OSStatusGetName "Failed to establish swapfile: %s\n" Printf

		if (ret@ STATUS_FORBIDDEN_OPERATION ==)
			"SystemInit shouldn't be run as a subprocess!\n" OSGetStdErr FPrintf
			-1 OSExit
		end
	end

	auto swapfilename
	OSFILEPATHMAX alloc swapfilename!

	while (ret@)
		"Enter the path of the swapfile [none]: " Printf
		
		swapfilename@ // s
		OSFILEPATHMAX 1 - // max
		Gets

		if (swapfilename@ gb ~~)
			"No swapfile -- NOT RECOMMENDED!\n" Printf

			break
		end

		swapfilename@ SetSwapFile ret!

		if (ret@)
			ret@ OSStatusGetName "Failed to establish swapfile: %s\n" Printf
		end
	end

	LotsOfTests

	'\n' Putc

	BootMemoryInformation OSMemoryQuery ret!

	if (ret@)
		ret@ OSStatusGetName "Couldn't query system memory usage: %s\n" Printf
	end else
		BootMemoryInformation OSMemoryInformationDump
	end

	'\n' Putc

	0 // signaled
	OSEVENT_SYNCH // type
	ACCESS_OWNER_ALL // permissions
	"DeadSystemEvent" // name
	OSEventCreate ret! DeadSystemEvent!

	if (ret@)
		ret@ OSStatusGetName "Couldn't create DeadSystemEvent\n" OSError
	end

	while (1)
		auto config
		"/mintia/SystemInit.cfg" // path
		0 // create
		0 // write
		OSConfigFileLoad ret! config!

		if (ret@ ~~)
			config@ StartLines

			config@ OSConfigFileFree
		end else
			ret@ OSStatusGetName "Couldn't open /mintia/SystemInit.cfg: %s\n" Printf
		end

		if (LineCount@)
			1 // alertable
			OSWAIT_TIMEOUTINFINITE // timeout
			DeadSystemEvent@ // objecthandle
			OSWaitForObject drop
		end

		"No managed lines, or all failed\n\n" Printf

		SingleUserMode ret!

		if (ret@)
			ret@ OSStatusGetName "Single-user mode failed: %s\n" Printf

			OSSHUTDOWN_HALT OSShutdownSystem drop
		end
	end
end

fn SingleUserMode { -- ok }
	"Strike ^D to start multi-user mode.\n" Printf

	auto phandle
	auto thandle

	"/mintia/bin/cmd.exe" // path
	0 // creationflags
	0 // creationparams
	ACCESS_OWNER_ALL // permissions
	"cmd.exe" // name
	OSSpawn ok! phandle! thandle!

	if (ok@)
		return
	end

	thandle@ OSClose drop

	1 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	phandle@ // objecthandle
	OSWaitForObject drop

	phandle@ OSClose drop
end

struct Line
	OSFILEPATHMAX Manager
	OSFILEPATHMAX TTYName
endstruct

var LineCount 0

fn StartLines { config -- }
	auto ok

	auto iterator
	"" // sectionname
	config@ // config
	OSConfigGetKeyIterator ok! iterator!

	if (ok@)
		ok@ OSStatusGetName "bad config: %s\n" OSError
	end

	while (iterator@)
		auto key
		auto manager
		auto ttyname
		iterator@ // iterator
		config@ // config
		OSConfigNextKey ok! iterator! manager! key!

		if (ok@)
			ok@ OSStatusGetName "bad config: %s\n" OSError
		end

		key@ OSConfigGetKeyName ttyname!

		auto line
		Line_SIZEOF OSHeapAllocate ok! line!

		if (ok@)
			ok@ OSStatusGetName "%s\n" OSAbort
		end

		line@ Line_Manager + // dest
		manager@ // src
		strcpy

		line@ Line_TTYName + // dest
		ttyname@ // src
		strcpy

		auto handle
		line@ // context
		pointerof ManageLineThread // startfunc
		0 // creationflags
		ACCESS_OWNER_ALL // permissions
		ttyname@ // name
		OSCURRENTPROCESS // processhandle
		OSThreadCreate ok! handle!

		if (ok@)
			ok@ OSStatusGetName "failed to create thread: %s\n" OSError
		end

		handle@ OSClose drop

		1 // inc
		LineCount // ptr
		OSInterlockedIncrement drop
	end
end

fn ManageLineThread { context -- ret }
	while (1)
		auto phandle
		auto thandle

		context@ Line_TTYName + // arg
		context@ Line_Manager + // path
		OSPROCESS_DETACHCONSOLE OSPROCESS_NOINHERITH | // creationflags
		0 // creationparams
		ACCESS_OWNER_ALL // permissions
		context@ Line_Manager + OSLastComponent // name
		OSSpawn ret! phandle! thandle!

		if (ret@)
			ret@ OSStatusGetName
			context@ Line_Manager +
			context@ Line_TTYName +
			"%s: %s failed to start: %s\n" Printf

			break
		end

		thandle@ OSClose drop

		1 // alertable
		OSWAIT_TIMEOUTINFINITE // timeout
		phandle@ // objecthandle
		OSWaitForObject ret!

		auto status
		phandle@ OSProcessReadStatus drop status!

		phandle@ OSClose drop

		if (status@)
			break
		end
	end

	auto oldcount
	1 // dec
	LineCount
	OSInterlockedDecrement oldcount!

	context@ OSHeapFree

	if (oldcount@ 1 ==)
		DeadSystemEvent@ OSEventSignal drop
	end
end