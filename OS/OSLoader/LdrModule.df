//
// Implements module loading support for OSLoader.
// Stolen from OSDLL.dll's DLLModule and reworked for the bootosphere.
//

#include "<df>/dragonfruit.h"

#include "OSLoader.h"

#include "LOFF.h"

const LDRMODULEFLAGS_REBASESELF 1
const LDRMODULEFLAGS_REBASE     2

const LDRMODULEFLAGS_REBASEEITHER (LDRMODULEFLAGS_REBASE LDRMODULEFLAGS_REBASESELF |)

var LdrDLLListHead 0
public LdrDLLListHead

var LdrDLLListTail 0
public LdrDLLListTail

// TODO use tons of hash tables and stuff so this isn't the slowest thing ever

fn LdrModuleCreate { name -- dll ok }
	LdrModule_SIZEOF
	LdrMemoryAllocate ok! dll!

	if (ok@)
		return
	end

	dll@ LdrModule_Name + // dest
	name@ // src
	strcpy

	0 dll@ LdrModule_Next + !

	0 dll@ LdrModule_HeadVAddr + !
	0 dll@ LdrModule_HeadLength + !

	0 dll@ LdrModule_DriverInit + !

	0 dll@ LdrModule_Timestamp + !
	0 dll@ LdrModule_Base + !

	0 dll@ LdrModule_Format + !

	0 dll@ LdrModule_Flags + !
end

fn LdrModuleFindByName { name -- dll ok }
	LDRSTATUS_NOT_FOUND ok!

	LdrDLLListHead@ dll!

	while (dll@)
		if (dll@ LdrModule_Name + name@ strcmp)
			0 ok!

			return
		end

		dll@ LdrModule_Next + @ dll!
	end
end

// try to open module file by name.

fn LdrModuleOpenFile { name -- file ok }
	if (name@ "HAL.dll" strcmp)
		LdrPlatformHALName@ name!
	end

	auto path
	64 alloc path!

	if (name@ gb '/' ~=)
		path@ "/mintia/" strcpy
		path@ 8 + name@ strcpy
	end else
		name@ path!
	end

	auto after
	0 after!

	if (path@ "/mintia/BootDrivers/" 20 strncmp ~~)
		path@ "%s\n" Printf
	end else
		1 after!
	end

	path@ // path
	LdrBootDevice // device
	LdrFileOpen ok! file!

	if (ok@ ~~)
		if (after@)
			path@ "%s\n" Printf
		end
	end
end

fn LdrModuleDoImports { dll -- ok }
	// iterate import table and recursively load any modules this one depends
	// upon.

	0 ok!

	auto head
	dll@ LdrModule_HeadVAddr + @ head!

	auto count
	head@ LOFFHeader_ImportCount + @ count!

	auto ptr
	head@ LOFFHeader_ImportTableOffset + @ head@ + ptr!

	auto strtab
	head@ LOFFHeader_StringTableOffset + @ head@ + strtab!

	auto sectionheader

	auto rebased
	0 rebased!

	auto i
	0 i!

	while (i@ count@ <)
		auto dllp

		0 // flags
		ptr@ LOFFImport_Name + @ strtab@ + // name
		LdrModuleLoad ok! dllp!

		if (ok@)
			LdrModuleNameBuffer // dest
			ptr@ LOFFImport_Name + @ strtab@ + // src
			strcpy

			ok@
			LdrModuleNameBuffer "Failed to load system binary %s (%i)\n" LdrCrash
		end

		auto headp
		dllp@ LdrModule_HeadVAddr + @ headp!

		// resolve import
		dllp@ ptr@ LOFFImport_Name + !

		if (rebased@ ~~)
			// check for all the cases that necessitate a rebasing.

			// use a cursed while loop here for easier control flow

			while (1)
				if (headp@ LOFFHeader_Timestamp + @ ptr@ LOFFImport_Timestamp + @ ~=)
					LDRMODULEFLAGS_REBASE dll@ LdrModule_Flags + |=
					1 rebased!
					break
				end

				headp@ LOFFHeader_TextHeader + @ headp@ + sectionheader!
				if (sectionheader@ LOFFSectionHeader_LinkedAddress + @ ptr@ LOFFImport_ExpectedText + @ ~=)
					LDRMODULEFLAGS_REBASE dll@ LdrModule_Flags + |=
					1 rebased!
					break
				end

				headp@ LOFFHeader_DataHeader + @ headp@ + sectionheader!
				if (sectionheader@ LOFFSectionHeader_LinkedAddress + @ ptr@ LOFFImport_ExpectedData + @ ~=)
					LDRMODULEFLAGS_REBASE dll@ LdrModule_Flags + |=
					1 rebased!
					break
				end

				headp@ LOFFHeader_BSSHeader + @ headp@ + sectionheader!
				if (sectionheader@ LOFFSectionHeader_LinkedAddress + @ ptr@ LOFFImport_ExpectedBSS + @ ~=)
					LDRMODULEFLAGS_REBASE dll@ LdrModule_Flags + |=
					1 rebased!
					break
				end

				break
			end
		end

		1 i +=
		LOFFImport_SIZEOF ptr +=
	end
end

fn LdrModuleMap { handle dll -- ok }
	auto head
	dll@ LdrModule_HeadVAddr + @ head!

	auto realva

	auto sectionheader
	head@ LOFFHeader_DataHeader + @ head@ + sectionheader!

	if (sectionheader@ LOFFSectionHeader_SectionSize + @)
		// map data section

		sectionheader@ LOFFSectionHeader_SectionSize + @ PAGEOFFSETMASK + PAGESHIFT >> // pages
		sectionheader@ LOFFSectionHeader_LinkedAddress + @ // prefva
		0 // fixed
		OSLOADERMEM_USED // type
		LdrMemoryAllocatePhysicalRangeAndMap ok! realva!

		if (ok@)
			return
		end

		sectionheader@ LOFFSectionHeader_SectionSize + @ // length
		realva@ // buf
		sectionheader@ LOFFSectionHeader_SectionOffset + @ // offset
		handle@ // file
		LdrFileRead ok! drop

		if (ok@)
			return
		end

		if (realva@ sectionheader@ LOFFSectionHeader_LinkedAddress + @ ~=)
			// couldn't map at preferred address, mark module rebased and update
			// the header field

			LDRMODULEFLAGS_REBASESELF dll@ LdrModule_Flags + |=

			realva@ sectionheader@ LOFFSectionHeader_LinkedAddress + !
		end
	end

	head@ LOFFHeader_BSSHeader + @ head@ + sectionheader!

	if (sectionheader@ LOFFSectionHeader_SectionSize + @)
		// map bss section

		sectionheader@ LOFFSectionHeader_SectionSize + @ PAGEOFFSETMASK + PAGESHIFT >> // pages
		sectionheader@ LOFFSectionHeader_LinkedAddress + @ // prefva
		0 // fixed
		OSLOADERMEM_USED // type
		LdrMemoryAllocatePhysicalRangeAndMap ok! realva!

		if (ok@)
			return
		end

		realva@ // ptr
		sectionheader@ LOFFSectionHeader_SectionSize + @ // size
		0 // word
		memset

		if (realva@ sectionheader@ LOFFSectionHeader_LinkedAddress + @ ~=)
			// couldn't map at preferred address, mark module rebased and update
			// the header field

			LDRMODULEFLAGS_REBASESELF dll@ LdrModule_Flags + |=

			realva@ sectionheader@ LOFFSectionHeader_LinkedAddress + !
		end
	end

	head@ LOFFHeader_TextHeader + @ head@ + sectionheader!

	if (sectionheader@ LOFFSectionHeader_SectionSize + @)
		// map text section

		sectionheader@ LOFFSectionHeader_SectionSize + @ PAGEOFFSETMASK + PAGESHIFT >> // pages
		sectionheader@ LOFFSectionHeader_LinkedAddress + @ // prefva
		0 // fixed
		OSLOADERMEM_USED // type
		LdrMemoryAllocatePhysicalRangeAndMap ok! realva!

		if (ok@)
			return
		end

		sectionheader@ LOFFSectionHeader_SectionSize + @ // length
		realva@ // buf
		sectionheader@ LOFFSectionHeader_SectionOffset + @ // offset
		handle@ // file
		LdrFileRead ok! drop

		if (ok@)
			return
		end

		if (realva@ sectionheader@ LOFFSectionHeader_LinkedAddress + @ ~=)
			// couldn't map at preferred address, mark module rebased and update
			// the header field

			LDRMODULEFLAGS_REBASESELF dll@ LdrModule_Flags + |=

			realva@ sectionheader@ LOFFSectionHeader_LinkedAddress + !
		end
	end
end

fn LdrGetSymbol { name dll -- symbol ok }
	auto head
	dll@ LdrModule_HeadVAddr + @ head!

	head@ LOFFHeader_SymbolTableOffset + @ head@ + symbol!

	auto i
	0 i!

	auto count
	head@ LOFFHeader_SymbolCount + @ count!

	auto strtab
	head@ LOFFHeader_StringTableOffset + @ head@ + strtab!

	LDRSTATUS_BAD_EXECUTABLE ok!

	while (i@ count@ <)
		if (symbol@ LOFFSymbol_Type + @ LOFFGLOBAL ==)
			auto sname
			symbol@ LOFFSymbol_NameOffset + @ strtab@ + sname!

			if (sname@ name@ strcmp)
				0 ok!

				return
			end
		end

		LOFFSymbol_SIZEOF symbol +=
		1 i +=
	end
end

fn LdrModuleResolveSymbols { dll -- ok }
	auto head
	dll@ LdrModule_HeadVAddr + @ head!

	auto symbol
	head@ LOFFHeader_SymbolTableOffset + @ head@ + symbol!

	auto i
	0 i!

	auto count
	head@ LOFFHeader_SymbolCount + @ count!

	auto importtab
	head@ LOFFHeader_ImportTableOffset + @ head@ + importtab!

	auto strtab
	head@ LOFFHeader_StringTableOffset + @ head@ + strtab!

	while (i@ count@ <)
		if (symbol@ LOFFSymbol_Type + @ LOFFEXTERN ==)
			auto name
			symbol@ LOFFSymbol_NameOffset + @ strtab@ + name!

			auto import
			symbol@ LOFFSymbol_ImportIndex + @ import!

			auto addr

			if (import@ ~~)
				// search in all the loaded DLLs

				LdrDLLListHead@ dll!

				LDRSTATUS_BAD_EXECUTABLE ok!

				while (dll@)
					name@ // name
					dll@ // dll
					LdrGetSymbolAddress ok! addr!

					if (ok@ ~~)
						break
					end

					dll@ LdrModule_Next + @ dll!
				end
			end else
				importtab@ import@ 1 - LOFFImport_SIZEOF * + import!

				name@ // name
				import@ LOFFImport_Name + @ // dll
				LdrGetSymbolAddress ok! addr!
			end

			if (ok@)
				LdrModuleNameBuffer // dest
				name@ // src
				strcpy

				LdrModuleNameBuffer
				"symbol '%s' not found" Printf

				if (import@)
					dll@ LdrModule_Name + IDENTITYSPACEMASK &
					import@ LOFFImport_Name + @ LdrModule_Name + IDENTITYSPACEMASK &
					" in %s, referenced by %s\n" Printf
				end else
					dll@ LdrModule_Name + IDENTITYSPACEMASK &
					", referenced by %s\n" Printf
				end

				return
			end

			LOFFRESOLVED symbol@ LOFFSymbol_Type + !
			addr@ symbol@ LOFFSymbol_Value + !
		end

		LOFFSymbol_SIZEOF symbol +=
		1 i +=
	end

	0 ok!
end

fn LdrModuleApplyFixups { sectionheader id dll -- ok }
	auto head
	dll@ LdrModule_HeadVAddr + @ head!

	auto fixup
	sectionheader@ LOFFSectionHeader_FixupTableOffset + @ head@ + fixup!

	auto symtab
	head@ LOFFHeader_SymbolTableOffset + @ head@ + symtab!

	auto count
	sectionheader@ LOFFSectionHeader_FixupCount + @ count!

	0 ok!

	auto i
	0 i!

	auto base
	sectionheader@ LOFFSectionHeader_LinkedAddress + @ base!

	while (i@ count@ <)
		auto symbol
		fixup@ LOFFFixup_SymbolIndex + @ LOFFSymbol_SIZEOF * symtab@ + symbol!

		if (symbol@ LOFFSymbol_Type + @ LOFFRESOLVED ==)
			fixup@ LOFFFixup_Offset + @ base@ + // ptr
			symbol@ LOFFSymbol_Value + @ // value
			fixup@ LOFFFixup_Type + @ // type
			LdrDoFixup ok!

			if (ok@)
				return
			end
		end elseif (symbol@ LOFFSymbol_Type + @ LOFFEXTERN ~=) // this fixup refers to this code module
			if (dll@ LdrModule_Flags + @ LDRMODULEFLAGS_REBASESELF &)
				if (symbol@ LOFFSymbol_Section + @ id@ ~=)
					auto q

					if (symbol@ LOFFSymbol_Section + @ LOFFTEXT ==)
						head@ LOFFHeader_TextHeader + @ head@ + q!
					end elseif (symbol@ LOFFSymbol_Section + @ LOFFDATA ==)
						head@ LOFFHeader_DataHeader + @ head@ + q!
					end elseif (symbol@ LOFFSymbol_Section + @ LOFFBSS ==)
						head@ LOFFHeader_BSSHeader + @ head@ + q!
					end else
						LDRSTATUS_BAD_EXECUTABLE ok!

						return
					end

					fixup@ LOFFFixup_Offset + @ base@ + // ptr
					symbol@ LOFFSymbol_Value + @ q@ LOFFSectionHeader_LinkedAddress + @ + // value
					fixup@ LOFFFixup_Type + @ // type
					LdrDoFixup ok!

					if (ok@)
						return
					end
				end else
					fixup@ LOFFFixup_Offset + @ base@ + // ptr
					symbol@ LOFFSymbol_Value + @ base@ + // value
					fixup@ LOFFFixup_Type + @ // type
					LdrDoFixup ok!

					if (ok@)
						return
					end
				end
			end
		end

		LOFFFixup_SIZEOF fixup +=
		1 i +=
	end

	0 ok!
end

fn LdrModuleRebase { dll -- ok }
	if (dll@ LdrModule_Flags + @ LDRMODULEFLAGS_REBASE &)
		dll@ LdrModuleResolveSymbols ok!

		if (ok@)
			return
		end
	end

	auto head
	dll@ LdrModule_HeadVAddr + @ head!

	head@ LOFFHeader_TextHeader + @ head@ + // sectionheader
	LOFFTEXT // id
	dll@ // dll
	LdrModuleApplyFixups ok!

	if (ok@)
		return
	end

	head@ LOFFHeader_DataHeader + @ head@ + // sectionheader
	LOFFDATA // id
	dll@ // dll
	LdrModuleApplyFixups ok!
end

fn LdrGetSymbolAddress { name dll -- address ok }
	auto symbol
	name@ dll@ LdrGetSymbol ok! symbol!

	if (ok@)
		return
	end

	auto head
	dll@ LdrModule_HeadVAddr + @ head!

	auto sectionheader

	if (symbol@ LOFFSymbol_Section + @ LOFFTEXT ==)
		head@ LOFFHeader_TextHeader + @ head@ + sectionheader!
	end elseif (symbol@ LOFFSymbol_Section + @ LOFFDATA ==)
		head@ LOFFHeader_DataHeader + @ head@ + sectionheader!
	end elseif (symbol@ LOFFSymbol_Section + @ LOFFBSS ==)
		head@ LOFFHeader_BSSHeader + @ head@ + sectionheader!
	end else
		LDRSTATUS_BAD_EXECUTABLE ok!

		return
	end

	symbol@ LOFFSymbol_Value + @ address!

	sectionheader@ LOFFSectionHeader_LinkedAddress + @ address +=
end

buffer LdrModuleNameBuffer 64

fn LdrModuleLoad { flags name -- dll ok }
	name@ LdrModuleFindByName ok! dll!

	if (ok@ ~~)
		// already loaded, return

		return
	end

	// not loaded. load it

	auto handle
	name@ LdrModuleOpenFile ok! handle!

	if (ok@)
		return
	end

	auto bytesread

	auto header
	LOFFHeader_SIZEOF alloc header!

	LOFFHeader_SIZEOF // length
	header@ // buf
	0 // offset
	handle@ // file
	LdrFileRead ok! bytesread!

	if (ok@)
		return
	end

	// verify parameters

	if (bytesread@ LOFFHeader_SIZEOF <)
		LDRSTATUS_BAD_EXECUTABLE ok!

		return
	end

	if (header@ LOFFHeader_Magic + @ LOFFMAGIC ~=)
		LDRSTATUS_BAD_EXECUTABLE ok!

		return
	end

	if (header@ LOFFHeader_TargetArchitecture + @ LOFFARCHITECTURE ~=)
		LDRSTATUS_EXEC_NOT_FOR_ARCH ok!

		return
	end

	// create a module block

	name@ LdrLastComponent LdrModuleCreate ok! dll!

	if (ok@)
		return
	end

	// find out head size

	auto headsz
	header@ LOFFHeader_BSSHeader + @ LOFFSectionHeader_SIZEOF + headsz!

	auto head

	// map in the head

	headsz@ PAGEOFFSETMASK + PAGESHIFT >> // pages
	KERNELSTRUCTURES // prefva
	0 // fixed
	OSLOADERMEM_DEBUG // type
	LdrMemoryAllocatePhysicalRangeAndMap ok! head!

	if (ok@)
		return
	end

	headsz@ // length
	head@ // buf
	0 // offset
	handle@ // file
	LdrFileRead ok! bytesread!

	if (ok@)
		return
	end

	// initialize module block.

	head@ dll@ LdrModule_HeadVAddr + !
	headsz@ dll@ LdrModule_HeadLength + !
	LDRMODULEFORMAT_LOFF dll@ LdrModule_Format + !

	// map module sections.

	handle@ // file
	dll@ // dll
	LdrModuleMap ok!

	if (ok@)
		return
	end

	auto sectionheader
	head@ LOFFHeader_TextHeader + @ head@ + sectionheader!

	sectionheader@ LOFFSectionHeader_LinkedAddress + @ dll@ LdrModule_Base + !

	head@ LOFFHeader_Timestamp + @ dll@ LdrModule_Timestamp + !

	auto entry
	head@ LOFFHeader_EntrySymbol + @ entry!

	if (entry@ 0xFFFFFFFF ~=)
		if (LdrSystemEntryPoint@)
			"conflicting entrypoints\n" LdrCrash
		end

		head@ LOFFHeader_SymbolTableOffset + @ head@ + entry@ LOFFSymbol_SIZEOF * + entry!

		sectionheader@ LOFFSectionHeader_LinkedAddress + @ entry@ LOFFSymbol_Value + @ + entry!

		entry@ LdrSystemEntryPoint!

		entry@ "system entrypoint @ 0x%08x\n" Printf
	end

	// add to tail of module list.

	auto t
	LdrDLLListTail@ t!

	if (t@ ~~)
		0 dll@ LdrModule_Next + !

		dll@ LdrDLLListHead!
		dll@ LdrDLLListTail!
	end else
		0 dll@ LdrModule_Next + !

		dll@ IDENTITYSPACE | t@ LdrModule_Next + !
		dll@ LdrDLLListTail!
	end

	dll@ LdrModuleDoImports ok!

	if (ok@)
		return
	end

	if ("-relink" LdrArgsCheck)
		LDRMODULEFLAGS_REBASEEITHER dll@ LdrModule_Flags + |=
	end

	if (head@ LOFFHeader_Fragment + @)
		LDRMODULEFLAGS_REBASE dll@ LdrModule_Flags + |=
	end

	if (dll@ LdrModule_Flags + @ LDRMODULEFLAGS_REBASEEITHER &)
		// needs to be rebased

		dll@ LdrModuleRebase ok!

		if (ok@)
			return
		end
	end
end