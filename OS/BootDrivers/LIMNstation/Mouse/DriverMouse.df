//
// Implements the amtsu mouse driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"
#include "<ll>/OSDLL/OSMouseControl.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALLIMNstationAmtsu.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALConsole.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/Console.h"

const MOUSEMID 0x4D4F5553

const MOUSECMDREAD  1
const MOUSECMDRESET 2

struct Mouse
	4 ID
	4 EventBuffer
	KeDPC_SIZEOF DPC
endstruct

table DriverMouseDispatch
	0                                    // open
	0                                    // close
	0                                    // iocontrol
	pointerof DriverMouseRead            // read
	0                                    // write
	0                                    // system control
	0                                    // parse
	0                                    // create
	0                                    // flush
	pointerof IODeviceDeleteFileObject   // delete object
	0                                    // set information
	0                                    // get information
	0                                    // rename
	0                                    // readblock
	0                                    // writeblock
	0                                    // truncate
	0                                    // readdirectory
	0                                    // getpageaddr
	0                                    // delete device object
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

table DriverMouse
	IOVERSION_MAJOR                      // ioversion major
	IOVERSION_MINOR                      // ioversion minor

	"mouse"                              // name
	OSFILETYPE_CHARDEVICE                // type
	pointerof DriverMouseDispatch        // dispatch table
	Mouse_SIZEOF                         // extension size

	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
	0                                    // reserved
endtable

table MouseTable[16]

fn (FDriverInit) DriverInit { stage -- ok }
	if (stage@ STAGE_THREAD ==)
		pointerof DriverMouseEnumerate // func
		MOUSEMID // mid
		HALLIMNstationAmtsuEnumerate drop
	end

	0 ok!
end

fn (HALLIMNstationAmtsuCallbackF) DriverMouseEnumerate { id -- }
	auto name
	OBNAMEMAX alloc name!

	name@ // dest
	"mouse" // src
	strcpy

	id@ // n
	name@ 5 + // str
	itoa

	auto dev
	auto ok
	name@ // name
	0 // sizeinbytes
	DriverMouse // driver
	ACCESS_OWNER_READ ACCESS_GROUP_READ | // permissions
	IODeviceCreate ok! dev!

	if (ok@)
		ok@ name@ "DriverMouseEnumerate: failed to create %s (%i)\n" KeCrash
	end

	auto mouse
	dev@ IODeviceGetExtension mouse!

	pointerof DriverMouseDPCFunction // function
	mouse@ Mouse_DPC + // dpc
	KeDPCInitialize

	id@ mouse@ Mouse_ID + !

	auto mousebuffer
	3 // sizelog (2^3 = 8 entries)
	3 // valuesizelog (2^3 = 8 bytes)
	IPLINTERACTIVE // synchipl
	0 // quotablock
	ExRingBufferCreate ok! mousebuffer!

	if (ok@)
		ok@ name@ "DriverMouseEnumerate: failed to create %s (%i)\n" KeCrash
	end

	mousebuffer@ mouse@ Mouse_EventBuffer + !

	mouse@ [id@]MouseTable!

	auto irq
	id@ HALLIMNstationAmtsuIDToIrq irq!

	pointerof DriverMouseInterrupt // handler
	irq@ // int
	IPLINTERACTIVE // ipl
	HALInterruptRegister

	id@ HALLIMNstationAmtsuSetInterrupt
end

fn (IODispatchReadFunction) DriverMouseRead { timeout flags kflags offset mdl fcb -- bytesread ok }
	auto mouse
	fcb@ IOFileControlBlockGetDeviceObject IODeviceGetExtension mouse!

	auto ringbuf
	mouse@ Mouse_EventBuffer + @ ringbuf!

	auto lastmode
	mdl@ MmMDLHeader_Mode + @ lastmode!

	auto buffer
	mdl@ MmMDLHeader_VirtualAddress + @ buffer!

	auto length
	mdl@ MmMDLHeader_Length + @ length!

	0 bytesread!

	if (length@ OSMousePacket_SIZEOF %)
		// not a multiple of the mouse event packet size

		STATUS_INVALID_ARGUMENT ok!

		return
	end

	auto waitonempty
	EXRINGDONTWAIT waitonempty!

	if (timeout@)
		EXRINGWAIT waitonempty!
	end

	auto kpacket
	OSMousePacket_SIZEOF alloc kpacket!

	while (bytesread@ length@ <)
		auto valueptr

		timeout@ // timeout
		lastmode@ // lastmode
		waitonempty@ EXRINGSYNCH | // waitonempty
		ringbuf@ // ringbuffer
		ExRingBufferReadValue ok! valueptr! drop

		if (ok@)
			return
		end

		// we specified EXRINGSYNCH so we need to remember to lower IPL before
		// we return.

		if (lastmode@ USERMODE ==)
			valueptr@@ kpacket@ OSMousePacket_EventType + !
			valueptr@ 4 + @ kpacket@ OSMousePacket_Info + !

			IPLLOW KeIPLLower

			buffer@ // dest
			kpacket@ // src
			OSMousePacket_SIZEOF // size
			KeSafeCopyOut ok!

			if (ok@)
				return
			end
		end else
			valueptr@@ buffer@ OSMousePacket_EventType + !
			valueptr@ 4 + @ buffer@ OSMousePacket_Info + !

			IPLLOW KeIPLLower
		end

		OSMousePacket_SIZEOF buffer +=
		OSMousePacket_SIZEOF bytesread +=
	end

	0 ok!
end

fn (DPCFunction) DriverMouseDPCFunction { context1 context2 -- }
	IOBOOSTMOUSE // priboost
	context1@ Mouse_EventBuffer + @ // ringbuffer
	ExRingBufferWakeReader
end

fn (HALInterruptHandler) DriverMouseInterrupt { int -- }
	auto mouse

	auto id
	int@ HALLIMNstationAmtsuIrqToID id!

	[id@]MouseTable@ mouse!

	auto eventbuf
	mouse@ Mouse_EventBuffer + @ eventbuf!

	auto eventtype
	auto info

	while (1)
		mouse@ MouseRead info! eventtype!

		if (eventtype@ ~~)
			break
		end

		auto valueptr

		eventtype@ // value
		1  // overwrite
		0 // timeout
		KERNELMODE // lastmode
		EXRINGDONTWAIT // waitonfull
		eventbuf@ // ringbuffer
		ExRingBufferWriteValue drop valueptr!

		info@ valueptr@ 4 + !
	end

	auto dpc
	mouse@ Mouse_DPC + dpc!

	if (dpc@ KeDPC_Enqueued + @ ~~)
		// defer waking up any blocked readers til later,
		// otherwise we will BSOD since we're at IPLINTERACTIVE

		mouse@ // context1
		0 // context2
		DPCLOWIMPORTANCE // importance
		dpc@ // dpc
		KeDPCEnqueue
	end
end

fn MouseRead { mouse -- eventtype info }
	auto id
	mouse@ Mouse_ID + @ id!

	auto rs
	HALCPUInterruptDisable rs!

	id@ HALLIMNstationAmtsuSelect
	MOUSECMDREAD HALLIMNstationAmtsuCommand
	HALLIMNstationAmtsuReadA eventtype!
	HALLIMNstationAmtsuReadB info!

	rs@ HALCPUInterruptRestore
end