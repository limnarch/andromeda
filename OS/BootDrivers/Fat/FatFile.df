//
// Implements file management for the FAT driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "<inc>/ViewCache.h"

#include "Fat.h"

fn FatFCBCacheLock { alertable mount -- ok }
	fnsection "PAGE$text"

	KERNELMODE // waitmode
	alertable@ // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	mount@ IOMount_Extension + @ FatData_FCBCacheMutex + // object
	KeThreadWaitForObject ok!
end

fn FatFCBCacheUnlock { mount -- }
	fnsection "PAGE$text"

	0 // abandon
	mount@ IOMount_Extension + @ FatData_FCBCacheMutex + // mutex
	KeMutexRelease drop
end

fn (IODispatchPokeFunction) FatPoke { poketype object -- }
	// this function gives us a chance to update timestamps when an operation
	// occurs that might bypass us entirely i.e. a fully cached read or write.

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	if (fcb@ FSFileControlBlockGetMount IOMount_Flags + @ OSMOUNT_READONLY &)
		return
	end

	if (poketype@ IOPOKE_WRITE ==)
		fcb@ // fcb
		object@ // fileobject
		FatFileUpdateModifyTimestamp
	end elseif (poketype@ IOPOKE_READ ==)
		fcb@ // fcb
		object@ // fileobject
		FatFileUpdateAccessTimestamp
	end
end

fn (IODispatchSetSecurityFunction) FatSetSecurity { uid gid permissions object -- ok }
	fnsection "PAGE$text"

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	if (uid@ -1 ~=)
		STATUS_NOT_SUPPORTED ok!
		return
	end

	if (gid@ -1 ~=)
		STATUS_NOT_SUPPORTED ok!
		return
	end

	if (permissions@ -1 ==)
		0 ok!
		return
	end

	permissions@ fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatFCBData_SavedPermissions + !
end

fn FatFCBCacheFlush { destroy mount -- ok }
	fnsection "PAGE$text"

	STATUS_NOT_IMPLEMENTED ok!
end

fn (IOFilesystemReclaimFunction) FatFCBReclaim { preferredcount fsdeviceobject -- actualcount }
	fnsection "PAGE$text"

	0 actualcount!
end

fn FatFCBCreateFromDirent { name flags dirfcb longdirentseek shortdirentseek shortdirent mount -- fcb ok }
	fnsection "PAGE$text"

	auto firstcluster
	shortdirent@ FatDirectoryEntry_FirstClusterLowI + gi firstcluster!

	if (mount@ IOMount_Extension + @ FatData_FatType + @ 32 ==)
		shortdirent@ FatDirectoryEntry_FirstClusterHighI + gi 16 << firstcluster |=
	end

	auto filetype

	if (shortdirent@ FatDirectoryEntry_AttributeB + gb FAT_ATTR_DIRECTORY &)
		OSFILETYPE_DIRECTORY filetype!
	end else
		OSFILETYPE_FILE filetype!
	end

	name@ // name
	flags@ // flags
	filetype@ // filetype
	mount@ // mount
	FatFCBCreate ok! fcb!

	if (ok@)
		return
	end

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto fcbdata
	fcbp@ IOFileControlBlockPaged_FSContext + @ fcbdata!

	firstcluster@ fcbdata@ FatFCBData_StartingCluster + !

	shortdirent@ FatDirectoryEntry_FileSizeBytes + @ fcb@ IOFileControlBlock_SizeInBytes + !

	if (filetype@ OSFILETYPE_DIRECTORY ==)
		fcb@ FatFCBMeasureSize ok!

		if (ok@)
			-1 // writeout
			fcb@ // fcb
			FatFCBDelete

			return
		end
	end

	// read the timestamps.

	auto timestamp
	shortdirent@ FatDirectoryEntry_CreationDateI + gi FatDateToUnix timestamp!
	shortdirent@ FatDirectoryEntry_CreationTimeI + gi FatTimeToUnix timestamp +=

	shortdirent@ FatDirectoryEntry_CreationTimeTenthB + gb 10 / timestamp +=

	timestamp@ fcbp@ IOFileControlBlockPaged_CreationTime + KeTime_SecPart + !

	shortdirent@ FatDirectoryEntry_ModificationDateI + gi FatDateToUnix timestamp!
	shortdirent@ FatDirectoryEntry_ModificationTimeI + gi FatTimeToUnix timestamp +=

	timestamp@ fcbp@ IOFileControlBlockPaged_ModifyTime + KeTime_SecPart + !

	shortdirent@ FatDirectoryEntry_AccessDateI + gi FatDateToUnix timestamp!

	timestamp@ fcbp@ IOFileControlBlockPaged_AccessTime + KeTime_SecPart + !

	// FAT timestamps are in local time, so we have to normalize it to UTC.
	// currently this does not remove the bias from daylight savings time, but
	// Ke has an opportunity to normalize that and we shouldn't have to touch
	// this again.

	fcbp@ IOFileControlBlockPaged_CreationTime + // desttime
	fcbp@ IOFileControlBlockPaged_CreationTime + // srctime
	KeLocalTimeToRealTime

	fcbp@ IOFileControlBlockPaged_ModifyTime + // desttime
	fcbp@ IOFileControlBlockPaged_ModifyTime + // srctime
	KeLocalTimeToRealTime

	fcbp@ IOFileControlBlockPaged_AccessTime + // desttime
	fcbp@ IOFileControlBlockPaged_AccessTime + // srctime
	KeLocalTimeToRealTime

	longdirentseek@ fcbdata@ FatFCBData_LongDirentSeek + !
	shortdirentseek@ fcbdata@ FatFCBData_ShortDirentSeek + !

	fcb@ // childfcb
	dirfcb@ // fcb
	mount@ // mount
	FatDirectoryInsertCachedChild
end

fn FatFCBCreate { name flags filetype mount -- fcb ok }
	fnsection "PAGE$text"

	auto namelen
	0 namelen!

	if (name@)
		name@ strlen 1 + namelen!
	end

	if (flags@ OSFILEFLAG_PAGEFILE &)
		mount@ IOMount_FsDeviceObject + @ // devobj
		filetype@ // filetype
		0 // flags
		IOFileControlBlockCreate ok! fcb!
	end else
		mount@ IOMount_FsDeviceObject + @ // devobj
		filetype@ // filetype
		IOFCBFLAG_PAGED // flags
		IOFileControlBlockCreate ok! fcb!
	end

	if (ok@)
		return
	end

	auto fcbdata
	if (flags@ OSFILEFLAG_PAGEFILE & ~~)
		if (filetype@ OSFILETYPE_DIRECTORY ==)
			FatDCBData_SIZEOF namelen@ + // bytes
			'FDCp' // tag
			PAGED // flags
			MmAllocWithTag ok! fcbdata!
		end else
			FatFCBData_SIZEOF namelen@ + // bytes
			'FFCp' // tag
			PAGED // flags
			MmAllocWithTag ok! fcbdata!
		end
	end else
		FatFCBData_SIZEOF namelen@ + // bytes
		'FFCX' // tag
		0 // flags
		MmAllocWithTag ok! fcbdata!
	end

	if (ok@)
		-1 // writeout
		fcb@ // fcb
		IOFileControlBlockDelete drop

		return
	end

	auto fcbnp
	FatFCBDataNonpaged_SIZEOF // bytes
	'FFCn' // tag
	0 // flags
	MmAllocWithTag ok! fcbnp!

	if (ok@)
		fcbdata@ MmFree

		-1 // writeout
		fcb@ // fcb
		IOFileControlBlockDelete drop

		return
	end

	if (filetype@ OSFILETYPE_DIRECTORY ==)
		OSDEFAULTDIRPERMISSIONS fcbdata@ FatFCBData_SavedPermissions + !
	end else
		OSDEFAULTFILEPERMISSIONS fcbdata@ FatFCBData_SavedPermissions + !
	end

	fcbnp@ fcbdata@ FatFCBData_Nonpaged + !
	fcbdata@ fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + !

	0 fcbdata@ FatFCBData_ParentFCBData + !
	0 fcbdata@ FatFCBData_LeftChild + !
	0 fcbdata@ FatFCBData_RightChild + !

	0 fcbdata@ FatFCBData_ParentDirDCB + !

	fcb@ fcbdata@ FatFCBData_FCB + !

	0 fcbdata@ FatFCBData_ReclaimNext + !
	0 fcbdata@ FatFCBData_ReclaimPrev + !

	0 fcbdata@ FatFCBData_Name + !

	if (namelen@)
		if (filetype@ OSFILETYPE_DIRECTORY ==)
			fcbdata@ FatDCBData_SIZEOF + // dest
			name@ // src
			namelen@ // sz
			memcpy

			fcbdata@ FatDCBData_SIZEOF +
			fcbdata@ FatFCBData_Name + !
		end else
			fcbdata@ FatFCBData_SIZEOF + // dest
			name@ // src
			namelen@ // sz
			memcpy

			fcbdata@ FatFCBData_SIZEOF +
			fcbdata@ FatFCBData_Name + !
		end
	end

	0 fcbdata@ FatFCBData_LongDirentSeek + !
	0 fcbdata@ FatFCBData_ShortDirentSeek + !

	0 fcbdata@ FatFCBData_StartingCluster + !

	flags@ fcbdata@ FatFCBData_InitialFlags + !
	1 fcbdata@ FatFCBData_References + !

	0 fcbdata@ FatFCBData_Flags + !

	-1 fcbnp@ FatFCBDataNonpaged_LastFATLinkClusterOff + !
	0 fcbnp@ FatFCBDataNonpaged_LastFATLinkValue + !

	if (filetype@ OSFILETYPE_DIRECTORY ==)
		0 fcbdata@ FatDCBData_SplayTreeRoot + !
		0 fcbdata@ FatDCBData_DirentHint + !
		-1 fcbdata@ FatDCBData_LastDirentIndex + !
		0 fcbdata@ FatDCBData_FreeDirentCount + !

		0 // sizeinbits
		0 // data
		fcbdata@ FatDCBData_DirentBitmapHeader + // header
		ComBitmapInitialize
	end
end

fn FatFCBDelete { writeout fcb -- }
	fnsection "PAGE$text"

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	if (DEBUGCHECKS)
		if (fcbdata@ FatFCBData_References + @ 1 ~=)
			fcbdata@ FatFCBData_References + @ "FatFCBDelete: FCB had %d references\n" KeCrash
		end
	end

	if (fcbdata@ FatFCBData_ParentDirDCB + @)
		fcb@ // childfcb
		fcb@ FSFileControlBlockGetMount // mount
		FatDirectoryRemoveCachedChild
	end

	if (fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FileType + @
		OSFILETYPE_DIRECTORY ==)

		if (DEBUGCHECKS)
			if (fcbdata@ FatDCBData_SplayTreeRoot + @)
				"FatFCBDelete: directory cache had children\n" KeCrash
			end
		end

		auto bmp
		fcbdata@ FatDCBData_DirentBitmapHeader + ComBitmapGetData bmp!

		if (bmp@)
			bmp@ MmFree
		end
	end

	writeout@ // writeout
	fcb@ // fcb
	IOFileControlBlockDelete drop

	fcbdata@ FatFCBData_Nonpaged + @ MmFree
	fcbdata@ MmFree
end

fn FatFCBMeasureSize { fcb -- ok }
	fnsection "PAGE$text"

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	auto length
	-1 // mustlen
	fcbdata@ FatFCBData_StartingCluster + @ // cluster
	mount@ // mount
	FatClusterChainValidate ok! length!

	if (ok@)
		return
	end

	FATFILEFLAG_VALIDATED fcbdata@ FatFCBData_Flags + |=

	length@
	mount@ IOMount_Extension + @ FatData_ClusterSizeShift + @ <<
	fcb@ IOFileControlBlock_SizeInBytes + !
end

fn FatFCBReference { fcb -- }
	fnsection "PAGE$text"

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	0 mount@ FatFCBCacheLock drop

	fcb@ FatFCBReferenceLockHeld

	mount@ FatFCBCacheUnlock
end

fn FatFCBReferenceLockHeld { fcb -- }
	fnsection "PAGE$text"

	// assumes the FCB cache lock is held

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	auto oldcount
	fcbdata@ FatFCBData_References + @ oldcount!

	oldcount@ 1 + fcbdata@ FatFCBData_References + !

	if (oldcount@ ~~)
		// remove from reclaimable list

		auto ls
		fcbdata@ FatFCBData_ReclaimPrev + @ ls!

		auto ns
		fcbdata@ FatFCBData_ReclaimNext + @ ns!

		if (ls@)
			ns@ ls@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatFCBData_ReclaimNext + !
		end else
			ns@ fatdata@ FatData_ReclaimableListHead + !
		end

		if (ns@)
			ls@ ns@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatFCBData_ReclaimPrev + !
		end else
			ls@ fatdata@ FatData_ReclaimableListTail + !
		end

		IOFileControlBlockDecrementReclaimable
	end
end

fn FatFCBDereference { fcb -- }
	fnsection "PAGE$text"

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	0 mount@ FatFCBCacheLock drop

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	auto oldcount
	fcbdata@ FatFCBData_References + @ oldcount!

	if (DEBUGCHECKS)
		if (oldcount@ ~~)
			"FatFCBDereference: underflow\n" KeCrash
		end
	end

	oldcount@ 1 - fcbdata@ FatFCBData_References + !

	if (oldcount@ 1 ==)
		if (fcbdata@ FatFCBData_Flags + @ FATFILEFLAG_DELETE & ~~)
			// insert into reclaimable list

			auto t
			fatdata@ FatData_ReclaimableListTail + @ t!

			if (t@ ~~)
				0 fcbdata@ FatFCBData_ReclaimNext + !
				0 fcbdata@ FatFCBData_ReclaimPrev + !

				fcb@ fatdata@ FatData_ReclaimableListHead + !
				fcb@ fatdata@ FatData_ReclaimableListTail + !
			end else
				0 fcbdata@ FatFCBData_ReclaimNext + !

				t@ fcbdata@ FatFCBData_ReclaimPrev + !
				fcb@ t@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatFCBData_ReclaimNext + !
				fcb@ fatdata@ FatData_ReclaimableListTail + !
			end

			IOFileControlBlockIncrementReclaimable
		end
	end

	mount@ FatFCBCacheUnlock

	if (oldcount@ 1 ==)
		if (fcbdata@ FatFCBData_Flags + @ FATFILEFLAG_DELETE &)
			// delete the file on disk

			fcb@ FatFileDelete
		end
	end
end

fn FatFileDelete { fcb -- }
	fnsection "PAGE$text"

end

fn FatFileUpdate { fcb -- }
	fnsection "PAGE$text"

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto fcbdata
	fcbp@ IOFileControlBlockPaged_FSContext + @ fcbdata!

	auto dirfcb
	fcbdata@ FatFCBData_ParentDirDCB + @ dirfcb!

	if (dirfcb@ ~~)
		return
	end

	// it's okay to fiddle with the dirent here, since the FCB is already part
	// of the parent directory's splay tree, which means nobody is going to be
	// looking at this dirent directly.

	auto bcb
	auto fatdirent

	auto ok
	0 // skipempty
	fcbdata@ FatFCBData_ShortDirentSeek + @ // seek
	dirfcb@ // fcb
	0 // lastbcb
	FatDirectoryGetRawEntry ok! drop bcb! fatdirent!

	if (ok@)
		return
	end

	// re-encode the relevant fcbdata fields into the dirent

	auto firstcluster
	fcbdata@ FatFCBData_StartingCluster + @ firstcluster!

	firstcluster@ 0xFFFF & fatdirent@ FatDirectoryEntry_FirstClusterLowI + si
	firstcluster@ 16 >> fatdirent@ FatDirectoryEntry_FirstClusterHighI + si

	fcb@ IOFileControlBlock_SizeInBytes + @
	fatdirent@ FatDirectoryEntry_FileSizeBytes + !

	// update timestamps

	auto localtime
	KeTime_SIZEOF alloc localtime!

	auto stamp

	localtime@ // desttime
	fcbp@ IOFileControlBlockPaged_AccessTime + // srctime
	KeRealTimeToLocalTime

	localtime@ KeTime_SecPart + @ FatUnixToDate stamp!

	stamp@ fatdirent@ FatDirectoryEntry_AccessDateI + si

	localtime@ // desttime
	fcbp@ IOFileControlBlockPaged_ModifyTime + // srctime
	KeRealTimeToLocalTime

	localtime@ KeTime_SecPart + @ FatUnixToDate stamp!

	stamp@ fatdirent@ FatDirectoryEntry_ModificationDateI + si

	localtime@ KeTime_SecPart + @ FatUnixToTime stamp!

	stamp@ fatdirent@ FatDirectoryEntry_ModificationTimeI + si

	localtime@ // desttime
	fcbp@ IOFileControlBlockPaged_CreationTime + // srctime
	KeRealTimeToLocalTime

	localtime@ KeTime_SecPart + @ FatUnixToDate stamp!

	stamp@ fatdirent@ FatDirectoryEntry_CreationDateI + si

	localtime@ KeTime_SecPart + @ FatUnixToTime stamp!

	stamp@ fatdirent@ FatDirectoryEntry_CreationTimeI + si

	bcb@ VcBufferDirty
	bcb@ VcBufferDecrementMapCount drop
end

fn FatFileUpdateModifyTimestamp { fcb fileobject -- }
	fnsection "PAGE$text"

	auto time
	KeTime_SIZEOF alloc time!

	time@ KeTimeQuery

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	if (time@ KeTime_SecPart + @
		fcbp@ IOFileControlBlockPaged_ModifyTime + KeTime_SecPart + @ ~=)

		fcbp@ IOFileControlBlockPaged_ModifyTime + // dest
		time@ // src
		KeTime_SIZEOF // sz
		memcpy

		if (fileobject@)
			FATFILECONTEXT_UPDATEONCLOSE fileobject@ IOFile_Context + |=
		end else
			fcb@ FatFileUpdate
		end
	end
end

fn FatFileUpdateAccessTimestamp { fcb fileobject -- }
	fnsection "PAGE$text"

	auto time
	KeTime_SIZEOF alloc time!

	time@ KeTimeQuery

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	// only update access timestamp if it is prior to the modify timestamp OR
	// it is older than a day.

	if (fcbp@ IOFileControlBlockPaged_AccessTime + KeTime_SecPart + @
		fcbp@ IOFileControlBlockPaged_ModifyTime + KeTime_SecPart + @ <
		time@ KeTime_SecPart + @ fcbp@ IOFileControlBlockPaged_AccessTime + KeTime_SecPart + @ - 86400 >= ||)

		if (time@ KeTime_SecPart + @
			fcbp@ IOFileControlBlockPaged_AccessTime + KeTime_SecPart + @ ~=)

			fcbp@ IOFileControlBlockPaged_AccessTime + // dest
			time@ // src
			KeTime_SIZEOF // sz
			memcpy

			if (fileobject@)
				FATFILECONTEXT_UPDATEONCLOSE fileobject@ IOFile_Context + |=
			end else
				fcb@ FatFileUpdate
			end
		end
	end
end