//
// Implements the Parse and Delete dispatch routines for the FAT driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "<inc>/ViewCache.h"

#include "Fat.h"

fn (IODispatchParseFunction) FatParse { fileobject initialfcb process -- reparsepath ok }
	fnsection "PAGE$text"

	0 reparsepath!
	0 ok!

	auto path
	fileobject@ IOFile_OpenedPath + @ path!

	if (path@ ~~)
		STATUS_NOT_FOUND ok!
		return
	end

	initialfcb@ FatFCBReference

	auto mount
	initialfcb@ FSFileControlBlockGetMount mount!

	initialfcb@ IOFileControlBlockLock ok!

	while (path@ gb)
		fileobject@ // fileobject
		path@ // path
		initialfcb@ // fcb
		mount@ // mount
		process@ // process
		FatCrunchPathComponent ok! initialfcb! path!

		if (ok@)
			if (initialfcb@ ~~)
				// FatCrunchPathComponent already cleaned up.

				return
			end

			break
		end
	end

	initialfcb@ IOFileControlBlockUnlock

	// at this point the FCB should be refed but unlocked

	if (ok@)
		initialfcb@ FatFCBDereference

		return
	end

	if (fileobject@ IOFile_Flags + @ OSFILEFLAG_MUSTCREATE &)
		initialfcb@ FatFCBDereference

		STATUS_ALREADY_EXISTS ok!

		return
	end

	if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATEDIR &)
		if (initialfcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FileType + @ OSFILETYPE_DIRECTORY ~=)
			initialfcb@ FatFCBDereference

			STATUS_ALREADY_EXISTS ok!

			return
		end
	end

	fileobject@ // fileobject
	initialfcb@ // fcb
	FatFillFileObject
end

fn (IODispatchDeleteObjectFunction) FatDeleteObject { object -- ok }
	fnsection "PAGE$text"

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	if (object@ IOFile_Context + @ FATFILECONTEXT_WRITABLE &)
		-1 fatdata@ FatData_WritableFiles + KeInterlockedIncrement drop
	end

	if (object@ IOFile_Context + @ FATFILECONTEXT_UPDATEONCLOSE &)
		fcb@ FatUpdateDirent
	end

	// the FCB may or may not stop existing after we deref it here, so don't
	// touch it again.

	fcb@ FatFCBDereference

	mount@ FatMountDereference

	0 ok!
end

fn FatFillFileObject { fileobject fcb -- }
	fnsection "PAGE$text"

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	mount@ FatMountReference

	fcb@ // fcb
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatFCBData_SavedPermissions + @ // permissions
	UID_SYSTEM // uid
	GID_SYSTEM // gid
	fileobject@ // fileobject
	mount@ // mount
	FSFileObjectFill
end

fn FatCrunchPathComponent { fileobject path fcb mount process -- nextpath nextfcb ok }
	fnsection "PAGE$text"

	0 ok!

	fcb@ nextfcb!
	path@ nextpath!

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	auto pcomp
	256 alloc pcomp!

	while (nextpath@ gb '/' ==)
		1 nextpath +=
	end

	if (nextpath@ gb ~~)
		// no more path, done

		return
	end

	// more path. traverse

	if (fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FileType + @ OSFILETYPE_DIRECTORY ~=)
		STATUS_NOT_A_DIRECTORY ok!

		return
	end

	if (process@)
		// check traverse rights (on behalf of the CALLING process,
		// not the receiver of the handle)

		ACCESS_EXEC // access
		fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatFCBData_SavedPermissions + @ // permbits
		UID_SYSTEM // owninguid
		GID_SYSTEM // owninggid
		mount@ // mount
		FSCheckAccess ok!

		if (ok@)
			// no rights

			return
		end
	end

	auto len
	0 len!

	while (1)
		if (nextpath@ gb '/' ==)
			break
		end

		if (nextpath@ gb 0 ==)
			break
		end

		if (len@ 255 >=)
			STATUS_NAME_TOO_LONG ok!

			return
		end

		nextpath@ gb pcomp@ len@ + sb

		1 len +=
		1 nextpath +=
	end

	0 pcomp@ len@ + sb

	if (pcomp@ "." strcmp)
		return
	end

	if (pcomp@ ".." strcmp)
		if (fcb@ mount@ IOMount_RootFCB + @ ==)
			return
		end

		fcbdata@ FatFCBData_ParentDirDCB + @ nextfcb!

		nextfcb@ FatFCBReferenceLockHeld

		fcb@ IOFileControlBlockUnlock
		fcb@ FatFCBDereference

		nextfcb@ IOFileControlBlockLock ok!

		if (ok@)
			nextfcb@ FatFCBDereference

			0 nextfcb!
		end

		return
	end

	fileobject@ IOFile_Flags + @ // flags
	pcomp@ // name
	fcb@ // dirfcb
	mount@ // mount
	FatDirectoryGetChildByName ok! nextfcb!

	if (ok@)
		fcb@ nextfcb!

		if (ok@ STATUS_NOT_FOUND ~=)
			return
		end

		if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATE & ~~)
			return
		end

		if (nextpath@ gb)
			return
		end

		ACCESS_WRITE // access
		fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatFCBData_SavedPermissions + @ // permbits
		UID_SYSTEM // owninguid
		GID_SYSTEM // owninggid
		mount@ // mount
		FSCheckAccess ok!

		if (ok@)
			return
		end

		fileobject@ // fileobject
		pcomp@ // name
		fcb@ // dirfcb
		FatCreateFile ok! nextfcb!

		fcb@ IOFileControlBlockUnlock
		fcb@ FatFCBDereference

		if (ok@)
			0 nextfcb!
		end else
			nextfcb@ IOFileControlBlockLock ok!

			if (ok@)
				nextfcb@ FatFCBDereference

				0 nextfcb!
			end
		end

		return
	end

	fcb@ IOFileControlBlockUnlock
	fcb@ FatFCBDereference

	nextfcb@ IOFileControlBlockLock ok!

	if (ok@)
		nextfcb@ FatFCBDereference

		0 nextfcb!
	end
end

fn FatCreateFile { fileobject name dirfcb -- fcb ok }
	fnsection "PAGE$text"

	OSFILEFLAG_MUSTCREATE ~ fileobject@ IOFile_Flags + &=

	STATUS_NOT_IMPLEMENTED ok!
end