//
// Implements directory management for the FAT driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "<inc>/ViewCache.h"

#include "Fat.h"

fn (IODispatchReadDirectoryFunction) FatReadDirectory { seek dirent fcb -- nextseek ok }
	fnsection "PAGE$text"

	STATUS_NOT_IMPLEMENTED ok!
end

fn (IODispatchUnlinkFunction) FatUnlink { name dirfcb -- ok }
	fnsection "PAGE$text"

	STATUS_NOT_IMPLEMENTED ok!
end

fn (IODispatchRenameFunction) FatRename { srcname srcfcb destname destfcb -- ok }
	fnsection "PAGE$text"

	STATUS_NOT_IMPLEMENTED ok!
end

fn FatDirectoryGetRawEntry { skipempty seek fcb lastbcb -- fatdirent bcb nextseek ok }
	fnsection "PAGE$text"

	// make sure not to overwrite the caller's lastbcb in case of an error
	// return.

	lastbcb@ bcb!

	// get the next raw entry from the directory
	// ignores LFN etc

	// FCB is locked by caller

	if (DEBUGCHECKS)
		if (fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FileType + @ OSFILETYPE_DIRECTORY ~=)
			// should have been caught by the IO system code
			"FatDirectoryGetEntry: not a directory\n" KeCrash
		end
	end

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	auto bytesize
	fcb@ IOFileControlBlock_SizeInBytes + @ bytesize!

	auto byteoff
	seek@ FatDirectoryEntry_SIZEOF * byteoff!

	auto mapfcb

	if (fatdata@ FatData_FatType + @ 32 ~=
		mount@ IOMount_RootFCB + @ fcb@ == &&)
		// FAT12/16 access the root directory thru the volume file

		fatdata@ FatData_RootFirstCluster + @ // actually the first sector
		fatdata@ FatData_SectorSizeShift + @ << byteoff +=

		fatdata@ FatData_RootFirstCluster + @
		fatdata@ FatData_SectorSizeShift + @ << bytesize +=

		mount@ IOMount_FsDeviceObject + @ IODevice_FileControlBlock + @ mapfcb!
	end else
		if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
			fcb@ IOFileControlBlockCacheCheck ok! drop

			if (ok@)
				return
			end
		end

		fcb@ mapfcb!
	end

	auto pageno
	byteoff@ FILEVIEWSHIFT >> pageno!

	auto curpageno
	auto data

	if (lastbcb@)
		lastbcb@ VcBuffer_FileOffset + @ FILEVIEWSHIFT >> curpageno!
		lastbcb@ VcBuffer_WindowAddress + @ byteoff@ FILEVIEWOFFSETMASK & + data!
	end else
		-1 curpageno!
	end

	while (byteoff@ bytesize@ <)
		if (pageno@ curpageno@ ~=)
			// must read in a new page

			byteoff@ // offset
			mapfcb@ // fcb
			VcFileControlBlockMap ok! bcb! data!

			if (ok@)
				lastbcb@ bcb!
				return
			end

			if (lastbcb@)
				lastbcb@ VcBufferDecrementMapCount drop
			end

			bcb@ lastbcb!

			pageno@ curpageno!
		end

		if (skipempty@)
			if (data@ gb FAT_DIRENT_FREE_ALL ==)
				// there are no more dirents in this directory

				break
			end

			if (data@ gb FAT_DIRENT_FREE ~=)
				data@ fatdirent!

				1 seek +=
				seek@ nextseek!

				0 ok!

				return
			end
		end else
			data@ fatdirent!

			1 seek +=
			seek@ nextseek!

			0 ok!

			return
		end

		FatDirectoryEntry_SIZEOF data +=
		FatDirectoryEntry_SIZEOF byteoff +=
		byteoff@ FILEVIEWSHIFT >> pageno!
		1 seek +=
	end

	seek@ nextseek!
	STATUS_END_OF_FILE ok!
end

fn FatDirectoryGetEntry { seek dirent fcb lastbcb -- bcb nextseek ok }
	fnsection "PAGE$text"

	// return the next valid entry in the fs-independent dirent.
	// deals with LFN.

	lastbcb@ bcb!

	auto fatdirent
	1 // skipempty
	seek@ // seek
	fcb@ // fcb
	bcb@ // lastbcb
	FatDirectoryGetRawEntry ok! seek! bcb! fatdirent!

	if (ok@)
		return
	end

	// figure out what kind of entry this is.
	// the cases we care about are normal short file name, and LFN.

end

fn FatRootDirectoryFindVolumeLabel { mount -- }
	fnsection "PAGE$text"

	auto ok

	auto fatdirent

	auto fcb
	mount@ IOMount_RootFCB + @ fcb!

	auto bcb
	0 bcb!

	auto seek
	0 seek!

	while (1)
		1 // skipempty
		seek@ // seek
		fcb@ // fcb
		bcb@ // lastbcb
		FatDirectoryGetRawEntry ok! seek! bcb! fatdirent!

		if (ok@)
			break
		end

		auto attr
		fatdirent@ FatDirectoryEntry_AttributeB + gb attr!

		if (attr@ FAT_ATTR_LFN ~=
			attr@ FAT_ATTR_VOLUME_ID & &&)

			// found it. copy it

			auto label
			mount@ IOMount_Extension + @ FatData_VolumeLabel + label!

			auto lastcharpos
			0 lastcharpos!

			auto i
			0 i!

			while (i@ 11 <)
				fatdirent@ gb label@ sb

				if (fatdirent@ gb ~~)
					break
				end

				if (fatdirent@ gb 0x20 ~=)
					label@ lastcharpos!
				end

				1 label +=
				1 fatdirent +=
				1 i +=
			end

			if (lastcharpos@)
				0 lastcharpos@ 1 + sb
			end else
				0 mount@ IOMount_Extension + @ FatData_VolumeLabel + sb
			end

			break
		end
	end

	if (bcb@)
		bcb@ VcBufferDecrementMapCount drop
	end
end

fn FatRootDirectoryCreate { mount -- ok }
	fnsection "PAGE$text"

	// create the FCB for the root directory.

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	auto fcb
	0 // flags
	OSFILETYPE_DIRECTORY // filetype
	mount@ // mount
	FatFCBCreate ok! fcb!

	if (ok@)
		return
	end

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	// set root directory as its own parent

	fcb@ fcbdata@ FatFCBData_ParentDirDCBData + !

	fatdata@ FatData_RootFirstCluster + @ fcbdata@ FatFCBData_StartingCluster + !

	if (fatdata@ FatData_FatType + @ 32 ==)
		// the root directory has a cluster chain in FAT32.

		fcb@ FatFCBMeasureSize ok!

		if (ok@)
			-1 // writeout
			fcb@ // fcb
			FatFCBDelete

			return
		end
	end else
		// the root directory has a fixed size in FAT12/16.

		fatdata@ FatData_RootEntryCount + @ FatDirectoryEntry_SIZEOF *
		fcb@ IOFileControlBlock_SizeInBytes + !
	end

	fcb@ mount@ IOMount_RootFCB + !

	fcb@ FatDirectoryFCBInitialize ok!

	if (ok@)
		0 mount@ IOMount_RootFCB + !

		-1 // writeout
		fcb@ // fcb
		FatFCBDelete

		return
	end
end

fn FatDirectoryFCBInitialize { fcb -- ok }
	fnsection "PAGE$text"

	// should be called on a new directory FCB after the size has been
	// determined (and cluster chain checked for validity) with
	// FatFCBMeasureSize.
	// constructs the dirent bitmap and initializes the child splay tree.

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	0 fcbdata@ FatDCBData_SplayTreeRoot + !
	0 fcbdata@ FatDCBData_DirentHint + !
	-1 fcbdata@ FatDCBData_LastDirentIndex + !
	
	auto size
	fcb@ IOFileControlBlock_SizeInBytes + @ size!

	auto entries
	size@ FatDirectoryEntry_SIZEOF / entries!

	auto bmpsz
	entries@ 7 + 3 >> bmpsz!

	auto bmp
	bmpsz@ // size
	'FDEB' // tag
	PAGED // flags
	MmAllocWithTag ok! bmp!

	if (ok@)
		return
	end

	entries@ // sizeinbits
	bmp@ // data
	fcbdata@ FatDCBData_DirentBitmapHeader + // header
	ComBitmapInitialize

	// iterate all of the directory entries and fill the dirent bitmap
	// appropriately.

	auto runlength
	0 runlength!

	auto runtype
	1 runtype!

	auto runstart
	0 runstart!

	auto seek
	0 seek!

	auto bcb
	0 bcb!

	auto free
	0 free!

	while (1)
		auto dirent
		0 // skipempty
		seek@ // seek
		fcb@ // fcb
		bcb@ // lastbcb
		FatDirectoryGetRawEntry ok! seek! bcb! dirent!

		if (ok@)
			break
		end

		if (dirent@ gb FAT_DIRENT_FREE ==
			dirent@ gb 0 == ||)

			if (runtype@)
				runlength@ // runlength
				runstart@ // index
				fcbdata@ FatDCBData_DirentBitmapHeader + // header
				ComBitmapSetBits

				0 runtype!
				1 runlength!
				seek@ 1 - runstart!
			end else
				1 runlength +=
			end

			if (dirent@ gb 0 ==)
				// there are no more dirents.

				entries@ seek@ - 1 - runlength +=

				seek@ 1 - fcbdata@ FatDCBData_LastDirentIndex + !

				break
			end
		end elseif (runtype@ ~~)
			runlength@ free +=

			runlength@ // runlength
			runstart@ // index
			fcbdata@ FatDCBData_DirentBitmapHeader + // header
			ComBitmapClearBits

			1 runtype!
			1 runlength!
			seek@ 1 - runstart!
		end else
			1 runlength +=
		end
	end

	if (ok@ STATUS_END_OF_FILE ==)
		0 ok!
	end

	if (ok@)
		bmp@ MmFree
	end elseif (runlength@)
		if (runtype@)
			runlength@ // runlength
			runstart@ // index
			fcbdata@ FatDCBData_DirentBitmapHeader + // header
			ComBitmapSetBits
		end else
			runlength@ free +=

			runlength@ // runlength
			runstart@ // index
			fcbdata@ FatDCBData_DirentBitmapHeader + // header
			ComBitmapClearBits
		end
	end

	fcbdata@ FatDCBData_DirentBitmapHeader +
	ComBitmapDump

	fcbdata@ FatDCBData_LastDirentIndex + @
	free@ "dir: %d free, %d last\n" Printf

	free@ fcbdata@ FatDCBData_FreeDirentCount + !

	if (bcb@)
		bcb@ VcBufferDecrementMapCount drop
	end
end