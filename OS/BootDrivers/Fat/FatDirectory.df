//
// Implements directory management for the FAT driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "<inc>/ViewCache.h"

#include "Fat.h"

fn (IODispatchReadDirectoryFunction) FatReadDirectory { seek dirent fcb -- nextseek ok }
	fnsection "PAGE$text"

	if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		auto mount
		fcb@ FSFileControlBlockGetMount mount!

		// only initialize caching if this is FAT32 or the FCB is not root.
		// the reason for this is that on FAT12/16, we access the root
		// directory through the volume file, and its FCB is just a dummy.
		// in that case, we don't want to initialize caching on it, since no
		// I/O will ever go through it anyway.

		if (mount@ IOMount_Extension + @ FatData_FatType + @ 32 ==
			fcb@ mount@ IOMount_RootFCB + @ ~= ||)

			fcb@ IOFileControlBlockCacheCheck ok! drop

			if (ok@)
				return
			end
		end
	end

	fcb@ IOFileControlBlockLockShared ok!

	if (ok@)
		return
	end

	auto bcb
	0 bcb!

	auto fatdirent

	seek@ // seek
	dirent@ // dirent
	fcb@ // fcb
	bcb@ // lastbcb
	FatDirectoryGetEntry ok! nextseek! drop bcb! drop

	fcb@ IOFileControlBlockUnlock

	if (bcb@)
		bcb@ VcBufferDecrementMapCount drop
	end
end

fn (IODispatchUnlinkFunction) FatUnlink { name dirfcb -- ok }
	fnsection "PAGE$text"

	name@ FatVerifyName ok!

	if (ok@)
		if (ok@ STATUS_ALREADY_EXISTS ==)
			STATUS_FORBIDDEN_OPERATION ok!
		end

		return
	end

	auto mount
	dirfcb@ FSFileControlBlockGetMount mount!

	if (dirfcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
		if (mount@ IOMount_Extension + @ FatData_FatType + @ 32 ==
			dirfcb@ mount@ IOMount_RootFCB + @ ~= ||)

			dirfcb@ IOFileControlBlockCacheCheck ok! drop

			if (ok@)
				return
			end
		end
	end

	auto fcb
	0 // flags
	name@ // name
	dirfcb@ // dirfcb
	mount@ // mount
	FatDirectoryGetChildByName ok! fcb!

	if (ok@)
		return
	end

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto fcbdata
	fcbp@ IOFileControlBlockPaged_FSContext + @ fcbdata!

	if (fcbp@ IOFileControlBlockPaged_FileType + @ OSFILETYPE_DIRECTORY ==)
		// return an appropriate error status if this is a directory with
		// cached children.

		if (fcbdata@ FatDCBData_SplayTreeRoot + @)
			fcb@ FatFCBDereference

			STATUS_IS_A_DIRECTORY ok!

			return
		end
	end

	if (fcbdata@ FatFCBData_References + @ 1 ~=)
		fcb@ FatFCBDereference

		STATUS_FILE_BUSY ok!

		return
	end

	// remove all cache pages.
	// this has to be done before we free the disk blocks, otherwise pageouts
	// in progress will behave unpredictably.

	0 // writeout
	fcb@ // fcb
	IOFileControlBlockDestroyCache

	// free disk blocks.

	fcb@ FatTruncateToZero ok!

	if (ok@)
		return
	end

	// free dirent(s).

	fcb@ FatFreeDirents

	// delete FCB.

	-1 // writeout
	fcb@ // fcb
	FatFCBDelete
end

fn (IODispatchRenameFunction) FatRename { srcname srcfcb destname destfcb -- ok }
	fnsection "PAGE$text"

	STATUS_NOT_IMPLEMENTED ok!
end

fn FatDirectoryGetRawEntry { dirty skipempty seek fcb lastbcb -- fatdirent bcb nextseek ok }
	fnsection "PAGE$text"

	// make sure not to overwrite the caller's lastbcb in case of an error
	// return.

	lastbcb@ bcb!

	// get the next raw entry from the directory
	// ignores LFN etc

	// FCB is locked by caller

	if (DEBUGCHECKS)
		if (fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FileType + @ OSFILETYPE_DIRECTORY ~=)
			// should have been caught by the IO system code
			"FatDirectoryGetEntry: not a directory\n" KeCrash
		end
	end

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	auto bytesize
	fcb@ IOFileControlBlock_SizeInBytes + @ bytesize!

	auto byteoff
	seek@ FatDirectoryEntry_SIZEOF * byteoff!

	auto mapfcb

	if (fatdata@ FatData_FatType + @ 32 ~=
		mount@ IOMount_RootFCB + @ fcb@ == &&)
		// FAT12/16 access the root directory thru the volume file

		fatdata@ FatData_RootFirstCluster + @ // actually the first sector
		fatdata@ FatData_SectorSizeShift + @ << byteoff +=

		fatdata@ FatData_RootFirstCluster + @
		fatdata@ FatData_SectorSizeShift + @ << bytesize +=

		mount@ IOMount_FsDeviceObject + @ IODevice_FileControlBlock + @ mapfcb!
	end else
		if (fcb@ IOFileControlBlock_CacheInfoBlock + @ ~~)
			fcb@ IOFileControlBlockCacheCheck ok! drop

			if (ok@)
				return
			end
		end

		fcb@ mapfcb!
	end

	auto pageno
	byteoff@ FILEVIEWSHIFT >> pageno!

	auto curpageno
	auto data

	if (lastbcb@)
		lastbcb@ VcBuffer_FileOffset + @ FILEVIEWSHIFT >> curpageno!
		lastbcb@ VcBuffer_WindowAddress + @ byteoff@ FILEVIEWOFFSETMASK & + data!
	end else
		-1 curpageno!
	end

	while (byteoff@ bytesize@ <)
		if (pageno@ curpageno@ ~=)
			// must read in a new page

			if (dirty@ bcb@ &&)
				bcb@ VcBufferDirty
			end

			byteoff@ // offset
			mapfcb@ // fcb
			VcFileControlBlockMap ok! bcb! data!

			if (ok@)
				lastbcb@ bcb!
				return
			end

			if (lastbcb@)
				lastbcb@ VcBufferDecrementMapCount drop
			end

			bcb@ lastbcb!

			pageno@ curpageno!
		end

		if (skipempty@)
			if (data@ gb FAT_DIRENT_FREE_ALL ==)
				// there are no more dirents in this directory

				break
			end

			if (data@ gb FAT_DIRENT_FREE ~=)

				data@ fatdirent!

				1 seek +=
				seek@ nextseek!

				0 ok!

				return
			end
		end else
			data@ fatdirent!

			1 seek +=
			seek@ nextseek!

			0 ok!

			return
		end

		FatDirectoryEntry_SIZEOF data +=
		FatDirectoryEntry_SIZEOF byteoff +=
		byteoff@ FILEVIEWSHIFT >> pageno!
		1 seek +=
	end

	seek@ nextseek!
	STATUS_END_OF_FILE ok!
end

fn FatDirectoryGetLFNEntry { dirent fatdirent seek fcb lastbcb -- shortdirent bcb nextseek ok }
	fnsection "PAGE$text"

	lastbcb@ bcb!
	seek@ nextseek!
	-1 ok!

	// parse the LFN entries and assemble the name into the fs-independent
	// dirent. the first LFN entry is supplied in fatdirent, subsequent ones
	// we have to get ourselves.

	auto dest
	dirent@ OSDirectoryEntry_Name + dest!

	auto ordinal
	fatdirent@ FatLFNEntry_OrdinalB + gb ordinal!

	if (ordinal@ 0x40 & ~~)
		// corrupted LFN entry, skip
		return
	end

	auto firstchecksum
	fatdirent@ FatLFNEntry_ChecksumB + gb firstchecksum!

	0x40 ~ ordinal &=

	if (ordinal@ ~~)
		// corrupted LFN entry, skip
		return
	end

	if (ordinal@ 20 >)
		// corrupted LFN entry, skip
		return
	end

	ordinal@ 13 * dest +=
	0 dest@ sb

	while (ordinal@)
		13 dest -=

		auto thisent
		dest@ thisent!

		if (fatdirent@ FatDirectoryEntry_AttributeB + gb FAT_ATTR_LFN_MASK & FAT_ATTR_LFN ~=)
			// corrupted LFN entry
			return
		end

		if (fatdirent@ FatLFNEntry_OrdinalB + gb 0x40 ~ & ordinal@ ~=)
			// corrupted LFN entry
			return
		end

		if (fatdirent@ FatLFNEntry_ChecksumB + gb firstchecksum@ ~=)
			// corrupted LFN entry
			return
		end

		if (fatdirent@ FatLFNEntry_TypeB + gb 0 ~=)
			// corrupted LFN entry
			return
		end

		if (fatdirent@ FatLFNEntry_FirstClusterLowI + gi 0 ~=)
			// corrupted LFN entry
			return
		end

		auto src
		fatdirent@ FatLFNEntry_Name1 + src!

		auto i
		0 i!

		while (i@ 5 <)
			// this completely obliterates the upper 8 bits of the character
			// encoding, but we don't support UCS-2 anyway.

			src@ gb thisent@ sb

			if (src@ gb ~~)
				0 ok!
				break
			end

			1 i +=
			2 src +=
			1 thisent +=
		end

		if (ok@)
			fatdirent@ FatLFNEntry_Name2 + src!
			0 i!

			while (i@ 6 <)
				src@ gb thisent@ sb

				if (src@ gb ~~)
					0 ok!
					break
				end

				1 i +=
				2 src +=
				1 thisent +=
			end
		end

		if (ok@)
			fatdirent@ FatLFNEntry_Name3 + src!
			0 i!

			while (i@ 2 <)
				src@ gb thisent@ sb

				if (src@ gb ~~)
					0 ok!
					break
				end

				1 i +=
				2 src +=
				1 thisent +=
			end
		end

		0 // dirty
		0 // skipempty
		nextseek@ // seek
		fcb@ // fcb
		bcb@ // lastbcb
		FatDirectoryGetRawEntry ok! nextseek! bcb! fatdirent!

		if (ok@)
			return
		end

		-1 ok!

		1 ordinal -=
	end

	-1 ok!

	// we should now have the short entry in fatdirent.
	// first lets confirm its a valid short entry.

	fatdirent@ shortdirent!

	if (fatdirent@ gb FAT_DIRENT_FREE ==
		fatdirent@ gb FAT_DIRENT_FREE_ALL == ||)

		// not valid.

		return
	end

	if (fatdirent@ FatDirectoryEntry_AttributeB + gb FAT_ATTR_LFN_MASK & FAT_ATTR_LFN ==)
		// not valid.

		1 nextseek -=

		return
	end

	if (fatdirent@ FatDirectoryEntry_AttributeB + gb FAT_ATTR_VOLUME_ID &)
		// not valid.

		return
	end

	// now lets check that the LFN checksum matches the short entry name.

	auto checksum
	fatdirent@ FatLFNChecksum checksum!

	if (checksum@ firstchecksum@ ~=)
		// not a match. back the nextseek up by one so that this short entry
		// name isn't skipped.

		1 nextseek -=

		return
	end

	0 ok!
end

fn FatLFNChecksum { shortname -- checksum }
	fnsection "PAGE$text"

	shortname@ gb checksum!

	auto i
	1 i!

	1 shortname +=

	while (i@ 11 <)
		if (checksum@ 1 &)
			0x80
			checksum@ 1 >> +
			shortname@ gb +
			checksum!
		end else
			0x00
			checksum@ 1 >> +
			shortname@ gb +
			checksum!
		end

		0xFF checksum &=

		1 i +=
		1 shortname +=
	end
end

fn FatDirectoryGetShortEntry { dirent fatdirent seek fcb lastbcb -- shortdirent bcb nextseek ok }
	fnsection "PAGE$text"

	lastbcb@ bcb!
	seek@ nextseek!
	0 ok!

	fatdirent@ shortdirent!

	// parse the short entry and assemble the name into the fs-independent
	// dirent. this is pretty easy for short entries.

	auto dest
	dirent@ OSDirectoryEntry_Name + dest!

	auto src
	fatdirent@ src!

	auto i
	0 i!

	while (i@ 8 <)
		if (src@ gb ~~
			src@ gb ' ' == ||)

			break
		end

		src@ gb dest@ sb

		1 src +=
		1 dest +=
		1 i +=
	end

	fatdirent@ 8 + src!

	if (src@ gb ' ' ~=
		src@ gb 0 ~= &&)

		// theres an extension

		'.' dest@ sb
		1 dest +=

		0 i!

		while (i@ 3 <)
			if (src@ gb ~~
				src@ gb ' ' == ||)

				break
			end

			src@ gb dest@ sb

			1 dest +=
			1 i +=
			1 src +=
		end
	end

	0 dest@ sb

	// skip . and .. since mintia handles these specially and so these dirents
	// are not relevant to our driver.

	if (dirent@ OSDirectoryEntry_Name + "." strcmp)
		-1 ok!
		return
	end

	if (dirent@ OSDirectoryEntry_Name + ".." strcmp)
		-1 ok!
		return
	end
end

fn FatDirectoryGetEntry { seek dirent fcb lastbcb -- shortdirent bcb longseek nextseek ok }
	fnsection "PAGE$text"

	// return the next valid entry in the fs-independent dirent.
	// deals with LFN.

	lastbcb@ bcb!
	seek@ nextseek!

	while (1)
		-1 longseek!

		auto fatdirent

		0 // dirty
		1 // skipempty
		nextseek@ // seek
		fcb@ // fcb
		bcb@ // lastbcb
		FatDirectoryGetRawEntry ok! nextseek! bcb! fatdirent!

		if (ok@)
			break
		end

		// figure out what kind of entry this is.
		// the cases we care about are normal short file name, and LFN.
		// we loop in case the entry turns out to be corrupted and the routine
		// we call to parse it decides to skip over it.

		auto attr
		fatdirent@ FatDirectoryEntry_AttributeB + gb attr!

		if (attr@ FAT_ATTR_LFN_MASK & FAT_ATTR_LFN ==)
			nextseek@ 1 - longseek!

			dirent@ // dirent
			fatdirent@ // fatdirent
			nextseek@ // seek
			fcb@ // fcb
			bcb@ // lastbcb
			FatDirectoryGetLFNEntry ok! nextseek! bcb! shortdirent!
		end elseif (attr@ FAT_ATTR_VOLUME_ID & ~~)
			-1 longseek!

			dirent@ // dirent
			fatdirent@ // fatdirent
			nextseek@ // seek
			fcb@ // fcb
			bcb@ // lastbcb
			FatDirectoryGetShortEntry ok! nextseek! bcb! shortdirent!
		end else
			-1 longseek!
			-1 ok!
		end

		// loop until ok either indicates EOF or success.

		if (ok@ STATUS_END_OF_FILE ==)
			break
		end

		if (ok@ ~~)
			break
		end
	end
end

fn FatDirectoryFindEntry { name fcb -- longdirentseek shortdirentseek shortdirent bcb ok }
	fnsection "PAGE$text"

	auto dirent
	OSDirectoryEntry_SIZEOF alloc dirent!

	0 shortdirentseek!

	0 bcb!

	while (1)
		shortdirentseek@ // shortdirentseek
		dirent@ // dirent
		fcb@ // fcb
		bcb@ // lastbcb
		FatDirectoryGetEntry ok! shortdirentseek! longdirentseek! bcb! shortdirent!

		if (ok@)
			break
		end

		if (name@ dirent@ OSDirectoryEntry_Name + strcmp)
			1 shortdirentseek -=
			return
		end
	end

	if (bcb@)
		bcb@ VcBufferDecrementMapCount drop
	end

	if (ok@ STATUS_END_OF_FILE ==)
		STATUS_NOT_FOUND ok!
	end
end

fn FatRootDirectoryFindVolumeLabel { mount -- }
	fnsection "PAGE$text"

	auto ok

	auto fatdirent

	auto fcb
	mount@ IOMount_RootFCB + @ fcb!

	auto bcb
	0 bcb!

	auto seek
	0 seek!

	while (1)
		0 // dirty
		1 // skipempty
		seek@ // seek
		fcb@ // fcb
		bcb@ // lastbcb
		FatDirectoryGetRawEntry ok! seek! bcb! fatdirent!

		if (ok@)
			break
		end

		auto attr
		fatdirent@ FatDirectoryEntry_AttributeB + gb attr!

		if (attr@ FAT_ATTR_LFN_MASK & FAT_ATTR_LFN ~=
			attr@ FAT_ATTR_VOLUME_ID & &&)

			// found it. copy it

			auto label
			mount@ IOMount_Extension + @ FatData_VolumeLabel + label!

			auto lastcharpos
			0 lastcharpos!

			auto i
			0 i!

			while (i@ 11 <)
				fatdirent@ gb label@ sb

				if (fatdirent@ gb ~~)
					break
				end

				if (fatdirent@ gb 0x20 ~=)
					label@ lastcharpos!
				end

				1 label +=
				1 fatdirent +=
				1 i +=
			end

			if (lastcharpos@)
				0 lastcharpos@ 1 + sb
			end else
				0 mount@ IOMount_Extension + @ FatData_VolumeLabel + sb
			end

			break
		end
	end

	if (bcb@)
		bcb@ VcBufferDecrementMapCount drop
	end
end

fn FatRootDirectoryCreate { mount -- ok }
	fnsection "PAGE$text"

	// create the FCB for the root directory.

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	auto fcb
	0 // name
	0 // flags
	OSFILETYPE_DIRECTORY // filetype
	mount@ // mount
	FatFCBCreate ok! fcb!

	if (ok@)
		return
	end

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	fatdata@ FatData_RootFirstCluster + @ fcbdata@ FatFCBData_StartingCluster + !

	if (fatdata@ FatData_FatType + @ 32 ==)
		// the root directory has a cluster chain in FAT32.

		fcb@ FatFCBMeasureSize ok!

		if (ok@)
			-1 // writeout
			fcb@ // fcb
			FatFCBDelete

			return
		end
	end else
		// the root directory has a fixed size in FAT12/16.

		fatdata@ FatData_RootEntryCount + @ FatDirectoryEntry_SIZEOF *
		fcb@ IOFileControlBlock_SizeInBytes + !
	end

	fcb@ mount@ IOMount_RootFCB + !
end

fn FatDirectoryFCBInitializeAllocation { fcb -- ok }
	fnsection "PAGE$text"

	// should be called on a directory FCB the first time someone tries to
	// allocate or deallocate entries within the directory.
	// constructs the dirent bitmap.

	fcb@ IOFileControlBlockLock ok!

	if (ok@)
		return
	end

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	if (fcbdata@ FatDCBData_DirentBitmapHeader + ComBitmapGetData)
		fcb@ IOFileControlBlockUnlock

		// already initialized

		0 ok!

		return
	end
	
	auto size
	fcb@ IOFileControlBlock_SizeInBytes + @ size!

	auto entries
	size@ FatDirectoryEntry_SIZEOF / entries!

	auto bmpsz
	entries@ 7 + 3 >> bmpsz!

	auto bmp
	bmpsz@ // size
	'FDEB' // tag
	PAGED // flags
	MmAllocWithTag ok! bmp!

	if (ok@)
		fcb@ IOFileControlBlockUnlock

		return
	end

	entries@ // sizeinbits
	bmp@ // data
	fcbdata@ FatDCBData_DirentBitmapHeader + // header
	ComBitmapInitialize

	// iterate all of the directory entries and fill the dirent bitmap
	// appropriately.

	auto runlength
	0 runlength!

	auto runtype
	1 runtype!

	auto runstart
	0 runstart!

	auto seek
	0 seek!

	auto bcb
	0 bcb!

	auto free
	0 free!

	while (1)
		auto dirent

		0 // dirty
		0 // skipempty
		seek@ // seek
		fcb@ // fcb
		bcb@ // lastbcb
		FatDirectoryGetRawEntry ok! seek! bcb! dirent!

		if (ok@)
			break
		end

		if (dirent@ gb FAT_DIRENT_FREE ==
			dirent@ gb 0 == ||)

			if (runtype@)
				runlength@ // runlength
				runstart@ // index
				fcbdata@ FatDCBData_DirentBitmapHeader + // header
				ComBitmapSetBits

				0 runtype!
				1 runlength!
				seek@ 1 - runstart!
			end else
				1 runlength +=
			end

			if (dirent@ gb 0 ==)
				// there are no more dirents.

				entries@ seek@ - runlength +=

				seek@ 1 - fcbdata@ FatDCBData_LastDirentIndex + !

				break
			end
		end elseif (runtype@ ~~)
			runlength@ free +=

			runlength@ // runlength
			runstart@ // index
			fcbdata@ FatDCBData_DirentBitmapHeader + // header
			ComBitmapClearBits

			1 runtype!
			1 runlength!
			seek@ 1 - runstart!
		end else
			1 runlength +=
		end
	end

	if (ok@ STATUS_END_OF_FILE ==)
		0 ok!
	end

	if (runlength@)
		if (runtype@)
			runlength@ // runlength
			runstart@ // index
			fcbdata@ FatDCBData_DirentBitmapHeader + // header
			ComBitmapSetBits
		end else
			runlength@ free +=

			runlength@ // runlength
			runstart@ // index
			fcbdata@ FatDCBData_DirentBitmapHeader + // header
			ComBitmapClearBits
		end
	end

	if (ok@)
		bmp@ MmFree

		0 // sizeinbits
		0 // data
		fcbdata@ FatDCBData_DirentBitmapHeader + // header
		ComBitmapInitialize
	end

//	fcbdata@ FatDCBData_DirentBitmapHeader +
//	ComBitmapDump

//	bmp@ MmBlockChargeGet
//	fcbdata@ FatDCBData_LastDirentIndex + @
//	free@ "dir: %d free, %d last, %d bmpsz\n" Printf

	free@ fcbdata@ FatDCBData_FreeDirentCount + !

	if (bcb@)
		bcb@ VcBufferDecrementMapCount drop
	end

	fcb@ IOFileControlBlockUnlock
end

const NAME_EQUAL   0
const NAME_LESS    1
const NAME_GREATER 2

fn FatDirectoryGetCachedChild { name fcb mount -- childfcb ok }
	fnsection "PAGE$text"

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	1 // alertable
	mount@ // mount
	FatFCBCacheLock ok!

	if (ok@)
		return
	end

	// copypasted from ExSplayTreeFindNodeByValue and adapted for string
	// comparisons

	auto childfcbdata
	fcbdata@ FatDCBData_SplayTreeRoot + @ childfcbdata!

	while (1)
		if (childfcbdata@ ~~)
			break
		end

		auto cmp
		name@ childfcbdata@ ExSplayTreeNode_Value + @ FatNameCompare cmp!

		if (cmp@ NAME_LESS ==)
			childfcbdata@ ExSplayTreeNode_LeftChild + @ childfcbdata!
		end elseif (cmp@ NAME_GREATER ==)
			childfcbdata@ ExSplayTreeNode_RightChild + @ childfcbdata!
		end else
			childfcbdata@ // node
			fcbdata@ FatDCBData_SplayTreeRoot + // rootptr
			ExSplayTreeSplay

			break
		end
	end

	if (childfcbdata@ ~~)
		mount@ FatFCBCacheUnlock

		0 childfcb!

		return
	end

	childfcbdata@ FatFCBData_FCB + @ childfcb!
	childfcb@ FatFCBReferenceLockHeld

	mount@ FatFCBCacheUnlock
end

fn FatDirectoryInsertCachedChild { childfcb fcb mount -- }
	fnsection "PAGE$text"

	auto rootptr
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatDCBData_SplayTreeRoot + rootptr!

	auto childfcbdata
	childfcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ childfcbdata!

	0 childfcbdata@ ExSplayTreeNode_LeftChild + !
	0 childfcbdata@ ExSplayTreeNode_RightChild + !

	auto name
	childfcbdata@ ExSplayTreeNode_Value + @ name!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	0 // alertable
	mount@ // mount
	FatFCBCacheLock drop

	// add the childfcbdata to the mount's list of active fcbdatas.

	auto h
	fatdata@ FatData_FCBDataListHead + @ h!

	h@ childfcbdata@ FatFCBData_NextFCBData + !
	0 childfcbdata@ FatFCBData_PrevFCBData + !

	if (h@)
		childfcbdata@ h@ FatFCBData_PrevFCBData + !
	end

	childfcbdata@ fatdata@ FatData_FCBDataListHead + !

	// make the childfcbdata point to the directory FCB.

	fcb@ childfcbdata@ FatFCBData_ParentDirDCB + !
	fcb@ FatFCBReferenceLockHeld

	// insert the childfcbdata in the directory's splay tree.

	auto parent
	rootptr@@ parent!

	if (parent@ ~~)
		childfcbdata@ rootptr@!
		0 childfcbdata@ ExSplayTreeNode_Parent + !

		mount@ FatFCBCacheUnlock

		return
	end

	auto level
	0 level!

	while (1)
		if (level@ 8 ==)
			parent@ rootptr@ ExSplayTreeSplay
			0 level!
		end

		1 level +=

		auto cmp
		name@ parent@ ExSplayTreeNode_Value + @ FatNameCompare cmp!

		if (cmp@ NAME_LESS ==)
			if (parent@ ExSplayTreeNode_LeftChild + @)
				parent@ ExSplayTreeNode_LeftChild + @ parent!
			end else
				childfcbdata@ parent@ ExSplayTreeNode_LeftChild + !
				parent@ childfcbdata@ ExSplayTreeNode_Parent + !
				break
			end
		end else
			if (parent@ ExSplayTreeNode_RightChild + @)
				parent@ ExSplayTreeNode_RightChild + @ parent!
			end else
				childfcbdata@ parent@ ExSplayTreeNode_RightChild + !
				parent@ childfcbdata@ ExSplayTreeNode_Parent + !
				break
			end
		end
	end

	mount@ FatFCBCacheUnlock
end

fn FatDirectoryRemoveCachedChild { childfcb mount -- }
	fnsection "PAGE$text"

	auto childfcbdata
	childfcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ childfcbdata!

	auto fcb
	childfcbdata@ FatFCBData_ParentDirDCB + @ fcb!

	auto rootptr
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ FatDCBData_SplayTreeRoot + rootptr!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	0 // alertable
	mount@ // mount
	FatFCBCacheLock drop

	// remove the childfcbdata from the mount's list of active fcbdatas

	auto n
	childfcbdata@ FatFCBData_NextFCBData + @ n!

	auto p
	childfcbdata@ FatFCBData_PrevFCBData + @ p!

	if (n@)
		p@ n@ FatFCBData_PrevFCBData + !
	end

	if (p@)
		n@ p@ FatFCBData_NextFCBData + !
	end else // no prev means we were the head
		n@ fatdata@ FatData_FCBDataListHead + !
	end

	// remove the childfcbdata from the directory's splay tree.

	childfcbdata@ // node
	rootptr@ // rootptr
	ExSplayTreeRemove

	mount@ FatFCBCacheUnlock

	fcb@ FatFCBDereference
end

fn FatNameCompare { name1 name2 -- cmp }
	fnsection "PAGE$text"

	auto n1len
	name1@ strlen n1len!

	auto n2len
	name2@ strlen n2len!

	auto minlen
	n1len@ n2len@ min minlen!

	while (minlen@)
		if (name1@ gb name2@ gb >)
			NAME_GREATER cmp!
			return
		end

		if (name1@ gb name2@ gb <)
			NAME_LESS cmp!
			return
		end

		1 minlen -=
		1 name1 +=
		1 name2 +=
	end

	if (n1len@ n2len@ ==)
		NAME_EQUAL cmp!
		return
	end

	if (n1len@ n2len@ <)
		NAME_LESS cmp!
		return
	end

	NAME_GREATER cmp!
end

fn FatUpdateDirent { fcb -- }
	fnsection "PAGE$text"

	auto fcbp
	fcb@ IOFileControlBlock_Paged + @ fcbp!

	auto fcbdata
	fcbp@ IOFileControlBlockPaged_FSContext + @ fcbdata!

	auto dirfcb
	fcbdata@ FatFCBData_ParentDirDCB + @ dirfcb!

	if (dirfcb@ ~~)
		return
	end

	// it's okay to fiddle with the dirent here, since the FCB is already part
	// of the parent directory's splay tree, which means nobody is going to be
	// looking at this dirent directly.

	auto bcb
	auto fatdirent

	auto ok

	0 // dirty
	0 // skipempty
	fcbdata@ FatFCBData_ShortDirentSeek + @ // seek
	dirfcb@ // fcb
	0 // lastbcb
	FatDirectoryGetRawEntry ok! drop bcb! fatdirent!

	if (ok@)
		return
	end

	// re-encode the relevant fcbdata fields into the dirent

	auto firstcluster
	fcbdata@ FatFCBData_StartingCluster + @ firstcluster!

	firstcluster@ 0xFFFF & fatdirent@ FatDirectoryEntry_FirstClusterLowI + si
	firstcluster@ 16 >> fatdirent@ FatDirectoryEntry_FirstClusterHighI + si

	fcb@ IOFileControlBlock_SizeInBytes + @
	fatdirent@ FatDirectoryEntry_FileSizeBytes + !

	// update timestamps

	auto localtime
	KeTime_SIZEOF alloc localtime!

	auto stamp

	localtime@ // desttime
	fcbp@ IOFileControlBlockPaged_AccessTime + // srctime
	KeRealTimeToLocalTime

	localtime@ KeTime_SecPart + @ FatUnixToDate stamp!

	stamp@ fatdirent@ FatDirectoryEntry_AccessDateI + si

	localtime@ // desttime
	fcbp@ IOFileControlBlockPaged_ModifyTime + // srctime
	KeRealTimeToLocalTime

	localtime@ KeTime_SecPart + @ FatUnixToDate stamp!

	stamp@ fatdirent@ FatDirectoryEntry_ModificationDateI + si

	localtime@ KeTime_SecPart + @ FatUnixToTime stamp!

	stamp@ fatdirent@ FatDirectoryEntry_ModificationTimeI + si

	localtime@ // desttime
	fcbp@ IOFileControlBlockPaged_CreationTime + // srctime
	KeRealTimeToLocalTime

	localtime@ KeTime_SecPart + @ FatUnixToDate stamp!

	stamp@ fatdirent@ FatDirectoryEntry_CreationDateI + si

	localtime@ KeTime_SecPart + @ FatUnixToTime stamp!

	stamp@ fatdirent@ FatDirectoryEntry_CreationTimeI + si

	bcb@ VcBufferDirty
	bcb@ VcBufferDecrementMapCount drop
end

fn FatFreeDirents { fcb -- }
	fnsection "PAGE$text"

	auto ok

	auto fcbdata
	fcb@ IOFileControlBlock_Paged + @ IOFileControlBlockPaged_FSContext + @ fcbdata!

	auto dirfcb
	fcbdata@ FatFCBData_ParentDirDCB + @ dirfcb!

	auto mount
	fcb@ FSFileControlBlockGetMount mount!

	auto fatdata
	mount@ IOMount_Extension + @ fatdata!

	// if the directory has a dirent bitmap, we need to keep it up to date.

	auto bmp
	dirfcb@ FatDCBData_DirentBitmapHeader + ComBitmapGetData bmp!

	if (bmp@)
		dirfcb@ FatDCBData_DirentBitmapHeader + bmp!
	end

	auto bcb
	0 bcb!

	auto fatdirent

	auto startseek
	fcbdata@ FatFCBData_LongDirentSeek + @ startseek!

	auto seek
	startseek@ seek!

	auto entries
	1 entries!

	// free the long entries

	if (seek@ -1 ~=)
		auto longcount
		fcbdata@ FatFCBData_ShortDirentSeek + @ seek@ - longcount!

		while (longcount@)
			1 // dirty
			0 // skipempty
			seek@ // seek
			dirfcb@ // fcb
			bcb@ // lastbcb
			FatDirectoryGetRawEntry ok! drop bcb! fatdirent!

			if (ok@)
				if (bcb@)
					bcb@ VcBufferDirty
					bcb@ VcBufferDecrementMapCount drop
				end

				return
			end

			FAT_DIRENT_FREE fatdirent@ sb

			1 entries +=
			1 longcount -=
			1 seek +=
		end
	end else
		fcbdata@ FatFCBData_ShortDirentSeek + @ startseek!
	end

	1 // dirty
	0 // skipempty
	fcbdata@ FatFCBData_ShortDirentSeek + @ // seek
	dirfcb@ // fcb
	bcb@ // lastbcb
	FatDirectoryGetRawEntry ok! drop bcb! fatdirent!

	if (ok@)
		if (bcb@)
			bcb@ VcBufferDirty
			bcb@ VcBufferDecrementMapCount drop
		end

		return
	end

	FAT_DIRENT_FREE fatdirent@ sb

	bcb@ VcBufferDirty
	bcb@ VcBufferDecrementMapCount drop

	if (bmp@)
		// free the entries in the bitmap

		entries@ // runlength
		startseek@ // index
		bmp@ // header
		ComBitmapClearBits
	end
end

fn FatDirectoryGetChildByName { flags name dirfcb mount -- fcb ok }
	fnsection "PAGE$text"

	// search the splay tree for the current DCB for the name.

	name@ // name
	dirfcb@ // fcb
	mount@ // mount
	FatDirectoryGetCachedChild ok! fcb!

	if (ok@)
		return
	end

	if (fcb@)
		return
	end

	// the FCB for this name doesn't exist.
	// there are three cases at this point:
	//
	//  1. The file exists on disk and isn't cached yet.
	//  2. The file does not exist on disk at all.
	//  3. The file does not exist on disk, and we want to create it.
	//
	// We have to traverse the directory now and acquire an FCB.
	// After that, we insert it into the parent directory's cache.

	auto bcb
	auto shortdirent
	auto shortdirentseek
	auto longdirentseek

	name@ // name
	dirfcb@ // fcb
	FatDirectoryFindEntry ok! bcb! shortdirent! shortdirentseek! longdirentseek!

	if (ok@)
		return
	end

	name@ // name
	flags@ // flags
	dirfcb@ // dirfcb
	longdirentseek@ // longdirentseek
	shortdirentseek@ // shortdirentseek
	shortdirent@ // shortdirent
	mount@ // mount
	FatFCBCreateFromDirent ok! fcb!

	bcb@ VcBufferDecrementMapCount drop

	if (ok@)
		return
	end
end

fn FatVerifyName { name -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (name@ "." strcmp)
		STATUS_ALREADY_EXISTS ok!
		return
	end

	if (name@ ".." strcmp)
		STATUS_ALREADY_EXISTS ok!
		return
	end

	auto length
	0 length!

	while (name@ gb)
		if (length@ 255 >=)
			STATUS_NAME_TOO_LONG ok!
			return
		end

		if (name@ gb 0x20 < name@ gb 0x7F >= ||)
			STATUS_ILLEGAL_NAME ok!
			return
		end

		if (name@ gb '/' ==)
			STATUS_ILLEGAL_NAME ok!
			return
		end

		1 length +=
		1 name +=
	end
end