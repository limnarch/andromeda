//
// Implements disk block management for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/Security.h"

#include "<inc>/IO.h"

#include "<inc>/Process.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

fn AFSBlockBitmapReadFAT { mount -- ok }
	// read the entire FAT page-by-page to construct an in-memory bitmap of
	// free blocks. assumes disks will be a reasonable size (100-500MB) or
	// else this bitmap will be too large to fit in kernel pool and mounting
	// the volume will fail. could probably be made more flexible.

	auto afsdata
	mount@ IOMountGetContext afsdata!

	auto blocks
	afsdata@ AFSData_VolSize + @ blocks!

	auto fatpfdbe
	0 fatpfdbe!

	auto blkno
	0 blkno!

	auto runlength
	0 runlength!

	auto runtype
	1 runtype!

	auto runstart
	0 runstart!

	auto fatblkno
	afsdata@ AFSData_FATStart + @ fatblkno!

	auto off
	0 off!

	auto fatdata

	while (blkno@ blocks@ <)
		if (off@ AFSBLOCKOFFMASK & ~~)
			// must read in a new FAT block

			if (fatpfdbe@)
				fatpfdbe@ MmEvictablePageDereference drop
			end

			0 // flags
			0 // kflags
			afsdata@ AFSData_FATStart + @ AFSBLOCKSHIFT << off@ + // offset
			mount@ // mount
			FSVolumeBlockRead ok! fatpfdbe! fatdata!

			if (ok@)
				return
			end
		end

		auto type
		fatdata@ off@ AFSBLOCKOFFMASK & + @ type!

		if (type@ ~~)
			if (runtype@)
				if (AFSDEBUG)
					runlength@ runstart@ "setrun start=%d length=%d\n" Printf
				end

				runlength@ // runlength
				runstart@ // index
				afsdata@ AFSData_FreeBlockBitmap + // header
				ComBitmapSetBits

				0 runtype!
				1 runlength!
				blkno@ runstart!
			end else
				1 runlength +=
			end
		end elseif (runtype@ ~~)
			if (AFSDEBUG)
				runlength@ runstart@ "clearrun start=%d length=%d\n" Printf
			end

			runlength@ // runlength
			runstart@ // index
			afsdata@ AFSData_FreeBlockBitmap + // header
			ComBitmapClearBits

			1 runtype!
			1 runlength!
			blkno@ runstart!
		end else
			1 runlength +=
		end

		4 off +=
		1 blkno +=
	end

	if (runlength@)
		if (runtype@)
			if (AFSDEBUG)
				runlength@ runstart@ "final setrun start=%d length=%d\n" Printf
			end

			runlength@ // runlength
			runstart@ // index
			afsdata@ AFSData_FreeBlockBitmap + // header
			ComBitmapSetBits
		end else
			if (AFSDEBUG)
				runlength@ runstart@ "final clearrun start=%d length=%d\n" Printf
			end

			runlength@ // runlength
			runstart@ // index
			afsdata@ AFSData_FreeBlockBitmap + // header
			ComBitmapClearBits
		end
	end

	if (fatpfdbe@)
		fatpfdbe@ MmEvictablePageDereference drop
	end

	if (AFSDEBUG 2 >=)
		blocks@ "total blocks=%d\n" Printf

		2000 // ms
		KERNELMODE // waitmode
		0 // alertable
		KeThreadSleep drop
	end
end

fn AFSBlockBitmapInitialize { mount -- ok }
	auto afsdata
	mount@ IOMountGetContext afsdata!

	auto blocks
	afsdata@ AFSData_VolSize + @ blocks!

	0 afsdata@ AFSData_FreeBlockHint + !

	auto bmpsz
	blocks@ 7 + 3 >> bmpsz!

	auto bmp
	bmpsz@ // size
	'AFSb' // tag
	PAGED // flags
	MmAllocWithTag ok! bmp!

	if (ok@)
		return
	end

	blocks@ // sizeinbits
	bmp@ // data
	afsdata@ AFSData_FreeBlockBitmap + // header
	ComBitmapInitialize

	"AFSBlockBitmapMutex" // name
	KERNELMODE // mode
	afsdata@ AFSData_FreeBlockBitmapMutex + // mutex
	KeMutexInitialize

	mount@ AFSBlockBitmapReadFAT ok!
end

fn AFSBlockBitmapUninitialize { mount -- }
	auto afsdata
	mount@ IOMountGetContext afsdata!

	auto blocks
	afsdata@ AFSData_VolSize + @ blocks!

	auto bmpsz
	blocks@ 7 + 3 >> bmpsz!

	afsdata@ AFSData_FreeBlockBitmap + ComBitmapGetData MmFree
end

fn AFSBlockBitmapLockUnalertable { mount -- }
	KERNELMODE // waitmode
	0 // alertable
	OSWAIT_TIMEOUTINFINITE // timeout
	mount@ IOMountGetContext AFSData_FreeBlockBitmapMutex + // object
	KeThreadWaitForObject drop
end

fn AFSBlockBitmapUnlock { mount -- }
	0 // abandon
	mount@ IOMountGetContext AFSData_FreeBlockBitmapMutex + // mutex
	KeMutexRelease drop
end

fn AFSWalkFAT { startcount startblkno mount kflags -- blkno ok }
	startblkno@ blkno!

	auto fatblkno
	0 fatblkno!

	auto curfatblkno
	-1 curfatblkno!

	auto fatpfdbe
	0 fatpfdbe!

	0 ok!

	auto off

	auto fatdata

	auto afsdata
	mount@ IOMountGetContext afsdata!

	while (startcount@)
		if (blkno@ 0xFFFFFFFF ==)
			"AFSWalkFAT: blkno == 0xFFFFFFFF\n" KeCrash
		end

		blkno@ 2 << AFSBLOCKSHIFT >> fatblkno!
		blkno@ 2 << AFSBLOCKOFFMASK & off!

		if (fatblkno@ curfatblkno@ ~=)
			// must read in a new FAT block

			if (fatpfdbe@)
				fatpfdbe@ MmEvictablePageDereference drop
			end

			0 // flags
			kflags@ // kflags
			afsdata@ AFSData_FATStart + @ fatblkno@ + AFSBLOCKSHIFT << // offset
			mount@ // mount
			FSVolumeBlockRead ok! fatpfdbe! fatdata!

			if (ok@)
				return
			end

			fatblkno@ curfatblkno!
		end

		fatdata@ off@ + @ blkno!

		1 startcount -=
	end

	if (fatpfdbe@)
		fatpfdbe@ MmEvictablePageDereference drop
	end
end

fn AFSBlockDeallocateChain { first blkno mount -- }
	mount@ AFSBlockBitmapLockUnalertable

	auto fatblkno
	0 fatblkno!

	auto curfatblkno
	-1 curfatblkno!

	auto fatpfdbe
	0 fatpfdbe!

	auto ok

	auto off

	auto fatdata

	auto afsdata
	mount@ IOMountGetContext afsdata!

	while (blkno@ 0xFFFFFFFF ~=)
		blkno@ 2 << AFSBLOCKSHIFT >> fatblkno!
		blkno@ 2 << AFSBLOCKOFFMASK & off!

		if (fatblkno@ curfatblkno@ ~=)
			// must read in a new FAT block

			if (fatpfdbe@)
				fatpfdbe@ // pfdbe
				mount@ // mount
				FSVolumeBlockWrite drop

				fatpfdbe@ MmEvictablePageDereference drop
			end

			0 // flags
			IOKFLAG_URGENT // kflags
			afsdata@ AFSData_FATStart + @ fatblkno@ + AFSBLOCKSHIFT << // offset
			mount@ // mount
			FSVolumeBlockRead ok! fatpfdbe! fatdata!

			if (ok@)
				ok@ "AFSBlockDeallocateChain: failed to read FAT block (%i)\n" KeCrash
			end

			fatblkno@ curfatblkno!
		end

		if (first@ ~~)
			1 // runlength
			blkno@ // index
			afsdata@ AFSData_FreeBlockBitmap + // header
			ComBitmapClearBits
		end

		fatdata@ off@ + @ blkno!

		if (first@)
			0xFFFFFFFF fatdata@ off@ + !
			0 first!
		end else
			0 fatdata@ off@ + !
		end
	end

	if (fatpfdbe@)
		fatpfdbe@ // pfdbe
		mount@ // mount
		FSVolumeBlockWrite drop

		fatpfdbe@ MmEvictablePageDereference drop
	end

	mount@ AFSBlockBitmapUnlock
end

fn AFSBlockAllocateChain { pintable blocks lastblkno zero mount -- startblkno ok }
	mount@ AFSBlockBitmapLockUnalertable

	auto afsdata
	mount@ IOMountGetContext afsdata!

	auto run

	auto blkno
	afsdata@ AFSData_FreeBlockHint + @ // hint
	blocks@ // runlength
	afsdata@ AFSData_FreeBlockBitmap + // header
	ComBitmapFindRun ok! blkno!

	if (ok@ ~~)
		// we were able to allocate the whole thing in one run!

		blocks@ // runlength
		blkno@ // index
		afsdata@ AFSData_FreeBlockBitmap + // header
		ComBitmapSetBits

		blkno@ afsdata@ AFSData_FreeBlockHint + !

		// don't need to keep the bitmap locked since we don't need to use it
		// now that we already found a big run.

		mount@ AFSBlockBitmapUnlock

		1 run!
	end else
		// need to allocate one block at a time.

		0 run!
	end

	auto fatblkno
	0 fatblkno!

	auto curfatblkno
	-1 curfatblkno!

	auto fatpfdbe
	0 fatpfdbe!

	auto first

	// if we fail and need to undo the allocation chain we already did,
	// does AFSBlockDeallocateChain need to write back a 0xFFFFFFFF or not?
	// we decide that here.

	if (lastblkno@ -1 ==)
		0 first!
	end else
		lastblkno@ 2 << AFSBLOCKSHIFT >> fatblkno!

		0 // flags
		IOKFLAG_URGENT // kflags
		afsdata@ AFSData_FATStart + @ fatblkno@ + AFSBLOCKSHIFT << // offset
		mount@ // mount
		FSVolumeBlockRead ok! fatpfdbe! fatdata!

		if (ok@)
			ok@ "AFSBlockAllocateChain: failed to read FAT block (%i)\n" KeCrash
		end

		fatblkno@ curfatblkno!

		if (DEBUGCHECKS)
			if (fatdata@ lastblkno@ 2 << AFSBLOCKOFFMASK & + @ 0xFFFFFFFF ~=)
				"AFSBlockAllocateChain: final block had a link\n" KeCrash
			end
		end

		1 first!
	end

	auto killstart
	lastblkno@ killstart!

	-1 startblkno!

	auto fatdata

	while (blocks@)
		if (run@ ~~)
			// allocate next block

			afsdata@ AFSData_FreeBlockHint + @ // hint
			1 // runlength
			afsdata@ AFSData_FreeBlockBitmap + // header
			ComBitmapFindRun ok! blkno!

			if (ok@)
				// no space left on disk.
				// undo the allocations we already did.

				mount@ AFSBlockBitmapUnlock

				if (fatpfdbe@)
					fatpfdbe@ // pfdbe
					mount@ // mount
					FSVolumeBlockWrite drop

					fatpfdbe@ MmEvictablePageDereference drop
				end

				if (killstart@ -1 ~=)
					first@ // first
					killstart@ // blkno
					mount@ // mount
					AFSBlockDeallocateChain
				end

				STATUS_END_OF_DISK ok!

				return
			end

			1 // runlength
			blkno@ // index
			afsdata@ AFSData_FreeBlockBitmap + // header
			ComBitmapSetBits

			blkno@ afsdata@ AFSData_FreeBlockHint + !
		end

		if (pintable@)
			blkno@ pintable@!
			4 pintable +=
		end

		if (fatpfdbe@)
			blkno@ fatdata@ lastblkno@ 2 << AFSBLOCKOFFMASK & + !
		end else
			if (DEBUGCHECKS)
				if (startblkno@ -1 ~=)
					"AFSBlockAllocateChain: startblkno != -1\n" KeCrash
				end
			end

			blkno@ killstart!
			blkno@ startblkno!
		end

		blkno@ 2 << AFSBLOCKSHIFT >> fatblkno!

		if (fatblkno@ curfatblkno@ ~=)
			// must read in a new FAT block

			if (fatpfdbe@)
				fatpfdbe@ // pfdbe
				mount@ // mount
				FSVolumeBlockWrite drop

				fatpfdbe@ MmEvictablePageDereference drop
			end

			0 // flags
			IOKFLAG_URGENT // kflags
			afsdata@ AFSData_FATStart + @ fatblkno@ + AFSBLOCKSHIFT << // offset
			mount@ // mount
			FSVolumeBlockRead ok! fatpfdbe! fatdata!

			if (ok@)
				ok@ "AFSBlockAllocateChain: failed to read FAT block (%i)\n" KeCrash
			end

			fatblkno@ curfatblkno!
		end

		0xFFFFFFFF fatdata@ blkno@ 2 << AFSBLOCKOFFMASK & + !
		blkno@ lastblkno!

		if (run@)
			1 blkno +=
		end

		1 blocks -=
	end

	if (fatpfdbe@)
		fatpfdbe@ // pfdbe
		mount@ // mount
		FSVolumeBlockWrite drop

		fatpfdbe@ MmEvictablePageDereference drop
	end

	if (run@ ~~)
		mount@ AFSBlockBitmapUnlock
	end
end

fn AFSBlockMap { blkoff fcb kflags -- blkno ok }
	// convert a block offset within an FCB to an absolute disk block number.

	// we use two FAT lookup reference points: the file's first block number,
	// and that of the last successful lookup. if blkoff is >= the last
	// successful lookup, we can use it as a jumping off point to speed
	// things up. if thats not the case, we have to start at the first block
	// number.

	0 ok!

	auto fcbdata
	fcb@ IOFileControlBlockGetContext fcbdata!

	auto fcbblocks
	fcb@ IOFileControlBlockGetSize AFSBLOCKOFFMASK + AFSBLOCKSHIFT >> fcbblocks!

	if (blkoff@ fcbblocks@ >=)
		"AFSBlockMap: blkoff > size in blocks\n" KeCrash
	end

	if (blkoff@ 0 ==)
		// bit of a fast path

		fcbdata@ AFSFCBData_FirstFATLink + @ blkno!

		return
	end

	auto rs
	HALCPUInterruptDisable rs!

	auto lastlookup
	fcbdata@ AFSFCBData_LastFATLinkBlkOff + @ lastlookup!

	auto walkcount
	auto walkstart

	if (blkoff@ lastlookup@ >=)
		blkoff@ lastlookup@ - walkcount!
		fcbdata@ AFSFCBData_LastFATLinkValue + @ walkstart!
	end else
		blkoff@ walkcount!
		fcbdata@ AFSFCBData_FirstFATLink + @ walkstart!
	end

	rs@ HALCPUInterruptRestore

	walkcount@ // startcount
	walkstart@ // startblkno
	fcb@ IOFileControlBlockGetMount // mount
	kflags@ // kflags
	AFSWalkFAT ok! blkno!

	if (ok@)
		return
	end

	if (DEBUGCHECKS)
		if (blkno@ 0xFFFFFFFF ==)
			"AFSBlockMap: blkno=0xFFFFFFFF\n" KeCrash
		end
	end

	HALCPUInterruptDisable rs!

	if (blkoff@ lastlookup@ >= blkoff@ 8 >= ||)
		blkoff@ fcbdata@ AFSFCBData_LastFATLinkBlkOff + !
		blkno@ fcbdata@ AFSFCBData_LastFATLinkValue + !
	end

	rs@ HALCPUInterruptRestore
end

fn AFSBlockTruncate { pintable newblocks oldblocks zero flags fcb -- ok }
	auto fcbdata
	fcb@ IOFileControlBlockGetContext fcbdata!

	auto lastlookup
	fcbdata@ AFSFCBData_LastFATLinkBlkOff + @ lastlookup!

	auto walkcount
	auto walkstart

	0 ok!

	if (newblocks@ oldblocks@ <)
		// truncating, we need to seek to the new last block

		if (newblocks@)
			newblocks@ 1 - walkcount!
		end else
			newblocks@ walkcount!
		end

		fcbdata@ AFSFCBData_FirstFATLink + @ walkstart!
	end else
		// growing, we need to seek to the last block

		if (oldblocks@)
			oldblocks@ 1 - walkcount!

			if (walkcount@ lastlookup@ >=)
				walkcount@ lastlookup@ - walkcount!
				fcbdata@ AFSFCBData_LastFATLinkValue + @ walkstart!
			end else
				fcbdata@ AFSFCBData_FirstFATLink + @ walkstart!
			end
		end else
			-1 walkcount!
		end
	end

	auto blkno

	if (walkcount@)
		if (walkcount@ -1 ~=)
			walkcount@ // startcount
			walkstart@ // startblkno
			fcb@ IOFileControlBlockGetMount // mount
			0 // kflags
			AFSWalkFAT ok! blkno!

			if (ok@)
				return
			end
		end else
			-1 blkno!
		end
	end else
		walkstart@ blkno!
	end

	KeThreadCurrent@ KeThreadIgnoreKill drop

	if (newblocks@ oldblocks@ <)
		if (DEBUGCHECKS)
			if (blkno@ -1 ==)
				"AFSBlockTruncate: blkno == -1\n" KeCrash
			end
		end

		if (newblocks@)
			1 // first
			blkno@ // blkno
			fcb@ IOFileControlBlockGetMount // mount
			AFSBlockDeallocateChain
		end else
			0 // first
			blkno@ // blkno
			fcb@ IOFileControlBlockGetMount // mount
			AFSBlockDeallocateChain

			0xFFFFFFFF fcbdata@ AFSFCBData_FirstFATLink + !
		end

		0 fcbdata@ AFSFCBData_LastFATLinkBlkOff + !
		fcbdata@ AFSFCBData_FirstFATLink + @ fcbdata@ AFSFCBData_LastFATLinkValue + !
	end else
		auto startblock

		pintable@ // pintable
		newblocks@ oldblocks@ - // blocks
		blkno@ // lastblock
		zero@ // zero
		fcb@ IOFileControlBlockGetMount // mount
		AFSBlockAllocateChain ok! startblock!

		if (ok@)
			KeThreadCurrent@ KeThreadAcceptKill drop

			return
		end

		if (fcbdata@ AFSFCBData_FirstFATLink + @ -1 ==)
			if (startblock@ -1 ==)
				"AFSBlockTruncate: startblock == -1\n" KeCrash
			end

			startblock@ fcbdata@ AFSFCBData_FirstFATLink + !

			if (lastlookup@ 0 ==)
				startblock@ fcbdata@ AFSFCBData_LastFATLinkValue + !
			end
		end

		if (zero@)
			// zero out the chain now that we know it was allocated.

			KeThreadCurrent@ KeThreadAcceptKill drop

			if (zero@ 1 ==)
				newblocks@ oldblocks@ - AFSBLOCKSHIFT << // size
				oldblocks@ AFSBLOCKSHIFT << // offset
				flags@ // flags
				fcb@ // fcb
				IOCacheZeroData ok!
			end else
				// only zero the last block

				AFSBLOCKSIZE // size
				newblocks@ 1 - AFSBLOCKSHIFT << // offset
				flags@ // flags
				fcb@ // fcb
				IOCacheZeroData ok!
			end

			KeThreadCurrent@ KeThreadIgnoreKill drop

			if (ok@)
				if (oldblocks@)
					1 // first
					startblock@ // blkno
					fcb@ IOFileControlBlockGetMount // mount
					AFSBlockDeallocateChain
				end else
					0 // first
					startblock@ // blkno
					fcb@ IOFileControlBlockGetMount // mount
					AFSBlockDeallocateChain

					0xFFFFFFFF fcbdata@ AFSFCBData_FirstFATLink + !
				end
			end
		end
	end

	KeThreadCurrent@ KeThreadAcceptKill drop
end