//
// Implements the Parse and Delete dispatch routines for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "<inc>/ViewCache.h"

#include "AisixFS.h"

fn (IODispatchParseFunction) AFSParse { fileobject initialfcb process -- reparsepath ok }
	fnsection "PAGE$text"

	0 reparsepath!
	0 ok!

	auto path
	fileobject@ IOFile_OpenedPath + @ path!

	if (path@ ~~)
		STATUS_NOT_FOUND ok!
		return
	end

	auto pcomp
	60 alloc pcomp!

	auto mount
	initialfcb@ IOFileControlBlockGetMount mount!

	if (path@ gb)
		if (initialfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
			STATUS_NOT_A_DIRECTORY ok!

			return
		end

		if (initialfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
			initialfcb@ IOFileControlBlockCacheCheck ok! drop

			if (ok@)
				return
			end
		end

		initialfcb@ AFSFCBReference

		if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATE &)
			initialfcb@ IOFileControlBlockLock ok!
		end else
			initialfcb@ IOFileControlBlockLockShared ok!
		end

		if (ok@)
			initialfcb@ AFSFCBDereference
			return
		end

		while (1)
			while (path@ gb '/' ==)
				1 path +=
			end

			if (path@ gb ~~)
				// no more path, done

				initialfcb@ IOFileControlBlockUnlock

				break
			end

			auto fcbdata
			initialfcb@ IOFileControlBlockGetContext fcbdata!

			// more path, traverse

			if (process@)
				// check traverse rights (on behalf of the CALLING process,
				// not the receiver of the handle)

				ACCESS_EXEC // access
				fcbdata@ AFSFCBData_Permissions + @ // permbits
				fcbdata@ AFSFCBData_UID + @ // owninguid
				fcbdata@ AFSFCBData_GID + @ // owninggid
				mount@ // mount
				FSCheckAccess ok!

				if (ok@)
					// no rights

					initialfcb@ IOFileControlBlockUnlock
					initialfcb@ AFSFCBDereference

					return
				end
			end

			auto len
			0 len!

			while (1)
				if (path@ gb '/' ==)
					break
				end

				if (path@ gb 0 ==)
					break
				end

				if (len@ 59 >=)
					initialfcb@ IOFileControlBlockUnlock
					initialfcb@ AFSFCBDereference

					STATUS_NAME_TOO_LONG ok!

					return
				end

				path@ gb pcomp@ len@ + sb

				1 len +=
				1 path +=
			end

			0 pcomp@ len@ + sb

			if (pcomp@ "." strcmp)
				continue
			end

			auto nextfcb

			if (pcomp@ ".." strcmp)
				auto iparent
				initialfcb@ IOFileControlBlockGetContext AFSFCBData_IParent + @ iparent!

				if (iparent@ initialfcb@ IOFileControlBlockGetContext AFSFCBData_INum + @ ==)
					continue
				end

				0 // flags
				iparent@ // inum
				initialfcb@ IOFileControlBlockGetMount // mount
				AFSFCBRead ok! nextfcb!

				initialfcb@ IOFileControlBlockUnlock
				initialfcb@ AFSFCBDereference

				if (ok@)
					return
				end

				if (nextfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
					nextfcb@ IOFileControlBlockCacheCheck ok! drop

					if (ok@)
						nextfcb@ AFSFCBDereference

						return
					end
				end

				if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATE &)
					nextfcb@ IOFileControlBlockLock ok!
				end else
					nextfcb@ IOFileControlBlockLockShared ok!
				end

				if (ok@)
					nextfcb@ AFSFCBDereference

					return
				end

				nextfcb@ initialfcb!

				continue
			end

			auto bcb
			auto dirent

			pcomp@ // name
			initialfcb@ // dirfcb
			AFSDirectoryFindEntry ok! bcb! dirent!

			if (ok@)
				if (ok@ STATUS_NOT_FOUND ==)
					if (path@ gb ~~)
						if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATE &)
							ACCESS_WRITE // access
							fcbdata@ AFSFCBData_Permissions + @ // permbits
							fcbdata@ AFSFCBData_UID + @ // owninguid
							fcbdata@ AFSFCBData_GID + @ // owninggid
							mount@ // mount
							FSCheckAccess ok!

							if (ok@ ~~)
								fileobject@ // fileobject
								process@ // process
								pcomp@ // name
								initialfcb@ // dirfcb
								AFSCreateFile ok!
							end
						end
					end
				end

				initialfcb@ IOFileControlBlockUnlock
				initialfcb@ AFSFCBDereference

				return
			end

			// found the entry!

			if (path@ gb 0 ==)
				fileobject@ IOFile_Flags + @ // flags
				dirent@ AFSDirEnt_INum + @ // inum
				initialfcb@ IOFileControlBlockGetMount // mount
				AFSFCBRead ok! nextfcb!
			end else
				0 // flags
				dirent@ AFSDirEnt_INum + @ // inum
				initialfcb@ IOFileControlBlockGetMount // mount
				AFSFCBRead ok! nextfcb!
			end

			bcb@ VcBufferDecrementMapCount drop

			initialfcb@ IOFileControlBlockUnlock
			initialfcb@ AFSFCBDereference

			if (ok@)
				return
			end

			if (path@ gb)
				if (nextfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
					nextfcb@ AFSFCBDereference

					STATUS_NOT_A_DIRECTORY ok!

					return
				end
			end

			if (nextfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ==)
				if (nextfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
					nextfcb@ IOFileControlBlockCacheCheck ok! drop

					if (ok@)
						nextfcb@ AFSFCBDereference
						return
					end
				end

				if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATE &)
					nextfcb@ IOFileControlBlockLock ok!
				end else
					nextfcb@ IOFileControlBlockLockShared ok!
				end

				if (ok@)
					nextfcb@ AFSFCBDereference
					return
				end
			end

			nextfcb@ initialfcb!

			if (initialfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
				break
			end
		end
	end else
		initialfcb@ AFSFCBReference
	end

	// at this point the FCB should be refed but unlocked

	if (fileobject@ IOFile_Flags + @ OSFILEFLAG_MUSTCREATE &)
		initialfcb@ AFSFCBDereference

		STATUS_ALREADY_EXISTS ok!

		return
	end

	if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATEDIR &)
		if (initialfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
			initialfcb@ AFSFCBDereference

			STATUS_ALREADY_EXISTS ok!

			return
		end
	end

	fileobject@ // fileobject
	process@ // process
	initialfcb@ // fcb
	AFSFillFileObject

	if (ok@)
		initialfcb@ AFSFCBDereference
	end
end

fn AFSFillFileObject { fileobject process fcb -- }
	fnsection "PAGE$text"

	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	mount@ AFSMountReference drop

	auto fcbdata
	fcb@ IOFileControlBlockGetContext fcbdata!

	fcb@ // fcb
	fcbdata@ AFSFCBData_Permissions + @ ACCESS_ALL_ALL & // permissions
	fcbdata@ AFSFCBData_UID + @ // uid
	fcbdata@ AFSFCBData_GID + @ // gid
	fileobject@ // fileobject
	mount@ // mount
	FSFileObjectFill
end

fn AFSVerifyName { name -- ok }
	fnsection "PAGE$text"

	0 ok!

	if (name@ "." strcmp)
		STATUS_ALREADY_EXISTS ok!
		return
	end

	if (name@ ".." strcmp)
		STATUS_ALREADY_EXISTS ok!
		return
	end

	auto length
	0 length!

	while (name@ gb)
		if (length@ 59 >=)
			STATUS_NAME_TOO_LONG ok!
			return
		end

		if (name@ gb 0x20 < name@ gb 0x7F >= ||)
			STATUS_ILLEGAL_NAME ok!
			return
		end

		if (name@ gb '/' ==)
			STATUS_ILLEGAL_NAME ok!
			return
		end

		1 length +=
		1 name +=
	end
end

fn AFSCreateFile { fileobject process name dirfcb -- ok }
	fnsection "PAGE$text"

	name@ AFSVerifyName ok!

	if (ok@)
		return
	end

	auto mount
	dirfcb@ IOFileControlBlockGetMount mount!

	// allocate inode

	auto dirbcb
	auto ibcb

	auto inode
	auto inum

	mount@ AFSINodeAllocate ok! ibcb! inode! inum!
	
	if (ok@)
		return
	end

	// fill in fields

	if (fileobject@ IOFile_Flags + @ OSFILEFLAG_CREATEDIR &)
		2 inode@ AFSINode_type + !
	end else
		1 inode@ AFSINode_type + !
	end

	KeThreadCurrent@ PsThreadGetFilePermissions ACCESS_ALL_ALL & inode@ AFSINode_permissions + !
	KeProcessCurrent PsProcessGetUID inode@ AFSINode_uid + !
	dirfcb@ IOFileControlBlockGetContext AFSFCBData_INum + @ inode@ AFSINode_iparent + !

	auto time
	KeTime_SIZEOF alloc time!
	time@ HALRTCQuery
	time@ KeTime_SecPart + @ inode@ AFSINode_timestamp + !

	0xFFFFFFFF inode@ AFSINode_startblock + !
	0 inode@ AFSINode_bytesize + !

	// allocate directory entry

	auto dirent
	
	dirfcb@ AFSDirectoryAllocateEntry ok! dirbcb! dirent!

	if (ok@)
		0 inode@ AFSINode_type + !

		ibcb@ VcBufferDirty
		ibcb@ VcBufferDecrementMapCount drop

		return
	end

	// fill in fields

	inum@ dirent@ AFSDirEnt_INum + !

	dirent@ AFSDirEnt_name + // dest
	name@ // src
	59 // max
	strncpy

	// grab FCB for inode

	auto fcb
	fileobject@ IOFile_Flags + @ // flags
	inum@ // inum
	mount@ // mount
	AFSFCBRead ok! fcb!

	if (ok@)
		// failed to grab FCB, undo everything we just did

		0 inode@ AFSINode_type + !
		0 dirent@ AFSDirEnt_INum + !

		ibcb@ VcBufferDirty
		ibcb@ VcBufferDecrementMapCount drop

		dirbcb@ VcBufferDecrementMapCount drop

		return
	end

	// create object with FCB

	fileobject@ // fileobject
	process@ // process
	fcb@ // fcb
	AFSFillFileObject

	ibcb@ VcBufferDirty
	ibcb@ VcBufferDecrementMapCount drop

	dirbcb@ VcBufferDirty
	dirbcb@ VcBufferDecrementMapCount drop

	dirfcb@ AFSINodeUpdateModificationTime
end

fn (IODispatchDeleteObjectFunction) AFSDeleteObject { object -- ok }
	fnsection "PAGE$text"

	auto fcb
	object@ IOFile_FileControlBlock + @ fcb!

	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	auto afsdata
	mount@ IOMount_Extension + @ afsdata!

	if (object@ IOFile_Context + @ AFSFILECONTEXT_WRITABLE &)
		-1 afsdata@ AFSData_WritableFiles + KeInterlockedIncrement drop
	end

	if (object@ IOFile_Context + @ AFSFILECONTEXT_UPDATEONCLOSE &)
		fcb@ AFSINodeUpdate
	end

	// the FCB may or may not stop existing after we deref it here, so don't
	// touch it again.

	fcb@ AFSFCBDereference

	mount@ // mount
	AFSMountDereference drop

	0 ok!
end