//
// Implements the Parse and Delete dispatch routines for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

fn (IODispatchParseFunction) AFSParse { flags path initialfcb process -- reparsepath object ok }
	0 reparsepath!
	0 ok!

	auto fullpath
	path@ fullpath!

	auto pcomp
	60 alloc pcomp!

	auto mount
	initialfcb@ IOFileControlBlockGetMount mount!

	if (path@ gb)
		if (initialfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
			STATUS_NOT_A_DIRECTORY ok!

			return
		end

		if (initialfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
			1 // wantcaching
			initialfcb@ // fcb
			IOFileControlBlockCacheCheck ok! drop

			if (ok@)
				return
			end
		end

		initialfcb@ IOFileControlBlockReference drop

		if (flags@ OSFILEFLAG_CREATE &)
			initialfcb@ IOFileControlBlockLock ok!
		end else
			initialfcb@ IOFileControlBlockLockShared ok!
		end

		if (ok@)
			initialfcb@ IOFileControlBlockDereference drop
			return
		end

		while (1)
			while (path@ gb '/' ==)
				1 path +=
			end

			if (path@ gb ~~)
				// no more path, done

				initialfcb@ IOFileControlBlockUnlock

				break
			end

			auto fcbdata
			initialfcb@ IOFileControlBlockGetContext fcbdata!

			// more path, traverse

			if (mount@ IOMountGetFlags OSMOUNT_NOUID & ~~)
				if (process@)
					// check traverse rights (on behalf of the CALLING process,
					// not the receiver of the handle)

					ACCESS_EXEC // access
					fcbdata@ AFSFCBData_Permissions + @ // permbits
					fcbdata@ AFSFCBData_UID + @ // owninguid
					fcbdata@ AFSFCBData_GID + @ // owninggid 
					KeProcessCurrent // process
					SeCheckAccessFilesystemX ok!

					if (ok@)
						// no rights

						initialfcb@ IOFileControlBlockUnlock
						initialfcb@ IOFileControlBlockDereference drop

						return
					end
				end
			end

			auto len
			0 len!

			while (1)
				if (path@ gb '/' ==)
					break
				end

				if (path@ gb 0 ==)
					break
				end

				if (len@ 59 >)
					initialfcb@ IOFileControlBlockUnlock
					initialfcb@ IOFileControlBlockDereference drop

					STATUS_NAME_TOO_LONG ok!

					return
				end

				path@ gb pcomp@ len@ + sb

				1 len +=
				1 path +=
			end

			0 pcomp@ len@ + sb

			if (pcomp@ "." strcmp)
				continue
			end

			auto nextfcb

			if (pcomp@ ".." strcmp)
				auto iparent
				initialfcb@ IOFileControlBlockGetContext AFSFCBData_IParent + @ iparent!

				if (iparent@ initialfcb@ IOFileControlBlockGetContext AFSFCBData_INum + @ ==)
					continue
				end

				iparent@ // inum
				initialfcb@ IOFileControlBlockGetMount // mount
				AFSFCBRead ok! nextfcb!

				initialfcb@ IOFileControlBlockUnlock
				initialfcb@ IOFileControlBlockDereference drop

				if (ok@)
					return
				end

				if (nextfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
					1 // wantcaching
					nextfcb@ // fcb
					IOFileControlBlockCacheCheck ok! drop

					if (ok@)
						nextfcb@ IOFileControlBlockDereference drop

						return
					end
				end

				if (flags@ OSFILEFLAG_CREATE &)
					nextfcb@ IOFileControlBlockLock ok!
				end else
					nextfcb@ IOFileControlBlockLockShared ok!
				end

				if (ok@)
					nextfcb@ IOFileControlBlockDereference drop

					return
				end

				nextfcb@ initialfcb!

				continue
			end

			auto pfdbe
			auto dirent

			pcomp@ // name
			initialfcb@ // dirfcb
			AFSDirectoryFindEntry ok! pfdbe! dirent!

			if (ok@)
				if (ok@ STATUS_NOT_FOUND ==)
					if (path@ gb ~~)
						if (flags@ OSFILEFLAG_CREATE &)
							if (mount@ IOMountGetFlags OSMOUNT_READONLY &)
								STATUS_READONLY_FILESYSTEM ok!
							end else
								ACCESS_WRITE // access
								fcbdata@ AFSFCBData_Permissions + @ // permbits
								fcbdata@ AFSFCBData_UID + @ // owninguid
								fcbdata@ AFSFCBData_GID + @ // owninggid 
								KeProcessCurrent // process
								SeCheckAccessFilesystemX ok!

								if (ok@ ~~)
									process@ // process
									fullpath@ // fullpath
									flags@ // flags
									pcomp@ // name
									initialfcb@ // dirfcb
									AFSCreateFile ok! object!
								end
							end
						end
					end
				end

				initialfcb@ IOFileControlBlockUnlock
				initialfcb@ IOFileControlBlockDereference drop

				return
			end

			// found the entry!

			dirent@ AFSDirEnt_INum + @ // inum
			initialfcb@ IOFileControlBlockGetMount // mount
			AFSFCBRead ok! nextfcb!

			pfdbe@ MmEvictablePageDereference drop

			initialfcb@ IOFileControlBlockUnlock
			initialfcb@ IOFileControlBlockDereference drop

			if (ok@)
				return
			end

			if (path@ gb)
				if (nextfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
					nextfcb@ IOFileControlBlockDereference drop

					STATUS_NOT_A_DIRECTORY ok!

					return
				end
			end

			if (nextfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ==)
				if (nextfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
					1 // wantcaching
					nextfcb@ // fcb
					IOFileControlBlockCacheCheck ok! drop

					if (ok@)
						nextfcb@ IOFileControlBlockDereference drop
						return
					end
				end

				if (flags@ OSFILEFLAG_CREATE &)
					nextfcb@ IOFileControlBlockLock ok!
				end else
					nextfcb@ IOFileControlBlockLockShared ok!
				end

				if (ok@)
					nextfcb@ IOFileControlBlockDereference drop
					return
				end
			end

			nextfcb@ initialfcb!

			if (initialfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
				break
			end
		end
	end else
		initialfcb@ IOFileControlBlockReference drop
	end

	// at this point the FCB should be refed but unlocked

	if (flags@ OSFILEFLAG_MUSTCREATE &)
		initialfcb@ IOFileControlBlockDereference drop

		STATUS_ALREADY_EXISTS ok!

		return
	end

	fullpath@ // fullpath
	flags@ // flags
	initialfcb@ IOFileControlBlockGetContext AFSFCBData_Permissions + @ ACCESS_ALL_ALL & // permissions
	process@ // process
	initialfcb@ // fcb
	AFSCreateFileObject ok! object!

	if (ok@)
		initialfcb@ IOFileControlBlockDereference drop
	end
end

fn AFSCreateFileObject { fullpath flags permissions process fcb -- object ok }
	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	mount@ // mount
	AFSMountReference drop

	fullpath@ // openedpath
	flags@ // flags
	fcb@ IOFileControlBlockGetContext AFSFCBData_Permissions + @ ACCESS_ALL_ALL & // permissions
	fcb@ // fcb
	IOFileCreateObject ok! object!

	if (ok@)
		fcb@ IOFileControlBlockGetMount // mount
		AFSMountDereference drop

		return
	end

	if (mount@ IOMountGetFlags OSMOUNT_NOUID &)
		process@ PsProcessGetUID object@ ObObjectSetUID
		process@ PsProcessGetGID object@ ObObjectSetGID
	end else
		fcb@ IOFileControlBlockGetContext AFSFCBData_UID + @ object@ ObObjectSetUID
		fcb@ IOFileControlBlockGetContext AFSFCBData_GID + @ object@ ObObjectSetGID
	end
end

fn AFSVerifyName { name -- ok }
	0 ok!

	if (name@ "." strcmp)
		STATUS_FORBIDDEN_OPERATION ok!
		return
	end

	if (name@ ".." strcmp)
		STATUS_FORBIDDEN_OPERATION ok!
		return
	end

	auto length
	0 length!

	while (name@ gb)
		if (length@ 60 >=)
			STATUS_NAME_TOO_LONG ok!
			return
		end

		if (name@ gb 0x20 < name@ gb 0x7F >= ||)
			STATUS_ILLEGAL_NAME ok!
			return
		end

		if (name@ gb '/' ==)
			STATUS_ILLEGAL_NAME ok!
			return
		end

		1 length +=
		1 name +=
	end
end

fn AFSCreateFile { process fullpath flags name dirfcb -- object ok }
	name@ AFSVerifyName ok!

	if (ok@)
		return
	end

	auto mount
	dirfcb@ IOFileControlBlockGetMount mount!

	// allocate inode

	auto dirpfdbe
	auto ipfdbe

	auto inode
	auto inum

	mount@ AFSINodeAllocate ok! ipfdbe! inode! inum!
	
	if (ok@)
		return
	end

	// fill in fields

	if (flags@ OSFILEFLAG_CREATEDIR &)
		2 inode@ AFSINode_type + !
	end else
		1 inode@ AFSINode_type + !
	end

	KeThreadCurrent@ PsThreadGetFilePermissions ACCESS_ALL_ALL & inode@ AFSINode_permissions + !
	KeProcessCurrent PsProcessGetUID inode@ AFSINode_uid + !
	dirfcb@ IOFileControlBlockGetContext AFSFCBData_INum + @ inode@ AFSINode_iparent + !

	auto time
	KeTime_SIZEOF alloc time!
	time@ HALRTCQuery
	time@ KeTime_SecPart + @ inode@ AFSINode_timestamp + !

	0xFFFFFFFF inode@ AFSINode_startblock + !
	0 inode@ AFSINode_bytesize + !

	// allocate directory entry

	auto dirent
	dirfcb@ AFSDirectoryAllocateEntry ok! dirpfdbe! dirent!

	if (ok@)
		0 inode@ AFSINode_type + !

		ipfdbe@ // pfdbe
		mount@ // mount
		FSVolumeBlockWrite drop

		ipfdbe@ MmEvictablePageDereference drop

		return
	end

	// fill in fields

	inum@ dirent@ AFSDirEnt_INum + !

	dirent@ AFSDirEnt_name + // dest
	name@ // src
	59 // max
	strncpy

	// grab FCB for inode

	auto fcb
	inum@ // inum
	mount@ // mount
	AFSFCBRead ok! fcb!

	if (ok@)
		// failed to grab FCB, undo everything we just did

		0 inode@ AFSINode_type + !
		0 dirent@ AFSDirEnt_INum + !

		ipfdbe@ // pfdbe
		mount@ // mount
		FSVolumeBlockWrite drop

		OSPAGESIZE // extent
		dirpfdbe@ // pfdbe
		IOCachePageModifyFunction drop

		ipfdbe@ MmEvictablePageDereference drop
		dirpfdbe@ MmEvictablePageDereference drop

		return
	end

	// create object with FCB

	fullpath@ // fullpath
	flags@ // flags
	KeThreadCurrent@ PsThreadGetFilePermissions ACCESS_ALL_ALL & // permissions
	process@ // process
	fcb@ // fcb
	AFSCreateFileObject ok! object!

	if (ok@)
		0 inode@ AFSINode_type + !
		0 dirent@ AFSDirEnt_INum + !

		fcb@ AFSFCBDelete
	end

	ipfdbe@ // pfdbe
	mount@ // mount
	FSVolumeBlockWrite drop

	OSPAGESIZE // extent
	dirpfdbe@ // pfdbe
	IOCachePageModifyFunction drop

	ipfdbe@ MmEvictablePageDereference drop
	dirpfdbe@ MmEvictablePageDereference drop
end

fn (IODispatchDeleteObjectFunction) AFSDeleteObject { object -- ok }
	auto fcb
	object@ IOFileGetFileControlBlock fcb!

	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	auto mountctx
	mount@ IOMountGetContext mountctx!

	auto oldcount
	fcb@ IOFileControlBlockGetReferences oldcount!

	auto nuked
	0 nuked!

	if (oldcount@ 1 ==)
		if (0)
			auto fcbdata
			fcb@ IOFileControlBlockGetContext fcbdata!

			auto bucket
			fcbdata@ AFSFCBData_INum + @ AFSFCBMASK & bucket!

			bucket@ // bucket
			mount@ // mount
			AFSFCBCacheLockBucket ok!

			if (DEBUGCHECKS)
				if (ok@)
					"AFSDeleteObject: lock failed even though in a delete object routine\n" KeCrash
				end
			end

			if (fcb@ IOFileControlBlockGetReferences 1 ==)
				// TODO: delete file if this is the last reference and a deletion is
				// pending. may be annoying to synchronize.
			end

			bucket@ // bucket
			mount@ // mount
			AFSFCBCacheUnlockBucket
		end
	end

	if (nuked@ ~~)
		fcb@ IOFileControlBlockDereference drop
	end

	mount@ // mount
	AFSMountDereference drop

	0 ok!
end