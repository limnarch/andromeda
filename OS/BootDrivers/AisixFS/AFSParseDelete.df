//
// Implements the Parse and Delete dispatch routines for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Security.h"

#include "<inc>/Memory.h"

#include "<inc>/Object.h"

#include "<inc>/Process.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

fn (IODispatchParseFunction) AFSParse { flags path initialfcb process -- reparsepath object ok }
	0 reparsepath!
	0 ok!

	auto fullpath
	path@ fullpath!

	auto pcomp
	60 alloc pcomp!

	auto afsdirent
	AFSDirEnt_SIZEOF alloc afsdirent!

	auto mount
	initialfcb@ IOFileControlBlockGetMount mount!

	if (path@ gb)
		if (initialfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
			STATUS_NOT_A_DIRECTORY ok!

			return
		end

		if (initialfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
			1 // wantcaching
			initialfcb@ // fcb
			IOFileControlBlockCacheCheck ok! drop

			if (ok@)
				return
			end
		end

		initialfcb@ IOFileControlBlockReference drop
		initialfcb@ IOFileControlBlockLockShared ok!

		if (ok@)
			initialfcb@ IOFileControlBlockDereference drop
			return
		end

		while (1)
			while (path@ gb '/' ==)
				1 path +=
			end

			if (path@ gb ~~)
				// no more path, done

				initialfcb@ IOFileControlBlockUnlock

				break
			end

			auto fcbdata
			initialfcb@ IOFileControlBlockGetContext fcbdata!

			// more path, traverse

			if (mount@ IOMountGetFlags OSMOUNT_NOUID & ~~)
				if (process@)
					// check traverse rights (on behalf of the CALLING process,
					// not the receiver of the handle)

					ACCESS_EXEC // access
					fcbdata@ AFSFCBData_Permissions + @ // permbits
					fcbdata@ AFSFCBData_UID + @ // owninguid
					fcbdata@ AFSFCBData_GID + @ // owninggid 
					KeProcessCurrent // process
					SeCheckAccessFilesystemX ok!

					if (ok@)
						// no rights

						initialfcb@ IOFileControlBlockUnlock
						initialfcb@ IOFileControlBlockDereference drop

						return
					end
				end
			end

			auto len
			0 len!

			while (1)
				if (path@ gb '/' ==)
					break
				end

				if (path@ gb 0 ==)
					break
				end

				if (len@ 59 >)
					initialfcb@ IOFileControlBlockUnlock
					initialfcb@ IOFileControlBlockDereference drop

					STATUS_NAME_TOO_LONG ok!

					return
				end

				path@ gb pcomp@ len@ + sb

				1 len +=
				1 path +=
			end

			0 pcomp@ len@ + sb

			if (pcomp@ "." strcmp)
				continue
			end

			auto nextfcb

			if (pcomp@ ".." strcmp)
				auto iparent
				initialfcb@ IOFileControlBlockGetContext AFSFCBData_IParent + @ iparent!

				if (iparent@ initialfcb@ IOFileControlBlockGetContext AFSFCBData_INum + @ ==)
					continue
				end

				iparent@ // inum
				initialfcb@ IOFileControlBlockGetMount // mount
				AFSFCBRead ok! nextfcb!

				initialfcb@ IOFileControlBlockUnlock
				initialfcb@ IOFileControlBlockDereference drop

				if (ok@)
					return
				end

				if (nextfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
					1 // wantcaching
					nextfcb@ // fcb
					IOFileControlBlockCacheCheck ok! drop

					if (ok@)
						nextfcb@ IOFileControlBlockDereference drop

						return
					end
				end

				nextfcb@ IOFileControlBlockLockShared ok!

				if (ok@)
					nextfcb@ IOFileControlBlockDereference drop

					return
				end

				nextfcb@ initialfcb!

				continue
			end

			auto seek
			0 seek!

			while (1)
				seek@ // seek
				afsdirent@ // afsdirent
				initialfcb@ // fcb
				AFSDirectoryGetEntry ok! seek!

				if (ok@)
					initialfcb@ IOFileControlBlockUnlock
					initialfcb@ IOFileControlBlockDereference drop

					if (ok@ STATUS_IO_END_OF_FILE ==)
						STATUS_NOT_FOUND ok!
					end

					return
				end

				if (afsdirent@ AFSDirEnt_name + pcomp@ strcmp)
					// found the entry!

					afsdirent@ AFSDirEnt_INum + @ // inum
					initialfcb@ IOFileControlBlockGetMount // mount
					AFSFCBRead ok! nextfcb!

					initialfcb@ IOFileControlBlockUnlock
					initialfcb@ IOFileControlBlockDereference drop

					if (ok@)
						return
					end

					if (path@ gb)
						if (nextfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
							nextfcb@ IOFileControlBlockDereference drop

							STATUS_NOT_A_DIRECTORY ok!

							return
						end
					end

					if (nextfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ==)
						if (nextfcb@ IOFileControlBlockGetCacheInfoBlock ~~)
							1 // wantcaching
							nextfcb@ // fcb
							IOFileControlBlockCacheCheck ok! drop

							if (ok@)
								nextfcb@ IOFileControlBlockDereference drop

								return
							end
						end
					
						nextfcb@ IOFileControlBlockLockShared ok!

						if (ok@)
							nextfcb@ IOFileControlBlockDereference drop
							return
						end
					end

					nextfcb@ initialfcb!

					break
				end
			end

			if (initialfcb@ IOFileControlBlockGetType OSFILETYPE_DIRECTORY ~=)
				break
			end
		end
	end else
		initialfcb@ IOFileControlBlockReference drop
	end

	// at this point the FCB should be refed but unlocked

	initialfcb@ IOFileControlBlockGetMount // mount
	AFSMountReference drop

	fullpath@ // openedpath
	flags@ // flags
	initialfcb@ IOFileControlBlockGetContext AFSFCBData_Permissions + @ ACCESS_ALL_ALL & // permissions
	initialfcb@ // fcb
	IOFileCreateObject ok! object!

	if (ok@)
		initialfcb@ IOFileControlBlockDereference drop

		initialfcb@ IOFileControlBlockGetContext // mount
		AFSMountDereference drop
	end

	if (mount@ IOMountGetFlags OSMOUNT_NOUID &)
		process@ PsProcessGetUID object@ ObObjectSetUID
		process@ PsProcessGetGID object@ ObObjectSetGID
	end else
		initialfcb@ IOFileControlBlockGetContext AFSFCBData_UID + @ object@ ObObjectSetUID
		initialfcb@ IOFileControlBlockGetContext AFSFCBData_GID + @ object@ ObObjectSetGID
	end
end

fn (IODispatchDeleteObjectFunction) AFSDeleteObject { object -- ok }
	auto fcb
	object@ IOFileGetFileControlBlock fcb!

	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	auto mountctx
	mount@ IOMountGetContext mountctx!

	auto oldcount
	fcb@ IOFileControlBlockGetReferences oldcount!

	auto nuked
	0 nuked!

	if (oldcount@ 1 ==)
		if (0)
			auto fcbdata
			fcb@ IOFileControlBlockGetContext fcbdata!

			auto bucket
			fcbdata@ AFSFCBData_INum + @ AFSFCBMASK & bucket!

			bucket@ // bucket
			mount@ // mount
			AFSFCBCacheLockBucket ok!

			if (DEBUGCHECKS)
				if (ok@)
					"AFSDeleteObject: lock failed even though in a delete object routine\n" KeCrash
				end
			end

			if (fcb@ IOFileControlBlockGetReferences 1 ==)
				// TODO: delete file if this is the last reference and a deletion is
				// pending. may be annoying to synchronize.
			end

			bucket@ // bucket
			mount@ // mount
			AFSFCBCacheUnlockBucket
		end
	end

	if (nuked@ ~~)
		fcb@ IOFileControlBlockDereference drop
	end

	mount@ // mount
	AFSMountDereference drop

	0 ok!
end