//
// Implements the Read and Write dispatch routines for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

// We do need to worry about per-file synchronization issues in the
// filesystem specific code, because the upper-level code does not achieve
// this for us.

fn (IODispatchReadFunction) AFSReadFile { timeout flags kflags offset mdl fcb -- bytesread ok }
	auto bytesize
	fcb@ IOFileControlBlockGetSize bytesize!

	auto volfcb
	fcb@ FSVolumeGetFCB volfcb!

	0 ok!

	0 bytesread!

	if (offset@ bytesize@ >=)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	mdl@ MmMDLHeader_Length + @ bytesread!

	if (bytesread@ AFSBLOCKOFFMASK &)
		STATUS_UNALIGNED ok!

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	bytesize@ AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & bytesize!

	bytesize@ offset@ -
	bytesread@
	min bytesread!

	if (bytesread@ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	bytesread@ // length
	flags@ // flags
	kflags@ // kflags
	offset@ // offset
	mdl@ // mdl
	fcb@ // fcb
	0 // write
	AFSReadWrite ok!
end

fn (IODispatchWriteFunction) AFSWriteFile { flags kflags offset mdl fcb -- byteswritten ok }
	auto bytesize
	fcb@ IOFileControlBlockGetSize bytesize!

	0 ok!

	0 byteswritten!

	if (offset@ bytesize@ >=)
		STATUS_END_OF_FILE ok!

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	mdl@ MmMDLHeader_Length + @ byteswritten!

	if (byteswritten@ AFSBLOCKOFFMASK &)
		STATUS_UNALIGNED ok!

		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	bytesize@ AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & bytesize!

	bytesize@ offset@ -
	byteswritten@
	min byteswritten!

	if (byteswritten@ ~~)
		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	byteswritten@ // length
	flags@ // flags
	kflags@ // kflags
	offset@ // offset
	mdl@ // mdl
	fcb@ // fcb
	1 // write
	AFSReadWrite ok!
end

fn AFSReadWrite { length flags kflags offset mdl fcb write -- ok }
	length@ mdl@ MmMDLHeader_Length + !

	auto volfcb
	fcb@ FSVolumeGetFCB volfcb!

	write@ ~~ // lockforwrite
	mdl@ // mdl
	MmMDLPin ok!

	if (ok@)
		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	auto fragmentstart
	auto fragmentlength

	auto fragmentlastblkno
	-1 fragmentlastblkno!

	auto fragmentoffset
	0 fragmentoffset!

	auto bufoffset
	0 bufoffset!

	auto fragged
	0 fragged!

	while (bufoffset@ length@ <)
		auto blkno
		offset@ AFSBLOCKSHIFT >> // blkoff
		fcb@ // fcb
		kflags@ // kflags
		AFSBlockMap ok! blkno!

		if (ok@)
			break
		end

		if (fragmentlastblkno@ -1 ~=)
			if (blkno@ fragmentlastblkno@ 1 + ~=)
				// not contiguous -- new fragment.
				// write the last one.

				fragmentoffset@ // offset
				fragmentstart@ // start
				fragmentlength@ // length
				mdl@ // mdl
				flags@ // flags
				kflags@ // kflags
				volfcb@ // volfcb
				write@ // write
				AFSTransfer ok!

				if (ok@)
					break
				end

				1 fragged!
				-1 fragmentlastblkno!
			end
		end

		if (fragmentlastblkno@ -1 ==)
			blkno@ AFSBLOCKSHIFT << fragmentstart!
			bufoffset@ fragmentoffset!
			0 fragmentlength!
		end

		AFSBLOCKSIZE fragmentlength +=
		blkno@ fragmentlastblkno!

		AFSBLOCKSIZE offset +=
		AFSBLOCKSIZE bufoffset +=
	end

	if (ok@)
		ok@ // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete

		return
	end

	if (fragged@ ~~)
		// transfer never fragmented, pass the entire MDL to the volume file

		if (write@)
			flags@ // flags
			kflags@ // kflags
			fragmentstart@ // offset
			mdl@ // mdl
			volfcb@ // fcb
			volfcb@ FSVolumeFCBGetWriteFunction IODispatchWriteFunction ok! drop
		end else
			OSWAIT_TIMEOUTINFINITE // timeout
			flags@ // flags
			kflags@ // kflags
			fragmentstart@ // offset
			mdl@ // mdl
			volfcb@ // fcb
			volfcb@ FSVolumeFCBGetReadFunction IODispatchReadFunction ok! drop
		end
	end else
		if (fragmentlength@)
			fragmentoffset@ // offset
			fragmentstart@ // start
			fragmentlength@ // length
			mdl@ // mdl
			flags@ // flags
			kflags@ // kflags
			volfcb@ // volfcb
			write@ // write
			AFSTransfer ok!
		end

		0 // status
		0 // priboost
		mdl@ // mdl
		MmMDLComplete
	end
end

fn AFSTransfer { offset start length mdl flags kflags volfcb write -- ok }
	auto fragmdl
	0 // mode (gets filled in by MmMDLSplit)
	length@ // length
	mdl@ MmMDLHeader_VirtualAddress + @ offset@ + // vaddr
	kflags@ // kflags
	MmMDLAllocate ok! fragmdl!

	if (ok@)
		return
	end

	mdl@ MmMDLHeader_VirtualAddress + @ offset@ + // vaddr
	length@ // length
	mdl@ // srcmdl
	fragmdl@ // destmdl
	MmMDLSplit

	if (write@)
		flags@ // flags
		kflags@ // kflags
		start@ // offset
		fragmdl@ // mdl
		volfcb@ // fcb
		volfcb@ FSVolumeFCBGetWriteFunction IODispatchWriteFunction ok! drop
	end else
		OSWAIT_TIMEOUTINFINITE // timeout
		flags@ // flags
		kflags@ // kflags
		start@ // offset
		fragmdl@ // mdl
		volfcb@ // fcb
		volfcb@ FSVolumeFCBGetReadFunction IODispatchReadFunction ok! drop
	end
end