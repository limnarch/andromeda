//
// Implements the Read and Write dispatch routines for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

// We do need to worry about per-file synchronization issues in the
// filesystem specific code, because the upper-level code does not achieve
// this for us.

fn (IODispatchEnqueueIOPFunction) AFSReadWriteFile { iopl -- done ok }
	0 ok!
	0 done!

	auto fcb
	iopl@ IOPacketLocation_FileControlBlock + @ fcb!

	auto bytesize
	fcb@ IOFileControlBlockGetSize bytesize!

	auto offset
	iopl@ IOPacketLocation_Offset + @ offset!

	auto iop
	iopl@ IOPacketFromLocation iop!

	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	auto bytes
	iopl@ IOPacketLocation_Length + @ bytes!

	if (offset@ bytesize@ >=)
		1 done!

		if (iopl@ IOPacketLocation_FunctionCodeB + gb IODISPATCH_READ ==)
			0 iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Length + !
		end else
			STATUS_END_OF_FILE ok!
		end

		ok@ // status
		0 // priboost
		iop@ // iop
		IOPacketCompleteLow

		return
	end

	if (fcb@ IOFileControlBlockGetType OSFILETYPE_BLOCKDEVICE ==)
		// this is actually the volume device, just redirect the request to
		// the underlying device.

		mount@ IOMount_UnderlyingDeviceObject + @ IODevice_FileControlBlock + @ iopl@ IOPacketLocation_FileControlBlock + !

		if (iopl@ IOPacketLocation_Offset + @ iopl@ IOPacketLocation_Length + @ + bytesize@ >)

			// truncate the transfer to the size of the volume file.
			// this should be paging I/O from the viewcache, so lets trust the
			// length and offset not to overflow.

			bytesize@ iopl@ IOPacketLocation_Offset + @ - iopl@ IOPacketLocation_Length + !
		end

		IODONE_SAMELOCATION done!

		return
	end

		iopl@ IOPacketLocation_Offset + @
		"file io %d\n" KeCrash

	bytes@ AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & bytes!

	bytesize@ offset@ -
	bytes@
	min bytes!

	if (bytes@ ~~)
		1 done!

		0 iop@ IOPacketHeader_StatusBlock + OSStatusBlock_Length + !

		0 // status
		0 // priboost
		iop@ // iop
		IOPacketCompleteLow

		return
	end
end

