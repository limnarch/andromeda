//
// Implements the Read and Write dispatch routines for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

// We do need to worry about per-file synchronization issues in the
// filesystem specific code, because the upper-level code does not achieve
// this for us.

fn (IODispatchReadFunction) AFSReadFile { timeout flags kflags offset mdl fcb -- bytesread ok }
	auto bytesize
	fcb@ IOFileControlBlockGetSize bytesize!

	auto volfcb
	fcb@ FSVolumeGetFCB volfcb!

	auto readfunc
	volfcb@ FSVolumeFCBGetReadFunction readfunc!

	0 ok!

	0 bytesread!

	if (offset@ bytesize@ >=)
		return
	end

	mdl@ MmMDLHeader_Length + @ bytesread!

	if (bytesread@ AFSBLOCKOFFMASK &)
		STATUS_UNALIGNED ok!

		return
	end

	bytesize@ AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & bytesize!

	bytesize@ offset@ -
	bytesread@
	min bytesread!

	if (bytesread@ ~~)
		return
	end

	bytesread@ mdl@ MmMDLHeader_Length + !

	1 mdl@ MmMDLPin ok!

	if (ok@)
		return
	end

	auto fragmentstart
	auto fragmentlength

	auto fragmentlastblkno
	-1 fragmentlastblkno!

	auto fragmentoffset
	0 fragmentoffset!

	auto bufoffset
	0 bufoffset!

	auto fragmdl
	0 fragmdl!

	while (bufoffset@ bytesread@ <)
		auto blkno
		offset@ AFSBLOCKSHIFT >> // blkoff
		fcb@ // fcb
		kflags@ // kflags
		AFSBlockMap ok! blkno!

		if (ok@)
			break
		end

		if (fragmentlastblkno@ -1 ~=)
			if (blkno@ fragmentlastblkno@ 1 + ~=)
				// not contiguous -- new fragment.
				// write the last one.

				0 // mode (gets filled in by MmMDLSplit)
				fragmentlength@ // length
				mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
				kflags@ // kflags
				MmMDLAllocate ok! fragmdl!

				if (ok@)
					break
				end

				mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
				fragmentlength@ // length
				mdl@ // srcmdl
				fragmdl@ // destmdl
				MmMDLSplit

				timeout@ // timeout
				flags@ // flags
				kflags@ // kflags
				fragmentstart@ // offset
				fragmdl@ // mdl
				volfcb@ // fcb
				readfunc@ IODispatchReadFunction ok! drop

				fragmdl@ MmFree

				if (ok@)
					break
				end

				-1 fragmentlastblkno!
			end
		end

		if (fragmentlastblkno@ -1 ==)
			blkno@ AFSBLOCKSHIFT << fragmentstart!
			bufoffset@ fragmentoffset!
			0 fragmentlength!
		end

		AFSBLOCKSIZE fragmentlength +=
		blkno@ fragmentlastblkno!

		AFSBLOCKSIZE offset +=
		AFSBLOCKSIZE bufoffset +=
	end

	if (ok@)
		mdl@ MmMDLUnpin
		return
	end

	if (fragmdl@ ~~)
		// transfer never fragmented, pass the entire MDL to the volume file

		timeout@ // timeout
		flags@ // flags
		kflags@ // kflags
		fragmentstart@ // offset
		mdl@ // mdl
		volfcb@ // fcb
		readfunc@ IODispatchReadFunction ok! drop
	end else
		while (1)
			0 // mode (gets filled in by MmMDLSplit)
			fragmentlength@ // length
			mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
			kflags@ // kflags
			MmMDLAllocate ok! fragmdl!

			if (ok@)
				break
			end

			mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
			fragmentlength@ // length
			mdl@ // srcmdl
			fragmdl@ // destmdl
			MmMDLSplit

			timeout@ // timeout
			flags@ // flags
			kflags@ // kflags
			fragmentstart@ // offset
			fragmdl@ // mdl
			volfcb@ // fcb
			readfunc@ IODispatchReadFunction ok! drop

			fragmdl@ MmFree

			if (ok@)
				break
			end

			break
		end
	end

	mdl@ MmMDLUnpin
end

fn (IODispatchWriteFunction) AFSWriteFile { flags kflags offset mdl fcb -- byteswritten ok }
	auto bytesize
	fcb@ IOFileControlBlockGetSize bytesize!

	auto volfcb
	fcb@ FSVolumeGetFCB volfcb!

	auto writefunc
	volfcb@ FSVolumeFCBGetWriteFunction writefunc!

	0 ok!

	0 byteswritten!

	if (offset@ bytesize@ >=)
		STATUS_END_OF_DISK ok!

		return
	end

	mdl@ MmMDLHeader_Length + @ byteswritten!

	if (byteswritten@ AFSBLOCKOFFMASK &)
		STATUS_UNALIGNED ok!

		return
	end

	bytesize@ AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & bytesize!

	bytesize@ offset@ -
	byteswritten@
	min byteswritten!

	if (byteswritten@ ~~)
		return
	end

	byteswritten@ mdl@ MmMDLHeader_Length + !

	0 mdl@ MmMDLPin ok!

	if (ok@)
		return
	end

	auto fragmentstart
	auto fragmentlength

	auto fragmentlastblkno
	-1 fragmentlastblkno!

	auto fragmentoffset
	0 fragmentoffset!

	auto bufoffset
	0 bufoffset!

	auto fragmdl
	0 fragmdl!

	while (bufoffset@ byteswritten@ <)
		auto blkno
		offset@ AFSBLOCKSHIFT >> // blkoff
		fcb@ // fcb
		kflags@ // kflags
		AFSBlockMap ok! blkno!

		if (ok@)
			break
		end

		if (fragmentlastblkno@ -1 ~=)
			if (blkno@ fragmentlastblkno@ 1 + ~=)
				// not contiguous -- new fragment.
				// write the last one.

				0 // mode (gets filled in by MmMDLSplit)
				fragmentlength@ // length
				mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
				kflags@ // kflags
				MmMDLAllocate ok! fragmdl!

				if (ok@)
					break
				end

				mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
				fragmentlength@ // length
				mdl@ // srcmdl
				fragmdl@ // destmdl
				MmMDLSplit

				flags@ // flags
				kflags@ // kflags
				fragmentstart@ // offset
				fragmdl@ // mdl
				volfcb@ // fcb
				writefunc@ IODispatchWriteFunction ok! drop

				fragmdl@ MmFree

				if (ok@)
					break
				end

				-1 fragmentlastblkno!
			end
		end

		if (fragmentlastblkno@ -1 ==)
			blkno@ AFSBLOCKSHIFT << fragmentstart!
			bufoffset@ fragmentoffset!
			0 fragmentlength!
		end

		AFSBLOCKSIZE fragmentlength +=
		blkno@ fragmentlastblkno!

		AFSBLOCKSIZE offset +=
		AFSBLOCKSIZE bufoffset +=
	end

	if (ok@)
		mdl@ MmMDLUnpin
		return
	end

	if (fragmdl@ ~~)
		// transfer never fragmented, pass the entire MDL to the volume file

		flags@ // flags
		kflags@ // kflags
		fragmentstart@ // offset
		mdl@ // mdl
		volfcb@ // fcb
		writefunc@ IODispatchWriteFunction ok! drop
	end else
		while (1)
			0 // mode (gets filled in by MmMDLSplit)
			fragmentlength@ // length
			mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
			kflags@ // kflags
			MmMDLAllocate ok! fragmdl!

			if (ok@)
				break
			end

			mdl@ MmMDLHeader_VirtualAddress + @ fragmentoffset@ + // vaddr
			fragmentlength@ // length
			mdl@ // srcmdl
			fragmdl@ // destmdl
			MmMDLSplit

			flags@ // flags
			kflags@ // kflags
			fragmentstart@ // offset
			fragmdl@ // mdl
			volfcb@ // fcb
			writefunc@ IODispatchWriteFunction ok! drop

			fragmdl@ MmFree

			if (ok@)
				break
			end

			break
		end
	end

	mdl@ MmMDLUnpin
end