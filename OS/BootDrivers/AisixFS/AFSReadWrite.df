//
// Implements the Read and Write dispatch routines for the AisixFS driver.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/HALLog.h"
#include "<inc>/HALDriver.h"
#include "<inc>/HALRTC.h"
#include "<inc>/HALInterrupt.h"
#include "<inc>/HALCPU.h"
#include "<inc>/HALMap.h"

#include "<inc>/Kernel.h"

#include "<inc>/Executive.h"

#include "<inc>/Memory.h"

#include "<inc>/IO.h"

#include "<inc>/FSRTL.h"

#include "AisixFS.h"

// We do need to worry about per-file synchronization issues in the
// filesystem specific code, because the upper-level code does not achieve
// this for us.

fn (IODispatchReadFunction) AFSReadFile { timeout flags kflags offset mdl fcb -- bytesread ok }
	auto bytesize
	fcb@ IOFileControlBlockGetSize bytesize!

	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	0 ok!

	0 bytesread!

	if (offset@ bytesize@ >=)
		return
	end

	auto lastmode
	mdl@ MmMDLHeader_Mode + @ lastmode!

	auto buffer
	mdl@ MmMDLHeader_VirtualAddress + @ buffer!

	auto length
	mdl@ MmMDLHeader_Length + @ length!

	bytesize@ AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & bytesize!

	bytesize@ offset@ -
	length@
	min length!

	while (bytesread@ length@ <)
		auto blockno
		offset@ AFSBLOCKSHIFT >> blockno!

		auto blockoff
		offset@ AFSBLOCKOFFMASK & blockoff!

		auto m

		length@ bytesread@ -
		AFSBLOCKSIZE blockoff@ -
		min m!

		blockno@ // blkoff
		fcb@ // fcb
		kflags@ // kflags
		AFSBlockMap ok! blockno!

		if (ok@)
			return
		end

		auto br

		m@ // length
		blockno@ AFSBLOCKSHIFT << blockoff@ + // offset
		buffer@ // buf
		lastmode@ // lastmode
		mount@ // mount
		FSVolumeRead ok! br!

		if (ok@)
			return
		end

		if (DEBUGCHECKS)
			if (br@ m@ ~=)
				blockno@ br@ m@ "AFSReadFile: volume read failed (expected %d, read %d, blkno=%d)\n" KeCrash
			end
		end

		m@ buffer +=
		m@ bytesread +=
		m@ offset +=
	end
end

fn (IODispatchWriteFunction) AFSWriteFile { flags kflags offset mdl fcb -- byteswritten ok }
	auto bytesize
	fcb@ IOFileControlBlockGetSize bytesize!

	auto mount
	fcb@ IOFileControlBlockGetMount mount!

	0 ok!

	0 byteswritten!

	if (offset@ bytesize@ >=)
		STATUS_END_OF_DISK ok!

		return
	end

	0 mdl@ MmMDLPin ok!

	if (ok@)
		return
	end

	mdl@ MmMDLMap ok!

	if (ok@)
		mdl@ MmMDLUnpin
		return
	end

	auto lastmode
	mdl@ MmMDLHeader_Mode + @ lastmode!

	auto buffer
	mdl@ MmMDLHeader_MappedAddress + @ buffer!

	auto length
	mdl@ MmMDLHeader_Length + @ length!

	bytesize@ AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & bytesize!

	bytesize@ offset@ -
	length@
	min length!

	while (byteswritten@ length@ <)
		auto blockno
		offset@ AFSBLOCKSHIFT >> blockno!

		auto blockoff
		offset@ AFSBLOCKOFFMASK & blockoff!

		auto m

		length@ byteswritten@ -
		AFSBLOCKSIZE blockoff@ -
		min AFSBLOCKOFFMASK + AFSBLOCKNUMBERMASK & m!

		blockno@ // blkoff
		fcb@ // fcb
		kflags@ // kflags
		AFSBlockMap ok! blockno!

		if (ok@)
			break
		end

		auto bw

		m@ // length
		blockno@ AFSBLOCKSHIFT << blockoff@ + // offset
		buffer@ // buf
		lastmode@ // lastmode
		mount@ // mount
		FSVolumeWrite ok! bw!

		if (ok@)
			break
		end

		if (DEBUGCHECKS)
			if (bw@ m@ ~=)
				"AFSWriteFile: volume write failed\n" KeCrash
			end
		end

		m@ buffer +=
		m@ byteswritten +=
		m@ offset +=
	end

	mdl@ MmMDLUnmap
	mdl@ MmMDLUnpin
end