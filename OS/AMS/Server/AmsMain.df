//
// Initialization for the MINTIA Authority Management Server.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "<inc>/AmsAPI.h"

#include "Ams.h"

var AmsApiPort 0

fn Main { ... -- ret }
	AmsInit ret!

	ret@ OSCURRENTTHREAD OSThreadTerminate drop
end

fn AmsInit { -- ok }
	OSPORT_FLAG_NO_HANDLES // flags
	AmsMessage_SIZEOF // maxlen
	ACCESS_OWNER_ALL ACCESS_GROUP_EXEC | ACCESS_WORLD_EXEC | // permissions
	"AmsApiPort" // name
	OSPortCreate ok! AmsApiPort!

	if (ok@)
		return
	end

	auto dirh
	0 // flags
	ACCESS_EXEC ACCESS_WRITE | // access
	"//:/" // path
	OSOpen ok! dirh!

	if (ok@)
		return
	end

	AmsApiPort@ // objecthandle
	dirh@ // directoryhandle
	OSDirectoryInsert ok!

	if (ok@)
		return
	end

	auto thandle
	0 // context
	pointerof AmsApiThread // startfunc
	0 // creationflags
	ACCESS_OWNER_ALL // permissions
	"API" // name
	OSCURRENTPROCESS // processhandle
	OSThreadCreate ok! thandle!

	if (ok@)
		return
	end

	thandle@ OSClose drop
end

fn AmsApiThread { context -- ret }
	AmsApiLoop ret!
end

fn AmsApiLoop { -- ok }
	auto rxmsg
	AmsMessage_SIZEOF alloc rxmsg!

	auto replymsg
	0 replymsg!

	while (1)
		// we do not need to deal with handles being passed sporadically
		// because AMS specifies that we do not allow them when we create
		// the port object.

		rxmsg@ // rxmsg
		replymsg@ // txmsg
		OSWAIT_TIMEOUTINFINITE // timeout
		AmsApiPort@ // porthandle
		OSPortSendAndWaitReceive ok!

		0 replymsg!

		if (ok@)
			continue
		end

		if (rxmsg@ OSMessageHeader_TypeB + gb OSPORT_MESSAGE_CONNECTION ==)
			rxmsg@ AmsHandleConnection
		end elseif (rxmsg@ OSMessageHeader_TypeB + gb OSPORT_MESSAGE_DISCONNECT ==)
			rxmsg@ AmsHandleDisconnection
		end elseif (rxmsg@ OSMessageHeader_TypeB + gb OSPORT_MESSAGE_REQUEST ==)
			// process request
		end else
			// unknown, ignore
			continue
		end
	end
end

fn AmsHandleConnection { msg -- }
	auto ok

	auto client
	AmsClientCreate ok! client!

	if (ok@)
		// reject the connection

		0 // context
		msg@ // txmsg
		1 // reject
		AmsApiPort@ // porthandle
		OSPortAccept drop

		return
	end

	client@ // context
	msg@ // txmsg
	0 // reject
	AmsApiPort@ // porthandle
	OSPortAccept ok!

	if (ok@)
		// client disappeared while we were processing its connection request

		client@ AmsClientDelete

		return
	end
end

fn AmsHandleDisconnection { msg -- }
	msg@ OSMessageHeader_Context + @ AmsClientDelete
end