//
// Management of the user information database.
//

#include "<df>/dragonfruit.h"

#include "<ll>/OSDLL/OS.h"

#include "Ams.h"

// We use a pair of .cfg files as the "database". This is not efficient. We
// could at least cache the lookups.

var AmsDbUserConfig 0
var AmsDbGroupConfig 0

fn AmsDbOpen { -- ok }
	"/mintia/users.cfg" // path
	0 // create
	1 // write
	OSConfigFileLoad ok! AmsDbUserConfig!

	if (ok@)
		ok@ OSStatusGetName "\namssrv: failed to open users.cfg: %s\n" OSGetStdErr FPrintf
		return
	end

	"/mintia/groups.cfg" // path
	0 // create
	1 // write
	OSConfigFileLoad ok! AmsDbGroupConfig!

	if (ok@)
		AmsDbUserConfig@ OSConfigFileFree

		ok@ OSStatusGetName "\namssrv: failed to open groups.cfg: %s\n" OSGetStdErr FPrintf
	end
end

fn AmsDbClose { -- }
	AmsDbUserConfig@ OSConfigFileFree
	AmsDbGroupConfig@ OSConfigFileFree
end

fn AmsDbUserWrite { -- ok }
	AmsDbUserConfig@ OSConfigFileWrite ok!

	if (ok@)
		"amssrv: warning: failed to writeback user db!\n" OSGetStdErr FPrintf
	end
end

fn AmsDbGroupWrite { -- ok }
	AmsDbGroupConfig@ OSConfigFileWrite ok!

	if (ok@)
		"amssrv: warning: failed to writeback group db!\n" OSGetStdErr FPrintf
	end
end

fn AmsDbUserGetByName { username -- userptr ok }
	auto iterator
	AmsDbUserConfig@ OSConfigGetSectionIterator ok! iterator!

	while (iterator@)
		iterator@ // iterator
		AmsDbUserConfig@ // config
		OSConfigNextSection ok! iterator! userptr!

		if (ok@)
			return
		end

		if (userptr@ OSConfigGetSectionName username@ strcmp)
			return
		end
	end

	STATUS_NO_SUCH_USER ok!
end

fn AmsDbUserGetByUID { uid -- userptr ok }
	auto iterator
	AmsDbUserConfig@ OSConfigGetSectionIterator ok! iterator!

	while (iterator@)
		iterator@ // iterator
		AmsDbUserConfig@ // config
		OSConfigNextSection ok! iterator! userptr!

		if (ok@)
			return
		end

		auto key
		"uid" // keyname
		userptr@ // section
		OSConfigGetKey ok! key!

		if (ok@ ~~)
			auto chkuid
			key@ OSConfigGetKeyValue chkuid!

			if (chkuid@ ~~)
				continue
			end

			chkuid@ atoi chkuid!

			if (chkuid@ uid@ ==)
				return
			end
		end
	end

	STATUS_NO_SUCH_USER ok!
end

fn AmsDbUserGetName { userptr -- username }
	userptr@ OSConfigGetSectionName username!
end

fn AmsDbUserGetProperty { property userptr -- value ok }
	auto key
	property@ // keyname
	userptr@ // section
	OSConfigGetKey ok! key!

	if (ok@)
		return
	end

	key@ OSConfigGetKeyValue value!

	if (value@ ~~)
		-1 ok!
	end
end

fn AmsDbUserSetProperty { value property userptr -- ok }
	auto key
	property@ // keyname
	userptr@ // section
	OSConfigGetKey ok! key!

	if (ok@)
		return
	end

	value@ key@ OSConfigSetKey ok!
end

// groups

fn AmsDbGroupGetByName { groupname -- groupptr ok }
	auto iterator
	AmsDbGroupConfig@ OSConfigGetSectionIterator ok! iterator!

	while (iterator@)
		iterator@ // iterator
		AmsDbGroupConfig@ // config
		OSConfigNextSection ok! iterator! groupptr!

		if (ok@)
			return
		end

		if (groupptr@ OSConfigGetSectionName groupname@ strcmp)
			return
		end
	end

	STATUS_NO_SUCH_GROUP ok!
end

fn AmsDbGroupGetByGID { gid -- groupptr ok }
	auto iterator
	AmsDbGroupConfig@ OSConfigGetSectionIterator ok! iterator!

	while (iterator@)
		iterator@ // iterator
		AmsDbGroupConfig@ // config
		OSConfigNextSection ok! iterator! groupptr!

		if (ok@)
			return
		end

		auto key
		"gid" // keyname
		groupptr@ // section
		OSConfigGetKey ok! key!

		if (ok@ ~~)
			auto chkgid
			key@ OSConfigGetKeyValue chkgid!

			if (chkgid@ ~~)
				continue
			end

			chkgid@ atoi chkgid!

			if (chkgid@ gid@ ==)
				return
			end
		end
	end

	STATUS_NO_SUCH_GROUP ok!
end

fn AmsDbGroupGetName { groupptr -- groupname }
	groupptr@ OSConfigGetSectionName groupname!
end

fn AmsDbGroupGetProperty { property groupptr -- value ok }
	auto key
	property@ // keyname
	groupptr@ // section
	OSConfigGetKey ok! key!

	if (ok@)
		return
	end

	key@ OSConfigGetKeyValue value!

	if (value@ ~~)
		-1 ok!
	end
end